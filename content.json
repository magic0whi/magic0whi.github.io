{"posts":[{"title":"Containerize China APPs with systemd-nspawn","text":"A prescription for 国产软件洁癖症. Thanks to liolok’s work[1] Container bringup Here using Tencent Meeting as an example 12345678910$ su# cd /var/lib/machines# container_name=wemeet# btrfs subvolume create ${container_name}# codename=focal# repository_url='https://repo.huaweicloud.com/ubuntu/'# debootstrap --include=systemd-container \\--components=main,universe,multiverse \\${codename} ${container_name} ${repository_url} Get into the container just created: 12345678910# cp /path/to/TencentMeeting_0300000000_2.8.0.3_x86_64_default.publish.deb /var/lib/machines/container_name/root/# systemd-nspawn --machine=${container_name} --bind-ro=/etc/resolv.confroot@wemeet # dpkg -i TencentMeeting_0300000000_2.8.0.3_x86_64_default.publish.debroot@wemeet # apt -f installroot@wemeet # apt install xorg # If needed install xorgroot@wemeet # ln -s /opt/wemeet/wemeetapp.sh /usr/local/bin/wemeetroot@wemeet # useradd -m wemeetroot@wemeet # su --login wemeet --shell /bin/bashwemeet@wemeet $ mkdir --parents ~/.config ~/.local/share Wrap up Desktop shortcut~/.local/share/applications/wemeet.desktop1234567[Desktop Entry]Comment=Tencent Video ConferencingExec=/home/proteus/.local/bin/wemeetIcon=/path/to/wemeetapp.pngName=Tencent MeetingTerminal=falseType=Application Startup script~/.local/bin/wemeet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/bin/bashapp=wemeethome=/home/${app}host_data=/usr/sharedata=${home}/.local/sharehost_conf=${XDG_CONFIG_HOME:-~/.config}conf=${home}/.configoptions=&quot;--as-pid2 --machine=${app} --user=${app} --chdir=${home}&quot;# Trayhost_dbus=${DBUS_SESSION_BUS_ADDRESS#unix:path=}if [ -z &quot;${host_dbus}&quot; ]; then host_dbus=&quot;/run/user/$(id --user)/bus&quot;fidbus=/run/user/host/busoptions=&quot;${options} --bind-ro=${host_dbus}:${dbus} --setenv=DBUS_SESSION_BUS_ADDRESS=unix:path=${dbus}&quot;# Soundhost_pulse=${PULSE_SERVER#unix:}if [ -z &quot;${host_pulse}&quot;]; then host_pulse=&quot;/run/user/$(id --user)/pulse/native&quot;fipulse=/run/user/host/pulseoptions=&quot;${options} --bind-ro=${host_pulse}:${pulse} --setenv=PULSE_SERVER=unix:${pulse}&quot; # Iconsoptions=&quot;${options} --bind-ro=${host_data}/icons:${data}/icons --setenv=XCURSOR_PATH=${data}/icons&quot;# Fontsoptions=&quot;${options} --bind-ro=${host_data}/fonts:${data}/fonts --bind-ro=${host_conf}/fontconfig:${conf}/fontconfig&quot;# Displayoptions=&quot;${options} --bind-ro=/tmp/.X11-unix/ --setenv=DISPLAY=$DISPLAY&quot;xauth_file=&quot;/tmp/xauth-${app}&quot;touch ${xauth_file}xauth nextract - &quot;${DISPLAY}&quot; | sed -e 's/^..../ffff/' | xauth -f &quot;${xauth_file}&quot; nmerge -options=&quot;${options} --bind=${xauth_file} --setenv=XAUTHORITY=${xauth_file}&quot;# Devicesoptions=&quot;${options} --bind=/dev/dri/ --property=DeviceAllow='char-drm rw'&quot; # Graphic cardsoptions=&quot;${options} --bind=/dev/input/ --property=DeviceAllow='char-input r'&quot; # Joysticksecho &quot;List of cmdline options applied to systemd-nspawn:&quot;printf &quot;%s\\n&quot; ${options} | sort# resolv.confoptions=&quot;${options} --bind-ro=/etc/resolv.conf&quot;kdesu bash -c &quot;systemd-nspawn ${options} ${app}&quot; Please be aware that here I use kdesu as an alternative to sudo, which is include in KDE desktop. Don’t forget to give executable permission chmod +x ~/.local/bin/wemeet Reference ^ \"Containerize Steam with systemd-nspawn\". liolok.com. Retrieved 2022-3-10.","link":"/zh-cn/computer/2022/Containerize-China-APPs-with-systemd-nspawn/"},{"title":"a-guide-to-zhuyin","text":"A brief guide to zhuyin input &amp; keyboard 注音键盘 如图是台湾使用最广的大千式键盘, 由于我这里只有美式键盘, 只能靠记忆来在 PC 上使用注音输入法. 注音五十音 ㄅ b ㄉ d ˇ ˋ ㄓ zh ˊ ˙ ㄚ a ㄞ ai ㄢ an ㄦ er ㄆ p ㄊ t ㄍ g ㄐ j ㄔ ch ㄗ z ㄧ y/i ㄛ o ㄟ ei ㄣ en ㄇ m ㄋ n ㄎ k ㄑ q ㄕ sh ㄘ c ㄨ w/u ㄜ e ㄠ ao ㄤ ang ㄈ f ㄌ l ㄏ h ㄒ x ㄖ r ㄙ s ㄩ yu/ü ㄝ ê ㄡ ou ㄥ eng ㄧㄣ in ㄩㄣ ün ㄧㄥ ing ㄨㄥ weng/ong ㄩㄥ yong","link":"/zh-cn/computer/2022/a-guide-to-zhuyin/"},{"title":"archlinux-installation-standard","text":"My standards of install Arch Linux. Pre-installation Update the system clock 1# timedatectl set-ntp true Preparing the partitions Partition layout: 12345678910+-----------------------+------------------------+| Boot partition | LUKS2 encrypted system || | partition || | || /boot | / || | || | /dev/mapper/cryptroot ||-----------------------|------------------------|| /dev/sda1 | /dev/sda2 |+-----------------------+------------------------+ Preparing non-boot partitions 12345# cryptsetup -y -v --pbkdf-memory=114514 luksFormat /dev/sda2# cryptsetup open /dev/sda2 cryptroot# cryptsetup --allow-discards --perf-no_read_workqueue --perf-no_write_workqueue --persistent refresh cryptroot# mkfs.btrfs -L arch_os /dev/mapper/cryptroot# mount /dev/mapper/cryptroot /mnt You can set the filesystem label later by using btrfs filesystem label /dev/mapper/cryptroot &quot;arch_os&quot; Preparing the boot partition 1# mkfs.fat -F32 /dev/sda1 Btrfs subvolumes Create top-level subvolumes1234# btrfs subvolume create /mnt/@# btrfs subvolume create /mnt/@snapshots# btrfs subvolume create /mnt/@home# btrfs subvolume create /mnt/@var_log Mount top-level subvolumes Unmount the system partition at /mnt.1# umount /mnt Now mount the newly created subvolumes by using the subvol= mount option (with enabled compress zstd).123456# mount -o compress=zstd,subvol=@,discard=async /dev/mapper/cryptroot /mnt# mkdir -p /mnt/{boot,home,.snapshots,var/log}# mount -o discard /dev/sda1 /mnt/boot# mount -o compress=zstd,subvol=@home,discard=async /dev/mapper/cryptroot /mnt/home# mount -o compress=zstd,subvol=@snapshots,discard=async /dev/mapper/cryptroot /mnt/.snapshots# mount -o compress=zstd,subvol=@var_log,discard=async /dev/mapper/cryptroot /mnt/var/log Create nested subvolumes Create any nested subvolumes you do not want to have snapshots when taking a snapshot of /. Every nested subvolume will be an empty directory inside the snapshot.123# mkdir -p /mnt/var/cache/pacman# btrfs subvolume create /mnt/var/cache/pacman/pkg# btrfs subvolume create /mnt/var/tmp Installation Select mirrors1# sed -i '1iServer = https://mirrors.cloud.tencent.com/archlinux/$repo/os/$arch' /etc/pacman.d/mirrorlist Install essential packages12345678910# pacstrap -K /mnt base linux linux-firmware \\rng-tools openssh zram-generator bluez bluez-utils iwd zerotier-one \\btrfs-progs tmux bash-completion udisks2 btop man rsync tealdeer \\zsh{,-autosuggestions,-syntax-highlighting,-history-substring-search} \\pipewire wireplumber pipewire-alsa pipewire-pulse \\base-devel git gvim ripgrep fzf ctags \\vulkan-tools libva-utils hyfetch \\xorg-server bspwm sxhkd ly polybar xdo xorg-xrdb picom rofi redshift flameshot alacritty feh \\noto-fonts{,-cjk,-emoji} \\fcitx5-im fcitx5-chinese-addons fcitx5-mozc fcitx5-pinyin-zhwiki Configure the system shell12345678910# genfstab -U /mnt &gt;&gt; /mnt/etc/fstab# arch-chroot /mnt# hwclock --systohc# locale-gen$ #Recreate the initramfs image# mkinitcpio -P# useradd -m -s /bin/bash &lt;Username&gt;$ # Setting the new user and root user's password# passwd &lt;Username&gt;# passwd root Installing the EFI boot manager shell1# bootctl install Configuring the boot loader /boot/loader/loader.conf1234default arch.conftimeout 4console-mode maxeditor no /boot/loader/entries/arch.conf1234title Arch Linuxlinux /vmlinuz-linuxinitrd /initramfs-linux.imgoptions root=/dev/mapper/cryptroot rootflags=compress=zstd,subvol=@,discard=async /boot/loader/entries/arch-fallback.conf1234title Arch Linux (fallback)linux /vmlinuz-linuxinitrd /initramfs-linux-fallback.imgoptions root=/dev/mapper/cryptroot rootflags=compress=zstd,subvol=@,discard=async AUR helper paru. 123456789# mkdir /build# chown -R &lt;Username&gt;:&lt;Username&gt; /build# cd /build# sudo -u &lt;Username&gt; git clone --depth=1 https://aur.archlinux.org/paru.git# cd paru# sudo -u &lt;Username&gt; GITFLAGS=&quot;--depth=1&quot; makepkg --noconfirm -si# pacman -Qtdq | xargs -r pacman --noconfirm -Rcns# rm -rf /home/&lt;Username&gt;/.cache# rm -rf /build Reboot to installed system to ensure that systemd is running. Post-installation Enable daemons shell1234567891011# systemctl enable --now iwd.service# systemctl enable --now systemd-networkd.service# systemctl enable --now systemd-resolved.service$ # Enable Random number generation# systemctl enable --now rngd.service$ # Enable sshd# systemctl enable --now sshd.service$ # Enable bluetooth auto power-on# systemctl enable --now bluetooth.service$ Enable systemd-oomd (Userspace OOM daemon)# systemctl enable systemd-oomd.service Enroll TPM key list installed TPMs and the driver in use: shell1$ systemd-cryptenroll --tpm2-device=list If you encounter messages such as “TPM2 support is not installed”, try install tpm2-tss. Binds the key to PCRs 0 and 7 (System firmware and Secure Boot state): 1# systemd-cryptenroll --tpm2-device=auto --tpm2-pcrs=0+7 /dev/sda2 Regenerate the initramfs: 1# mkinitcpio -P To remove a key enrolled, run: 1# systemd-cryptenroll /dev/sdX --wipe-slot=slot_number where slot_number is the numeric LUKS slot number in which your TPM key is stored. Alternatively, run: 1# systemd-cryptenroll /dev/sdX --wipe-slot=tpm2 to remove all TPM-associated keys from your LUKS volume. Swapfile in a btrfs filesystem and enable hibernation (support dm-crypt) Swap file creation 12# btrfs filesystem mkswapfile --size 32g --uuid clear /.snapshots/swapfile# swapon /.snapshots/swapfile Add appropriate entry in fstab: /etc/fstab12.../.snapshots/swapfile none swap defaults 0 0 Setting the required kernel parameters 12# btrfs inspect-internal map-swapfile -r /.snapshots/swapfile198122980 Finally, edit the bootloader’s configuration: /boot/loader/entries/arch.conf12...options ... resume=/dev/mapper/cryptroot resume_offset=198122980 Secure Boot by using a signed boot loader (shim) Install shim-signed[AUR], sbsigntools and efibootmgr 1# paru -S shim-signed sbsigntools efibootmgr As shim tries to launch grubx64.efi, rename systemd boot loader to it. 1# cp /boot/EFI/systemd/systemd-bootx64.efi /boot/EFI/BOOT/grubx64.efi Copy shim and MokManager to boot loader directory: 12# cp /usr/share/shim-signed/shimx64.efi /boot/EFI/BOOT/BOOTx64.EFI# cp /usr/share/shim-signed/mmx64.efi /boot/EFI/BOOT/ (Optional) create a new NVRAM entry to boot BOOTx64.EFI: 1# efibootmgr --verbose --disk /dev/sda --part 1 --create --label &quot;Shim&quot; --loader /EFI/BOOT/BOOTx64.EFI Generate a Machine Owner Key: 12$ openssl req -newkey rsa:4096 -nodes -keyout MOK.key -new -x509 -sha256 -days 3650 -subj &quot;/CN=my Machine Owner Key/&quot; -out MOK.crt$ openssl x509 -outform DER -in MOK.crt -out MOK.cer Sign boot loader (named grubx64.efi) and kernel: 12# sbsign --key MOK.key --cert MOK.crt --output /boot/vmlinuz-linux /boot/vmlinuz-linux# sbsign --key MOK.key --cert MOK.crt --output /boot/EFI/BOOT/grubx64.efi /boot/EFI/BOOT/grubx64.efi Copy MOK.cer to a FAT formatted file system (Here I use EFI system partition). 1# cp MOK.cer /boot/ Reboot and enable Secure Boot. If shim does not find the certificate grubx64.efi is signed with in MokList it will launch MokManager (mmx64.efi). In MokManager select Enroll key from disk, find MOK.cer and add it to MokList. When done select Continue boot and your boot loader will launch and it will be capable launching any binary signed with your Machine Owner Key. Tips Run fc-cache -fv to rebuild font information cache files. Use blkid or lsblk -f to see the persistent block device naming Use ip link to show network interface names Configure memory pressure killing (Here I set it slice wide to make it observable in oomctl): shell1# systemctl edit user.slice Having this in your editor: 123[Slice]ManagedOOMMemoryPressure=killManagedOOMMemoryPressureLimit=50% Configure swap-based killing: 1# systemctl edit --force -- -.slice With this in your edior: 12[Slice]ManagedOOMSwap=kill (Optional) See also oomd.conf(5): /etc/systemd/oomd.conf123[OOM]SwapUsedLimit=80%DefaultMemoryPressureDurationSec=20s Furthmore, you can set OOMPolicy=kill to a service unit, which says if one of the process belong to this service is being killed by systemd-oomd, the whole service will also get killed (this option sets service’s cgroup memory.oom.group to 1, which means all tasks belonging to this cgroup were killed together). Additional Packages123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108[AUR] ttf-material-design-icons-extended[AUR] fcitx5-pinyin-moegirl[AUR] fcitx5-pinyin-cedictfcitx5-material-color# GPU - Intelvulkan-intelintel-media-driver^[AUR] libva-intel-driver-hybrid- [AUR] intel-hybrid-codec-driver# GPU - Nvidianvidia-open nvidia-prime# GPU - AMDmesavulkan-radeonlibva-mesa# GPU Tools[AUR] raytracinginvulkan-gitranger ffmpegthumbnailer perl-image-exiftool ueberzugyt-dlphtopcmakegdbtreenmapcompsizebcp7zipunraropenbsd-netcattraceroutewireguard-toolsntfs-3gdocker{,-compose}howdyarch-install-scripts pacman-contrib devtoolscifs-utilspicocom # ($ picocom -b 1500000 /dev/ttyUSB0, Ctrl-a Ctrl-q to quit)[AUR] snowflake-pt-client-git[AUR] cppmancmus # Music Playergdu/ncdu/dust # Calculate storage usage## Desktop appsfirefoxprofile-sync-daemonanki-bin fcitx5-qt6-gitblenderkritalibreoffice-stillmpvobs-studioremmina libvncserver freerdptelegram-desktopzathura zathura-pdf-popplerthunderbird[AUR] bitwarden[AUR] yesplaymusic-electron[AUR] microsoft-edge-dev-bin[AUR] qv2ray[AUR] visual-studio-code-bin- gnome-keyring # required to store vscode login token- seahorse # GUI to manage keyring## Gamingsteamvkd3d-proton-mingw-gitlutrisinnoextractsunshinepython-pippython-matplotlibpython-pandaspython-seaborn[AUR] hexo-cli[AUR] clight clightdtexlive-latexextratexlive-binextratexlive-mathscience## MATLABlibxcrypt-compat gtk2[AUR] wsdd2## Systemd-nspawn bootstrapdebootstrap ubuntu-keyring## Manager &amp; VMcockpit-machines virt-installvirt-manager libvirt dmidecode dnsmasq iptables-nft edk2-ovmf swtpmqemu ^[AUR] qemu-user-static - [AUR] binfmt-qemu-static-all-arch[AUR] xray[AUR] v2rayaqtcreator","link":"/zh-cn/computer/2020/archlinux-installation-standard/"},{"title":"bookmark","text":"互联网上の资源 IDE C/C++ for Visual Studio Code QT Creator QT download Windows Windows,Office 等镜像 TechBench ESD 解密 decrypt-multi UUPDL KMS client setup keys list Intel (CS)ME, CS(TXE), CS(SPS), PMC, PHY &amp; PCHC Firmware Repositories Windows 10 更新补丁汇总合集 最新支持的 Visual C++ 下载 Linux OriginCode 的服务 Clansty’s Archlinux Repository Android Google Camera Ports Android APK 魔改&amp;破解 mobilism Education Tools 跨平台在线数学可视化 GeoGebra , desmos 在线求解微积分/矩阵等 积分(反导数)计算器 - Symbolab 在线获取试卷 考试酷 在线图书信息库 arbookfind 学术论文一站式搜索 GFsoso SCI-Hub 论文下载可用网址链接 - 实时更新 Library Genesis创世纪图书馆 Z-Library 学术相关书籍/论文 类似ChemDraw, 不过是网页版 MolView ChemDoodle WEB drawio 开源的在线图表制作软件 Chemical Equations Chemical Structure Search 画出结构, 找到化学物质, 感谢 @Alice_486 Learn 计算机工程中缺失的一课 CS自救指北 中科院考试大纲 Yifei Xiong 的数学笔记 数学乐 平面设计/音乐音效 doyoudo Crashcourts中文字幕 Crashcourts BioHack Academy BioHack Academy on Vimeo Bio Academany GaudiLabs Wolfram MathWorld chemcollective GeeksforGeeks | A computer science portal for geeks Learn X in Y Minutes Writing an OS in Rust Full stack open 2021 CS自学指南 Paper The mouse Sry locus harbors a cryptic exon that is essential for male sex determination Github This chapter has benn deprecated and now I useing Github star as a substitution. 手撕 leetcode 求是潮技术研发中心 linux 超赞应用 trackerslist Locale-Emulator FontMod DeepCreamPy Find illustration SauceNao Yande.re Sankaku Channel iqdb konachan 版权自由图片 Pixabay BT ACG.RIP Bangumi Moe Rarbg Free Software Movement 开源许可检查 FOSSA Internet 域名价格比对 domcomp 在线传感器数据分析 Grafana 在线查毒 Virustotal 游戏破解状态 CrackWatch Steam 创意工坊在线下载器 Steam Workshop Downloader Goldberg Steam 模拟器 goldberg_emulator Oracle 账户密码 BugMeNot 油猴脚本 Greasy Fork 免费上网账号 存储 SSD/NAS/DAS 技术论坛 教你制作能打印PCB的压印机 Diyyouware 嘉立创SMT贴片 图拉丁之家 查看账号是否遭数据泄露 have i been pwned? 信息安全 Seebug 随机生成美国/加拿大/日本人信息 haoweichi 基站查询 OpenCellid 萌站·次元导航 生物实验用机器人 Opentrons Seebug SJTUG - A Joyful Techie User Group OpenWeather 生信人 DrugBank Online Sketchfab 科创 美卡论坛 DeepL : 比 Google Translate 好用的在线翻译 QuillBot : English rephrase Kemono.party : 心里要知道白嫖不是长久之计, 每个人的劳动都应当尊重. DevDocs API Documentation : 各种编程语言和软件的文档集合(比如 CPP reference) 科学网-博客 Mathpix Snip : 图片转 Tex Softwares OBS 解压 Inno Setup 打包的资源 Innoextrace OpenBuilds Software - FREE Software for CNC Control News medias iYouPort - IYP","link":"/zh-cn/computer/2020/bookmark/"},{"title":"bspwm-notes","text":"Cheatsheet for bspwm Concepts A desktop is (a pointer to) a tree. There are 1-10 (Roman Numbers) desktops (trees). Monitor is just your real monitor, they divide the distribution of ten trees. Such as eDP-1 for first five tree (1-5), HDMI-1 for last five trees (5-10). One leaf node holds one window (node ≈ window) Manual mode Manual Mode: User preselect the insertion point. If you don’t preselect, new node position will be determined by automatic scheme 1234567891011121314151617181920 a a a / \\ / \\ / \\ 1 b ---&gt; c b ---&gt; c b ^ / \\ / \\ / \\ / \\ / \\ 2 3 4 1 2 3 d 1 2 3 ^ / \\ 5 4 ^+-----------------------+ +-----------------------+ +-----------------------+| | | | | | | | | || | 2 | | 4 | 2 | | 5 | 4 | 2 || | | | ^ | | | ^ | | || 1 |-----------| |-----------|-----------| |-----------|-----------|| ^ | | | | | | | || | 3 | | 1 | 3 | | 1 | 3 || | | | | | | | |+-----------------------+ +-----------------------+ +-----------------------+ X Y Z Automatic Mode Automatic Mode: The insertion position of new node determined by automatic scheme (longest_side, alternate, spiral) and initial polarity (first_child or second_child). bspc config automatic_scheme {longest_side,alternate,spiral} Longest side scheme: the split direction was chosen based on dimensions of the tiling rectangle (whether height or width is longer) and the initial polarity. The following scenario set the initial polarity to second_child:123456789101112131415161718 1 a a ^ / \\ / \\ ---&gt; 1 2 ---&gt; 1 b ^ / \\ 2 3 ^+-----------------------+ +-----------------------+ +-----------------------+| | | | | | | || | | | | | | 2 || | | | | | | || 1 | | 1 | 2 | | 1 |-----------|| ^ | | | ^ | | | || | | | | | | 3 || | | | | | | ^ |+-----------------------+ +-----------------------+ +-----------------------+ X Y Z Alternate scheme: If parent is split horizontally, the child will be split vertically and vise versa. Spiral scheme: It is best shows as image.123456789101112131415161718192021 a a a / \\ / \\ / \\ 1 b ---&gt; 1 c ---&gt; 1 d / \\ / \\ / \\ 2 3 4 b 5 c ^ ^ / \\ ^ / \\ 3 2 b 4 / \\ 3 2+-----------------------+ +-----------------------+ +-----------------------+| | | | | | | | || | 2 | | | 4 | | | 5 || | ^ | | | ^ | | | ^ || 1 |-----------| | 1 |-----------| | 1 |-----------|| | | | | | | | | 3 | || | 3 | | | 3 | 2 | | |-----| 4 || | | | | | | | | 2 | |+-----------------------+ +-----------------------+ +-----------------------+ X Y Z New node take the place of insertion point, whole tree rooted as its parent reattached and swapped at first depth. Cheatsheet &lt;super-Return&gt; Open terminal &lt;super-Space&gt; Open menu launcher &lt;super-Esc&gt; sxhkd reload &lt;super-M&gt;-q,r Quit / Restart bspwm bspc {quit,wm -r} &lt;super-[S]&gt;-w Close / Kill focused node bspc node -{c,k} &lt;super&gt;-m Alter tiled / monocle layout bspc desktop -l next &lt;super&gt;-y Send the newest marked node to the newest preselected node (only current desktop) &lt;super&gt;-g Swap focused node and the node has biggest window &lt;super&gt;-t,&lt;S&gt;-t,s,f Set node state to tiled / pseudo tilted / floating / fullscreen &lt;super-C&gt;-m,x,y,z Set node flag to marked / locked / sticky / private &lt;super-[S]&gt;-h,j,k,l Traverse / Swap node to west / south / north / east &lt;super&gt;-b Traverse brother node &lt;super&gt;-p Select parent node &lt;super&gt;-comma,period Traverse first / second node while selecting a parent node &lt;super-[S]&gt;-c Traverse next / prev node in current desktop &lt;super&gt;-{,} Traverse prev / next desktop in current monitor &lt;super&gt;-`,&lt;Tab&gt; Traverse last node / desktop &lt;super&gt;-o,i Traverse older / newer node in traverse history &lt;super-[S]&gt;-0-9 Traverse desktop 0-9 / Send focused node to desktop 0-9 &lt;super-C&gt;-h,j,k,l,1-9 Preselect direction / ratio for new node to insert bspc node {-p {west,souch,north,east},-o 0.{1-9}} &lt;super-C-[S]-Space&gt; Cancel the preselection for focused node / desktop &lt;super-M-[S]&gt;-h,j,k,l (Resize) Expand / Contract node by moving one of its side outward / inward &lt;super-Left,Upwn,UP,Right&gt; Move a floating node See Also bspwm(1)","link":"/zh-cn/computer/2022/bspwm-notes/"},{"title":"git-usage","text":"Some notes on Git Difference between ^ and ~ commit^n choose the nth parent of the commit HEAD^ = HEAD^1 = HEAD~ = HEAD~1 123456789101112131415161718192021G H I J \\ / \\ / D E F \\ | / \\ \\ | / | \\|/ | B C \\ / \\ / AA = = A^0B = A^ = A^1 = A~1C = A^2D = A^^ = A^1^1 = A~2E = B^2 = A^^2F = B^3 = A^^3G = A^^^ = A^1^1^1 = A~3H = D^2 = B^^2 = A^^^2 = A~2^2I = F^ = B^3^ = A^^3^J = F^2 = B^3^2 = A^^3^2 See What’s the difference between HEAD^ and HEAD~ in Git? Clone Clone a repository with its submodules (--recurse-submodules) 1git clone --recurse-submodules git@domain.tld:repo.git` Add &amp; Move &amp; Remove Add file in a interactive patch way (-p/--patch) 1git add -p &lt;file&gt; Move (Rename) file and then stage: git mv &lt;filename1&gt; &lt;filename2&gt; Remove file: git rm &lt;file&gt; Remove file in index only: git rm --cached &lt;file&gt; Commit Automatically stage changes then commit: git commit -a Fast modify last commit: git commit --amend Log Show log in a friendly format: git log --graph --oneline --decorate --all Show commits with diff patch (-p/-u/--patch/--cc (dense)): git log -cc, git log --cc -1 (For HEAD only) Show commits for a user (--author=/--committer=): git log --author=&lt;pattern&gt; Grep in commit logs: git log --grep=&lt;pattern&gt; Diff Show a summary: git diff --stat Show diff of the last commit: git diff HEAD HEAD~1 or git diff HEAD^! Blame Show each line of a file with last commit hash and author: git blame &lt;file&gt; Stash git stash git stash pop Branch &amp; Remove Create a branch and set its upstream (-t/--track): git branch &lt;new-branch&gt; &lt;remote-branch&gt; Delete a branch (-d/--delete): git branch -d &lt;branch&gt; Delete a remote branch (-d/--delete): git push &lt;remote&gt; -d &lt;branch&gt; / git push &lt;remote&gt; :&lt;branch&gt; Rename a branch (-m/--move): git branch -m &lt;old-branch&gt; &lt;new-branch&gt; To rename a remtoe branch, first delete the remote branch, then push a branch with new name: git push &lt;remote&gt; :&lt;old-branch&gt;; git push &lt;remote&gt; &lt;new-branch&gt; Add remote and choose a branch to track: (-t/--track): git remote add -t &lt;remote-branch&gt; &lt;remote-name&gt; &lt;url&gt; Tag tag current HEAD: git tag &lt;tag-name&gt; push tags (under refs/tags): git push --tags Rebase Modify last 10 commits: git rebase -i HEAD~10 pick doesn’t change this commit drop drop this commit edit edit this commit squash merge this commit with one commit above Reset &amp; Clean Reset work tree and delete untracked files: git reset --hard HEAD; git clean -fdx Reset: --soft only change HEAD to &lt;commit&gt; --mixed reset index only. --hard reset both index and working tree --keep reset working tree only (If a file differ between &lt;commit&gt; and HEAD, and also has modified copy in index, this reset will be abort) Clean: -f --force allow git clean to delete files or directories while clean.requireForce is not set to false. -d Normally, when no is set, git clean will not recurse into untracked directories to removing too much. Specify -d to have it recurse into such directories as well. -x Remove ignored files and directories mentioned in .gitignore Restore Restore a file from specify commit: git restore -s &lt;commit&gt; &lt;file&gt; Rvert Create a revert commit (Useful when in a team): git revert &lt;commit&gt; k Submodule Show submodule status: git submodule status Add a submodule: git submodule add -b &lt;remote-branch&gt; [--name &lt;name&gt;] &lt;url&gt; Initialize and update submodule to superproject’s recorded commit SHA-1: git submodule update --init or git submodule init; git submodule update Update submodule to its remote-tracking branch: git submodule update --remote &lt;submodule-name&gt; Specify how differences in submodule are shown when using git diff: git diff --submodule=[diff|log|short] Push only when submodule commits are available on remote-tracking branch: git push --recurse-submodules=check Push also submodule commits: git push --recurse-submodules=on-demand Run command in each submodules: git submodule foreach &lt;command&gt; More Greater Submodule for Git 使用git-subrepo 然后使用git subrepo为开头 还可将子目录变为子仓库: 1$ git subrepo init &lt;subdir&gt; [-r &lt;remote&gt;] [-b &lt;branch&gt;] [--method &lt;merge|rebase&gt;] Git Cherry-pick git cherry-pick用于把另一个本地分支的commit修改应用到当前分支 假设dev分支有一个hash为38361a68的commit 12$ git checkout master$ git cherry-pick 38361a68 Git Format-patch Create patch files between two commit1$ git format-patch &lt;r1&gt;..&lt;r2&gt; Single commit patch1$ git format-patch -1 &lt;r1&gt; Create patch file since commit r1 (But doesn’t include this commit)1$ git format-patch &lt;r1&gt; Apply series of patches1$ git am *.patch Limit memory usage of git-gc 123$ git config --global pack.windowMemory &quot;100m&quot;$ git config --global pack.packSizeLimit &quot;100m&quot;$ git config --global pack.threads &quot;1&quot;","link":"/zh-cn/computer/2022/git-usage/"},{"title":"Some Hexo usages","text":"Hexo 的一些命令和概念速记 部署Git仓库 1git@blog ~$ git init --bare blog.git 然后就是Git Hook的配置, 见前面 别忘了 chmod +x post-update 若想使用git-shell: usermod -s /usr/bin/git-shell git Hexo 文章加密 123$ cd blog$ npm install hexo-blog-encrypt$ nano /Hexo/_config.yml 添加如下内容 1234# Security## 文章加密 hexo-blog-encryptencrypt: enable: true 然后在想加密的文章头部添加上对应字段, 如 123456789---title: hello worlddate: 2016-03-30 21:18:02tags:toc: truepassword: 12345abstract: 该博文的摘要message: 密码输入框的描述性文字--- 另见Github项目说明 升级Hexo 1234# npm install npm-check-updates # 或者 npm-check, npm-upgrade$ cd /path/to/your/blog$ ncu # 更新 package.json$ npm update # 更新插件 分类和标签 只有文章支持分类和标签, 您可以在 Front-matter 中设置. 在其他系统中, 分类和标签听起来很接近, 但是在 Hexo 中两者有着明显的差别: 分类具有顺序性和层次性而标签没有顺序和层次 123456categories:- Diarytags:toc: true- PS3- Games 资源引用 设置 post_asset_folder: true 之后会开启 Hexo 的文章资源文件管理功能. Hexo 将会在我们每一次通过 hexo new &lt;title&gt; 命令创建新文章时自动创建一个同名文件夹, 于是我们便可以将文章所引用的相关资源放到这个同名文件夹下, 然后通过相对路径引用. 123{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %} Example: 1{% asset_link unbound.conf.example &quot;/etc/unbound/unbound.conf&quot; %} 具体见: 标签插件 一些技巧示例 单个页面使用赛博朋克主题, 在 Front-matter 加入如下内容:123456---variant: cyberpunkarticle: highlight: theme: qtcreator_dark--- 一些 Bulma 的提示信息(来自Icarus主题)123456789101112131415161718&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-globe-asia mr-2&quot;&gt;&lt;/i&gt;这是一个页面提示&lt;a href=&quot;{% post_path zh-CN/Getting-Started %}&quot;&gt;超链接&lt;/a&gt;.&lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message message-immersive is-warning&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-question-circle mr-2&quot;&gt;&lt;/i&gt;Something wrong with this article? Click &lt;a href=&quot;https://github.com/ppoffice/hexo-theme-icarus/edit/site/source/_posts/en/Getting-Started.md&quot;&gt;here&lt;/a&gt; to submit your revision.&lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message is-primary&quot; style=&quot;font-size:inherit&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;这是一条讯息.&lt;/div&gt;&lt;/article&gt; 如下: 这是一个页面提示 超链接. Something wrong with this article? Click here to submit your revision. 这是一条讯息. Bulma 的带内容标签示范 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div class=&quot;tabs is-boxed my-3&quot;&gt; &lt;ul class=&quot;mx-0 my-0&quot;&gt; &lt;li class=&quot;is-active&quot;&gt; &lt;a href=&quot;#tab1&quot;&gt; &lt;span class=&quot;icon is-small&quot;&gt;&lt;i class=&quot;fas fa-file-code&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;span&gt;标签1&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#tab2&quot;&gt; &lt;span class=&quot;icon is-small&quot;&gt;&lt;i class=&quot;fas fa-cubes&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;span&gt;标签2&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div id=&quot;tab1&quot; class=&quot;tab-content&quot;&gt; foooooooooo!&lt;/div&gt;&lt;div id=&quot;tab2&quot; class=&quot;tab-content is-hidden&quot;&gt; woooooooooo!&lt;/div&gt;&lt;!-- 最好加条横线以和下文内容区分 --&gt;&lt;hr&gt;&lt;!-- 在页面底部添加 JS 脚本 --&gt;&lt;script&gt;window.addEventListener('DOMContentLoaded', () =&gt; { Array .from(document.querySelectorAll('.tabs li')) .forEach((tab) =&gt; { tab.addEventListener('click', (e) =&gt; { e.preventDefault(); const currentTab = document.querySelector('.tabs li.is-active'); currentTab.classList.remove('is-active'); document .getElementById(currentTab.querySelector('a').getAttribute('href').substring(1)) .classList.add('is-hidden'); const newTab = e.currentTarget; newTab.classList.add('is-active'); document .getElementById(e.currentTarget.querySelector('a').getAttribute('href').substring(1)) .classList.remove('is-hidden'); }); });});&lt;/script&gt; 标签1 标签2 foooooooooo! woooooooooo! 使用内联 CSS 管理行首缩进. (虽然我更喜欢用在段落前加 &amp;emsp\\; 这种方式) 123456789&lt;span class=sentence&gt;凌晨 1 时, 大多数人已睡了三小时, 进入易醒的浅睡阶段, 对疼痛特别敏感.&lt;/span&gt;&lt;style type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt;.sentence { /* padding:.3em .5em .1em 2em; */ padding-left: 2em; background: pink; }&lt;/style&gt; KaTeX div 标签中 DisplayMode (用 “\\\\[,\\\\]” 包裹) 的 KaTeX 会莫名地有条滚动条, 通过内联 css 隐藏它:12345&lt;style type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt;.katex-html { overflow-x: hidden;}&lt;/style&gt; 通过内联 JS 脚本实现 KaTex 参数自定义:123456789101112131415161718192021222324&lt;div id=&quot;katex-1&quot;&gt;&lt;/div&gt;&lt;script&gt;window.onload = () =&gt; { var html = katex.renderToString(` \\\\begin{equation} \\\\begin{split} a &amp;=b+c \\\\\\\\ &amp;=e+f \\\\end{split} \\\\end{equation} \\\\\\\\ \\\\htmlStyle{color: red;}{x} \\\\\\\\ \\\\href{https://katex.org/}{\\KaTeX} \\\\\\\\ \\\\includegraphics[height=0.8em, totalheight=0.9em, width=0.9em, alt=KA logo]{https://katex.org/img/khan-academy.png}` , { displayMode: true, trust: (context) =&gt; ['\\\\includegraphics', '\\\\href', '\\\\htmlStyle'].includes(context.command) }); document.getElementById('katex-1').insertAdjacentHTML( 'afterend', html );};&lt;/script&gt; 一些踩坑: Hexo 中的内嵌 \\(\\KaTeX\\) 如果出现这样的字符 (R) 会被识别成商标 (®), 需转义括号: \\(R\\) Code of conduct (KaTeX): MATLAB command: \\textsf{one(4)} not \\textsf{one}(4). Inequality: \\gt,\\lt not &gt;,&lt;.","link":"/zh-cn/computer/2020/hexo-usage/"},{"title":"kvm","text":"Some notes in KVM &amp; GVT-g for tpm support install swtpm For btrfs If you store your kvm images under btrfs filesystem. It is recommend to enable nocow, for example chattr +C /var/lib/libvirt/images. GVT-g with i915ovmfPkg Using the VBIOS i915ovmfPkg, these paramters were no longer works: 1234&lt;qemu:arg value='-set'/&gt;&lt;qemu:arg value='device.hostdev0.ramfb=on'/&gt;&lt;qemu:arg value='-set'/&gt;&lt;qemu:arg value='device.hostdev0.driver=vfio-pci-nohotplug'/&gt; Using Qemu GTK to get a more smoothly experience: 1234567891011121314151617&lt;domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'&gt; &lt;qemu:commandline&gt; &lt;qemu:arg value='-display'/&gt; &lt;qemu:arg value='gtk,gl=on'/&gt; &lt;qemu:env name='DISPLAY' value=':0'/&gt; &lt;qemu:env name='MESA_LOADER_DRIVER_OVERRIDE' value='iris'/&gt; &lt;/qemu:commandline&gt; &lt;qemu:override&gt; &lt;qemu:device alias='hostdev0'&gt; &lt;qemu:frontend&gt; &lt;qemu:property name='display' type='string' value='on'/&gt; &lt;qemu:property name='romfile' type='string' value='/i915ovmf.rom'/&gt; &lt;qemu:property name='x-igd-opregion' type='bool' value='true'/&gt; &lt;/qemu:frontend&gt; &lt;/qemu:device&gt; &lt;/qemu:override&gt;&lt;/domain&gt; Hypervisor Feafures Meanwhile, I’ve set some minor stuffs such like KVM hidden, vendor_id, full KVM mode and cpu pins (specific for my i7-8750H, with a iothread created). Whereas some virtio features for disks and network bridges were enabled to satisfy my experience: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'&gt; &lt;os&gt; &lt;loader readonly='yes' secure='yes' type='pflash'&gt;/usr/share/edk2-ovmf/x 64/OVMF_CODE.secboot.fd&lt;/loader&gt; &lt;!-- Secure Boot --&gt; &lt;/os&gt; &lt;iothreads&gt;1&lt;/iothreads&gt; &lt;vcpu placement='static'&gt;8&lt;/vcpu&gt; &lt;cputune&gt; &lt;!-- Use lscpu -e to see cpu topology. Here I pinned CPU2,3,4,5. To hypervisor, CPU1 to emulator and iothread --&gt; &lt;vcpupin vcpu='0' cpuset='2'/&gt; &lt;vcpupin vcpu='1' cpuset='8'/&gt; &lt;vcpupin vcpu='2' cpuset='3'/&gt; &lt;vcpupin vcpu='3' cpuset='9'/&gt; &lt;vcpupin vcpu='4' cpuset='4'/&gt; &lt;vcpupin vcpu='5' cpuset='10'/&gt; &lt;vcpupin vcpu='6' cpuset='5'/&gt; &lt;vcpupin vcpu='7' cpuset='11'/&gt; &lt;emulatorpin cpuset='1,7'/&gt; &lt;iothreadpin iothread='1' cpuset='1,7'/&gt; &lt;/cputune&gt; &lt;cpu mode='host-passthrough' check='none' migratable='off'&gt; &lt;topology sockets='1' dies='1' cores='4' threads='2'/&gt; &lt;cache mode='passthrough'/&gt; &lt;/cpu&gt; &lt;features&gt; &lt;hyperv mode='custom'&gt; &lt;relaxed state='on'/&gt; &lt;vapic state='on'/&gt; &lt;spinlocks state='on' retries='8191'/&gt; &lt;vpindex state='on'/&gt; &lt;runtime state='on'/&gt; &lt;synic state='on'/&gt; &lt;!-- For me, enable stimer will cause win10 KVM don't boot --&gt; &lt;!-- &lt;stimer state='on'&gt; &lt;direct state='on'/&gt; &lt;/stimer&gt; --&gt; &lt;reset state='on'/&gt; &lt;vendor_id state='on' value='GenuineIntel'/&gt; &lt;frequencies state='on'/&gt; &lt;reenlightenment state='on'/&gt; &lt;tlbflush state='on'/&gt; &lt;ipi state='on'/&gt; &lt;evmcs state='on'/&gt; &lt;/hyperv&gt; &lt;kvm&gt; &lt;hidden state='on'/&gt; &lt;/kvm&gt; &lt;ioapic driver='kvm'/&gt; &lt;smm state='on'/&gt; &lt;!-- Secure Boot --&gt; &lt;/features&gt; &lt;clock offset='localtime'&gt; &lt;timer name='rtc' tickpolicy='catchup'/&gt; &lt;timer name='pit' tickpolicy='delay'/&gt; &lt;timer name='hpet' present='no'/&gt; &lt;timer name='kvmclock' present='no'/&gt; &lt;timer name='hypervclock' present='yes'/&gt; &lt;timer name='tsc' present='yes' mode='native'/&gt; &lt;/clock&gt; &lt;devices&gt; &lt;!-- Through I've added the virtio mouse and keyboard, the PS2 devices cannot be removed as they are an internal function of the emulated Q35/440FX chipsets --&gt; &lt;input type='mouse' bus='virtio'/&gt; &lt;input type='keyboard' bus='virtio'/&gt; &lt;disk type='file' device='disk'&gt; &lt;driver name='qemu' type='qcow2' cache='none' io='native' discard='unmap' iothread='1' queues='8'/&gt; &lt;source file='/mnt/storage4/win10.qcow2'/&gt; &lt;target dev='vda' bus='virtio'/&gt; &lt;/disk&gt; &lt;interface type='direct'&gt; &lt;mac address='11:45:14:19:19:81'/&gt; &lt;source dev='macvtap0' mode='vepa'/&gt; &lt;model type='virtio'/&gt; &lt;/interface&gt; &lt;/devices&gt;&lt;/domain&gt;","link":"/zh-cn/computer/2020/kvm/"},{"title":"make-a-risc-v-cpu","text":"如何造一个RISC-V架构的CPU Bit Extender 和 Splitter 都可以用来扩充地址以使信号兼容高位宽线路, 此外, Splitter 可裁剪数据以使电路兼容低位宽线路, 如程序计数器 二进制 可按4位二进制对应1位16进制, 从右往左转换为16进制数 0对应0V (地线), 1对应5V 逻辑门 MOSFET, 全称 金属-氧化物半导体场效应晶体管, 分为N型和P型, 是组成逻辑门的基本元件 有栅极 G, 漏极 D, 源极 S 三个端口 P型 输入0导通 输入1则断开, (有个小圈圈的是P型) N型 输入1导通 输入0则断开 (在Logisim就叫Transistor) 8种逻辑门实现: 附文件: Logic_gate_implemented_by_mosfet.circ CPU 组成 ALU 全称 Arithmetic &amp; Logic Unit 算术和逻辑单元 CPU中用来计算加减乘除的单元 由加法器, 减法器, 乘法器, 除法器, 多路复用器组合而成 ALUSel: 0000 加法(add) 0001 and 0010 or 0011 xor 0100 shift logical right(srl) 0101 shift arithmetic right(sra) 0110 shift logical left(sll) 0111 compare less than(slt) 1000 除法(div) 1001 求余(rem) 1010 正数乘法(mul) 1011 正数乘法(后32位)(mulh) 1100 减法(sub) 1101 直接输出B(bsel) 1110 我还不知道 1111 我还不知道 加法器 元件符号: 半加法器无法处理前者输出的进位 所以在半加法器基础上再加一个加法器, 以处理上一个加法器输出的进位 即前一个加法器处理 A+B=Sum , 后一个半加法器再处理 Sum+Carry 具体实现: 附文件: Half_adder_and_full_adder.circ 减法器 减法器可由一个加法器加上另一个加法器和一个非门得到 原理: (假设加法器只有4位) 5-4=5+(-4)=1=0B0001 将 -4 视为正数 4 然后按位取反再加一(称为二补数): 4 -&gt; 0100 , 取反得 1011 , 1011+1=1100 将 5 和 0B1100 相加: 0B1100+0B0101=0B0001 (最高位溢出) 此时可以发现, 5+4的二补数 的结果正好等于 5-4 的结果 有符号数的最高位被用来表示符号位. 如4位的系统中, 0000~0111 代表0~7 这8个正数; 1000~1111代表 -8~-1 这8个负数 有符号数(Signed number): 能表示正数和负数 无符号数(Unsigned number): 只能表示负数 乘法器 乘法器的本质是移位加法 举个例子: 5x7=35=0101x0111=0010 0011 从被乘数的最低位开始，如果第 i 位为 1，则乘数左移 i 位后与之前的值相加，若 0 则不动，直至被乘数的最高位 0101x0111=(第0位为1) 0111&lt;&lt;0 + (第1位为0) + (第2为为1) 0111&lt;&lt;2 + (第3位为0) 为什么能成立呢? 可以这样: 5x7=7+7+7+7+7=7+4x7=7x2^0+7x2^2=7&lt;&lt;0+7&lt;&lt;2 除法器 除法器的本质是移位加减(和平时算除法的方式是一样的) 举个例子: 74 / 8 = 9 = 1001010 / 1000 = 1001 0100 1010 将除数移到高位: 1000 0000 然后将被除数减去当前除数: (0100 1010 - 1000 0000) &lt; 0 若减去后小于零, 商左移补0一位, 然后除数右移一位, 此时: 商=0 除数=0100 0000 将被除数减去当前的除数: 0100 1010 - 0100 0000 = 0000 1010 若减去后打于零, 商左移补1一位, 然后除数右移一位, 此时: 商=01 除数=0010 0000 以此往复, 直到被除数变为0(移了8位), 或者被除数减去当前除数结果为0 多路复用器 Multiplexer 多路复用器, 简称 Mux 通过控制 Sel 以输出 A, B, C, D 之中其中一路的值 具体实现: 附文件: Four_way_multiplexer.circ 寄存器 (别去管它一开始的状态是怎样的) 寄存器由 8 个 D 触发器构成 触发器=锁存器+时钟信号的调控 S-R 触发器 S-R 代表 Set-Reset D 触发器 D 代表 Data 将时钟上沿信号直接接到Enable端口上, 数据的更改受到时钟信号调控, 然而不能长期保存数据 寄存器 在时钟信号这边另加一个与门和端口, 这样就可以决定是否放行时钟信号, 从而防止数据被时钟信号刷掉 具体实现: 附文件: Four_way_multiplexer.circ RAM 然后是底层原理: Logisim中无法直接模拟DRAM, SRAM我试过也不行 横着的线称为字线(wordline), 用于启用指定地址下的8个内存单元 竖着的线称为位线(bitline), 负责数据的输入和输出 解码器(Decoder)负责根据输入的内存地址开启对应的字线 附上解码器(Decoder)的具体实现 附文件: 2_bit_Decoder.circ 附上一个RAM的使用示例: 文件: RAM_example.circ 程序计数器 程序计数器用于指向当前指令(IMEN)内存中的地址 时钟每上沿一次, 计数+4(内存中一条字线管理32位数据, 也就是4个字节) 具体实现: Program_Counter.circ RISC-V 架构 指令抓取 -&gt; 指令解码 -&gt; 执行 -&gt; 内存操作 -&gt; 回写 结构 RISC-V架构(按先后顺序排列: PC寄存器: 存储在指令内存中, CPU当前执行的位置 指令内存(IMEM): 储存需要运行的指令, 程序运行时, 数据不能够被更改 32个寄存器(reg0~reg31): 储存程序运行时的一些临时变量 ALU: 逻辑与数学运算 数据内存(DMEM): 负责存储较大的数据, 程序运行时能够被读写 以上模块构成了RICV-V的数据管线(Data Pipeline) 控制单元(Control Unit): 充当&quot;阀门&quot;, 负责协调以上模块 指令集(Instruction Set): 特定架构下CPU实现的一套操作, 如加减法, 指令集 核心指令格式 规定了所有指令集需要参照的格式(见表格): RISC-V中, 单条指令长度固定32位, 有六个基本类型(R I S SB U UJ) opcode: 规定指令内容(类似于编程中的函数符号, 如func(var1, var2) ), 7位. rd: 目标寄存器(Destination reg), 指定指令结果存储到哪个寄存器中, 5位(对应32个寄存器). 而 S, SB 这两种没有规定 rd, 说明这两种指令操作不会产生新的值(类似于编程中没有返回值的函数). rs1 和 rs2: 来源寄存器(source reg), 类似于函数的参数 如 a+b=c 中, rs1 对应 a, rs2 对应 b, rd 对应 c funct3和funct7: 函数(function), 3代表3位, 7代表7位, 作用是定义函数的实现(如规定a?b是加法 a+b 还是减法 a-b) imm: 立即数(immediate value), 类似于常数(如 a+4=c 的 4) RV64I 基础指令 注意: RISC-V 虽然有32个寄存器, 但寄存器 x0 的值恒为 0, 这是因为 0 这个数经常被用到, 如将 x1 初始化为 0 可用 addi x1, x0, 0 图中用的是Verilog, 一种逻辑描述语言, 若你懂些英文, 建议看一看再读下面的内容 Verilog_for_61C.pdf 汇编语言的格式: add x1, x2, x3 , x1 代表 rd, x2 代表 rs1, x3 代表 rs2 addi x1, x2, 5 , 5 是立即数(或者叫常数) 一些指令的解释: add 和 addw 这样的指令实现的是相同的操作, 区别在于带 ‘w’ 后缀表示与32位兼容(只使用64位寄存器的前32位) jal: 将指令指针从当前位置往后跳 imm/2 行(为什么除2而不是4, 因为有短指令, 具体看下面). 从表中看到, 它的定义是 R[rd]=PC+4; PC=PC + {imm,1b’0}, 由分号分隔, 说明这个指令有两个步骤. 第一步是将(本来要执行的)指令地址储存到 rd 中(方便那边的指令执行完毕后跳转回来) 第二步是修改PC寄存器, 同时赋值的 imm 左移补一个 0 (至于为什么要补一个0而不是两个0, 因为RISC-V虽然一般的指令长度是32位(4字节), 但它也支持16位的短指令, 所以跳转的最小值实际上是2. 你会发现, imm每次+1, 因为后面补了一个0, 实际上+1就变成+2了, 补两个0就是+4) 有些时候, 若某个程序比较大, 以至于需要跳转的行数特别大(jal-&gt;属于UJ指令-&gt;imm最大20位-&gt;最大跳转长度 2^20), 无法直接跳转, 就需要组合技 auipc + jalr auipc 后面的 imm 补了12个0(换算成十进制是4096 -&gt; 往后跳 imm * 1024行), 可以表达很大的跳转行数, 但不会实际执行, auipc 只是将计算后的地址储存到 rd 中. jalr 是从寄存器取得指令内存地址, 并加上 imm/4 行(jalr 的 imm 竟然没有补0)后赋值到PC, 同样的, 将(本来要执行的)指令地址储存到 rd 中以方便跳转回来. 示例(我要将PC地址跳1024+5行, 并将回跳地址保存在寄存器 x2): auipc x1, 1 jalr x2, x1, 20 从指令集到机器代码 机器代码是指令实际储存在内存中的样子 举个例子: addi x1, x0, 1 要将他转化为机器码, 需要查表(本章开局那里)得到addi的参数: type: I opcode: 0010011 funct3: 000 因为addi是I型, 根据Core Instruction Formats的定义将这句汇编代码翻译成机器码: 31 20 19 15 14 12 11 7 6 0 000000000001 00000 000 00001 0010011 为了方便可以转成16进制: 0x00100093 CPU实现 附上一个花了我三天的CPU实现, 参考了 T-K-233 的设计, 一些地方略有不同 risv_v_simple.circ","link":"/zh-cn/computer/2020/make-a-risc-v-cpu/"},{"title":"linux-usage","text":"一份我的 Linux 手扎 A paper of my Linux gists Linux Common Commands Shell builtin &amp; Concept filter: 能用在管道里的命令属于过滤器. 什么样的命令能用于管道? 能对 stdin 文本按行处理, 并将结果输出到 stdout 的命令 cp, diff 不属于过滤器 Linux 命令特点 如果没有 argument, 默认从 stdin 读. 默认输出到 stdout type xxx 查看命令类型(外部命令还是内部命令) man builtins 查看 shell 的内部命令文档 help xxx 可查看内部命令的快速帮助 history 查看命令历史, 搭配 fc 使用 Redirect: 覆盖（write）输出重定向 &gt; 追加（append）重定向 &gt;&gt; 字符串输入重定向 &lt;&lt;&lt; 理解命令行参数的实现，stdin/stdout/stderr的用法 1234567891011121314151617181920#include&lt;stdio.h&gt;int main(int argc, char *argv[]) { int i = 0; char c; for (; i &lt; argc; ++i) { fprintf(stdout, &quot;%d: %s\\n&quot;, i, argv[i]); } fflush(stdout); c = fgetc(stdin); while (c != EOF) { if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') { c = c + 'A' - 'a'; } fputc(c, stdout); c = fgetc(stdin); } fflush(stdout); fprintf(stderr, &quot;I am stderr\\n&quot;); fflush(stderr);} 取值符 $ $$(等价于 ${$}) 当前 Shell 的 PID $0 上一个命令返回的状态编号 (≥0) Shell中的变量 默认是字符串 declare -i 可定于整数类型变量12345$ x=5$ y=3$ declare -i l=$x+$y$ l=l+3 // 此时变量l是整数类型// 也可用 k=$(($x+$y)), 不过 k 依然是字符串类型 如果做整数数值运算, 会把非整数都理解为 0. declare +i 把变量整数属性去掉 Shell For loop for.sh12345sum=$1for ((i=0;i&lt;$num; i=i+1))do nohup ./run-folder.sh $num $i &amp;done Shell Function sum.sh123456789101112131415function sum() { echo $# # 收到的参数数量 echo $* # 参数的字符串 echo $0 # 第0个参数, 执行文件的名字 echo $1 # 第一个参数 echo $@ # 参数数组}sum 1 2 7 'a' # 函数调用# 结果是# 4# 1 2 7 a# ./sum.sh# 1# 1 2 7 a awk awk 过滤第三列成绩大于等于 90 的同学: awk '$3 &gt;= 90 {print}' scores.txt4 | less $3 &gt;= 90 为条件式 (pattern) {print} 为动作 (action) 输出单独第二列列可用 {print $2} ($0则表示所有列, 即整行) 条件式为可选, 如输出第二列和第五列 awk '{print $2, $5}' scores.txt | less 特殊变量NR表示当前行号, 如过滤掉第一行 awk 'NR &gt; 1 {print $2, $5}' scores.txt | less 特殊模式 BEGIN 表示文件开始, END 表示文件结尾, 如在文件开始添加一行表头, 在结尾加一句 “Hi, bye”: awk 'BEGIN {print &quot;No. ID. Score&quot;}; {print}; END {print &quot;HI, BYE&quot;}' scores.txt4 | less awk 还能定义变量计算平均成绩: awk 'BEGIN {sum = 0}; {sum = sum + $3}; END {aver = sum / NR; print NR, sum, aver}' scores.txt4 | less 或者计算字符数 awk '{cn = cn + length($0) + 1}; END {print NR, cn}' scores.txt4 (+1 是因为每行的末尾还有一个换行符) 或者计算字段(用到特殊变量NF, 表示当前行字段数) awk '{cn = cn + length($0) + 1; wn = wn + NF}; END {print NR, wn, cn}' scores.txt4 (可通过 wc scores.txt4 来验证行数、字段数和字符数) egrep -o 只显示匹配上的文字, 如只显示匹配2000年人民日报的序号 cat */*.txt | egrep '^[0-9-]+' -o | sort | less -n 可显示行号, -v 匹配取反, -i 大小写不敏感, -r 递归查询文件夹目录 sort默认是使用ASCII码排序, 对于数字排序, 需要加上参数 -n 对 scores.txt4 的第三列(成绩)进行排序 sort -n -k 3 scores.txt4 | less 反向排序时可加参数 -r. -u 可删除排序内容相同的行, 与 sort | uniq 的区别是 uniq 命令是删除完全一样的行, 而前者会删除匹配列内容相同的行. tr 可转换文字大小写, 如 tr 'a-z' 'A-Z' xargs 可将管道前一个命令的输出作为输入参数 如计算一堆文件内数字及’-'的数量 find . -name '*[0-9][0-9][0-9]*.txt' | xargs egrep -o '^[0-9-]+' | wc -l diff 共有三个命令: d(delete)、c(change)、a(add) 如 130d129 为删除 130 行对齐到 129 行, 249a130,131 为将后者的 130, 131 行添加到前者的 249 行后, 271,373c163,271 为拿后者的 163, 271 行去替换前者的 271, 373行 nohup 防止退出账户导致程序挂起 让程序后台运行 nohup bash run0.sh &amp; Filesystem 一个文件对应一个 inode (存储文件属性+block的指针列表)和0~n个block(存储文件真实内容) 硬链接: 同一个文件, 有多个名字; 只针对文件, 不支持目录; 不能跨文件系统. 软连接: 不同文件; 文件/目录都可以; 可用跨文件系统. 为什么文件夹不能创建硬链接, 硬连接数却大于1? 因为目录下的&quot;.“和子目录的”…&quot;能够增加目录硬链接数. Misc findmnt list all mounted filesystems. # systool -v -m module_name list options that are set for a loaded module. sed The usage of group in regular expression: ((regex) and \\1) 1$ sed -i 's,\\$\\([^$]*\\)\\$,\\\\\\\\(\\1\\\\\\\\),g' file.md grep Find in files: 1$ grep -iRl &quot;your-text-to-find&quot; ./ rsync Copy and preserve all attributes1$ rsync -aXHAv -P $SOURCE_DIR/ $TARGET_DIR/` Copy only, don’t keep permission and owner (keep only touch times)1$ rsync -rlt -P --no-owner --no-group --no-perms $SOURCE_DIR/ $TARGET_DIR/ Synchronize folders, be aware that --delete will delete any additional folder / files from $TARGET_DIR which is not in $SOURCE_DIR1$ rsync -aXHAz -v -P --exclude={&quot;filename1&quot;,&quot;path/to/filename2&quot;} --delete $SOURCE_DIR/ $TARGET_DIR/ ss ss is member of iproute tools set List sockets statitics: ss -s To see which process was using specific port: ss -nlptu | grep $PORT_NUMBER dd To backup your GPT: 1# dd if=/dev/sda of=gpt-partition.bin bs=512 count=34 To restore your GPT 1# dd if=gpt-partition.bin of=/dev/sda bs=512 count=34 pwgen Random password generator To generate 20 different passwords which has length 12 and at least one big letter (-c), number (-n), symbol (-y). Furthmore, -s can generate more randomize passwords 1$ pwgen -cnys 12 20 Recursively chmod all directories and exclude files To recursively give directories read &amp; execute privileges: 1# find /path/to/dir -type d -exec chmod 755 {} + To recursively give files read privileges: 1# find /path/to/dir -type f -exec chmod 644 {} + Reference from StackExchange Exclusive delete By using glob extension in bash: 12# shopt -s extglob# rm -r !(filename1|filename2|dir1) ssh-keygen Show the fingerprint of a keyfile:12$ ssh-keygen -l -f &lt;/path/to/key&gt;$ ssh-keygen -l -E md5 -f &lt;/path/to/key&gt; Modify the comment of a keyfile:1$ ssh-keygen -c -C &lt;Your comment&gt; -f &lt;/path/to/key&gt; Show the information of a keyfile:1$ ssh-keygen -y -f &lt;Your key&gt; Kernel interface UUID Generator (Or uuidgen):1$ cat /proc/sys/kernel/random/uuid Show available entropy:1cat /proc/sys/kernel/random/entropy_avail Show battery capacity remain:1$ cat /sys/class/power_supply/&lt;Your battery name&gt;/capacity List network interfaces: ls /sys/class/net or ip link Show monitor modes from kernel DRM module1$ cat /sys/class/drm/card0/card0-eDP-1/modes Iptables IPSET u32 匹配 判断一个包的 TCP Seq 的最后一个值是否等于 41 : 0&gt;&gt;22&amp;0x3C@ 4 &amp;0xFF=0x29 举个例子(可以用 WireShark 抓包): 123456Source IP: 121.41.89.52= 01111001 00101001 01011001 00110100B = 79 29 59 34H = 2032752948DIP Header：45 00 00 3c 00 00 40 00 31 06 ef 34 **79 29 59 34** c0 a8 c7 81TCP Header：00 50 95 3c 8d 7f 52 ac 69 15 33 be a0 12 71 20 cd dc 00 00 02 04 05 14 04 02 08 0a 08 c8 62 fa 00 1c 30 a1 01 03 03 07 0&gt;&gt;22 的含义是从 IP 报头的 0 下标取 4 字节(共 32 位, u32 默认取 4 字节), 然后按位右移 22 位, 从而得到剩余的开头 10 位. 如 45 00 00 3c = 0100 0101 0000 0000 0000 0000 0011 1100 右移 22 位 得到 1 14 = 01 0001 0100 后面的 &amp;0x3C 的含义是和 0x3C = 0011 1100 进行按位与运算(实际上就是过滤) 因此本例中 0&gt;&gt;22&amp;0x3C 即 01 0001 0100 &amp; 00 0011 1100 得到 00 0001 0100, 通过这两个操作我们得到了 IP 头的第 4~7 位的值 记录 IP 头长度的值是 IP 头的第 4~7 位的值值再加两个 0 也就是 01 0100 (十进制的 20) @ 的含义是根据左边的值推进指针, 本例中 0&gt;&gt;22&amp;0x3C@ 即推进 20 个字节 剩下的也没什么好说的了, 从 TCP 头第 4 下标处取 4 字节然后用掩码 0xFF 按位与取得其中的最后一个字节, 然后比较是否等于 0x29 = 41D 等号后可以是单个值也可以是一个区间, 如判断一个包的 TCP Seq 的最后一个值是否在 41~60 之间 0&gt;&gt;22&amp;0x3C@ 4 &amp;0xFF=0x29:0x3C bash IF Statement in Bash Integer Operator123456-eq equal-ne not equal-gt greater-ge geeater or equal-lt lesser-le lesser or equal File Operator1234567891011-e File or directory exist-r Readable-w Writable-x Executable-f Whether a normal file-d &quot;dir&quot; Whether a directory exists! -d &quot;dir&quot; Whether a directioy not exists-c Whether a char file-b Whether a block file-s Ture if file size is not zero-t Whether a tty file String Operator12345678910==POSIX shstr1 = str2str1 &gt; str2 compare by alphabetical orderstr1 &lt; str2-z str True if the string length is zero.-n str True if the string length is non-zero.==Bash specific (Can use pattern matching '[[' ']]')str1 == str2str1 != str2str1 =~ regex extended regular expression Logical Operator12345-a And-o Or! Not[] &amp;&amp; [] And (For pattern matching use '[[' ']]')[] || [] Or Bash Extended Globbing Glob Regular Expression Equivalent * .* ? . [a-z] SAME ?(pattern) (regex)? *(pattern) (regex)* +(pattern) (regex)+ @(pattern) (regex){1} !(pattern) ^((?!regex).)*$ Variable Parameter Expansions ::n Cut n chars from left to right if n is positive, otherwise right to left if negative :n Cut to end start from column n, if n is negative then right to left (use :(-n) or : -n) :x:y Cut y chars start from column x ${food:-Cake} Defaults to Cake if $food does not exist STR=&quot;/path/to/foo.cpp&quot; echo ${STR%/*} # /path/to Cut from right to left, single % means non-greedy. echo ${STR#*/} # path/to/foo.cpp Cut from left to right, single # means non-greedy. echo ${STR%.cpp} # /path/to/foo Two % is greedy. echo ${STR##*.} # cpp Two # is greedy. echo ${STR/foo/bar} # /path/to/bar.cpp String substitition, single / means non-greedy echo ${STR//o/b} # /path/tb/fbb.cpp Two / is greedy Bash Built-in variables $# number of arguments SSH Tunnel X11vnc startup With SDDM and SSH Tunnel. Please be aware that this command need to be executed on client-side. 1ssh -t -L 5900:localhost:5900 &lt;REMOTE HOST&gt; 'sudo x11vnc -localhost -display :0 -auth $(find /var/run/sddm/ -type f)' Trap Reset signal TERM’s action to the default: trap - TERM Signal Number Signal Name Default Action 0 EXIT Nothing 2 INT Terminate (Interrupt, weakest, Ctrl+C) 15 TERM Terminate (Exit cleanly, normal) 1 HUP Terminate (Hangup, normal, sent from SSH disconnect) 3 QUIT Terminate (Harshest but still handle ignorable, core dump) 9 KILL Terminate (Unconditionally)","link":"/zh-cn/computer/2020/linux-usage/"},{"title":"my-software-configuration","text":"配置文件整合 linux sysctl/etc/sysctl.d/99-sysctl.conf123456# BBR TCP Congestionnet.core.default_qdisc = cakenet.ipv4.tcp_congestion_control = bbr# Kernel Panic auto reboot after 30 minuteskernel.panic = 3780 Windows 10/11 禁用遥感 组策略:1234Administrative Templates -&gt; Windows Components -&gt; Data Collection and Preview Builds -&gt; Allow Telemetry -&gt; Enabled, Options: 0 - Security [Enterprise Only] 计划任务:12345Task Scheduler Library -&gt; Microsoft -&gt; Windows -&gt; Application Experience -&gt; Microsoft Compatibility Appraiser -&gt; Disable 禁用 Connected User Experiences and Telemetry1Set-Service DiagTrack -StartupType Disabled 启用UTC1reg add &quot;HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_QWORD /f 参考 Archlinux Wiki 禁用英特尔CPU幽灵/熔断/僵尸负载漏洞补丁12reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management&quot; /v FeatureSettingsOverride /t REG_DWORD /d 3 /freg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management&quot; /v FeatureSettingsOverrideMask /t REG_DWORD /d 3 /f 参考 Microsoft Docs 任务栏时间显示秒钟1reg add &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced&quot; /v ShowSecondsInSystemClock /t REG_DWORD /d 1 /f 默认使用半角标点符号(全角/半角切换: Ctrl+.)12345678Time &amp; Language -&gt; Language -&gt; Chinese (Simplified, China) -&gt; Microsoft Pinyin -&gt; Options -&gt; General -&gt; Use English punctuations when in Chinese input mode: On Scoop installed git bash: “Open Git Bash” here context menu git-install-context.reg git-uninstall-context.reg Windows 11 full right-click menu enable: reg add &quot;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32&quot; /f /ve disable: reg delete &quot;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}&quot; /f Don’t forget to reboot. reference: https://gist.github.com/nebula-moe/75c49c261d1fc9e780df8ed9d0baed97 MPV 脚本 portable_config\\scripts\\auto-profiles.lua shaders文件 portable_config\\shaders\\, 请自行取消我的注释以启用shaders KrigBilateral.glsl nnedi3-nns32-win8x4.hook nnedi3-nns64-win8x4.hook SSimDownscaler.glsl SSimSuperRes.glsl 升级Openwrt 记录小米路由器3G 的 Openwrt 配置 使用 sysupgrade 方式升级123# cd /tmp# wget https://downloads.openwrt.org/snapshots/targets/ramips/mt7621/openwrt-ramips-mt7621-mir3g-squashfs-sysupgrade.tar# sysupgrade /tmp/openwrt-ramips-mt7621-mir3g-squashfs-sysupgrade.tar 升级完后最好更新以下新版本系统的软件包123# opkg update# opkg list-upgradable# opkg list-upgradable | sed -e &quot;s/\\s.*//&quot; | while read PKG_NAME; do opkg upgrade &quot;${PKG_NAME}&quot;; done 安装的软件包123456789nanodiffutilshtopopenssh-sftp-server # if default ssh server dropbear cannnot connectluci-sslluci-theme-materialluci-app-upnpluci-app-wolluci-app-mwan3 Hexo Config:hexo/_config.yml12345678910111213141516171819202122232425262728293031323334353637# 标签页标题title: Ndoskrnl's blogdescription: 'There is nothing to say now'author: Ndoskrnl# 多语言支持language:- zh-cn- en# 时区timezone: 'Asia/Shanghai'# Urlurl: http://blog.ndoskrnl.net# 文章永久链接(目录)permalink: :lang/:category/:year/:title/# 永久链接变量默认值配置permalink_defaults: lang: en# 新文章文件目录new_post_name: :lang/:category/:title.md# 资源文件夹post_asset_folder: true# 主题theme: icarus# 解决半角符号渲染成全角的问题marked: smartypants: false# 部署到 Github Pagesdeploy: type: git repo: git@github.com:ndoskrnl/ndoskrnl.github.io.git branch: master Icarus 主题设置 主题设置由于改动较多且时效性不高, 这里不作记录 具体请见主题配置文件 theme/icarus/_config.yml 将主页样式变为归档页形式: 直接将theme/icarus/layout/index.jsx 替换成 theme/icarus/layout/archive.jsx 内的内容 Git Hook/home/git/blog.git/hooks/post-update1234567891011121314151617181920212223242526#!/bin/bash# 首先删除旧文件# 启用extglob才能用!(xx)之类的语法shopt -s extglobrm -rf /srv/git/www/!(node_modules)# git checkoutgit --work-tree=/srv/git/www --git-dir=/srv/git/blog.git checkout -f# 进入网页文件夹目录cd /srv/git/www# 若node_modules文件夹不存在, 安装依赖插件if [ ! -d /srv/git/www/node_modules ]; then npm installfi# 若package.json有改动, 更新插件CHANGED=$(git --git-dir=/srv/git/blog.git diff HEAD^! --stat -- package.json | wc -l)if [ $CHANGED -gt 0 ]; then rm -rf /srv/git/www/node_modules npm installfi# 生成静态网页hexo g 额外安装的插件123hexo-symbols-count-time # 字数统计hexo-filter-plantuml # UML Diagram for hexohexo-deployer-git # Git 部署 (Github Pages)","link":"/zh-cn/computer/2021/my-software-configuration/"},{"title":"windows10-usage","text":"记录一些windows的使用技巧 查看哪些进程正在使用我的摄像头 前往微软文档下载Process Explorer 注意要以管理器权限运行procexp64.exe 具体使用方法: 首先在设备管理器找到摄像头的&quot;物理设备对象名称&quot;, 右键复制 打开 Process Explorer 然后 Ctrl + F, 查询句柄. (这里我打开了mumu模拟器的相机应用) 注意事项: 1. 如果只有svchost.exe而查不到其他使用该句柄的程序, 则一般是某个uwp应用在使用该设备 2. 也可以查看其他设备(如麦克风) 启用 Compact 压缩 123compact /compactos:always # 压缩所有系统文件compact /compactos:query # 查询系统的压缩状态。compact /compactos:never # 取消所有系统文件的压缩 清理组件存储(WinSxS ) 12dism.exe /Online /Cleanup-Image /AnalyzeComponentStore # 查看组件存储大小dism.exe /online /Cleanup-Image /StartComponentCleanup # 执行组件存储清理 Intel ME Firmware 查看 ME 信息1&gt; MEInfoWin.exe 备份 ME 固件1FWUpdLcl.exe -SAVE xxxx.bin 刷写 ME 固件1FWUpdLcl64.exe -f ..\\ME8_1.5M_Production.bin Hyper-V Manager Troubleshoot 首先客户机和宿主机都要启用 WinRM12345678910111213141516PS C:\\Users\\ndoskrnl&gt; Enable-PSRemoting -ForceWinRM has been updated to receive requests.WinRM service type changed successfully.WinRM service started.Set-WSManQuickConfig : &lt;f:WSManFault xmlns:f=&quot;http://schemas.microsoft.com/wbem/wsman/1/wsmanfault&quot; Code=&quot;2150859113&quot;Machine=&quot;localhost&quot;&gt;&lt;f:Message&gt;&lt;f:ProviderFault provider=&quot;Config provider&quot;path=&quot;%systemroot%\\system32\\WsmSvc.dll&quot;&gt;&lt;f:WSManFault xmlns:f=&quot;http://schemas.microsoft.com/wbem/wsman/1/wsmanfault&quot;Code=&quot;2150859113&quot; Machine=&quot;DESKTOP-1KNPPCL&quot;&gt;&lt;f:Message&gt;WinRM firewall exception will not work since one of the networkconnection types on this machine is set to Public. Change the network connection type to either Domain or Private andtry again. &lt;/f:Message&gt;&lt;/f:WSManFault&gt;&lt;/f:ProviderFault&gt;&lt;/f:Message&gt;&lt;/f:WSManFault&gt;At line:116 char:17+ Set-WSManQuickConfig -force+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidOperation: (:) [Set-WSManQuickConfig], InvalidOperationException + FullyQualifiedErrorId : WsManError,Microsoft.WSMan.Management.SetWSManQuickConfigCommand 遇到错误, 用 Set-NetConnectionProfile 将所有网络设置为 Private:123456789101112131415PS C:\\Users\\ndoskrnl&gt; Get-NetConnectionProfileName : Network 5InterfaceAlias : ZeroTier One [83048a06326c5a60]InterfaceIndex : 9NetworkCategory : PrivateIPv4Connectivity : LocalNetworkIPv6Connectivity : LocalNetworkName : Xiaomi_XXXX_5GInterfaceAlias : vEthernet (External Network With Adapter)InterfaceIndex : 16NetworkCategory : PrivateIPv4Connectivity : InternetIPv6Connectivity : InternetPS C:\\Users\\ndoskrnl&gt; Set-NetConnectionProfile -InterfaceIndex 9 -NetworkCategory Private 有时候即使设置了还是会报错, 直接上参数 -SkipNetworkProfileCheck 吧:1PS C:\\Users\\ndoskrnl&gt; Enable-PSRemoting -SkipNetworkProfileCheck -Force 然后再在客户端设置 TrustedHosts1Set-Item WSMan:localhost\\client\\trustedhosts -value &quot;DESKTOP-XXXXXXX.lan&quot; -Force 查看一下确保无错:1Get-Item WSMan:localhost\\client\\trustedhosts 多个主机名可用逗号分隔123$curValue = (Get-Item wsman:\\localhost\\Client\\TrustedHosts).valueSet-Item wsman:\\localhost\\Client\\TrustedHosts -Value `&quot;$curValue, Server01.Domain01.Fabrikam.com&quot;","link":"/zh-cn/computer/2020/windows10-usage/"},{"title":"water-purifier","text":"一份 DIY 净水器需要的零件单 TODO: 优化格式 配件单 汇通RO膜 75G, 型号ULP1812-75 45元 GVE冠宇达电源24V电源, 型号GM48-240200-D, 接口为DC圆头5.5mmx2.5mm 29.9元 CNKB科博高压开关, 型号HPS-1 9元 CNKB科博冲洗电磁阀300CC, 型号FPD-360M30 13.8元 GBN逆止阀, 型号LDK2K2 5元 三角洲75G增压泵, 型号EC-103-75 92元 CNKB科博进水电磁阀, 型号FPD-360L30 12.8元 CNKB科博低压开关, 型号LPS-1 9元 乐透3.2G压力桶, 型号NPTK-3.2G 55元 DNT迪恩特2分快接球阀 1.9元 10寸滤瓶扳手 1.2元 2分CCK管x20米 11.8元(0.59元/米) 2分PE管剪刀 2.8元 DNT迪恩特2分快插弯头x15 7.5元(0.5元/件) DNT迪恩特2分T型三通x3 1.8元(0.6元/件) RO五级挂板 15元 乐透后置活性炭滤芯T33 15元 RO反渗透膜壳1812型(送3个2分快接头) 9.8元 10寸2分口滤瓶x3(两白一透明) 54元(18元/件) DNT迪恩特2分外丝转二分管x6 2.4元(0.4元/件) 10寸前三级通用滤芯(PPF棉、UDF颗粒活性炭,CTO压缩活性炭) 19.8元 1812型大单夹x2 0.8元(0.4元/件) RO膜壳扳手 1元 1812型子母夹x2 0.8元(0.4元/件) 家用净水器电脑版电源母插头(2.5mm的头) 1.2元 家用净水器电脑版 29元 2分一体合金三通阀门(送生料带) 5.5元 304不锈钢外六角十字三组合螺丝10只 3.8元 合计456.6元 提示 一般来说, 前置第一级3个月一换, 二三级6个月一换. 陶氏跟杜邦合并了, 国产杜邦用了陶氏的技术, 性价比最高(淘宝搜杜邦陶氏1812-75只要89)","link":"/zh-cn/daily-life/2021/water-purifier/"},{"title":"Grammars-for-English-Majors-Band-4","text":"Believe in Yourself Believe in your dreams. Believe that you are loved. Believe that you make a different. Believe we can build a better world. Believe there’s light at the end of the tunnel. Believe that you may be that light for someone else. Believe that the best is yet to be. Believe in yourself. 记录要记忆的东西 语法 语法基本概念 名词与主谓一致 代词 限定词 形容词、副词及比较结构 介词 情态助动词 非谓语动词 名词性从句 定语从句 状语从句 时态与语态 虚拟语气 反意疑问句 倒装与省略 词汇 英语6种主要构词法 派生法(Derivation): 词根是派生词的基础, 在词根前加前缀或在词根后加后缀, 从而构成一个与原单词意义相近或相反的新词叫派生法. 前缀: 通常前缀并不影响词根的词性, 而仅对词根的意义加以修饰, 表示否定、相反、时间、方位等意义. 英语中有几个前缀, 如: be-(befriend), en-(enslave)/em-(embody), a-(ablaze), 不改变词根的基本意义, 而是引起词性的变化. 后缀: 英语中的后缀具有较强的语法作用, 后缀不改变词根的基本意义, 而是改变词性. 也有一些带后缀的派生词改变词义, 不改变词性, 例如: neighborhood, gangster, machinery 合成法(Compounding): 指由两个或两个以上本身有独立含义的单词合在一起组成一个新词的构词形式. 转化法(Conversion): 把一种词性用作另一种词性而词形不变的方法. 在词类转化上, 数量最多的当属动词和名词的相互转化. 通常表现为一词多义的现象. 截短法(Clipping): 讲一个较长的单词接短用以构成新词的方法, 主要有截除首部、截除尾部、截除首尾等形式. 通常意义不变. 截除首部 earthquake-&gt;quake 截除尾部 laboratory-&gt;lab 截除首尾 influenza-&gt;flu 混合法(Blending): 将两个词的某一部分合并, 或将一个词加上另一个词的一部分, 从而构成新词的方法. 混合法可分为4类: 词头+词尾(head+tail): television+broadcast-&gt;telecast 电视广播 词头+词头(head+head): situation+comedy-&gt;sitcom 情景剧 词头+词(head+word): medical+care-&gt;medicare 医疗保险 词+词尾(word+tail): news+broadcast-&gt;newscast 新闻报道 首字母缩略法(Acronym) Test of English as a Foreign Language-&gt;TOFEL 托福 常用词根词缀 前缀 表示否定、相反的前缀 dis-=not, the opposite of 否定, 相对 discourage vt. 使灰心 disinfect v. 杀菌(消毒) disapprove v. 不同意 il-, im-, in-, ir-=not 不, 非, 无 illiterate adj. 文盲的 n. 文盲 immoral adj. 不道德的 indifferent adj. 不关心的 irrelevant adj. 不相关的 non-=not 不, 非, 无 nonsense n. 废话 non-binding adj. 不具约束力的 un-=not 不, 非, 无 uncover vt. 揭露 unabridged adj. 未删节的, 完整的 anti-=against 反对, 防止 antinuclear adj. 反对使用核能的 anti-terrorist adj. 反恐怖主义的 contra-, counter-=against 反对, 相反 contrary adj. 相反的 n. [the ~] 相反 counterattack v. 反攻, 反击 表示程度的前缀 macro-=great 大的, 大规模的 macroeconomics n. 宏观经济 macrocosm n. 宏观世界, 宇宙 micro-=small 小, 微小 microwave n. 微波 microbiology n. 微生物学 multi-=many 多 multiple adj. 多样的 multimedia adj. 多媒体的 n. 多媒体 poly-=many 多 polysylabic n. 多音节的 表示时间的前缀 ante-, anti-=before 预先, 前 antecedent adj. 先行的 n. 前例 anticipate vt. 预料; 先于…行动 fore-=before 预先, 前 foresee vt. 预见, 预知 forehead n. 前额 pre-=before 预先, 前 preface n. 序言 predecessor n. 前辈; 前身 post-=after 后 postpone vt. 推迟 postwar adj. 战后的 表示数字的前缀 demi-, hemi-, semi-=half 半 demigod n. 半神半人 hemisphere n. 地球的半球; 大脑半球 semiconductor n. 半导体 semifinal n. 半决赛 mono-=one 一, 单 monotonous adj. 单调的 monopoly n. 垄断; 垄断商品 uni-=one 一, 单 unique adj. 唯一的 umilateral adj. 单边的 bi-, di-,=two 二, 双 bilingual adj. 双语的 dilemma n. (进退两难的)窘境 du-, dou-=two 二, 双 dual adj. 双(重)的 duplicate adj. 复制的 vt. 复制 double adj. 成双的 tri-=three 三 triangle n. 三角形 tripod n. 三脚架 quart-, quadr-=four 四 quartet n. 四重奏 quadruped adj. 四足的 pent-=five 五 pentagon n. 五角形; 五角大楼 pentathlon n. 五项全能运动 deca-, deci-=ten 十 decade n. 十年 decimal adj. 十进位的 centi-=hundred; hundredth 百; 百分之一 centigrade adj. 百分度的; 摄氏的 centimeter n. 厘米 kilo-=thousand 千 kilogram n. 千克 kilowatt n. 千瓦 milli-=thousand; thousandth 千; 千分之一 millipede n. 千足虫 millimeter n. 毫米 表示方位的前缀 dia-=between; through 在两者之间; 穿过 dialogue n. 对话, 对白 diameter n. 直径 e-, ef-, ex-=out 出, 出来 emit vt. 发出, 射出 effluent n. 废弃, 污水 exhale v. 呼出 excerpt n. 摘录 extra-=beyond 超出 extraordinary adj. 不平常的 extracurricular adj. 课外的 inter-=between, among 在…之间 interior n. 内部 adj. 内部的 interfere vi. 干涉; 干扰 sub-, suc-, sup-=under 在…之下 subordinate adj. 下级的; 从属的 successor n. 继任者 suppress vt. 镇压; 禁止发表; 抑制 tele-=far off 远的 telecommunication n. 电讯; 长途通信 telescope n. 望远镜 trans-=across 横过, 超过 transcend vt. 超出, 超越 transatlantic adj. 横跨大西洋的 super-=above, over 在…之上 superb adj. 极好的, 高质量的 superficial adj. 肤浅的; 表面的 ultra-=beyond, extremely 超过,极端 ultraviolet adj. 紫外(线)的 ultrasound n. 超声波 其他常见前缀 auto-=self 自己 autonomy n. 自治 autobiography n. 自传 bene-, bon-=good 好 beneficial adj. 有益的 bonus n. 奖金; 额外给予的东西 bio-=concerning living things 生物的, 生命的 biotechnology n. 生物技术 biodegrade v. 生物降解 by-=less important 次要的, 附带的 by-product n. 副产品 bypass n. 旁路 mal-=bad 坏 malfunction n. 失灵, 故障 malnutrition n. 营养不良 miss-=wrong, bad 错, 坏 mislead vt. 使误解; 把…带坏 misfortune n. 不幸, 逆境 co-, col-, com-, con-, cor-=together; intensifier 共同; 加强语气 coexist v. 共存, 并存 collaborate v. 合作; 通敌 combine v. 结合, 联合 consolidate v. 巩固; 合并 corrosive adj. 腐蚀性的; 侵蚀性的 syn-=together; same 一起; 相同 syndrome n. 综合病症 synonym n. 同义词 后缀 名词后缀 常见名词后缀 -ess 表示&quot;女性&quot; actress n. 女演员 waitress n. 女服务生 hostess n. 女主人 lioness n. 母狮 -ism, -asm 表示&quot;主义、学说&quot; Buddhism n. 佛教 communism n. 共产主义 egoism n. 利己主义 enthusiasm n. 热情,热忱 -ic(s) 表示&quot;…学&quot; logic n. 逻辑(学) physics n. 物理学 electronics n. 电子学 linguistics n. 语言学 -(o)logy 表示&quot;学科&quot; biology n. 生物学 sociology n. 社会学 ecology n. 生态; 生态学 ideology n. 思想(体系); 观念学 -©ule; -ie, -y; -let; -ing 表示&quot;小&quot; molecule n. 分子 birdie n. 小鸟儿 kitty n. 小猫, 猫咪 booklet n. 小册子 leaflet n. 传单 duckling n. 雏鸭 -an, -ian, -arian; -ant, -ent; -ist; -ar, -er, -or; -ee 表示&quot;人&quot; musician n. 音乐家 librarian n. 图书管理员 applicant n. 申请者 correspondent n. 记者 violinist n. 小提琴手 scholar n. 学者 painter n. 画家 executor n. 执行者 employee n. 雇员 interviewee n. 受访者 抽象名词后缀 -ability, -ibility ability n. 能力 flexibility n. 弹性 -age leakage n. 泄漏 postage n. 邮资 -al revival n. 苏醒; 复兴 refusal n. 拒绝 -ance, -ence allowance n. 津贴, 零用钱 reference n. 提及 -ancy, -ency expectancy n. 预料 frequency n. 次数, 频率 -cy accuracy n. 精确 privacy n. 隐私 -dom kingdom n. 王国 freedom n. 自由 -ery bravery n. 勇敢, 无畏 slavery n. 奴隶制 -hood childhood n. 童年 neighborhood n. 四邻 -ion, -ation, -ition revision n. 修订 observation n. 观察 transition n. 过渡 -ity, -ty maturity n. 成熟 cruelty n. 残忍 -ment retirement n. 退休 refinement n. 精炼; 优美 -ness darkness n. 黑暗 wilderness n. 荒野 -ship leadership n. 领导(层) scholarship n. 学问 -sion, -ssion precision n. 精确 depression n. 抑郁; 不景气 -ure closure n. 关闭; 终止 exposure n. 暴露; 揭发 形容词后缀 常见形容词后缀 -able, -ible 表示&quot;有能力、易做、适合&quot; suitable adj. 适当的, 合适的 vulnerable adj. 易受伤的; 易受攻击的 compatible adj. 兼容的; 合得来的 -ful 表示&quot;充满的&quot; dreadful adj. 糟透了的; 可怕的 thoughtful adj. 沉思的; 体贴的 -ior 表示&quot;比较级&quot; inferior adj. 劣等的; 下级的 superior adj. 上级的; 较好的 -most 表示&quot;最高级&quot; utmost adj. 极度的 foremost adj. 首要的, 最佳的 -less 表示&quot;否定&quot; restless adj. 焦躁不安的 groundless adj. 无根据的 -like 表示&quot;似的&quot; childlike adj. 孩子般的; 天真的 ladylike adj. 淑女般的; 端庄的 -proof 表示&quot;防…的&quot; waterproof adj. 防水的 bulletproof adj. 防弹的 -ward 表示方向 inward adj. 内心的, 里面的 outward adj. 外表的, 外面的 表示&quot;状态、性质&quot;的形容词后缀 -al natural adj. 自然的, 天然的 structural adj. 结构(上)的 -an, -arian suburban adj. 郊外的 vegetarian adj. 素食的 -ant, -ent pleasant adj. 令人愉快的 different adj. 不同的 -ary, -ory customary adj. 习惯上的 advisory adj. 顾问的; 劝告的 -ate passionate adj. 充满热情的 considerate adj. 体贴的 -en golden adj. 金色的 wooden adj. 木制的 -ic, -ical scenic adj. 景色优美的 psychological adj. 心理(学)的 -ish childish adj. 幼稚的 reddish adj. 略带红色的 -ive adaptive adj. 适应的 persuasive adj. 有说服能力的 -ous, -ious injurious adj. 有害的, 致伤的 harmonious adj. 和谐的 poisonous adj. 有毒的; 有害的 ambitious adj. 有抱负的, 雄心勃勃的 -y, -ly scary adj. 吓人的 manly adj. 男子气概的 副词后缀 ly 表示&quot;状态&quot; barely adv. 仅仅, 几乎不 deadly adv. 非常 readily adv. 乐意地; 容易地 shortly adv. 立刻 -wise 表示&quot;方式&quot; clockwise adv. 顺时针方向地 otherwise adv. 否则; 在其他方面 likewise adv. 同样地 -ward(s) 表示&quot;方向&quot; afterward(s) adv. 以后 backward(s) adv. 向后; 朝反方向 outward(s) adv. 向外 straightforward adv. 坦率地; 直截了当 动词后缀 表示&quot;做&quot;“造成”“使” -ate equate v. 使相等 originate vi. 起源于 vt. 创造 -en tighten v. 使变量; 加固 strengthen v. 加油, 巩固 -(i)fy horrify v. 使恐怖 simplify v. 简化 -ize, -ise maximize v. 增加到最大限度 specialise v. 专门研究 -ish publish v. 出版; 公布 impoverish v. 是穷困 表示反复的声音或动作 -er flicker v. (火焰)忽明忽暗, 闪烁 mutter v. 轻声低语 -le scribble v. 撩草地写 twinkle v. 闪烁 trickle v. 滴, 淌; 慢慢地移动 常见易混词辨析 词汇题6大常用解题技巧","link":"/zh-cn/learn/2021/Grammars-for-English-Majors-Band-4/"},{"title":"How-To-Ask-Questions-The-Smart-Way.tar.gz","text":"一个更简单的&lt;&lt;提问的智慧&gt;&gt;, 缓解 TL; DR 话不在多而在精 表现出你为解决问题做过的努力, 愿意在找答案的过程中做点什么, 越有可能得到帮助 不要在太多的不同群组上重复转贴同样的问题（cross-post）, 别像机关枪似的一次&quot;扫射&quot;所有的帮助渠道, 这就像大喊大叫一样会使人不快 在即时聊天软件(如QQ)寻求帮助，最好不要发布很长的问题描述，有些人称之为频道洪水. 最好通过一句话的问题描述来开始聊天 在邮件列表或论坛中, 大约 50 字以内的标题是抓住资深专家注意力的好机会 选择提问对象 当某个项目提供开发者邮件列表时, 要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题 如果一个项目既有&quot;使用者&quot;也有&quot;开发者&quot;板块, 非代码问题向&quot;使用者&quot;列表或论坛提问. 不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音 张贴前最好先暗地里观察几天以了解那里的行事方式 确定提问内容 别用喋喋不休的&quot;帮帮忙、跪求、急&quot;, 这样让人反感的话(用这种标题会被条件反射式地忽略) 来浪费这个机会. 避免用无意义的额外提问，例如&quot;有人能帮我吗？&quot;. 除非你想得到是或否类型的回答。例如：没错，没有人能帮你 如果在非母语的论坛提问, 你可以犯点拼写和语法上的小错, 但决不能在思考上马虎 (没错，我们通常能弄清两者的分别) 提示潜在回复者你有潜在的语言困难是很好的: English is not my native language; please excuse typing errors. 英文不是我的母语, 请原谅我的错字或语法 描述问题症状而非你的猜测 告诉大佬们你认为问题是怎样造成的并没什么帮助. (如果你的推断如此有效，还用向别人求助吗？) 你应当将你的推测付诸实践(如果这不是不可挽回的), 然后说明你做了什么尝试 描述目标而不是过程 如果你想弄清楚如何做某事(而不是报告一个 Bug), 在开头就描述你的目标, 然后才陈述重现你所卡住的特定步骤 一个好标题范例是 目标 —— 差异式 的描述 提升人际交往能力 彬彬有礼, 多用&quot;请&quot;和&quot;谢谢您的关注&quot;, 或&quot;谢谢你的关照&quot;. 让大家都知道你对他们花时间免费提供帮助心存感激 如果你觉得被冒犯了, 试着平静地反应. 如果有人真的做了出格的事, 邮件列表、群组或论坛中的前辈多半会招呼他. 如果这没有发生而你却发火了, 那么你发火对象的言语可能在社区中看起来是正常的. 而你将被视为有错的一方, 这将伤害到你获取信息或帮助的机会 绝不要自以为够格得到答案, 你没有; 你并没有. 毕竟你没有为这种服务支付任何报酬. 你将会是自己去挣到一个答案, 靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题, 而不仅仅是被动的从他人处索取知识","link":"/zh-cn/learn/2020/How-To-Ask-Questions-The-Smart-Way/"},{"title":"girls_dressing_skills","text":"怎么穿搭好看得体 如何着装才得体和谐 着装的审美 着装的基本要求 干净整洁, 不能又折又皱, 可学习熨烫技术 衣服轮着穿, 两套衣服穿两周比一套衣服连续穿三天好 过于保守和过于暴露是不自信的表现. 魅力应透过得体的装扮, 优雅的举止, 丰富的见识和谦逊温和的品行展现. 服装的审美 穿衣有三层境界: 第一是和谐, 第二是美感, 第三是个性. 由浅入深. 在选择衣服颜色时, 要依据颜色自身特点, 自己的体型, 肤色, 结合自己的喜好搭配. 不同的衣服有不同的穿搭技巧, 下面列出三点注意: 穿偏短的裙子, 要穿连裤丝股袜, 不能穿半截袜. 即丝袜袜口应被裙子下拜遮掩(国内不适合搞绝对领域hh). 短袜不能配凉鞋. 白色衣服和裤子应穿肉色内衣, 白裤子不能配黑皮鞋等. 衣服的洗涤和收纳 衣服的正确洗涤方法 用洗衣机时, 清洗前将口袋物品取出, 口袋外翻, 拉链拉好, 以免刮到其他衣服. 查看衣服的洗涤标签以确定洗涤和晾干方法, 内衣最好手洗 不要把衣服穿得很脏才洗, 沾上污渍的衣物要及时清洗 外衣/袜子不要与内衣一起洗 衣服的收纳及保护 当季衣服放衣橱里 过季的衣服分门别类放入防潮袋, 有需要可真空压缩. 化纤, 丝质, 棉织品不可用樟脑或香包, 易损害衣物. 空气湿度大不能晒毛衣, 羽绒服之类的衣服. 选对色彩衬肤色 色彩的搭配原则和方法 同类色搭配: 颜色色相相同或相近, 深浅明暗不同的两种同一类颜色相配. 是最简便基本的配色法. 比如绿色配天蓝, 墨绿配浅绿, 咖啡配米色. 但同类色容易显得平庸土气, 可用围巾, 披肩, 皮带, 有颜色的手势, 包包等提升亮点. 对比色搭配: 用强烈的对比撞色或明度差异明显的颜色, 即二种相隔较远的颜色搭配. 如红色与清绿色, 黄色与紫色. 但难以驾驭, 需谨慎, 一般人的肤色难以匹配. 可5:3或3:2配色技巧. 分离色搭配: 具有色彩感的服装与黑白灰搭配的配色法. 适合对色彩不自信的女生. 以黑白色作底, 上半身或下半身颜色鲜艳. 补色搭配: 每一色相与相对色相之间的关系, 即两种相对颜色的配合. 如黑白搭配 冬天宜用暖色, 夏天宜用冷色搭配 色彩与肤色的搭配 一个简单的方法, 找一个日光充足的白天, 找两件衣服, 一件蓝色一件橙色. 蓝色好看, 就适合冷色, 橙色好看, 就适合暖色. 皮肤白皙的女生, 可尝试色彩明度高的颜色, 浅色系也合适, 但不适合紫罗兰色, 亮黄色, 纯白色. 皮肤发黄的女生, 不建议穿着咖色, 褐色, 橘色, 砖红色, 蓝紫色的衣服, 且灰色调容易显得没精神. 不管是那种肤色, 不建议穿和肤色一样颜色的衣服. 基本靠-你衣柜里必备的衣服","link":"/zh-cn/learn/2021/girls-dressing-skills/"},{"title":"markdown","text":"旨在统一文档的符号、Katex 书写格式 规范 正文 使用顿号 “、” 来表示同级. 不需要空格(因为是全角符号) 下一行要留空: html表格标签结尾 图片资源标签 {%img %} Markdown 子列表(若接下来还有文本) 内容尽量用数字列表(1. 2. 3.)包装(比如本文) 若定义需要多行来解释, 第一行留空, 如:12341. 定义内容 xxx xxxx xxxxx 标题避免使用 KaTeX 式子(因为TOC无法解析) LaTeX 所有数学式子、符号必须用 LaTeX 修饰 KaTeX式子两边要留一个空格间距 尽量不在 KaTeX 式子中使用逗号; 两个 Katex 式子之间的逗号 “,” 留一个空格间距 式子后面括号注释(如 \\(y=x \\quad(x\\geqslant 0)\\) 使用的空格间距统一为 \\quad 使源文档中 KaTeX 尽量地短(减少空格的使用) (R) 会变成版权标志, 应该使用 \\(R\\) 提示 下划线 &lt;u&gt;&lt;/u&gt; KaTeX 使用自定义的空格长度可用 \\mskip{1em} Katex 中 省略号 “…” 可以用 \\dots 表示 波浪线 “~” \\sim 星号 “*” 要加斜杠变成 \\* Markdown 语法 标题 123# 最大标题## 第二大标题###### 最小标题 样式文本 样式 语法 键盘快捷键 示例 输出 粗体 ** ** 或 __ __ 命令/控制键 + b **这是粗体文本** 这是粗体文本 斜体 * * 或 _ _ 命令/控制键 + i *这是斜体文本* 这是斜体文本 删除线 ~~ ~~ ~~这是错误文本~~ 这是错误文本 粗体和嵌入的斜体 ** ** 和 _ _ **此文本 _非常_ 重要** 此文本 非常 重要 全部粗体和斜体 *** *** ***所有这些文本都很重要*** 所有这些文本都是斜体 引用文本 您可以使用&gt;来引用文本。 123用 Abraham Lincoln 的话来说：&gt; 原谅我爆粗口 表格 1234| First Header | Second Header || ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell | 有用的链接： Github-MD基础书写和格式 Github-使用表格组织化信息 锚点 12345&lt;!-- 定义锚点 --&gt; &lt;span id=&quot;const_method&quot;&gt;&lt;/span&gt;&lt;!-- 锚点链接 --&gt; [const method](#const_method)","link":"/zh-cn/learn/2020/markdown/"},{"title":"simple-chemistry-experiment","text":"一些安全条例 Solvent Polarity Table https://sites.google.com/site/miller00828/in/solvent-polarity-table Notes 含聚苯二甲酸酯(如饮料瓶常用的 PET)会和氢氧化钠等强碱反应, 因此不能用作存放强碱的容器. 砂坂孔隙度: (XC/EC) G1 20-30um 滤除粗沉淀即胶状沉淀物 © G2 10-15 滤除粗沉淀即气体洗涤 (M) G3 4.5-9um 滤除系沉淀, 过滤水银 (F) G4 3-4um 滤除系沉淀或极细沉淀物 柱层析吸附剂主要有有硅酸镁，硅胶，氧化铝，其中硅酸镁最后，不推荐硅胶和硅酸镁（硅酸镁本质为硅胶+氧化镁 ,硅胶目数越小越粗，但是也越安全），硅胶粉尘无法排出且会导致肺纤维化 对于只含碳氢氧这三种元素的有机废液，找个铁盆，放到一个空旷的地方，做好消防措施，导入废液，点燃，等燃烧干净之后就可以了​ 选展开剂之前建议先跑 TCL, 极性变化大的话可以考虑梯度淋洗​ Laboratory Glassware B190250 有柄烧杯 1 双刻度线250ML; 直径(mm) 77; 高度(mm) 96; 壁厚(mm) 3 F624125 带刻度恒压滴液漏斗（四氟节门） 1 容量(mL) 125; 磨口 24/40; 四氟节门(mm) 2 C254400 球型冷凝器 1 冷凝部分长度(mm) 400; 磨口 24/40; 连接小咀外径(mm) 10 F184100 三角漏斗 1 上部直径(mm) 100; 磨口 24/40 C184262 闪式层析柱 1 外径(mm) 26 内径(mm) 20 壁厚(mm) 3; 有效长度(mm) 254; 磨口 24/40; 节门(mm) 2 C184322C 具砂板闪式层析柱 1 外径(mm) 32; 内径(mm) 26; 壁厚(mm) 3; 有效长度(mm) 254; 磨口 24/40; 节门(mm) 2 ZH112534X 脂肪提取器/套 1 组合组成 E112585X (抽提套管, 小号, 孔隙度XC) +C243445 (球型冷凝器, 34/45, 高度275mm) +E103424 (脂肪提取器, 上磨口34/45, 下磨口24/40) +F124500 (单口平底烧瓶, 500mL,24/40) A922440 90°抽气接头(外磨口) 1 磨口 24/40 节门(mm) 10 F080100 六角底座量筒 2 100ML; 2支/盒 S402429 空心塞 1 24口直型设计 F150050 微量抽滤瓶 1 容量(mL) 50 F604060M 布什漏斗 1 容量(mL) 60; 外径(mm) 40; 砂板孔隙度 G3","link":"/zh-cn/learn/2021/simple-chemistry-experiment/"},{"title":"terms","text":"术语记录表 术语 解释 标签 - - - KDF (Key derivation function)密钥派生函数, 属于 hash 函数, 通常用来将短密码变成长密码 Cryptography CoW (Copy-on-write)多个进程共享一个副本, 只有一个进程尝试修改该资源时, 系统才会执行复制 Btrfs RTTI (Run-time Type Information)a feature of the C++ programming language that exposes information about an object’s data type at runtime. C++ TLDR (Too Long; Didn’t read.)太长不看, 等价于 TLDW(Too Long; Didn’t Watch) 贝特里奇头条定律 (Betteridge’s law of headlines)指任何以问号结尾的新闻标题, 都能够用’不’来回答 回音室效应 (Echo Chamber)In news media, echo chamber is a metaphorical description of a situation in which beliefs are amplified or reinforced by communication and repetition inside a closed system. By visiting an “echo chamber”, people are able to seek out information that reinforces their existing views, potentially as an unconscious exercise of confirmation bias. This may increase social and political polarization and extremism… 达克效应 (D-K effect)是一种认知偏差现象, 指能力欠缺的人在自己欠考虑的决定的基础上得出错误结论, 但是无法正确认识到自身的不足, 辨别错误行为. 这些能力欠缺者们沉浸在自我营造的虚幻优势之中, 常常高估自己的能力水平, 却无法客观评价他人的能力. GDP (Gross Domestic Product)国内生产总值 CPI (Consumer Price Index)消费者物价指数(通货膨胀率) PPI (Producer Price Index)生产者价格指数 PMI (Purchasing Managers’ Index)采购经理人指数(以50%作为经济强弱分界点) NFPA 704 (National Fire Protection Association)美国消防协会制定危险品紧急处理系统鉴别标准 Chemistry MTU (Maximum Transmission Unit)最大传输单元, 指位于数据链路层上的数据包所能通过的最大大小 Network LIR (Regional Internet Registry)区域互联网注册管理机构, 是管理世界上某特定地区互联网资源的组织, 包括 IP 地址和 AS 号. 现在(2021年)世界上有五个正在运作的区域互联网注册管理机构 Network 第一性原理(第一原理) 每个系统存在一个不能违背或删除的最基本命题. 寻找解决方案应尝试寻找更本质的需求 能指和所指 索绪尔语言学的一对概念, 能指意为描述实体的抽象语言本身(如词形、词音), 所指指抽象语言描述的实体及其相关的属性 SICP Structure and Interpretation of Computer Programs, 计算机程序的结构与解释, 是一本关于计算机程序设计的总体性观念的基础教科书. 书中使用程序 Lisp 语言的方言 Scheme 来解释计算机科学的核心概念, 包括抽象、递归、解释器以及元语言抽象 洗稿 指通过某些手段掩盖原文章的真实来源, 以争取审查时间差或躲避著作权的行为 HPLC (High-performance liquid chromatography)高效液相色谱法, 常用于生物化学和分析化学, 一种用于混合物分离、识别、量化各成分比例的技术 XRD (X-ray diffraction analysis)X射线衍射分析, 一种在材料科学中用于确定材料晶体结构的技术 DEXA Dual-energy X-ray absorptiometry is a means of measuring bone mineral density.","link":"/zh-cn/learn/2020/terms/"},{"title":"fabric-mod-list","text":"A detailed list of mods in my Minecraft server Launcher HMCL-3.5.2.216.jar Jan 2, 2022 Server Server name Release Date Minecraft Version fabric-installer-0.10.2 Dec 04, 2021 1.18.1 Powered by itzg’s docker image . Mods Common Mod name Download link Last Update Fabric API fabric-api-0.48.0+1.18.2.jar Mar 13, 2022 Architectury API (Fabric) architectury-4.1.36.jar Mar 27, 2022 Cloth Config API (Fabric) cloth-config-6.2.57-fabric.jar Feb 8, 2022 Fabric Language Kotlin fabric-language-kotlin-1.7.1+kotlin.1.6.10.jar Dec 20, 2021 Patchouli Patchouli-1.18.2-66-FABRIC.jar Mar 7, 2022 Not Enough Crashes (Fabric) notenoughcrashes-4.1.4+1.18.2-fabric.jar Mar 12, 2022 LazyDFU lazydfu-0.1.2.jar Feb 20, 2021 Krypton krypton-0.1.9.jar Mar 9, 2022 Lithium (Fabric) lithium-fabric-mc1.18.2-0.7.9.jar Mar 3, 2022 Starlight (Fabric) starlight-1.0.2+fabric.89b8d9f.jar Feb 28, 2022 Alternate Current alternate-current-mc1.18-1.1.0.jar Dec 1, 2021 Concurrent Chunk Management Engine (Fabric) c2me-fabric-mc1.18.2-0.2.0+alpha.7.0-all.jar Mar 5, 2022 FerriteCore (Fabric) ferritecore-4.2.0-fabric.jar Mar 4, 2022 Roughly Enough Items (REI) RoughlyEnoughItems-8.0.442.jar Mar 3, 2022 WTHIT wthit-fabric-4.8.0.jar Mar 21, 2022 megane megane-7.3.0.jar Mar 28, 2022 Polymorph (Fabric) polymorph-fabric-0.0.20-1.18.2.jar Mar 25, 2022 FallingTree (Forge&amp;Fabric) FallingTree-1.18.2-3.4.1.jar Mar 21, 2022 Universal Graves graves-2.0.0+1.18.2.jar Mar 30, 2022 AppleSkin appleskin-fabric-mc1.18.2-2.4.0.jar Mar 29, 2022 Applied Energistics 2 appliedenergistics2-11.0.0-alpha.1.jar Mar 27, 2022 Applied Energistics 2 Wireless Terminals AE2WTLib-11.0.0-alpha.1.jar Mar 27, 2022 Deep Mob Learning: Refabricated deepmoblearning-refabricated-0.5.4-beta.jar Mar 26, 2022 Reborn Core RebornCore-5.2.0-beta.2.jar Mar 5, 2022 Tech Reborn TechReborn-5.2.0-beta.2.jar Mar 5, 2022 Modern Industrialization Modern-Industrialization-1.1.0-alpha.01.jar Mar 27, 2022 Space Dimensions (Fabric) agape_space_18_2-0.5.6.jar Mar 17, 2022 CC: Restitched cc-restitched-1.100.5.jar Mar 30, 2022 Prefab prefab-fabric-3.1.2.jar Mar 29, 2022 Tax Free Levels TaxFreeLevels-1.3.jar Dec 8, 2021 Chest Cavity chestcavity-2.15.1.jar Mar 23, 2022 Nature’s Compass NaturesCompass-1.18.2-2.0.3-fabric.jar Mar 12, 2022 Milk+ milk_plus-3.0.0.jar Mar 5, 2022 Enhanced Mob Spawners fabric-branders-spawnermod-1.18.2-1.1.2.jar Mar 5, 2022 GeckoLib geckolib-fabric-1.18-3.0.35.jar Mar 1, 2022 Happiness (is a) Warm Gun HWGMod-1.18.2-1.1.4.jar Mar 27, 2022 Immersive Portals (DISABLED) immersive-portals-1.2.5-mc1.18.1-fabric.jar Jan 25, 2022 Observable (DISABLED) observable-1.2.3-fabric.jar Jan 28, 2022 Roughly Enough Resources (DISABLED) rer-2.4.1.jar Feb 16, 2022 Pending Mods: Culinaire, Industrial Revolution, Deep Mob Learning: Simulacrum, BlockTuner, IC2. Pending Mods (Management): None. Client-Side Mods Mod name Download link Last Update WMITAF wmitaf-fabric-mc1.18.1-2.2.0.jar Dec 15, 2021 cAn i MiNe thIS bLOCk? can-i-mine-this-block-1.2.0.jar Mar 7, 2022 Better Sneak BetterSneak-Fabric-1.18.2-1.0.0.jar Mar 31, 2022 Mouse Tweaks MouseTweaks-fabric-mc1.18-2.22.jar Jan 13, 2022 Just Enough Keys [JEK] [Fabric] justenoughkeys-0.5.3-fabric.jar Jan 12, 2022 Autofish Autofish-0.9.4-fabric-mc1.18.jar Dec 31, 2021 Xaero’s Minimap Xaeros_Minimap_22.4.0_Fabric_1.18.2.jar Mar 26, 2022 Light Overlay (Rift/Forge/Fabric) light-overlay-6.0.5.jar Mar 1, 2022 Trajectory preview [Fabric] Trajectory Preview-1.0-1.18.1.jar Dec 21, 2021 Mod Menu modmenu-3.1.0.jar Mar 2, 2022 ToolTipFix tooltipfix-1.0.4-1.18.jar Dec 1, 2021 Better Fps - Render Distance[Forge/Fabric] betterfpsdist-fabric-1.18-1.7.jar Feb 24, 2022 Dynamic FPS dynamic-fps-2.1.0.jar Jan 15, 2022 Enhanced Block Entities enhancedblockentities-0.6+1.18.2.jar Mar 27, 2022 Cull Leaves cullleaves-2.3.2.jar Oct 30, 2021 Entity Culling Fabric/Forge entityculling-fabric-mc1.18-1.5.0.jar Feb 9, 2022 Sodium sodium-fabric-mc1.18.2-0.4.1+build.15.jar Mar 2, 2022 Sodium Extra sodium-extra-mc1.18.2-0.4.2.jar Mar 9, 2022 Reese’s Sodium Options reeses_sodium_options-mc1.18.2-1.4.2.jar Mar 9, 2022 Indium indium-1.0.2+mc1.18.2.jar Mar 2, 2022 Baritone baritone-standalone-fabric-1.8.3.jar Mar 9, 2021 Advanced XRay (Fabric Edition) advanced-xray-fabric-1.18.2-1.0.0-build.11.jar Mar 27, 2022 Canvas Renderer (DISABLED) canvas-fabric-mc118-1.0.2282.jar Jab 11, 2021 WorldEdit CUI (Fabric) (DISABLED) WorldEditCUI-1.18.1+01-SNAPSHOT.jar Fan 7, 2022 Pending mod: Watson Note: Baritone conflicts with Immersive Portals. OptiFabric, Sodium and Canvas are conflict each other. Canvas Renderer recommands 4GiBs to run. If you use Canvas Renderer there is a recommand shader Lumi Lights Pending Mods: Physics Mod, Sodium Extra, Falling Leaves. Server-side Mods Mod name Download link Last Update LuckPerms LuckPerms-Fabric-5.4.15.jar Mar 27, 2022 Minecraft Command Permissions Fabric minecraft-command-permissions-1.5.0.jar Dec 2, 2021 spark spark-1.8.14-fabric.jar Mar 3, 2022 Fireplace Lib Fireplace-Lib-6.3.1+1.18.2.jar Mar 27, 2022 Unforgiving Void Unforgiving-Void-3.1.3+1.18.2.jar Mar 29, 2022 Ledger ledger-1.2.0.jar Mar 2, 2022 Dynmap-Forge/Fabric Dynmap-3.4-beta-3-fabric-1.18.2.jar Mar 29, 2022 Gunpowder (DISABLED) gunpowder-base-1.1.1.1+1.18.1.jar Dec 29, 2021 Gunpowder Currency (DISABLED) gunpowder-currency-1.0.8+gunpowder.1.1.1.1.mc.1.18.1.jar Dec 30, 2021 Gunpowder Market (DISABLED) gunpowder-market-1.0.7+gunpowder.1.1.1.1.mc.1.18.1.jar Dec 30, 2021 Grand Economy (DISABLED) Grand-Economy-5.1.1+1.18.jar Dec 1, 2021 WorldEdit (DISABLED) worldedit-mod-7.2.8.jar Dec 11, 2021 Pending Mods: Dynamic View[Forge/Fabric], Flan Minecraft IDs Using for mining by baritone :) Minecraft coal_ore iron_ore deepslate_iron_ore redstone_ore deepslate_redstone_ore diamond_ore iron_ore gold_ore lapis_ore The nether: nether_gold_ore nether_quartz_ore ancient_debris techreborn techreborn:tin_ore techreborn:deepslate_tin_ore techreborn:lead_ore techreborn:deepslate_lead_ore techreborn:bauxite_ore techreborn:deepslate_bauxite_ore techreborn:galena_ore techreborn:iridium_ore techreborn:ruby_ore techreborn:sapphire_ore techreborn:silver_ore techreborn:copper_ore The nether: techreborn:pyrite_ore techreborn:cinnabar_ore techreborn:sphalerite_ore The end: techreborn:tungsten_ore techreborn:sheldonite_ore techreborn:peridot_ore techreborn:sodalite_ore appliedenergistics2 appliedenergistics2:quartz_ore appliedenergistics2:charged_quartz_ore Modern Industrialization: modern_industrialization:tin_ore modern_industrialization:deepslate_tin_ore modern_industrialization:nickel_ore modern_industrialization:deepslate_nickel_ore modern_industrialization:lead_ore modern_industrialization:deepslate_lead_ore modern_industrialization:quartz_ore modern_industrialization:bauxite_ore modern_industrialization:deepslate_bauxite_ore modern_industrialization:antimony_ore modern_industrialization:deepslate_antimony_ore modern_industrialization:mozanite_ore modern_industrialization:deepslate_mozanite_ore Dynmap Due to the use of third-party services provided by LittleSkin, Dynmap needs to be configured. fabric-data/dynmap/configuration.txt12345# Control loading of player faces (if set to false, skins are never fetched)fetchskins: true# Customize URL used for fetching player skins (%player% is macro for name)skin-url: &quot;https://littleskin.cn/skin/%player%.png&quot; Worlds cleanup: Remove corresponding items in dynmap/forgeworlds.yml, then /dynmap reload LuckPerms Enable auto-op on fabric server (used as a “pssudo” root wildcard, as many mods support the operator system over permissions): All users will be de-opped unless they have the permission node luckperms.autoopserverroot/config/luckperms/luckperms.conf123456789101112# Enables or disables a special permission based system in LuckPerms for controlling OP status.## - If set to true, any user with the permission &quot;luckperms.autoop&quot; will automatically be granted# server operator status. This permission can be inherited, or set on specific servers/worlds,# temporarily, etc.# - Additionally, setting this to true will force the &quot;enable-ops&quot; option above to false. All users# will be de-opped unless they have the permission node, and the op/deop commands will be# disabled.# - It is recommended that you use this option instead of assigning a single '*' permission.# - However, on Fabric this setting can be used as a &quot;pseudo&quot; root wildcard, as many mods support# the operator system over permissions.auto-op = true C2ME Disable no-tick view distance due to mysterious ae2’s cable disconnect:serverroot/config/c2me.toml12[noTickViewDistance]enabled = false","link":"/zh-cn/minecraft/2020/fabric-mod-list/"},{"title":"mods-changes","text":"Legacy MOD changes Will be merged when the first release IC2 1.18 was published. 工业2 (已移除) 主配置文件改动 config/IC2.ini1234567[balance]; 移动储电箱无电量损耗energyRetainedInStorageBlockDrops = 1; 通过传送器时，玩家的背包重量不会增加能量消耗teleporterUseInventoryWeight = false; 关闭扳手拆机器logwrenchLogging = false 让打粉机可以打AE2的东西 config/ic2/macerator.ini1234567891011121314; certus quartz dustOreDict:crystalCertusQuartz = appliedenergistics2:material@2; nether quartz dustOreDict:gemQuartz = appliedenergistics2:material@3; fluix dustOreDict:crystalFluix = appliedenergistics2:material@8; sky stone dustappliedenergistics2:sky_stone_block = appliedenergistics2:material@45; ender dustminecraft:ender_pearl = appliedenergistics2:material@46 将高炉炼钢时间缩短为一分钟 config/ic2/blast_furnace.ini12345678910; Iron Ingotminecraft:iron_ingot = ic2:ingot#steel ic2:misc_resource#slag @fluid:1 @duration:600; Crushed Iron OreOreDict:crushedIron = ic2:ingot#steel ic2:misc_resource#slag @fluid:1 @duration:600; Iron Oreminecraft:iron_ore = ic2:ingot#steel ic2:misc_resource#slag @fluid:1 @duration:600; Purified Crushed Iron OreOreDict:crushedPurifiedIron = ic2:ingot#steel ic2:misc_resource#slag @fluid:1 @duration:600; Iron DustOreDict:dustIron = ic2:ingot#steel ic2:misc_resource#slag @fluid:1 @duration:600 砍树 与工业2橡胶树的兼容 config/treecapitator.cfg1234ic2_rubber_tree { S:logs=IC2:rubber_wood S:leaves=IC2:leaves} EpicBanItem (检查当工业2的采矿镭射枪nbt数据, 充能大于0时触发ban物品) config/epicbanitem/banitem.conf123456789101112131415161718&quot;ic2:mining_laser&quot;=[ { name=ban-mining-laser-in-ic2 priority=5 query { id=&quot;ic2:mining_laser&quot; &quot;tag.charge&quot; { &quot;$gt&quot;=&quot;0.0d&quot; } } update { &quot;$set&quot; { Damage=0 id=&quot;minecraft:air&quot; } } }]","link":"/zh-cn/minecraft/2020/mods-changes/"},{"title":"Altiumdesigner Notes","text":"进度 Pass 2/2, Stage 38/38, Completed 原理图库元件绘制 Comment is the display name of component in Schmetic Document, leave it empty or ‘*’ will keep its value same as Design Item ID. 放置原件时 &lt;Tab&gt; 可暂停 (暂停后调整属性), 按 &lt;CR&gt; 继续 设置格点 View→Grids→Set Snap Grid… 原理图绘制步骤 先不连线, 把各个模块对应的元件大致摆放好. 用&quot;绘制线&quot; (Place→Drawing Tools→Line) 跨分模块区域. 绘制时 &lt;S-Space&gt; 切换正交模式、钝角模式、任意角模式. 连好导线, 给管脚添加 NetLabel (Place→Net Label). 核对元件 Value 值 (如元件位号 R1、R2, 电阻阻值等) 位号编辑器能批量编号: Tools→Annotation→Annotate Schematics… 修改参数后需要重置来抹除之前更改: Reset All→Update Changes List 最后点击 Accept Changes (Create ECO)→Execute Changes 给元件添加封装 (Footprint). (即元件 3D 模型) 建议使用封装管理器 Tools→Footprint Manager… 原理图的编译设置及检查. 在Project→Project Options… 配置 Error Reporting 的类型. 常用设置:123456Violations Associated with Components: Duplicate Part Designators = Fatal Error // 相同的元件位号Violations Associated with Nets: Floating net labels = Fatal Error // 网络标号悬空 (没有连接元件) Floating power objects = Fatal Error // 电源对象悬空 Nets with only one pin = Fatal Error // 单端网络 常见 CHIP 封装的创建 (.PcbDoc) &lt;C-d&gt; 调出视图配置, 可切换 3D (3). 3D 视图下 &lt;S-RightMouse&gt;(Drag) 可调整角度. 如何相对某个悍盘进行一定, 首先将他们重叠在一起, 然后 M→Move Selection by X, Y… &lt;C-m&gt; 测量工具可测量两个顶点间的距离. &lt;S-c&gt; 可清楚测量标签. Edit→Set Reference→Center 可以设置原点 (根据目前悍盘位置计算) 文字和线的丝印要在丝印层 (Top Overlay) 画, 可在别的层画好辅助线, 丝印画好后, 切到辅助线所在层按 &lt;S-s&gt; 切换单层显示然后删掉辅助线. &lt;S-e&gt; 切换抓取模式, 在最底下的信息栏可以看到当前 Snap 模式. 如果丝印画在悍盘上, 可通过 Edit→Slice Tracks 来割断线条然后删除它. 利用 IPC 封装创建向导快速创建封装: (.PcbLib) Tools→IPC Compliant Footprint Wizard… 输入参数时, 底下勾选 Generate STEP Model Preview 可获得更逼真的模型预览. 对于 Solder Fillets 的 Board density Level 设置时, 如果板子上的元件比较密集可以设置 Level C - High density (悍盘会更小), 稀疏则可以选择 Level A - Low density, 默认的 B 适用于大多数情况. 3D 模型的创建和导入 默认 3D 模型的创建和导入都放在机械一层 (Mechanical 1). 导入: Place→3D Body 手动绘制: Place→Extruded 3D Body 默认绘制的是挤出类型 (Properties→3D Model Type→Extruded; Overall Height 是挤出高度设置, Standoff Height 悬浮高度) PCB 网表导入和模块化布局 网表导入及长久报错处理 (PcbDoc) Design→Import Changes From XXX.PrjPcb 或者 (SchDoc) Design→Update PCB Document XXX.PcbdDoc 在弹出的 Engineering Change Order 中, 如果只有一张原理图 Add Rooms 可以不勾 报错处理: 根据错误信息, 分析是没有封装还是管脚缺失, 还是管脚号和封装没对应. 常见绿色报错的消除 Tools→Design Rule Check… 可以修改设计规则检查的启用. (在 Design→Rules… 里可以修改规则的参数) 如果遇到提示悍盘直接短路的情况, 检查封装中悍盘的 Jumper (跳线) 参数是否设为 0 (禁用), 否则 AD 会连接 Jumper 参数相同的悍盘并导致短路. 元器件摆放&amp;板框评估&amp;叠层设置 器件阵列排步: Tool→Component Placement→Arrange Within Rectangle. 在机械一层用线画出矩形的两条边 Place→Line, 然后设置这两条线的长度为整数, 然后完成矩形. 使用线性尺寸工具标注长度: Place→Dimension→Linear. 然后设置原点 Edit→Origin→Set. 选中画好的板框 (选中其中一边后可按 &lt;Tab&gt; 快速选中相连的线), 然后 Design→Board Shape→Define Board Shape from Selected Objects 打开叠层管理器: Design→Layer Stack Manager…, 默认是 2 层, Overlay 后缀表示丝印层, Solder 表示阻悍层. 只有橙色的才是信号层如 Top Layer 和 Bottom Layer. 要添加新层, 可右键已有层然后 Insert layer {above,below}→{Signal,Plane,Core,Prepreg}, Signal 信号层, Plane 负片层(默认导通, 线起绝缘作用; 电源层), Core 心板(屏蔽用), Prepreg PP片(基材) PCB 布局 分割显示, 打开配合交叉选择模式(&lt;S-C-x&gt; Tools→Cross Select Mode 然后框选原理图的元件时对于 PCB 板上的元件也会被选择. 此时就可以配合矩形排列 (tol) 分离模块. 选中多个元件可以设置联合: Right Mouse→Unions→Create Union from selected objects 布局原则: 先大后小 PCB 布线 首先需要先把电源跳线隐藏掉, Design→Class… 打开对象类编辑器, 在 Net Classes 下新建一个 “PWR” 类, 然后把电源相关的网络都加进这个类. 要隐藏这个 “PWR”, 首先确保右下角 Panel 里的 PCB 面板启用, 然后可以在 PCB 面板里将 “PWR” 右键把 Connections 设置为隐藏. Route→Un-Route→Connection 可以一次性删除整根线(也可以点击某段线然后按 &lt;Tab&gt; 选中整根线删掉) Place 中的 Line 和 Track 的区别: Line 默认不设置网络, Track 会自动设置走线网络为起点悍盘的网络. 铺铜记得设置 Properties→{选择 Pour Over All Same Net Objects, 勾选 Remove Dead Copper} PCB 设计规则及 PCB 手动布线 Class、设计规则的创建 Design→Rules… 打开 PCB Rules and Constrains Editor 在规则编辑器中: Electrical→Clearance→Constraints→Minimum Clearance 可以设置最小间距 (推荐 6 mil) Routing→Width 可以修改线宽 (推荐最小 6mil, 最大20mil) 对于电源走线, 建议增加线宽(如 10mil), 在 Routing→Width 下新建一个规则, 然后在 Where The Object Matches 选择我们的电源类即可, 如 “PWR”. 注意规则的优先级. Routing→Routing Via Style→RoutingVias 可以设置过孔孔径 (建议 16mil) 和过孔直径 (建议是2倍过孔直径±2mil). 过孔还需要在首选项的默认设置进行更改 Tools→Preferences…→PCB Editor→Defaults→Primitive List→Via, Via Stack→(Diameter = 22mil, Hole Size = 12mil), Solder Mask Expansion→Manual 顶部底部都勾选 Tented (进行盖油处理, 过孔不是悍盘). Plane 过孔对不同平面的连接方式: →Power Plane Connect Style→PlaneConnect, 推荐设置为 Direct Connect 反悍盘间距: →Power Plane Clearance→PlaneClearance, 推荐 8mil 铺铜连接方式: →Polygon Connect Style→PolygonConnect, 手焊建议 Relief Connect, 回流焊建议 Direct Connect. 在 Constraints 勾选高级后还可对 SMD 悍盘、过孔的连接方式进行更改, 这里推荐将铺铜对过孔的连接设为 Direct Connect. Manufacturing →Silk To Solder Mask Clearance 建议将最小丝印到阻悍间距设为 2mil. 扇孔 (占位过孔) 的必要性 原则: 短线直径连接, 长线预先打过孔 好处: 在其他层布线的时候能提前避开过孔, 减少线路重排的工作量; 对于四层以上的板子, 连接 GND 的悍盘可以直接通过过孔连接 GND 层, 从而获得避免绕路并获得更好的信号质量. 信号线的走线 信号线尽量不要通过过孔走多层, 这样可以减少干扰. 电源走线 如果表层和底层都需要绕过远的线, 可以使用多个过孔在表层和底层来回穿梭的方式来走线. 负片层的电源可以通过走线画闭合圈来划分不同的电源区域 电源线走好后, 在表层和底层铺一块包围整个版面的地铜 (网络 GND), 注意铜皮需要用多边形挖空工具修掉死角 (减少尖端放点现象以减少对信号线的干扰) Place→Polygon Pour Cutout (记得重新灌铜). PCB 的 DRC 检查、拼板设计及资料输出 DRC 检查: (.PcbDoc) Tools→Design Rule Check…→(Left-Bottom Corner) Run Design Rule Check… (检查之前记得重新灌铜 tga) 丝印的调整: 丝印最好只有两个方向, 推荐从左到右, 竖着的底部朝右从下往上; 字宽/字高 4/25mil、5/30mil、6/45mil. 按 l 然后设置单独显示丝印和悍盘 (Overlay, Paste, Solder), 结合属性面板里的过滤器可以方便地手动微调丝印. 拼板: 工艺边 (夹持边)、定位孔、光学定位点 (3 个) 新建 PCB (File→New→PCB), 然后 (PcbDoc) Place→Embedded Board Array/Panelize 然后 &lt;Tab&gt; 在属性中选择 PCB Document 为要拼板的 PCB 文件, 列数 (Column Count), 行数 (Row Count), 并设置间距 Column Margin、Row Margin 和行列长度 Row Spacing、Column Spacing. 由于默认新建的 PCB 是二层板, 放置的如果是四层就会出现警告叠层不相同, 选择 Synchronize Automatically Now 同步叠层. 拼板阵列会自动同步原始 PCB 的更改. 用绘制线 (pl) 在机械一层 (Mechanical 1) 添加工艺边, 然后选中边框设置 PCB 板面大小 (dsd). 记得在负片层放置填充 (pf), 代表工艺边区域没有铜覆盖. 用多层悍盘 (pp, 层属性为 MultiLayer, 通常称为非金属化孔) 作为固定孔, 设置悍盘孔径和大小为 3mm (Prperties→Pad Stack→{(X/Y), Hole Size}), 四个角都要放置. 用表贴悍盘 (pp, 层属性为 Top Layer) 作为光学定位孔, 设置悍盘大小为 1mm (Properties→Pad Stack→ (X/Y)=1mm). 在板面的三个角放置. 如果底层也有器件的话, 底层也要相应放置光学定位孔. 装配图的输出: File→Assembly Outputs→Assembly Drawings; 或者 File→Smart PDF… 然后在 PCB Printout Settings 这步右键选择 Create Assembly Drawings, Printout Options 勾上 Holes, 对于底层还可勾上 Mirror. 右键→Properties… 可以对输出层进行编辑, 一般装配图留下丝印层 (Overlay)、机械一层 (Mechanical 1)、阻悍层 (Solder) 就够了. BOM 标的输出: (PcbDoc, SchDoc) Reports→Bill of Materials Gerber 文件的输出: File→Fabrication Outputs→Gerver Files, 然后在 Layer 选项卡下设置输出的层, 一般 Mirror 可以不勾. 在 Drill Drawing 勾选 Plot all used drill pairs 钻孔文件输出: File→Fabrication Outputs→NC Drill Files 坐标文件输出: File→Assembly Outputs→Generates pick and place files IPC 网表输出: File→Fabrication Outputs→Test Point Report, Report Formats 只勾选 IPC-D-356A 快捷键 自定义快捷键: 按住 &lt;C&gt; 点击想要修改快捷键的命令 j 搜索菜单 (PcbLib) JC 根据元件位号查找元件 a 对齐菜单 (Edit→Align) 移动 m 移动菜单 (Edit→Move) ms 移动已选元件 (→Move Selection) 在移动过程中, 按 X、Y 可镜像. &lt;S-MouseLeft&gt;(Drag) 快速复制元件 &lt;C-w&gt; 放置导线 (Place→Wire). &lt;BS&gt; 可撤回放置的点, 导线和绘制线都可用. Place→Net Label 放置网络标签 Place→Port 放置电源端口 &lt;C-m&gt; 测量工具, &lt;S-c&gt; 清除测量标签 &lt;C-h&gt; 或 &lt;Tab&gt; 连接全选 s 选择菜单 sl 线选 si 框选 sn 选择网络 &lt;S-r&gt; 改变走线绕路方式: Ignore Obstacles (忽略障碍), Walkaround Obstacles (绕开障碍), Push Obstacles (推挤障碍), HugNPush Obstacles (紧贴并推挤障碍), Stop At First Obstacle (遇到第一个障碍就停止), AutoRoute Current Layer (当前层自动布线), AutoRoute MultiLayer (多层自动布线). &lt;S-s&gt; 切换单层/多层显示. q 单位切换mil/mm n 网络/飞线显示和隐藏菜单 l / &lt;C-d&gt; 视图配置, 可切换层显示/关闭 ea 特殊粘贴 技巧 原理图库 对于元件 Name 属性, \\ 可给字加上上划线, 如 V\\I\\N 会显示为 VIN 添加大量管脚时可使用阵列式粘贴: Edit→Paste Array…), Primary Increment 对应 Designator, Secondary Increment 对应 Name, 记得先复制一个管脚到剪切板. 可从原理图反向生成原理图库: (.SchDoc) Design→Make Schematic Library 弹出的 Component Grouping 可将特定参数相同的归类到一起. 原理图 双击原理图边缘可快速弹出 Properties 菜单. 在原理图中, 可设置网络颜色 (View→Set Net Colors), 以便于查找单端网络. 对于没有网络标号的引脚, 如连接了悬空导线, 可加上 Generic No ERC 标号 (Place→Directives→Generic No ERC) 来禁用这里的 ERC 检查; 也可直接删除悬空导线. To update components modified in Schematic Library, use Tools→Update From Libraries… Click components/net labels with &lt;M&gt; can highlight this component/connetecd net labels. PCB 封装库 通孔(过孔)悍盘的设置是 Properties→Layer = Top Layer, 还可在 Properties→Solder Mask Expansion→Manual 中勾选 Tented 来使阻悍绿油覆盖通孔. 如果无法抓取原点, 按 &lt;S-e&gt; 来切换抓取模式(Snapping: All Layers, Current Layer, Off). 添加多个悍盘同样可以使用阵列粘贴: Edit→Paste Array…) 同样的, 可从 PCB 图反向生成 PCB 封装库: (.SchDoc) Design→Make PCB Library 更改完封装后别忘了在 PCB Library 选中该封装然后右键 Update PCB with XXX PCB 更改丝印大小: 选中丝印, 右键 Find Similar Objects…, 将 Object Specific→String Type→Designator 设为 Same. 然后就能选中所有丝印设置丝印文字大小了. 更改丝印位置: &lt;C-a&gt; 选中所有器件, a (对齐菜单) → Ppsition Component Text… 定位原件在原理图中的位置: (记得分屏显示原理图) Tools→Cross Probe 按住 &lt;C&gt; 点击悍盘可以进行高亮 在 Panel→PCB 里, 可以设置为 Mask 模式来高亮某个网络类. 还可设置网络颜色 (右键网络类→Change Net Color, 再次右键→Display Override→Selected On) 重新铺铜快捷方式 tgr (Tools→Polygon Pours→Repour Selected 设置扇孔时, 过孔会自动分配网络到走线上, 所以先从悍盘引出一条短的走线, 然后再添加过孔. PCB 走线 Route→Interactive Multi-Routing 可以选择多跟线进行平行走线. 设置一个网络内所有走线的宽度, s (选择菜单)→Net 选择网络, 然后在属性窗口 (Properties) 的过滤器图表中只选择走线 (Tracks) 即可对所有该网络的走线进行属性更改. 按住 &lt;C&gt; 高亮网络时可以按 [ / ] 调整高亮对比度. 在其他层复制的元件默认会在它所在的层粘贴, 想要粘贴到当前层需要使用 Edit→Paste→Special… 勾选 Paste on current layer. 缝合孔可以区域性地给网络添加过孔: Tools→Via Stitching/Shielding→Add Stiching to Net… 元件知识 零欧姆电阻=毫欧电阻, 一般为 20Ω-50Ω 作用: 作保险丝, 功能切换, 跳线, 作高频电感、电容, 作磁珠等 阻焊的作用是防止绿油覆盖. 固定孔要接地 走线载流能力一般20mil/A, 信号线一般 6mil 足够, 电源部分建议用铺铜连接","link":"/zh-cn/computer/2021/altiumdesigner-notes/"},{"title":"blender","text":"开始入门 Blender, 契机是我的米家随手吸尘器的配件-前置滤网的 ABS 框架被我烤变形了, 淘宝搜寻一番后发现卖 50+ 实在太贵, 遂自己建模打印一个. 常规设置 状态栏 (右下角) 显示内存、显存、点线面数量信息: Edit→Preferences…→Interface→Editors→Status Bar→[✓]{Scene Statistics, System Memory, Video Memory}. &dagger; Example Photos &dagger; (不推荐) 启用模拟三键鼠标(&lt;M-LeftMouse&gt; 旋转视角, 类似 MAYA): 开启会导致选择循环边快捷键变成双击选择, 建议适应鼠标中键旋转视角 (优势在于一只手就能旋转视角): Edit→Preferences…→Input→Mouse→[✓]Emulate 3 Button Mouse. 启用围绕选择物体旋转和自动深度 (解决视角无法继续推近的问题): Edit→Preferences…→Navigation→Orbit &amp; Pan→[✓]{Orbit Around Selection, Depth} 启用自动加载 Python 脚本 (一些插件需要开启, 不然可能会报错) Edit→Preferences…→Save &amp; Load→[✓]Auto Run Python Scripts. 启用插件: Edit→Preferences…→Add-ons→ Node: Node Wrangler (强大的节点工具) Rigging: Rigify (自带强大绑骨) Import-Export: Import Images as Planes (导入图像为平面) Import-Export: Export Autocad DXF Format (.dxf) (导出为 DXF 格式) Import-Export: Import AutoCAD DXF Format (.dxf) (导入为 DXF 格式) Add Curve: Extra Objects (额外曲线物体) Add Mesh: BoltFactory (螺栓) Add Mesh: Extra Objects (额外网格物体) Add Mesh: A.N.T.Landscape (简单地形制作) Interface: Modifier Tools (修改器工具) Interface: Copy Attributes Menu (复制属性菜单) Mesh: LoopTools (Loop 工具) Object: Bool Tool (布尔工具) Render: Auto Tile Size (自动 Tile 大小, 能自动帮你设置渲染块数量, 提供硬件利用率) UV: Magic UV (魔法 UV) 最后别忘了保存设置 Edit→Preferences…→≡→Save Preferences 基础操作 观察物体: ➀ 视角旋转 &lt;MiddleMouse&gt; (模拟三键鼠标 &lt;M-LeftMouse&gt;) ➁ 视角平移 &lt;S-MiddleMouse&gt; (模拟三键鼠标&lt;S-M-LeftMouse&gt;) ➂ 摄像机视图(切换) &lt;k0&gt; ➃ 透视/正交切换 &lt;k5&gt; 提示: 若没有小键盘, 可在首选项开启模拟数字键盘使普通数字键作为快捷键使用: Edit→Preferences…→Input→Keyboard→[✓]Emulate Numpad 摄像机 如何让摄像机跟随视角同步? (锁定相机到视图) n (开启 N 面板)→[View]→View Lock→[✓]Camera to View 如何更改摄像机取景框的比例和大小? 方法 1: ➀ 选中摄像机 (如 [Outliner &lt;S-F9&gt;]Scene Collection→Collection→[✓]Camera) ➁ [Properties &lt;S-F7&gt;]→[Output Properties]→Format→{Resolution (X,Y,%),Aspect (X,Y)} 方法 2: (关闭锁定相机到视图) 在相机视图下直接用鼠标滚轮和视角平移就可改变相机取景框在屏幕上的大小和位置. 找到一个不错的角度, 如何将当前的视角快速设为摄像机视图? ➀ 选中摄像机 ➁ &lt;C-M-k0&gt; 切换四视图 四视图分割(切换) &lt;C-M&gt;-q 顶视图 &lt;k7&gt;; 底视图 &lt;C-k7&gt; 前视图 &lt;k1&gt;; 后视图 &lt;C-k1&gt; 右视图 &lt;k3&gt;; 左视图 &lt;C-k3&gt; 翻转 &lt;k9&gt; (若当前非正交视图则绕Z轴翻转) 聚焦物体 选中物体→[3D Viewpont &lt;S-F5&gt;] &lt;kPoint&gt; 聚焦并隐藏其他物体(切换): 选中物体→[3D Viewport &lt;S-F5&gt;] &lt;kDivide&gt; 在四视图界面同步聚焦: &lt;C-kPoint&gt; 显示整个场景 &lt;Home&gt; 物体变换 在物体上的实时显示移动、旋转、调整工具: [3D Viewport &lt;S-F5&gt;](Top bar)[V] Gizmos→Object Gizmos→[✓]{Move,Rotate,Scale} Gizmo 快速开关 &lt;C-`&gt; 移动物体 g→{[&lt;S&gt;-](x,y,z),[0-9]+} 使其只在{轴,除去该轴的平面}上移动; 输入数字精确移动 移动归零 &lt;M&gt;-g 旋转物体 r[r] (默认基于当前视角旋转, 再按切换视角深度旋转)→{x,y,z,[0-9]+} 使其只在对应轴上旋转; 输入数字精确旋转(角度制). 旋转归零 &lt;M&gt;-r 缩放物体 s→{[&lt;S&gt;-(x,y,z),[0-9]+} 使其只在{轴,除去该轴的平面}上缩放; 输入数字精确缩放. 缩放归零 &lt;M&gt;-s 也可使用N面板调整物体: n→[Item]→Transform 选择物体 切换选择工具(移动/框选/刷选/套索) [3D Viewport &lt;S-F5&gt;] w, 在 [3D Viewport] 顶栏还可设置工具属性 (如交集选择) 全选 a; 取消全选 &lt;M&gt;-a 或 aa (快速) 新建/删除/复制物体 物体添加 &lt;S&gt;-a, 物品添加时的参数仅在新建时可调 删除物体 &lt;Del&gt; 或 x 复制物体 选中物体→&lt;C-c&gt; &lt;C-v&gt;; 或者 &lt;S-d&gt; 坐标系与轴心点 物体坐标系 设置默认坐标系: [3D Viewport](Top bar)[V]Transform Orientations 快捷键 , 局部 (Local) 坐标系: 基于物体本身方向 显示: 选中物体→[Properties &lt;S-F7&gt;]→[Object Properties]→Viewport Display→[✓]Axis. 在物体变换操作时, 多次按下轴字母可切换全局/默认坐标系, 法向 (Normal) 坐标系 实践: 切到法向坐标系→选中物体→编辑模式 &lt;Tab&gt;→启用面选择模式: [3D Viewport](Top bar) Face Selection Mode →点击一个平面, 尝试在 Z 轴上移动, 会发现这个平面的 Z 轴垂直于该平面 (法向) 如果没有启用模拟小键盘的话, 在编辑模式可用快捷键 1、2、3 启用点、线、面选择模式); 同样的, 进入变换模式后, 多次按下轴字母即可快速切换全局/默认坐标系. 万向 (Gimbal) 坐标系 对于万向轴来说, 它可通过固定两个轴 (旋转轴和转向轴) 的方式让第三轴绕旋转轴旋转, 如将圆球设置为旋转轴=它的局部 X 轴; 转向轴=它的局部 Z 轴: 切到万向坐标系→选中该圆球→[Properties &lt;S-F7&gt;]→[Object Properties]→Transform→Mode=‘YXZ Eular’ (第二个字母为旋转轴, 第三个字母为转向轴) 当我们尝试将该圆球绕 X 轴旋转, Y 轴会发生变化, 但无论如何旋转, 万向坐标系的 Z 轴永远保持和全局坐标 Z 轴一个方向, 且万向 Z 轴与万向 X 轴始终保持正交 (即万向 X 轴永远在 XY 平面). 视图 (View) 坐标系 坐标轴 XY 与视窗锁定, 上下为 Y, 左右为 X, 垂直屏幕方向为 Z 自定义坐标系/游标坐标系 将默认坐标系设为某个物体的局部坐标系 选中物体→[3D Viewport](Top bar)[V]Transform Orientations→点击 ‘+’ 号, 会生成一个与该物体名称相同的坐标系 游标 (Cursor) 坐标系: 和自定义坐标系相似, 不过是游标的局部坐标系. 要改变游标方向, 可使用游标工具或者 [3D Viewport] &lt;S-RightMouse&gt; 拖动, 移动后游标会朝向屏幕方向. 轴心点 原点: 选中单个物体后中心的橘黄色的小点称为原点. 变换原点: [3D Viewport](Upper Right Corner)[V]Options→Affect Only [✓]Origins, 然后可以对原点进行移动旋转缩放 恢复原点位置: 选中物体→[3D Viewport]&lt;RightMouse&gt;→Set Origin→{Geometry to Origin,Origin to Geometry,Origin to 3D Cursor, Origin to Center of Mass (Surface),Origin to Center of Mass (Volume)} 几何中心到原点, 原点到几何中心, 原点到3D游标, 原点到重心(表面), 原点到重心(体积) 变换轴心点: 选择多个物体后出现的一个变换位置用的轴心点, 要设置变换轴心点, 可使用句号键 . 调出浮动菜单或 [3D Viewport](Top bar)[V]Transform Pivot Point→{Bounting Box Center,3D Cursor,Individual Origins,Median Point,Active Element} 边界框中心、3D游标、各自的原点、质心点、活动元素 质心点 (Median Point): 为变换轴心点计算的默认方式, 是基于原点计算产生的均值, 在只有一个物体选择的情况下, 质心等于原点. 边界框中心 (Bounding Box Center): 选中多个物体的变换轴心点根据它们的边界框来计算. 显示边界框: 选中物体→[Properties]→Object Properties→Viewport Display→[✓]Bounds 3D游标 (3D Cursor): 变换轴心点是游标位置. 配合下一章的吸附. 各自的原点 (Individual Origins): 比较特别, 此模式下对选中的多个物体进行缩放和旋转都会对以各自的原点进行变换, 而不是一个统一的变换轴心点. 实践: 选中多个物体然后旋转变换试试. 活动元素 (Active Element): 变换轴心点的位置是活动元素 (最后选择的物体, [Scene Collection] 中高亮的那个) 的原点 当使用句号键 . 在浮动菜单勾选 Only Locations (9), 选择的多个物体的缩放和旋转只会相对于变换轴心点进行相对的距离和角度的变换而不会改变物体本身的缩放和旋转. 如旋转操作不旋转物体本身, 只是相对于变换轴心点的角度进行位置上的&quot;旋转&quot; 吸附与衰减编辑工具 吸附功能全解: 开启/关闭吸附 &lt;S-Tab&gt; 或 (Top bar - Center) 3D Viewport→Snap, 也可在变换操作时按住 &lt;C&gt; 来临时开启/关闭吸附. (Top bar - center) 3D Viewpont→Snap 旁的下拉菜单可调整吸附内容 (Snap To), 被吸附对象吸附基准点 (Snap With), 影响的变换 (Move, Rotate, Scale): 为了方便观察, 切换线框模式 &lt;S&gt;-z 或 (Top bar - Right) 3D Viewport→Viewport Shading=Wireframe. 对于吸附基准点 (Snap With), Closest=被吸附对象离吸附目标最近距离的顶点; Center=变换轴心点 (约等于质心, 但由变换轴心点的设置决定). &lt;S&gt;-s 呼出游标吸附浮动菜单, 可让游标吸附到各种位置上. 如将游标吸附到某个选择的面上: &lt;Tab&gt; 进入编辑模式→3 进入面选择模式→ 选中某个平面→&lt;S&gt;-s 呼出游标吸附菜单→Cursor to Selected. 增量模式 (Increment): 物体变换操作时会吸附到背景网格上, 可利用不同缩放下网络间距不同来达到选择移动 0.1M 或 1.0M 的效果. 默认是相对于网格的移动, 若在下拉菜单中勾选绝对栅格对齐 (Absolute Grid Snap), 则单个/多个物体的质心会被严格吸附到网格点上. 如图所示 (俯视图), 移动后, 两个方块的质心点被吸附到网格上: 顶点模式 (Vertex): 物体变换操作时会吸附到其他物体的顶点上. 下拉菜单中勾选背面剔除 (Backface Culling) 后, 将不会吸附当前视角下处在物体背面的顶点. 下拉菜单中勾选旋转对齐目标 (Align Rotation to Target) 后, 被吸附物体局部坐标轴的Z轴会与顶点法向对齐, 如图: 其他的功能, 自己尝试吧~ 这里说一下面吸附模式的妙用, 可以很方便地实现让一个物体摆放在另一个物体之上: 将要放置物体的原点置于底面的中心 (配合四视图比如正视图+吸附功能)→(Top bar - Center) 3D Viewport→[V] Snap→Snap to=face, Snap with=Median, 然后就可将这个物体完美放在另一个物体的平面上啦~ ) 面吸附模式下, 下拉菜单勾选项目独立元素 (Project Individual Elements) 后, 会使选择的多个物体使用各自的原点进行吸附. 此外, 若在编辑模式下进行面吸附, 可将网格物体贴合到另一个物体的面上, 目前版本贴合似乎有bug, 建议多开一个窗口在正交视图下 (四视图) 进行贴合. 垂直交线 (Edge Perpendicular) 模式: 物体会被吸附到吸附基准点与被吸附物体的边的垂直交线的交点上, 也适用于编辑模式下的顶点模式. 衰减编辑: 快捷键 O. 启用衰减编辑后, 对其中一个物体进行变换会带动周围的物体一起进行变换. 如图, 启用衰减编辑后, 变换物体时会出现一个灰色的圈, 圈内的物体会被带动, 鼠标滚轮可改变圈的大小 衰减模式有许多种, 自己尝试吧: (Top bar - Center) [V] Proportional Editing→{Smooth,Sphere,Root,Inverse Square,Sharp,Linear,Constant,Random} 提一下衰减编辑配合网格 (Grid) 物体在编辑模式下的运用: 勾选从视角投影 (Projected from View) 可做到根据视角的投影方向进行统一的操作: 常用基础操作 (游标、物体合并分立、操作重复执行、第一人称观察、物体隐藏、物体父子级、物体镜像变换) 游标操作: 游标移动相关浮动菜单 &lt;S&gt;-s 游标快速移动 &lt;S-RightMouse(Drag)&gt; 游标回到世界原点 &lt;S&gt;-c 物体合并分离: 合并: 选择物体→&lt;C&gt;-j 分离: 选择物体→&lt;Tab&gt; 编辑模式→选择分离部分 (快捷键 l 选择相邻元素) 然后 p 或 &lt;M&gt;-m 合并后原点为活动项原点, 分离后原点位置在分离物体原点上 操作重复执行: 复制/变换等常规操作完成后→&lt;S&gt;-r 第一人称观察和拍摄: &lt;S&gt;-` 进入后, [&lt;{S,M}&gt;-]{w,a,s,d,e,q} [加速,减速]前后左右上下, &lt;Space&gt; 快速前进到准星物体处 配合相机的锁定到视图可实现相机的自由移动 记录K帧: 选中相机→[Properties] Object Properties→Transform→将鼠标指针停留在各项参数上→按 i 键启动记录 (图中记录位置旋转缩放的信息)→[Timeline][✓] Auto Keying 开启自动记录关键帧→&lt;Space&gt; 启动播放→&lt;S&gt;-` 进入第一人称模式对摄像机进行移动 可以选中后按 x 或 &lt;Del&gt; 来删除一些不想要的关键帧 切到关键帧曲线编辑器 [Graph Editor], 可对关键帧进行一些平滑处理: [Graph Editor] a 键选择所有曲线→ (Top bar - Left) [Graph Editor] Key→Smooth Keys (快捷键 &lt;M&gt;-o) 来平滑关键帧. 平衡一次的效果可能不够明显, 可通过按住 &lt;M&gt;-O 平滑曲线 n 次: 物体隐藏、显示、禁用 隐藏: 选中物体然后→ h 或 [Outliner]→Scene Collection→点击物体旁边的&quot;小眼睛&quot;. 显示: 重新显示所有隐藏对象 &lt;M&gt;-h 视图/渲染中禁用: [Outliner] 右上角过滤器→Restriction Toggles→{[✓] Disable in Viewports (显示器图标),[✓] Disable in Renders (相机图标)} 然后就可对物体设置视图中禁用和渲染中禁用了: 物体父子级: 子物体与父物体变换操作时同步 建立父子级: 选中多个物体→&lt;C&gt;-p (活动项会成为父级) 清空父级: &lt;M&gt;-p 也可在 [Outliner] 按住 &lt;S&gt; 拖动物体来建立或取消父子级关系: 物体镜像变换 (复制一个保留在原位的物体方便参考, 选中物体→ &lt;S&gt;-d→&lt;RightMouse&gt; 取消位移) 选中物体→&lt;C&gt;-m 进入交互式镜像变换模式→{x,y,z} 或者 &lt;MiddleMouse(Drag)&gt; 可选择镜像轴 建模功能篇 初识编辑模式点线面与统计信息拓展 点、线、面选择模式切换: 1, 2, 3 模式加减选: &lt;S&gt;-{1,2,3} 可开启信息HUD来显示电线面等数据: [3D Viewport] (Top bar - Right)→Viewport Overlays→Guides→[✓]Statistics 物体模式 (Object Mode) 统计数据计算的所有物体数据总和 编辑模式 (Edit Mode) 统计数据计算当前进入编辑物体数据总和 三角形 (Triangles) 为网格等效为三角面之后的预估数量, 面是可以三角化的: 编辑模式下选择一个面→[3D Viewport] (Edit Mode - Top bar) Face→Triangulate Faces (&lt;C&gt;-t) 挤出类工具全解 (挤出、沿法向挤出、挤出各个面、挤出至游标) 初识T面板 左侧工具栏可通过 T 键开启/隐藏 鼠标移动到工具栏上后按 &lt;kPlus&gt;, &lt;kMinus&gt; 可实现UI缩放. 向右拖拽工具栏可以切换显示并排工具栏、名称工具栏 (推荐切换到下图的并排工具栏) 挤出并移动 进入编辑模式, T面板会出现编辑模式下的工具. 选择挤出到选区工具 (Extrude Region, 快捷键 e), 单个面默认沿面法向、多个面默认沿质心法向, 按下 [&lt;S&gt;-]{x,y,z} [锁定]对应轴向方向的移动, 也可以进入对应的正交视图规避未显示轴向的数据干扰 选中T面板挤出到选区工具→面选择模式选择一个面, 此时可看到一个黄色的加号→拖拽这个加号, 沿面法向挤出 翻车点: 挤出到选区工具的操作是挤出并移动, 按右键取消的只是移动, 但依旧会进行挤出从而产生一个重叠面. 解决方案是: 开启X射线模式 [3D Viewport] (Top bar - Right) [✓] Toggle X-Ray (&lt;M&gt;-z)→(Edit Mode - Vertex Selection Mode) 框选顶点→&lt;RightMouse&gt;→Mirror Vertices→By Distance (m). 对于边法向, 由于不是很直观, 开启法向线的显示: [3D Viewport] (Top bar - Right) [V] Overlays→Viewport Overlays→Normals→Display Split Normals; Size=0.45. 对于面法向, 除了在视图叠加层中开启法向线的显示外, 还可以启用面朝向, 蓝色为正面, 红色为反面: [3D Viewport] (Top bar - Right) [V] Overlays→Viewport Overlays→Geometry→[✓] Face Orientation. 沿法向挤出 (Extrude Along Normals) 新建两个平面, 将其中一个面翻转 (选中这个面, 然后 &lt;M&gt;-n 调出分割菜单, 选择 Flip 翻转): 可看到, 选中两个平面后, 挤出并移动工具会默认使用两物体质心点的法向: 要让选择的平面独立使用自己的法向, 应使用沿法向挤出 (Extrude Along Normals) 工具, 此时控制柄会变化: 此时拖动平面会沿着各自的法向进行挤出: 挤出各个面 (Extrude Individual) 让选择的每个面都独自的进行挤出; 在选取对象为多个相连面时, 沿法向挤出是相接的, 而挤出各个面是分开的. 在沿法向挤出模式下, 选择正方形的两个面进行挤出, 会沿着这两个面的夹角作为法向进行挤出: 如果要让挤出变得平均, 需要在挤出操作的历史记录里勾选 Offset Even (均等偏移): 挤出至光标 (Extrude to Cursor) 挤出到鼠标所在区域, 建议结合正交视图使用. 快捷键 (Edit Mode) &lt;C-RightMouse&gt;. 挤出流形 (Extrude Manifold) 使用其他挤出工具进行穿插挤压, 会出现多余面的问题: 使用挤出流形则可很好地解决这个问题: 快捷菜单 编辑模式下选中目标→&lt;M&gt;-e 可弹出全部和挤出相关的功能 Extrude Repeat 重复挤出 (也可使用 &lt;S&gt;-r 重复上次变换), 在弹出的历史操作消息框里可进行重复挤出的设置: 绕视图旋转 (Spin): 可让轮廓沿着视图旋转成为一个立体模型: 首先通过顶点挤出创建一个轮廓 然后在俯视图下, &lt;M&gt;-e→Spin 使其进行绕Z轴旋转: 当然, 可在历史操作里进行参数上的设置 内插面工具全解(激活内插、深度、外插、分离、边界与其他相关参数) 激活内插面 i, 激活后: 深度 (Hold) &lt;C&gt; 外插 o 边界 b 分离 i (分离开启会影响到边界和外插属性) 面边界: 只被一个面包含的边 倒角工具全解(全参数解析、额外拓展、解决倒角不均匀) 基础操作 快捷键 &lt;C&gt;-b 进入后可参考状态栏快捷键提示进行操作: 切换段数 &lt;ScrollWheel{Up,Down}&gt; 或 (Drag) s p 控制形状轮廓 (内凹还是外凸) 宽度类型 为了更好的演示, 将宽度、段数、形状的值调整至下图所示: 针对宽度类型, 分别有偏移量 (Offset), 宽度 (Width), 深度 (Depth), 百分比 (Percent), 绝对值 (Absolute) 对于前三个类型, 下图可以很好地解释: 偏移量宽度类型 Offset=平行边, 间距=垂线距离 百分比宽度类型 Percent 会根据倒角原始边的邻边长度决定, 需要注意邻边不同会产生倒角不均匀的问题. 绝对值宽度类型 Absolute , 绝对值=平行线端点连线斜边长度&gt;=垂线距离: 如何测两点距离: 举个例子, 倒角参数设置 Width Type 为 Width, 段数 Segments 为2, Shape 为1: 吸附模式为顶点吸附, 选中T面板的测量工具 Measure , (Hold) &lt;C&gt; (临时启用吸附) 拖动连接两个顶点即可: 如何测量 Width Type 为 Depth 的距离: 做一条辅助线. 选中两顶点按 j 在两点间作一辅助线, 吸附模式为顶点吸附和垂直交线吸附 Edge Perpendicular (按住 &lt;S&gt; 可同时启用多个吸附) 然后测量. 也可继续作一条垂直辅助线: 选中这条线段→&lt;RightMouse&gt;→Subdivide 将其一分为二. 平分后出现原线段的中点. 其他参数全解 材质编号 (Material Index) 给物体上材质: 选中物体→[Properties]→Material Properties→点击加号建立三个材质槽→将三个材质槽更名→[V]Surface→Base Color 设置基础色: 然后开启材质显示: [3D Viewport] (Top bar - Right) Viewport Shading=Material Preview 默认情况下物体会使用第一个材质, 可进入编辑模式指定该面的材质: 编辑模式选择面→[Properties]→Material Properties→选择材质槽→Assign 此时进行倒角操作, 会发现默认的 -1 材质编号会自动套用临边的材质. 更改这个参数来选择倒角边的材质: 平衡着色与硬化法向 想让倒角变得平滑, 最笨的方法是增加段数, 但面数增加会导致运算量增加. 更好的方法是使用 &lt;RightMouse&gt; Object Context Menu→Shade Smooth 平滑着色 默认平滑着色套用到全局, 可在 [Properties] Object Data Properties→[V]Normals→[✓]Auto Smooth 限制自动平滑角度 另一方法是硬化法向, 不影响原始法向, 仅平滑倒角. 为了让效果更明显, 将视图着色方式改为快照材质: [3D Viewport] (Top bar - Right) Viewport Shading=Solid; [3D Viewport] (Top bar - Right) [V]Shading→Lighting→MatCap→Studio Light=ceramic_dark.exr. 在倒角历史操作→[✓]Harden Normals. 钳制重叠 (Clamp Overlap) 可避免宽度增大到一定程度, 出现穿插的情况. 外斜接 (Miter Outer): 锐边 (Sharp)、补块 (Patch)、圆弧 (Arc) 内斜接 (Inner): 锐边(Sharp)、圆弧(Arc) 相交类型 (Intersection Type): 栅格填充 (Grid Fill)、截止 (Cutoff) 面强度 (Face Strength): 根据面权重限制法向平滑, 结合以后讲到的加权法向修改器可根据条件标记面权重强弱 (如面的面积、倒角区域), 实现不同强度区域不同程度平滑效果. 标记 (Mark) 缝合边 (Seams): 对一个带缝合边的边进行倒角时会出现缝合边断开, 历史操作菜单 (倒角)→Mark→[✓]Seams 启用缝合边 什么是缝合边? 有什么用? 选中物体, &lt;Tab&gt; 进入编辑模式, [Top Bar] UV Editing 打开UV编辑器. 删除原有UV映射: (选中物体) [Properties] Object Data Properties→[V]UV Maps→点击减号删除 想象剪一个纸盒, 要剪开的边就是缝合边 按 a 全选, 进行UV展开: [3D Viewport] (Top bar - Right) UV→Unwrap 锐边 (Sharp) 同理, 历史操作菜单→Mark→[✓]Sharp 可自动补全断离锐边. 什么是锐边? 有什么用? 勾选了锐边后, 90° 以下的法向自动平滑将不会对标记为锐边的边进行平滑. 自定义倒角轮廓: 历史操作菜单→Profile Type=Custom 图表里的顶点可拖移、删除: 更改预设的参数后点击应用预设 Apply Preset 来刷新, 比如楼梯预设的段数: 倒角不均匀与顶点倒角 倒角不均匀: 注意物体是否进行过变形, &lt;C&gt;-a 应用菜单→All Transforms 全部变换. 顶点倒角: 新建一平面, 选中→&lt;Tab&gt; Edit Mode→&lt;RightMouse&gt;→Subdivide &lt;C-S&gt;-B 进入顶点倒角模式, 参数的设置可参考边线倒角: 环切与偏移环切边工具全解(边线循环原理+全解析环切与偏移环切边工具) 循环边传递原理 环切工具全解 偏移循环边工具全解","link":"/zh-cn/computer/2021/blender/"},{"title":"c-notes","text":"Workflow: C + GDB + Makefile Makefile Introduction 1234567891011121314151617181920212223242526272829303132333435# Variables# Simple assignment ':=' and Recursive assignment '=' (More likely a pointer)A := FooB := ${A}C = ${A}A = Bar# Result: A = Bar, B = Foo, C = Bar# Conditional assignment '?=', assigns only if does not have a value.A ?= Fooo# Result: A = Bar# Appending '+='A += Foo# Result: A = Bar Foo# ${A} and $(A) are the same, I personally like to use '$()' to express that there is a function called.# Explicity tell Make those are phony target. So Make will not be confused if there is a file called 'clean' in the directory.PHONY: clean# The target first appears in Makefile is the default target, this means barely run 'make' will execute target 'all'.# We can override this behavior by using a special phony target called '.DEFAULT_GOAL'#.DEFAULT_GOAL := sub_targetall: sub_target target.c Recipe# prequisites is the required files or other sub targets or a local variable.sub_target: LOCAL_VAR = Foobarsub_target: prequisites Recipe# For targets don't build a file is called phony target, mostly 'clean' is like to be a phony targetphony_target: # Use '@' to suppress echoing @echo &quot;Hello World&quot; A Common Makefile for C 12345678910111213141516171819202122232425262728293031323334353637.PHONY = all cleanCC = gccLINKERFLAG = -lm# '$(wildcard pattern)' is one of the functions for filenames.# In this case all files with the '.c' extension will be stored in variable '${SRCS}'SRCS := $(wildcard *.c)# '$(VARNAME:%pattern1=pattern2%)' is substitution reference# In this case it removes the extension '.c'BINS := $(SRCS:%.c=%)# Same as#BINS := $(basename ${SRC})all: ${BINS}# '%' matches any target name, '$&lt;' is a patten to match first prerequisite, '$@' matches the target name%: %.o @echo 'Linking...' ${CC} ${LINKERFLAG} $&lt; -o $@# If ${BINS} = foo bar, then it is equavalent to#foo: foo.o# @echo 'Linking...'# gcc -lm foo.o -o foo##bar: bar.o# @echo 'Linking...'# gcc -lm bar.o -o bar# The targets order does not manner%.o: %.c @echo 'Compile to objects...' ${CC} -c $&lt;clean: @echo 'Cleaning up...' rm -rvf *.o ${BINS} Basic Data Types and its length Data Types Length (Bytes) Range Format Specifier \\[signed\\] int 4 -(2^31)~(2^31-1) %d (Dec), %o (Oct), %x (Hex) unsigned int 4 0~(2^32-1) %u short \\[int\\] 2 -(2^15)~(2^15-1) %hd unsigned short \\[int\\] 2 0~(2^16-1) %hu \\[long\\] long \\[int\\] 8 -(2^63)~(2^63-1) %[l]ld unsigned \\[long\\] long \\[int\\] (aka size_t) 8 0~(2^64-1) %[l]lu float 4 -3.4e-38~3.4e38 %f double 8 -1.7e-308~1.7e308 %lf long double 16 -1.2e-4932~1.7e4932 %Lf char 1 -128~127 %c unsigned char 1 0~255 %c char * (String) NA NA %s Different compilers may differ, this results was come from GCC11.2.0 (x86_64), you can test by using the C codes below: 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main(){ int a; signed int b; unsigned int c; short d; long e; long long f; float g; double h; long double i; char j; printf(&quot;int size %lu bytes \\n&quot;, sizeof(a)); printf(&quot;signed int size %lu bytes \\n&quot;, sizeof(b)); printf(&quot;unsigned int size %lu bytes \\n&quot;, sizeof(c)); printf(&quot;short size %lu bytes \\n&quot;, sizeof(d)); printf(&quot;long size %lu bytes \\n&quot;, sizeof(e)); printf(&quot;long long size %lu bytes \\n&quot;, sizeof(f)); printf(&quot;float size %lu bytes \\n&quot;, sizeof(g)); printf(&quot;double size %lu bytes \\n&quot;, sizeof(h)); printf(&quot;long double size %lu bytes \\n&quot;, sizeof(i)); printf(&quot;char size %lu bytes \\n&quot;, sizeof(j));} Some notes on format specifier: %m.ns: Output string, has length &gt;=m (add space from left if less), only read left n chars in a string. %-m.ns: Same as above, but add space from right if less than m. %m.nf: Same as above, but for float variables. %e: Shows the data in exponential form. %g: Auto select %f or %e determined by size. %%: Twice % to print ‘%’. C Compound Assignment Ten Compound Assignment: {+,-,*,/,%,&lt;&lt;,&gt;&gt;,&amp;,^,|}=. It was computed from right to left: 1234567int a=12;a+=a*=a/=a-6;// Is same asa=a/(a-6); // a=12/(12-6)=2a=a*a; // a=2*2=4a=a+a; // a=4+4=8 Assignment Expression Does NOT Do Variable Define 123456// Not allowedint a=b=c=5;// Allowedint b=2,c=3;int a=b=c=5; Library Functions in C Mathematics: #include &lt;math.h&gt; hypot(a,b) Return hypotenuse length from its neighbor edge a, b. sqrt(a) int abs(int x) / long labs(long x) / double fabs(double x) double {sin,cos,tan}(double x): Here x is radian. double {exp,log,log10}(double x): \\(e^x\\) / \\(\\ln x\\) / \\(\\log_{10}x\\) Memory: #include&lt;stdlib.h&gt; void *malloc(unsigned int size) allocate and return the memory address. void free(void *p) int system(const char *command) running a shell command, return -1 if failed. Basic Types, Array, Object 1234567891011121314151617181920212223242526272829303132333435363738// Variable definition auto create a memory space which has size equal to its data type (for integer it is 4 bytes)int i=233;int j=i; // equivalent to int j = 233;int *k=&amp;i; // the address of variable 'i'int l[3]={1,2,3}; // 'l' is a pointer to the address of first element in array, its type is 'int *'int *m=l; // '&amp;l' is not needed since 'l' has type 'int *'// Be aware for char pointer arrayschar *str={'h','e','l','l','o','\\0'}; // This is wrong, indeed it is same as 'char *str = 'h';'// Usingchar *str=(char[]) {'h','e','l','l','o','\\0'};// Orchar str[]={'h','e','l','l','o','\\0};// Orconst char *str=&quot;hello&quot;; // &quot;string&quot; implicitly creates a const memory area// No, there is no objects in CObject l; Object *m; // BTW, in C++ what object variable store is the copy construct function of that object '=()'. By default it copies all its member variables' value into new objectint (*n)[5]; // Create a pointer 'n' point to type 'int (*)[5]' and 'int [][5]' (a 2-dimensional integer array which explicitly has 5 columns)struct time{ long int day; long int hour;}struct time time1 = {1,0}; // struct variable does not store address, it might be only available in preprocessing stage.struct time time2 = time1;// Same as (similar to copy construct function in C++)struct time time2;time2.day=time1.day;time2.hour=time1.hour; Frequently Used Functions IO #include&lt;stdio.h&gt; scanf(&quot;pattern&quot;,&amp;address) Default delimiter is space ’ ', you can change it by using an pattern, for example, to use comma as delimiter:12float x, y, z;scanf(&quot;%f,%f,%f&quot;,&amp;x,&amp;y,&amp;z); // Then you can type '1.0,2.0,3.0' in terminal String puts(char *): Ouput a char array to STDOUT gets(char *): Similar to scanf() but use \\n as delimiter instead of space ’ '. strcat(char *str1,char *str2): Corcatenate str2 to the end of str1, changes apply to str1, return str1. strcmp(char *str1,char *str2): Compare by first different char (using sort of ASCII), return 0 if str1=str2; return positive if str1&gt;str2; return negative if str1&lt;str2. strlen(char *): Return the length of a char array. str{lwr,upr}(char *): Lowercase / Uppercase a char array. char *strchr(char *str, char ch): Return a pointer to the first occurance of the character ch in string str or return NULL if the character doesn’t found. int isalpha(int ch): Return non-zero if ch is a letter in alphabet. int isdigit(int ch) int isalnum(int ch): Return non-zero if ch is whether a letter or number. Functions If a function has type int, there is not necessary to have a declearation first (I defenitely recommand to have a declaration first):1234567891011121314151617181920#include&lt;stdio.h&gt;int main(){ int len; char str[100]; printf(&quot;please input a string:\\n&quot;); gets(str); len=length(str); printf(&quot;the string has %d characters.&quot;,len);}int length(char *p){ int n=0; while(*p!='\\0') { n++; p++; } return n;} There is a little bit clearer way to describe a recursion We have this code to do a factorial:12345678int factor1(int n){ int result; if(n==1) return 1; result=factor(n-1)*n; return result;} Now we describe it by using a “stair graph”(assume we call factor(5)): First stage we go down the stair123456789101112factor(5)=factor(4)*5---------- | factor(4)=factor(3)*4 ---------- | factor(3)=factor(2)*3 ---------- | factor(2)=factor(1)*2 ---------- | factor(1)=1 ---------- Down the stair Second stage we go up the stair1234567891011 factor(5)=24*5=120 | ---------- factor(4)=6*4=24 | ---------- factor(3)=2*3=6 | ---------- factor(2)=1*2=2 | ----------factor(1)=1 | ---------- Up the stair Veriable Store Types auto: For C language it is the default store types for variables. int i; equals auto int i; static: For local variable its memory was keep along the program running. For global variables and functions it means that they are only allowed to be called in this translation unit. (Local function) register: Variable will try to store in Registers. Optimize for frequency accessed variable. extern: TODO Struct &amp; Union &amp; Emum Struct format:123456789101112131415161718192021222324#include&lt;stdio.h&gt;//struct &lt;[struct_name]&gt;//{//} [&lt;var1,var2,...&gt;];struct Student{ int num; char name[20]; char sex; int age; float score;};int main(){ struct student student1={1001,&quot;Liming&quot;,'M',20,93.5}; printf(&quot;num: %d\\n&quot;,student1.num); printf(&quot;name: %s\\n&quot;,student1.name); printf(&quot;sex: %c\\n&quot;,student1.sex); printf(&quot;age: %d\\n&quot;,student1.age); printf(&quot;score: %5.1f\\n&quot;,student1.score);} Struct array12345678910111213struct student{ int num; char name[20]; float score;} stu[5] = { {101,&quot;liming&quot;,89}, {102,&quot;zhanghong&quot;,95}, {103.&quot;lili&quot;,89}, {104,&quot;weichen&quot;,85}, {105,&quot;yangfan&quot;,75} }; Struct pointer1234struct student *p;p=&amp;student1;printf(&quot;%s&quot;,(*p).name);printf(&quot;%s&quot;,p-&gt;name); Linked list123456789101112131415struct Student{ char name[15]; float mark; struct student *next;};typedef struct Student Node;typedef Node *Link;// Ortypedef struct Student{ char name[15]; float mark; struct student *next;} Node, *Link; Union: their members share the same memory1234567union &lt;[union_name]&gt;{ char name[]; int age; char sex; float labor_age;} [&lt;union_var1, union_var2,...&gt;] Enum:1234567891011//enum &lt;[enum_name]&gt;//{// E1,// E2,// E3//} [&lt;enum_var1,enum_var2,...&gt;]enum Weekday{ SUN,MON,TUE,WED,THU,FRI,SAT} Bit Operation And &amp; can be used as a filter. XOR ^ can be used to flip specific bits:1234 01000101^ 00001111---------- 01001010 Right shift &gt;&gt; do logical shift (for unsigned) or arithmetic shift (for signed; fill ‘1’ on the leftmost bits) Bit fields123456789101112131415struct packed_data{ // This bit fields distribute four bytes (see 'sizeof(unsigned int)'). They must be defined continuously, and can only have types '[signed] int', 'unsigned int'. unsigned int a:2; unsigned int b:1; unsigned int c:1; int i;}// It has the follow memory form:// -------------------------------------------------------------------------------------------------------------// | a | b | c | Not used | i |// -------------------------------------------------------------------------------------------------------------// | | | | |// 2bit 2bit 1bit 24bit 32 bit Macro #define with parameters1234567#include&lt;stdio.h&gt;#define MIN(a, b) (a&lt;b)?a:b#define SWAP(a,b) {int c;c=a;a=b;b=c;}// When you call SWAP(x,y), it just paste '{int c;c=x;x=y;y=c;}'// It doesn't paste text in &quot;&quot;// e.g. printf(&quot;SWAP(x,y)&quot;); Conditional compilation12345678910#define NUM 200main(){#if NUM&gt;100 printf(&quot;the number is larger than 100!&quot;);#elif NUM==100 printf(&quot;the number is equal to 100!&quot;);#else printf(&quot;the number is less than 100&quot;);#endif #ifdef MACRO_NAME: True if MACRO_NAME is defined. #ifndef MACRO_NAME: True if MACRO_NAME is not defined. #undef MACRO_NAME: Delete a defined macro MACRO_NAME. File Write / Read a file by char int fputs(const char *filename, FILE *fp) int fgetc(FILE *fp): Read a single char Example:12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){ FILE *fp; // File pointer char ch; char filename[]=&quot;text.txt&quot;; // Write Start if((fp=fopen(filename,&quot;w&quot;))==NULL) { printf(&quot;cannot open file\\n&quot;); exit(1); } ch=getchar(); ch=getchar(); while(ch!='#') { fputc(ch,fp); ch=getchar(); } fclose(fp); // Write End // Read Start if((fp=fopen(filename,&quot;r&quot;))==NULL) { printf(&quot;cannot open file\\n&quot;); exit(1); } while((ch=fgetc(fp))!=EOF) { putchar(ch); } fclose(fp); // Read End} Write / Read a file by string int fputs(const char *filename, FILE *fp) char *fgets(char *str, int n, FILE *fp): Store to char array str Example:1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){ FILE *fp; char str[100]; char filename[]=&quot;test.txt&quot;; // Write Start if((fp=fopen(filename,&quot;w&quot;))==NULL) { printf(&quot;cannot open file\\n&quot;); exit(1); } fputs(&quot;hello world&quot;, fp); fclose(fp); // Write End // Read Start if((fp=fopen(filename,&quot;rb&quot;))==NULL) { printf(&quot;cannot open file\\n&quot;); exit(1); } while(fgets(str,sizeof(str),fp)) printf(&quot;%s&quot;,str); fclose(fp); // Read End} Open mode: {r,w,a}[b] {read,write,append} only (binary) {r,w}[b]+ read &amp; write (binary) a[b]+ read &amp; append (binary Write / Read a file by block size_t fwrite(void *buf, size_t write_size, size_t count, FILE *fp) size_t fread(void *buf, size_t read_bytes, size_t count, FILE *fp) Example:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct student_score{ char Name[10]; int Num; int Chinese; int Math; int English;} score[100];int main(){ FILE *fp; int i, n; char filename[50]; printf(&quot;how many students in your class?\\n&quot;); scanf(&quot;%d&quot;, &amp;n); printf(&quot;please input filename:\\n&quot;); scanf(&quot;%s&quot;, filename); printf(&quot;please input Name, Number, Chinese, Math, English:\\n&quot;); for(i=0; i&lt;n; i++) { printf(&quot;NO%d&quot;, i); scanf(&quot;%s%d%d%d%d&quot;, score[i].Name, &amp;score[i].Num, &amp;score[i].Chinese, &amp;score[i].Math, &amp;score[i].English); } // Write Start if((fp=fopen(filename, &quot;wb&quot;)) == NULL) { printf(&quot;cannot open file\\n&quot;); exit(1); } for(i=0; i&lt;n; i++) if(fwrite(score, sizeof(struct student_score), 1, fp) != 1) printf(&quot;file write error\\n&quot;); fclose(fp); // Write End // Read Start if((fp=fopen(filename,&quot;rb&quot;)) == NULL) { printf(&quot;cannot open file\\n&quot;); exit(1); } for(i=0; i&lt;n; i++) { fread(score, sizeof(struct student_score), 1, fp); printf(&quot;%-10s%4d%4d%4d%4d\\n&quot;,score[i].Name, score[i].Num, score[i].Chinese, score[i].Math, score[i].English); } fclose(fp); // Read End} Input Example:12345678910how many students in your class?5please input filename:test.binplease input Name, Number, Chinese, Math, English:lili 1001 89 69 86mimi 1002 66 56 98qiqi 1003 99 56 23yuyu 1004 69 88 56xixi 1005 85 65 79 Write / Read a file in random position int fseek(FILE *fp, long int offset, int whence) The whence has three enums: SEEK_SET (Beginning of file), SEEK_CUR (Current position), SEEK_END (End of file). int feof(FILE *fp) return non-zero if fp is in End-of-File. void rewind(FILE *fp) set fp to beginning of the file. long int ftell(FILE *fp) return fp’s current position. int ferror(FILE *fp) return non-zero if some operation (read, write) to fp result an error.","link":"/zh-cn/computer/2022/c-notes/"},{"title":"ffmpeg 常用命令","text":"记一些 ffmpeg 的使用 本页面有些命令过长, 可以使用Shift + 鼠标滚轮的方式左右滚动查看 常用操作 查看文件信息: $ ffprobe -v quiet -print_format json -show_format -show_streams output.mkv 查看文件长度: $ ffprobe -select_streams v:0 -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 output.mkv 调整视频分辨率: -vf scale=854x480 VCB-Studio x265 压冻鳗常用参数:1$ &lt;stdout&gt; | x265 --y4m -D 10 --preset slower --deblock -1:-1 --ctu 32 --qg-size 8 --crf 15.0 --pbratio 1.2 --cbqpoffs -2 --crqpoffs -2 --no-sao --me 3 --subme 5 --merange 38 --b-intra --limit-tu 4 --no-amp --ref 4 --weightb --keyint 360 --min-keyint 1 --bframes 6 --aq-mode 1 --aq-strength 0.8 --rd 5 --psy-rd 2.0 --psy-rdoq 1.0 --rdoq-level 2 --no-open-gop --rc-lookahead 80 --scenecut 40 --qcomp 0.65 --no-strong-intra-smoothing --output &quot;output.hevc&quot; - 钱桑の常用参数 x26412345678910111213141516171819202122ffmpeg -i example.mp4 \\ -c:v libx264 \\ -preset slow \\ -pix_fmt yuv420p \\ -x264-params \\&quot;crf=28 \\:threads=4 \\:deblock=-1,-1 \\:keyint=600 \\:min-keyint=1 \\:bframes=8 \\:ref=4 \\:qcomp=0.55 \\:rc-lookahead=70 \\:aq-mode=1 \\:aq-strength=0.8 \\:me=umh \\:subme=7 \\:me_range=16 \\:psy-rd=1.3,0.15&quot; \\ -c:a copy \\ output.mp4 钱桑の常用参数 x265 10bit1234567891011121314151617181920212223242526272829303132333435ffmpeg -i example.mp4 \\ -c:v libx265 \\ -pix_fmt yuv420p10le \\ -preset slower \\ -x265-params \\ &quot;deblock=-1,-1 \\ :ctu=32 \\ :qg-size=8 \\ :crf=28.0 \\ :cbqpoffs=-2 \\ :crqpoffs=-2 \\ :me=3 \\ :subme=3 \\ :merange=20 \\ :limit-tu=4 \\ :no-amp=true \\ :ref=4 \\ :weightb=true \\ :keyint=600 \\ :min-keyint=1 \\ :bframes=6 \\ :aq-mode=1 \\ :aq-strength=0.8 \\ :rd=5 \\ :psy-rd=1.5 \\ :psy-rdoq=1.0 \\ :rdoq-level=1 \\ :rc-lookahead=60 \\ :scenecut=40 \\ :qcomp=0.65&quot; \\ -acodec aac \\ -ac 2 \\ -ab 79k \\ -ar 48000 \\ output.mp4 如果想压 8bit 可以改成 -pix_fmt yuvj420p 通过 VA-API 压 HEVC (相比软压缺少很多参数)1$ ffmpeg -hwaccel vaapi -hwaccel_device /dev/dri/renderD128 -vaapi_device /dev/dri/renderD128 -ss 0 -t 4:59 -i example.mkv -vf 'format=nv12,hwupload' -c:v hevc_vaapi -crf 26 -r 24 -acodec aac -strict -2 -ac 2 -ab 192k -ar 44100 -f mp4 -y output.mp4 通过 nvenc 压 H264 (相比软压缺少很多参数, 只有 meduim, slow, fast 三种 present 可选)1$ ffmpeg -hwaccel cuvid -c:v h264_cuvid -i example.mkv -c:v h264_nvenc -preset slow -b:v 2048 -bufsize 4096 -r 30 -profile:v high -level:v 4.1 -acodec aac -strict -2 -ac 2 -ab 192k -ar 44100 -pass 1 -f matroska output.mkv -y 选项解释 主要参考VCB-Studio的文档[2][4]. Encoding Mode (编码模式) --qp Quantization Parameter, 量化参数对应 CQ 模式, 默认值为 23. CQ 模式 (也称 CQP): Const Quantizer, 固定量化模式. 所有 P 帧采用一个固定的 Quantizer. Quantizer, 量化, 是一种衡量图像压缩程度的方法, 用 0-69 的浮点数表示, 0 为无损, 量化值越大, 图像被压缩的越多, 码率越低. 注意量化值不一定代表目视质量, 比如说一个纯色的图像可以以很高的量化值被量化, 占用的体积很小, 而一个很复杂的图像就算量化值不高. 但是压缩后观感也可能很差. 因为 quantizer 不能够较好的体现质量, 所以该模式一般由 Const Quality 模式替代. 就算不用 CQ 模式, Quantizer 这个概念依旧在编码中存在, 只不过编码器可以智能的浮动 QP 值. -crf CRF 模式: Constant Rate Factor 固定质量因子. x264 默认为 23.0, x265 默认为 28.0. x264 用一种结合人心理学估算出来的值, 来衡量视频的目测质量, 即是 RF (Rate Factor), 用浮点数表示, 0 为无损, 越高质量越差. CRF 就是在视频前后采用恒定的 RF 从而使视频前后的目测质量几乎一致. CRF 模式下，码率的时间分配效果是最理想的，也是最常用的模式. x264下, 对于一般视频, CRF 设置在 18-26 左右. 通常采用 19-21.5 就能使得 Rip 看上去很不错. 如需要绝对好的质量可以降低到 16, 但是码率也会很高. x265下, 日常编码建议 23 以上. 对于动漫的高画质编码, 建议至少 8.0 起. 注意, CRF 在搭配不同的参数前提下, 实际造成的目测效果还是有差距的, 甚至可能很大, 因此不能一概的认为 CRF 代表目视质量. 一般 vcb-s 用的 10bit 1080p BDRip，CRF 选择在 16~18 之间. --preset Preset 效率预设, x264 会自动设置很多参数来调节你对速度与效率的取舍. 最快的 ultrafast 速度媲美 GPU 加速, 最慢的 placebo 所需的时间可以是 ultrafast 的近百倍. Preset 越慢，x264 的码率效率越高，意味着单位码率能做到的画质越好. 一般推荐在 slow/slower/veryslow 三档. vcb-s 所用的参数一般基于 --preset &quot;veryslow&quot; --y4m 使用yuv420p颜色空间 -D/--depth 输出精度, 如输出 10bit: --depth 10 --deblock Deblocking 去色块. 现代编码器都是基于 MacroBlock 编码, 把画面划分为一块块的区域, 有损编码后, 区域之间就可能出现可见的 “分界线”. Deblock 的作用就是去除它们, 开启是肯定的. deblock 的两个参数分别是 alpha 和 beta 参数, 这两个参数默认是 0:0. 一般认为合理的范围是-3:-3~3:3 之间. 越是高码率的压片越建议调低; 因为设置高了, deblock 的强度会变大, 对画面有模糊的效果. 通常设置 -1:-1 就行了. 默认 0:0 已经算是比较合理的选择. deblock 的强度和 QP 值有关，所以 deblock 设置不变时, QP 值越低 (码率越高), deblock 的强度就会相应降低. --ctu Code Tree Unit, 指定最大允许 CTU 的尺寸. 虽然 x265 允许 64x64，但是过大的 TU 会增加平面的涂抹，增加运算量, 降低多线程优化可能, 总体来说在&lt;=1080p 的编码下弊大于利, 因此限制为 32 比较好. HEVC divides the picture into CTUs (Coding Tree Unit). In HEVC standard, if something is called xxxUnit, it indicates a coding logical unit which is in turn encoded into an HEVC bit stream. On the other hand, if something is called xxxBlock, it indicates a portion of video frame buffer where a process is target to. Coding Tree Unit is therefore a logical unit. It usually consists of three blocks, namely luma (Y) and two chroma samples (Cb and Cr), and associated syntax elements. Each block is called CTB (Coding Tree Block). CTB can be split into CBs[1] --qg-size 表示用于调整 QP 值的 CU (Coding Unit) 的最小单位, 越低 x265 调整一帧内 QP 值的灵活度越高. 推荐设置为最小值 8. A coding tree unit can be divided into coding units. CU consists of three CBs (Y, Cb, and Cr) and associated syntax elements. [1] --cbqpoffs x264 会根据 Psy 强度自动调整 Chroma 平面的码率分配, x265 无此机制所以经常出现 Chroma 欠码导致的色彩纹理削弱. 给 -2 左右的 offset 可以较好的缓解问题. --crqpoffs 同上, 建议 -2. --no-sao Sample Adatpive Offset, 然而也可称 Smoothing All Objects 可以减少 DCT ringing[3] 等欠码瑕疵, 但代价是极其暴力的涂抹效果, 所以要禁用它 (除非你是极低码率编码). Motion-Estimation (动态分析) --me ME Algorithm 动态搜索算法, 可选: Diamond (--me dia, x265 为 --me 0), 菱形搜索, 不推荐; Hex (--me hex, x265 为 --me 1), 六边形搜索, 默认选项. 只在非常追求速度的时候推荐; Multi Hex (--me umh, x265 为 --me 2), 多重六边形搜索. 非常均衡的算法, 效果非常好, 速度适中. 推荐一般情况下使用; Exhaustive (--me esa, x265 为 --me 4), 全面搜索. 很慢.; SATD Exhaustive(--me tesa) 经过转换的全面搜索. 速度比 esa 稍微慢一点点, 但是效果好一点, 所以一般有时间浪费的都选 tesa 而不是 esa. tesa 比起 umh, 提升在 5%~10%左右. 时间花费上则是 150%~200% 的增加. x265 下增加两个模式 (x265没有 tesa): Star (--me 3), Star is a three-step search adapted from the HM encoder: a star-pattern search followed by an optional radix scan followed by an optional star-search refinement; Full (--me 5), Full is an exhaustive search; an order of magnitude slower than all other searches but not much better than umh or star.[5] Star 综合来说好于 umh，但是不要试图用 Full。因为 x265 目前还没有对 Full 做优化，太慢了. --subme Subpixel Refinement 次像素级别优化. 从 0~11 效果越来越好, 速度也越来越慢. 追求速度推荐用 7, 追求质量推荐用 10, 最低建议 3 (preset = slow 时默认为 3). --merange ME Range, 表示搜索的最大范围. 一般 720p 给 16~24, 1080p 给 24~38. 值越大速度越慢. --me、--subme、--me_range 三个选项共同组成 ME 的参数组合. ME 是以编码时间换效率的另一套参数 (另一个是--ref、--bframes 构成的 Frame). 一般来说, 动态不高的番, 应该是用较强的 Frame 参数, 动态高的番则是用较强的 ME 参数. 一般来说，对于 x264, 下面三个组合是很好的快中慢三种选择: --me umh --subme 7 --me_range 16 --me umh --subme 10 --me_range 24 --me tesa --sumbe 10 --me_range 24 --no-amp、--no-rect amp 和 rect 是 HEVC 规范中对 block 的创新. 一般来说 block 都是正方形, rect 启用 1x2/2x1 类型的; amp 允许 1x4/3x4/4x1/4x3 类型的, 且 amp 是 rect 的充分但不必要条件. 通常来说，&lt;=1080p 下, 两个都没啥作用 (其中 amp 更没作用), 但都很耗时, 所以建议至少关闭 amp. --limit-tu 接上面, 如果 rect 开启, 建议开启 --limit-tu 4 来限制 x265 对分块的（可能）无效尝试. Reference Frames --ref Number of Reference Frames 参考帧数量. 表示某一帧最多允许参照多少其他的帧. ref 对编码所需时间的影响是线性的, ref 能带来的收益则是非线性的. 也即越高的 ReF, 额外收益越低. ref 是一个以编码时间换取编码效率的参数. ref 的数量不仅影响编码效率, 而且影响解码效率, 以及解码时最大缓存帧数. ref 和分辨率与帧率相乘后决定了播放设备需要达到的解码能力, x264 各个 Level 对其 ref 上限的支持有相应的限制. 对于日常的动漫, 一般来说，ref 设置如下: 追求速度的编码可以用 ref=4. 速度会很理想; 日常编码, ref=6, 相对 ref=4 可以节省 2%~4% 左右的体积. 追求压缩比的编码, ref=8, 相对 ref=4 可以节省 4%~8% 的体积. 追求极致压缩比的编码, ref 可以选择 13 左右. 相对 ref=4 可以节省 6%~15% 的体积. 特别静态的场景, 或者特别动态的场景 (比如噪点多的真人电影), ref 开高的意义均不大. 反而是动态程度一般, 场景混杂的, 开高 ref 效果比较好. vcb小组实测 ref 增加在 x265 中作用不明显. 建议不超过 6, 建议值为 4. --scene-cut (x264), --scenecut (x265) Number of Extra I-frames. 这是让 x264 决定是否切换场景的灵敏度. x264 会在场景切换的时候插入 I 帧，这个参数越低, x264 越容易判断场景做了切换, 越鼓励插入 I 帧. 通常保持默认 40 就好. --keyint Maximum GOP Size, 规定了最远两个 IDR 帧之间的距离. 这个值越大, 给编码器灵活度越高, 因为编码器不用被迫在不需要的情况下插入 IDR 帧; 但是也意味着拖动进度条的时候压力越大. 特别是 keyint=inf (x265 为 -1) 的时候, 一些真人访谈场景, 如果不切换场景, 很可能从头到尾只有一个第 0 帧是 IDR. 一般来说设置在 250~900 之间. 对于在线视频 360~480 是不错的选择. 本地视频 480~720 会比较合适. --min-keyint Minimum GOP Size, 规定了最近两个 IDR 帧之间的距离. 一般编码器在检测到场景转换的时候, 会插入 I 帧. 如果新插入的 I 帧距离上个 IDR 帧的距离 &gt;=min-keyint, 编码器就会将它设置为 IDR 帧. 否则会插入非 IDR 的 i 帧. 一般选择将 min-keyint 设置成 1, 所有 I 帧都会变为 IDR 帧. 关于 min-keyint 的设置有一种说法是考虑到画面中出现反复闪烁时, 设置一定大小的 min-keyint 可以避免插入 I 帧，而是插入 i 帧. 但实际上, x264 的 scene change 检测是十分智能的, 如果前后的场景可以有互相参考的价值, 那么即便中间有几个突变帧, 也不会贸然地插入 I 帧. 实际上, 这种情况在闪烁的地方插入 P 帧是完全没问题的, 因为即便是 P 帧, 其中的各个 macro-block 依然可以作为 I Block (独立编码), 所以没有使用 i 帧的必要性. (P 帧和 B 帧都可以有 Intra Block, 表现为某个 macroblock 不借助前后帧进行参考.) 事实上插入 i 帧还会导致兼容性问题, 例如为了 blu-ray compat 就需要设为 1, 所以始终用 --min-keyint 1 是最佳的选择. Bframes --open-gop, --no-open-gop Open GOP. 如果开启, 那么前一个 GOP 的 B 帧将可以参照下一个 GOP 的里面的帧. GOP 规定后面的不允许参照前面的, 但是前面的能否参照后面的, 则是由 OpenGOP 决定的. 如果开启, 那么在特定场景下可以增加编码效率, 但是一些播放设备和播放器不支持. 一般来说开启与否问题都不大. --weightb Weighted Prediction for B frame 允许 B 帧的加权预测, 在一些渐变场景比较有用. 百利无一害的选项, 默认开启. --bframes Number of B-Frames, 最大允许的连续 B 帧数量. 这个值越大, 编码时间稍有提高, 对压缩率也有帮助. B 帧并不是越高越好, 一般认为真人电影设置为 3~8, 动漫设置为 6~12 左右比较合适. --b-adapt Adaptive B-Frames, 采用什么算法来决定是否采用 B 帧. 对于 x264, 0-off 表示永远能用就用, 1-fast 是快速算法, 2-normal 采用的是常规算法. 2 比较优秀, 也会较慢. 一般推荐 --preset slow 及以上时候使用 2. x265 下有似乎有不同的实现[5]: With b-adapt 0, the GOP structure is fixed based on the values of --keyint and --bframes. With b-adapt 1 a light lookahead is used to choose B frame placement. With b-adapt 2 (trellis) a viterbi B path selection is performed. (Default) --b-pyramid B-Pyramid, B 帧参照其他 B 帧的方式. Disable 表示不允许 B 帧参照其他的 B 帧, Strict 为了 BD 原盘播放兼容性而设置, normal 则不加限制. 一般选择 normal 以最大化编码效率. x265 下只有启用和禁用. Rate Control --aq-mode Adaptive Quantizers, 简称 AQ. 没有 AQ, x264 会倾向于在平面和纹理处降低码率. 造成的效果就是线条部分看上去还行, 但是平面大幅度 block, 纹理烂掉. AQ 的作用就是来防止码率在纹理和平面处被过分的降低. AQ Mode, 选择 AQ 的算法. x264 有 Disable (aq-mode=0), Variance AQ (aq-mode=1) 和 Auto-Variance AQ(aq-mode=2). 一般来说, mode=1 效果中等, 比较安全, 不容易出现较烂的帧. mode=2 比较省码率, 但是偶尔容易出现烂帧. x265 有三种 aq 模式. aq-mode 1 是最安全稳定的 AQ, 适合高码率/高画质编码; aq-mode=2 相对来说效率最高, 适合中低码率的编码; aq-mode=3 对暗场进行加强, 适合 8bit 编码防止暗场压烂. 一般 10bit 编码根据 crf 高低决定 AQ 选取, 个人建议在 crf&lt;=16 时候使用 aq-mode=1, 否则使用 aq-mode 2. 注意同 crf 下, 不同 aq-mode 出来的体积是不一样的, 3&gt;1&gt;2. --aq-strength AQ Strength, AQ 强度. 对于 x264, 动漫选 0.6-1.0 左右; 真人选 0.8-1.2 左右. 越是高质量的编码, AQ 的 Strength 应该越高. 对于 x265, 动漫的 aq-strength 不用太高 (太高了码率也会浪费). 通常 aq-mode=1, aq-strength 给 0.8 比较合理; aq-mode=2, aq-strength 给 0.9 左右, aq-mode=3, aq-strength 给 0.7 左右. --qcomp 0.65 Quantizer Compression, 这个参数决定了 QP 的时域变化灵活度. 越低的数值代表灵活度越高, QP 值变动越大, 效果就是高动态场景下烂的比较严重, 因为 x264 会倾向于提高高动态下的 QP 值 (特别是引入 mbtree 之后). 通常认为, 越是倾向于高画质编码的, qcomp 需要给的越高, 反之亦然. qcomp=0 的时候效果接近固定比特率, qcomp=1 的时候效果接近固定 qp 值. qcomp 的作用会受到 mbtree 的影响. 建议设置为略高于默认 0.6 的 0.65, 对时域分配采取略保守的策略，来针对中高画质优化. --mbtree, --no-mbtree MB-tree (Marco-Block Tree) 是 x264 后期引入的一种码率控制和决策的工具, 在时域和空域都有重要的影响. MB-tree 的原理简单点说, 就是在编码过程中, 被大量参照的 block (被前后帧参照, 或者被同一帧其他部分参照) 给的 QP 值降低, 画质更好, 体积更大; 反之, 被参照少的帧 QP 增加, 画质更烂, 体积更小. 其逻辑在于, 被参照多的 block 理应有更好的画质, 这可以让参照它的更多 block 受益. MB-tree 的弊端主要在通常将平面和纹理涂抹的较为过分 (这些 block 通常是直接参照别的 block), MB-tree 也倾向于降低高动态部分的质量. 如果关闭 MB-tree, 通常细节会更好, 但是线条会有些欠码. 普遍认为，在中低码率的编码中 (crf&gt;18), MB-tree 永远是利大于弊的. 在极高码率的编码中 (crf&lt;16), MB-tree 永远是弊大于利的. 在高码率 (crf=16-18), 越是动态多, 噪点多, 线条锐利的片子, MB-tree 的正面作用越强. 开启 MB-tree 体积会减少很多. 所以一般开 MB-tree, crf 可以相比于关 MB-tree 低 1.0 左右. 比如 crf=16.5 mbtree=1、crf=17.5 mbtree=0 是 vcb-s 常用的选择. MB-tree 开启的时候, qcomp 的灵活度会被放大. 所以一般开 MB-tree 需要增加 qcomp (qcomp 数值增加, 灵活度降低). 比如 vcb-s 常用的参数: crf=16.0 mbtree=1 qcomp=0.80, crf=17.0 mbtree=0 qcomp=0.70; crf=16.5 mbtree=1 qcomp=0.75, crf=17.5 mbtree=0 qcomp=0.60; crf=17.0 mbtree=1 qcomp=0.75, crf=18.0 mbtree=0 qcomp=0.60; crf=19.0 mbtree=1 qcomp=0.70 (crf=19 的时候不宜关闭 MB-tree) --pbratio 降低 P 帧和 B 帧间画质差距. 动漫编码 B 帧数量庞大, 且 P、B 之间分工不明显, 因此降低这个参数对全局有利. Psycho-visual --psy-rd Psy 相关是一种 x264 引入的主观优化: 在欠码的时候, 人眼宁愿看到失真, 也不愿看到大范围的模糊. 虽然这种失真对客观的还原度来说不利, 但是它有利于保留画面纹理, 编码前后的图像看上去违和感较低, 细节锐度较好. 在 x264 中, 它有两个参数, 第一个是Psy-rd Strength, 心理学优化强度. 一般压制动漫选择 0.4-1.0，压制真人选择 0.7-1.3.越是高质量的编码, 可以开的越高. 但是在 CRF 模式下, 开高了 psy-rd 也会提高码率. 第二个参数是 Psy Trellis, 在 psy-rd 的基础上, 微调保留的噪点之类的微小细节的保留度. 一般开 MB-tree 时候, psy-trellis 可以给 0.1 左右. 关闭 MB-tree 时建议关闭.psy-trellis 的值越高, 会相应的调低 --chroma-qp-offset 以求让 Chroma 平面的细节得以保留. 所以在关闭 MB-tree 的时候, 一方面将 --psy-trellis 设置为 0，一方面将 --chroma-qp-offset 往下调 1 左右. 对于 x264 推荐设置为 0.6:0.15. 对于 x265, Psy 是目前调节锐利度和细节保留的重要工具, 低了会糊高了会出现动态瑕疵. 默认的 2.0 其实是个不错的数值. 如果中低码率编码，可以考虑降低到 1.5 左右. --psy-rdoq (x265) 作用类似 x264 中的 --psy-trellis, 默认 0.0, 设置为 1.0 有助于保留细节和噪点. Mode decision / Analysis --rd Rate distortion optimization 码率失真优化, 值越高计算度越复杂. 3 是一个比较平衡的选择. 目前 5 是实际最高选择. 根据官方 doc, --rd 3 和 --rd 4 相同, --rd 5 和 --rd 6 相同. --rdoq-level Specify the amount of rate-distortion analysis to use within quantization:[5] At level 0 rate-distortion cost is not considered in quant. At level 1 rate-distortion cost is used to find optimal rounding values for each level (and allows psy-rdoq to be effective). It trades-off the signaling cost of the coefficient vs its post-inverse quant distortion from the pre-quant coefficient. When --psy-rdoq is enabled, this formula is biased in favor of more energy in the residual (larger coefficient absolute levels). At level 2 rate-distortion cost is used to make decimate decisions on each 4x4 coding group, including the cost of signaling the group within the group bitmap. If the total distortion of not signaling the entire coding group is less than the rate cost, the block is decimated. Next, it applies rate-distortion cost analysis to the last non-zero coefficient, which can result in many (or all) of the coding groups being decimated. Psy-rdoq is less effective at preserving energy when RDOQ is at level 2, since it only has influence over the level distortion costs. 注意默认的 --preset medium 下它是 0, 这时候 rdoq 是没有用的. slow 及以上自动开启. --b-intra 允许 B 帧中出现 Intra Block. 动画建议. --rc-lookahead 编码时候往前看多少帧来规划 Coding Unit Tree (CUTree, 相当于 MBTree), 一般设置为 60-80 比较合理; 帧率越高的片源适合给的越高. --strong-intra-smoothing, --no-strong-intra-smoothing Enable strong intra smoothing for 32x32 intra blocks. This flag performs bi-linear interpolation of the corner reference samples for a strong smoothing effect. The purpose is to prevent blocking or banding artifacts in regions with few/zero AC coefficients. Default enabled --output 输出文件名 一些姿势 IPB 相关知识 IBP 帧: 视频压缩的过程中, 对于一段时间内相似的帧, 采用记录第一张, 后续几张只记录和第一张的区别, 这种想法是很自然的. 由此引申出两种帧: I 帧 (Independent Frame), 独立编码的帧. I 帧相当于记录一张 jpg, 一般常见于一个场景开头. 后续的帧就需要依赖 I 帧. P 帧(Predictive Frame), 需要依赖其他帧来编码的类型. P 帧需要参照在它之前的 I 帧或者其他的 P 帧, 因为它只记录差别, 所以对于那种前后差别很小甚至没有的帧, 使用 P 帧编码能极大地减少体积. MPEG2 之后，引入了第三种帧: B 帧 (Bi-directional Frame), 双向预测帧. B 帧跟 P 帧类似, 都是需要参照别的帧, 区别在于 B 帧需要参照它后面的帧, B 帧的记录和预测方式也做了调整, 使得 B 帧的预测方式更灵活, 对付高度静态规律的场景可以更有效的降低体积. 一种典型的排列方式: IPBBPBPIPPB… 视频开头一定是一个 I 帧. IDR 帧与 GOP 区间 I 帧中, 有一类特殊的 I 帧, 叫做 IDR 帧. IDR 帧的性质是, 比如第 1000 帧是 IDR 帧, 那么这一帧相当于一个分水岭, 从 1001 帧开始, 所有的帧都不能再参照 1000 帧之前的帧. 在 closed GOP 规定下 (x264 设置中可以指定, 并且 vcb-s 一直指定), 0~999 帧也不允许参照这个 IDR 帧以及之后的帧. 等于说 IDR 帧将视频分割成两个独立的部分: 前面的不能参照后面的(closed GOP 规定下), 后面的不能参照前面的. 这个性质在播放的时候额外有用: 如果我直接从第 1000 帧开始播放, 我可以毫无问题的播放下去, 因为我不需要参照 1000 帧之前的内容完成解码. 我从开头播放, 直到 999 帧的时候, 我都不需要参照 1000 帧及它后面的东西; 1000 帧之后的数据都损坏了, 0~999 帧也能正常播放. IDR 的全称叫做 Instantaneous Decoder Refresh, 意思是，解码到当前帧, 解码器就可以把缓存全清了, 之前的所有帧信息都没用了, 后续帧不会再去参照它们. 视频开头的 I 帧一定是 IDR 帧. 有时候, 我们用 I 帧表示 IDR 帧, i 帧表示非 IDR 的 I 帧. i 帧和 IDR 帧都只进行 intra prediction (所有参照信息都是帧内, 不借助前后帧). 区别在于 i 帧的前后 P、B 帧可以互相参考, 而 I 帧不允许. 从一个 IDR 帧开始, 到下一个 IDR 前的帧结束, 叫做 IDR 区间, 又叫做 GOP 区间. closed GOP 设定下, GOP 区间可以看做是独立的一段视频: 它里面的所有帧, 都不需要参照任何区间之外的东西, 只要一个 GOP 区间是齐全的, 区间里面所有的帧都能被解码. 我们平时看的视频就是多段 GOP 区间连接起来的. 在我们拖动进度条的时候，为啥有时候会卡顿，或者拖不准呢？其实是播放器干了这些事： 计算你拖动进度条的时间, 找出它应该是哪一帧, 假设为 N; 通过搜索视频索引信息, 找出 N 帧前面最近的一个 IDR 帧, 假设为 M (M&lt;=N). 很显然, M 和 N 同属于一个 GOP 区间, 这个区间开头的帧是 M; 如果你的播放器设置了快速索引, 视频将直接从 M 帧开始播放, 因为 M 帧是 IDR, 它不需要参照任何帧, 所以立刻可以开始播放. 这是为啥你会发现开始的地方总是在之前一点; 否则, 如果你的播放器设置了精确索引, 解码器会从 M 帧一直开始解码, 解码到 N 帧, 然后显示 N 帧的画面, 并继续播放. 当 N-M 比较大的时候, 播放器可能需要先解码几百甚至上千帧, 才能继续播放.如果视频允许很长的 GOP 区间, 这个视频在播放的时候, 拖动进度条就特容易卡顿. 如果设置了 --min-keyint 1, 那么所有 I 帧都是 IDR 帧 (vcb-s 也一直在用). 而 GOP 区间最大的范围则通过 --keyint 指定. 参考文献 ^ \"HEVC – What are CTU, CU, CTB, CB, PB, and TB?\". codesequoia.wordpress.com. Retrieved 2022-2-10. ^ \"VCB-Studio 教程 10 x265 v2.9 参数设置\". vcb-s.nmm-hd.org. Retrieved 2022-2-10. ^ Yu Yuan, David Feng, and Yu-Zhuo Zhong. \"The Causation and Solution of Ringing Effect in DCT-based Video Coding\". World Academy of Science, Engineering and Technology, International Journal of Computer, Electrical, Automation, Control and Information Engineering, vol. 2, no. 1, pp. 231-236, 2008 ^ \"VCB-Studio 教程 09 x264 参数设置\". vcb-s.nmm-hd.org. Retrieved 2022-2-10. ^ \"Command Line Options - x265 documentation\". x265.readthedocs.io. Retrieved 2022-2-10.","link":"/zh-cn/computer/2020/ffmpeg/"},{"title":"vim-usage","text":"Learn Vim - Shart Smart Way Here comes a cheatsheet &lt;S-a&gt; means Shift+A &lt;C-a&gt; means Ctrl+A &lt;CR&gt; means &lt;Enter&gt; or &lt;Return&gt; i_&lt;C-p&gt; means &lt;C-p&gt; in Insert Mode v_b_g &lt;C-a&gt; means g &lt;C-a&gt; in Visual Block-Wise Mode {a,b,c} means either a or b or c [a,b,c] means either a or b or c or none. TODO: works to be merged :t (copy) method copies all matches to an address. :j join command join the lines sort sort command sort the lines Spell Check: {],[}s Jump to next / prev wrong word z[u]{g,w,G,w} Add / Undo add good / wrong word under cursor to spellfile / or save to current session (Which is temporarily if you don’t save session) z= Find suggestion of the word under cursor Ch 01. Starting Vim Open Vim with two horizontal windows: vim -o2 [file1] [file2] Open Vim with two vertical windows: vim -O2 [file1] [file2] Ch 02 - Buffers, Windows, and Tabs Buffers :b{next,prev,first,last} Traverse buffers :[w]qall [Save] Close all :{buffers,ls,files} List buffers :bdelete Remove current buffer :[vertical ]ball Display all buffers {[vertically],horizontally} &lt;C-^&gt; Go to previously edited buffer Windows A window is how you are viewing a buffer through :[v]split [filename] Split window :[vertical ]sbuffer [N] Split window by buffer [N]. &lt;C-w&gt; {h,j,k,l} Navigate &lt;C-w&gt; {v,s} Opens a new {vertical,horizontal} split &lt;C-w&gt; {c,o} Closes {focused window,all other windows} &lt;C-w&gt; {r,R,H,J,K,L} Rotate focused window {down|right,up|left,far left,far bottom,far top,far right} :[vertical ]resize {80,+5} {Set,Increment} {[width],height} of focused window to {80,5} &lt;C-w&gt; {-,+,_,&lt;,&gt;,|,=} {Decrease 1 ,increase 1 ,maximize row, decrease 1, increase 1, maximize column, equal balance} for current horizontal or vertical split Tabs A tab is a collection of windows :tabnew [filename] Open a new tab :tabclose Close current tab :tab{next,prev,last,first} Go to {next,previous,last,first tab} Ch03. Searching Files Searching in Files With Grep :find / :edit :find finds file in path, :edit doesn’t. Using :set path+=&lt;your-path-here&gt; to set. 1. :vim /pattern/ file 2. :grep -R &quot;pattern&quot; /search/path Vim’s search uses Quickfix Window. :c{open,close,next,prev,older,newer,first,last} Open / Close / Navigate the quickfix window Browsing Files With Netrw :[S,V]Explore Starts netrw on current file {with split top / left half of the screen} % / d Create a new file / dir R / D Rename / Delete a file or directory Fzf Fzf syntax: ^ prefix exact match. e.g. ^welcome. $ suffix exact match. e.g. friends$. ' exact match. e.g. 'welcome my friends. | “or” match. e.g. friends | foes. ! inverse match. e.g. welcome !friends :Files or &lt;C-f&gt; Find files :Buffers or &lt;\\-b&gt; Find files in buffers :Rg or &lt;\\-f&gt; Find in files context :BLines or &lt;\\-/&gt; Find lines in current buffer :Marks or &lt;\\-'&gt; Find marks :Commits or &lt;\\-g&gt; Find git commits :Helptags or &lt;\\-H&gt; Find help tags :History or &lt;\\-h&gt; h Find in opened files’ history (list :oldfiles) :History: or &lt;\\-h&gt; : Find in command history :History/ or &lt;\\-h&gt; / Find in search history Search and Replace in Multiple Files First method12:grep &quot;pizza&quot;:cfdo %s/pizza/donut/g | update Second method123:%bd | e# &quot;Close all buffer except current file.:Files &quot;Select all files you want:bufdo %s/pizza/donut/g | update Ch04. Vim Grammar Grammar Rule There is only one grammar rule in Vim language: Verb (Operator) + Noun (Motion) y Yank text (copy) d Delete text and save to register c Delete text, save to register, and start insert mode ~ Toggle the case of the character under the cursor gU Uppercase text gu Lowercase text yy yank entire line dd delete entire line cc change entire line Some examples: y$ Yank to the end of the line dw Delete to the beginning of the next word c} Change to the end of paragraph y2h Yank two characters to the left d2w Delete the next two words c2j Change the next two lines gUiw Uppercase current word More Nouns (Text Objects) Two types of text objects: i + object Inner text object, select without the white space or the surrounding objects a + object Outer text object, select including the white space or the surrounding objects Common text objects: w A word p A paragraph s A sentence t XML tags ( / { / [ / &lt; or &gt; / ] / } / ) A pair of ( ) / { } / [ ] / &lt; &gt; &quot; / ' / ` A pair of &quot; &quot; / ' ' / ` ` % Navigate to another match, usually works for (), [], {} Ch05. Moving in a File Character Navigation A word is a sequence of characters containing only a-zA-Z0-9_. A WORD is a sequence of all characters except white space (a white space means either space, tab, and EOL). g{j,k} Down / Up in a soft-wrapped line w / W Move forward to the beginning of next word / WORD b / B Move backward to the beginning of previous word / WORD e / E Move forward to the end of next word / WORD g{e,E} Move backward to the end of previous word / WORD Current Line Navigation 0 / ^ Go to the first char / non-blank char $ / g_ Go to the last char / non-blank char n| Go to column n f / F Search forward / backward for a char t / T Search forward / backward for a char, stopping before match ; / , Repeat the last char search on same / opposite direction Sentence and Paragraph Navigation A sentence ends with either . ! ? followed by an EOL, a space, or a tab. A paragraph begins after each empty line and also at each set of a paragraph macro specified by the pairs of characters in paragraphs option. ( / ) Jump to the previous / next sentence { / } Jump to the previous / next paragraph [[ / ]] Jump to the previous / next section Line Number Navigation gg / G Go to first / last line nG Go to line n n% Go to n% in file &lt;C-g&gt; See total lines in a file Window Navigation H / M / L Go to top / medium / bottom of screen n{H,L} Go n line from top / bottom Scrolling &lt;C-{e,d,f}&gt; Scroll down a line / half screen / whole screen &lt;C-{y,u,b}&gt; Scroll up a line / half screen / whole screen z{t,z,b} Bring the current line to top / middle / bottom of your screen Search Navigation / / ? Search forward / backward for a match n / N Repeat last search in same / opposite direction of previous search :noh or &lt;Esc&gt;&lt;Esc&gt; Turn off match highlights * / # Search for whole word under cursor forward / backward, same as type /\\&lt;one\\&gt; / ?\\&lt;one\\&gt; g{*,#} Search for word under cursor forward / backward gn Searches forward for the last search pattern and do a visual selection Marking Position There is a difference between marking with lowercase letters (a-z) and uppercase letters (A-Z). Lowercase alphabets are local marks and uppercase alphabets are global marks (a.k.a. file marks). ma Mark position with mark a {',`}a Jump to line / exact position of mark a :marks View all marks Jump Any motion that moves farther than a word and current line navigation is probably a jump. '' / `` Jump back to line / exact position in current buffer before jump `[ / `] Jump to beginning / ending of previously changed or yanked text `&lt; / `&gt; Jump to the beginning / ending of last visual selection `0 Jump back to the last edited file when exiting vim :jumps See jump list &lt;C-{o,i}&gt; Move {up,down} the jump list m'5j Add current location to jump list, follows a move Ch06. Insert Mode i / I / gI Insert text before the {cursor,first non-blank character of the line,start of line} a / A Append text after the {cursor,end of line} o / O Starts a new line {below,above} the cursor and go insert mode s / S (=cc) Delete the {character,line} under the cursor and go insert mode gi Insert text in same position where the last insert mode was stopped &lt;Esc&gt; or &lt;C-[&gt; Exit insert mode &lt;C-c&gt; Exit insert mode and do not check for abbreviation &lt;C-{h,w,u}&gt; Delete {char,word,line} &lt;C-r&gt; a Insert text from register a &lt;C-x&gt; &lt;C-{y,e}&gt; Scroll {up,down} &lt;C-x&gt; &lt;C-{l,n,i,f,]}&gt; Auto completion {line,text from current file,text from included files,filename,tag} &lt;C-{n,p}&gt; Find the {next,previous} word match, or navigate {up,down} the auto completion pop-up menu &lt;C-{t,d}&gt; Indent current line {forward,backward} &lt;C-o&gt; &lt;normal cmd&gt; Excute a normal mode command &lt;C-o&gt; 100ihello Insert “hello” 100 times &lt;C-o&gt; !! curl https://google.com Run curl and insert stdout &lt;C-o&gt; !! pwd Run pwd and insert stdout &lt;C-o&gt; dtz Delete from current location till the letter z &lt;C-o&gt; D Delete from current location to the end of the line Repeating Insert Mode 10i: Vim will repeat the text 10 times. Ch07. the Dot Command What Is a Change? Any time you update (add, modify, or delete) the content of the current buffer, you are making a change. The exceptions are updates done by command-line commands (the commands starting with :) do not count as a change. Every action from the moment you press the insert command operator until you exit the insert command is considered as a change. Multi-line Repeat Let’s look at another example: 1234zlet zzone = &quot;1&quot;;zlet zztwo = &quot;2&quot;;zlet zzthree = &quot;3&quot;;let four = &quot;4&quot;; Let’s remove all the z’s. Input &lt;c-v&gt;jjdw... Including a Motion in a Change Replace all “let” with “const” in the following expressions: 123let one = &quot;1&quot;;let two = &quot;2&quot;;let three = &quot;3&quot;; To accomplish this. After you searched /let, run cgnconst&lt;esc&gt;... Ch08. Registers The Ten Register Types: Unnamed register (&quot;). Numbered registers (0-9). Small delete register (-). Named registers (a-z). Read-only registers (:, ., and %). Alternate file register (#). Expression register (=). Selection registers (* and +). Black hole register (_). Last search pattern register (/). Register Operators &quot;a Access / Store text into register a p / P Paste the text after / before the cursor 10&quot;ap Paste text from register a ten times &quot;ayiw Yank a word into register a The Unnamed Register It stores the last text you yanked, changed, or deleted. By default, p / P is connected to the unnamed register. The Numbered Registers The Yanked Register If you yank an entire line of text (yy), Vim actually saves that text in two registers: The unnamed register (&quot;). The yanked / zero register (0). The Non-zero Numbered Registers When you change or delete a text that is at least one line long, that text will be stored in the numbered registers 1-9 sorted by the most recent. As a side note, these numbered registers are automatically incremented when using the dot command .. The Small Delete Register Changes or deletions less than one line are not stored in the numbered registers 0-9, but in the small delete register (-). The Named Register You can append your text to the register. Using the uppercase version of that register. For example, suppose you have the word &quot;Hello &quot; already stored in register a. If you want to add “world” into register a, you can find the text “world” and yank it using A register (&quot;Ayiw). The Read-only Registers . stores the last inserted text : stores the last executed command-line % stores the name of current file The Alternate File Register In Vim, # usually represents the alternate file. An alternative file is the last file you opened. To insert the name of the alternate file, you can use &quot;#p. The Expression Register &quot;=1+1&lt;Enter&gt;p / &lt;C-r&gt; =1+1: Evaluate mathematical expression “1+1” and paste it / from insert mode &quot;=@a&lt;Enter&gt;p / &lt;C-r&gt; =@a: Get values from register a and paste it / from insert mode The Selection Registers Vim has two selection registers: star (*) and plus (+). You can use them to access copied text from external programs. If you yank a word from Vim with &quot;+yiw or &quot;*yiw, you can paste that text in the external program with &lt;c-v&gt;. Note that this only works if your Vim program comes with the +clipboard option (to check it, run :version). The Black Hole Register You can use the black hole register (_). To delete a line and not have Vim store the deleted line into any register, use &quot;_dd. The Last Search Pattern Register &quot;/p: Paste your last search (/ or ?) Viewing the Registers To view all your registers, use the :register command. To view only registers a, 1, and -, use :register a 1 -. Clearing a Register qaq Using Macro recording :call setreg('a', 'hello world') :let @a = '' Putting the Content of a Register (Command-line) :10put a: Paste text from register a to below line 10. :g/end/put _: Insert blank lines below all lines contain the text “end”, by using black hole register Ch09. Macros Basic Macros Suppose you have this text and you want to uppercase everything on each line: 12345hellovimmacrosareawesome With your cursor at the start of the line “hello”, run: 1qa0gU$jq The breakdown: qa starts recording a macro in the a register. 0 goes to beginning of the line. gU$ uppercases the text from your current location to the end of the line. j goes down one line. q stops recording. To replay it, run @a. Just like many other Vim commands, you can pass a count argument to macros. For example, running 3@a executes the macro three times. Command-Line Macro :2,3 normal @a: execute macro between lines 2 and 3, :normal allows the user to execute any normal mode command passed as argument. Recursive Macro Suppose you have this list again and you need to toggle the case of the first word: 1234a. chocolate donutb. mochi donutc. powdered sugar donutd. plain donut This time, let’s do it recursively: 1qaqqa0W~j@aq Now you can just run @a and watch Vim execute the macro recursively. How did the macro know when to stop? When the macro was on the last line, it tried to run j, since there was no more line to go to, it stopped the macro execution. Executing a Macro Across Multiple Files Suppose you have three txt files. Your task is to uppercase the first word only on lines containing the word “donut”. Assume you have 0W~j in register a. How can you quickly accomplish this? First file: 1234## savory.txta. cheddar jalapeno donutb. mac n cheese donutc. fried dumpling Second file: 1234## sweet.txta. chocolate donutb. chocolate pancakec. powdered sugar donut Third file: 123## plain.txta. wheat breadb. plain donut Here is how you can do it: :args *.txt to find all .txt files in your current directory and store in list :args. :argdo g/donut/normal @a executes the global command g/donut/normal @a on each file inside :args. :argdo update executes update command to save each file inside:args when the buffer has been modified. Appending a Macro Use the uppercase of registers to append a macro. e.g. qAiHello&lt;esc&gt;q Amending a Macro For example: First :put a to put macro’s contexts in register a. Change the macro’s context as usual text. Be aware that some operations like &lt;Esc&gt;, you can’t literally type &lt;Esc&gt;. To achieve that, (in insert mode) press {c,i,s}_&lt;C-v&gt; followed by &lt;Esc&gt;. Vim will print ^[, this is the internal code representation for the &lt;Esc&gt; key. Yank the text into register a, such as 0&quot;ay$. Macro Redundancy :let @z = @a. Duplicate a macro in register a to register z. Series vs Parallel Macro TL; DR: Using command-line :normal and specify a range, e.g. :1,$ normal @a. You want lowercase all the uppercased “FUNC”, then you record this macro qa0f{gui{jq: 123456import { FUNC1 } from &quot;library1&quot;;import { FUNC2 } from &quot;library2&quot;;import { FUNC3 } from &quot;library3&quot;;import foo from &quot;bar&quot;;import { FUNC4 } from &quot;library4&quot;;import { FUNC5 } from &quot;library5&quot;; Running 99@a, only executes the macro three times. It does not execute the macro on last two lines because the execution fails to run f{ on the “foo” line. You can always go to the next line where “FUNC4” is and replay that macro again. But what if you want to get everything done in one go? Run the macro in parallel. Recall from earlier section that macros can be executed using the command-line command :normal. If you run :1,$ normal @a, you will see that the macro is being executed on all lines except the “foo” line. It works! Ch10. Undo Undo Tree In Vim, every time you press u and then make a different change, Vim stores the previous state’s text by creating an “undo branch”. vim-mundo plugin is very useful to help visualize Vim’s undo tree. &lt;C-g&gt; u creates undo break in insert mode. g{+,-} Both u and &lt;C-r&gt; traverse only the main nodes in undo tree while g+ and g- traverse all nodes in the undo tree. :{w,r}undo file.undo Save / Load undo file :undolist See undo list. :earlier 10[f,s,m,d] Go to the state 10 times / saves / seconds / minutes / hours / days older :later 10 Go to the state 10 times newer Ch11. Visual Mode v / V / &lt;C-v&gt; Character-wise / Line-wise / Block-wise visual mode gv Go to the previous visual mode &lt;C-{x,a}&gt; {Decrement,Increment} numbers, alphabetical characters v_b_g &lt;C-{x,a} {Decrement,Increment} across multiple lines &gt; / &lt; Indent visual block forward / backward Visual Mode Navigation Press o or O in visual mode, the cursor jumps from the beginning to the end of the highlighted block, allowing you to expand the highlight area. Adding Text on Multiple Lines With your cursor on the first line: Run block-wise visual mode and go down two lines (&lt;c-v&gt; jj). Highlight to the end of the line ($). Append (A) then type text you want. Exit visual mode. Alternatively, you can also use the :normal command to add text on multiple lines: Highlight all 3 lines (vjj). Type :normal! A;. Ch12. Search and Substitute You can use \\C pattern anywhere in your search term to tell Vim that the subsequent search term will be case sensitive. If you do /\\Chello, it will strictly match “hello”, not “HELLO” or “Hello”. Search Visual Selected Text Yank the text you want. In search mode, type &lt;C-r&gt;&quot; (Paste text in unamed register) Repeating Search // Repeat the previous search s_&lt;{up,down,c-{n,p}}&gt; to traverse search history Repeating the Last Substitution &amp; or :s or leave the first substitute pattern argument black :s//awesome/ By the way, the repeat-substitution commands (&amp; and :s) do not retain the flags. To quickly repeat the last substitute command with all the flags, run :&amp;&amp;. Substitution Range Here are some range variations you can pass: :,3s/let/const/ Substitute from current line to line 3. :1,s/let/const/ Substitute from line 1 to current line. :3s/let/const/ Substitute on line 3 only. :%s/let/const/ Sbstitution on all lines. In addition to numbers, you can also use these symbols as range: . means the current line. A range of .,3 means between the current line and line 3. $ means the last line in the file. 3,$ range means between line 3 and the last line. +n means n lines after the current line. You can use it with . or without. 3,+1 or 3,.+1 means between line 3 and the line after the current line. Substitution Flags &amp; Reuse the flags from the previous substitute command. g Replace all matches in the line. c Ask for substitution confirmation. e Prevent error message from displaying when substitution fails. i / I Perform case insensitive / sensitive substitution. Changing the Delimiter You can change the delimiter with any single-byte characters (except for alphabets, numbers, or &quot;, |, and \\) when it is hard to tell which forward slashes (/) are part of the substitution pattern and which ones are the delimiters. Ch13. the Global Command Global Command Overview :g/pattern/cmd Executes cmd against each line that matches the pattern. :{g!,v}/pattern/command Run the global command on non-matching lines :g/console/d Remove all lines containing “console” :g/^/m 0 Reverse the entire file / buffer :g/TODO/t $ Aggregate all todos to the end of file :g/console/d_ Black hole delete that matches the pattern :g/pattern1/,/pattern2/cmd Apply the cmd within pattern1 and pattern2 :g/^$/,/./-1j Reduce multiple empty lines to one empty line, /^$/ represents an empty line. /./ represents a non-empty line (a line with at least one character), -1 means the line above that Advanced Sort If you have the following expressions: 123456789101112131415161718192021const arrayB = [ &quot;i&quot;, &quot;g&quot;, &quot;h&quot;, &quot;b&quot;, &quot;f&quot;, &quot;d&quot;, &quot;e&quot;, &quot;c&quot;, &quot;a&quot;,]const arrayA = [ &quot;h&quot;, &quot;b&quot;, &quot;f&quot;, &quot;d&quot;, &quot;e&quot;, &quot;a&quot;, &quot;c&quot;,] If you need to sort the elements inside the arrays, but not the arrays themselves, you can run this: 1:g/\\[/+1,/\\]/-1sort Ch14. External Commands :{r,w} &lt;filename&gt; / :{r,w} !cmd {Read,Write} a file / the {STDOUT,STDIN} of an external command to {current buffer,external command} :.!tr '[:lower:]' '[:upper:]' Uppercase current line !jtr '[a-z]' '[A-Z]' Uppercase the current line and the line below, the difference is this is a normal mode operator Ch15. Command-line Mode &lt;C-{b,e}&gt; Go to the start / end of the line &lt;C-{h,w,u}&gt; Delete one character / one word / entire line &lt;C-r&gt; &lt;C-{w,a,l,f}&gt; Get the word / WORD / line / filename under the cursor :his {:,/,?} View command / search history q{:,/,?} or {c,s}_&lt;C-f&gt; Open editable command / search history Ch16. Tags Here I recommand universal ctags, install it by pacman -S ctags $ ctags -R . manual generate tag files under cuurent directory $ ctags -R --exclude=.git --exclude=vendor --exclude=node_modules --exclude=db --exclude=log . :set tags? See tag files path set tags+=path/to/tags/file Add a new tag files location &lt;C-]&gt; or :tag Jump to a definition :tselect &lt;pattern&gt; Selective tag jumps, type numerical key to jump. g &lt;C-]&gt; or :tjump &lt;pattern&gt; Selective tag jumps, prompt only when &gt; 2 options. :tags List of the tags you have jumped to. Called tag stack. :pop “pop” the tag stack. Ch17. Fold There are six different fold methods: manual, indent, expression, syntax, diff, marker. manual is the default. You can persisting fold by save the View. Goto see Chaper Views, Sessions, and Viminfo zf&lt;any motion&gt; Fold operator, follows a motion, or use it in visual mode z{o,c,a} Open / Close / Toggle a foleded text. z{d,D} Delete a fold [Recursively] under cursor :,+1fold Fold in command-line mode z{R,M} Open / close all folds. :set foldmethod? See which folding method you are currently using. :set foldmethod={indent,syntax,marker} Set Indent / Syntax / Marker Fold mode :set shiftwidth=1 Set the how much spaces the Vim consider as an indent fold. :set foldmarker=coffee1,coffee2 Will fold texts between coffee1 and coffee2 Syntax Fold determined by syntax language highlighting. Using syntax plugin like vim-polyglot will work out of box Maker Fold determined by special markers defined in ‘foldmarker’ option. Diff Fold $ vimdiff &lt;file1&gt; &lt;file2&gt; or $ vim -d &lt;file1&gt; &lt;file2&gt; Expression Fold Expression fold allows you to define an expression to match for a fold. if the foldexpr return 0, then the line is not folded. :set foldmethod=foldexpr Suppose you want to fold all breakfast items starting with “p”: 123456donutpancakepop-tartsprotein barsalmonscrambled eggs 1:set foldexpr=getline(v:lnum)[0]==\\\\&quot;p\\\\&quot; Let’s break it down: getline() is a Vimscript function that returns the content of any given line. If you run :echo getline(5), it will return the content of line 5. v:lnum is Vim’s special variable for the 'foldexpr' expression. Vim scans each line and at that moment stores each line’s number in v:lnum variable. On line 5, v:lnum has value of 5. On line 10, v:lnum has value of 10. [0] in the context of getline(v:lnum)[0] is the first character of each line. When Vim scans a line, getline(v:lnum) returns the content of each line. getline(v:lnum)[0] returns the first character of each line. On the first line of our list, “donut”, getline(v:lnum)[0] returns “d”. On the second line of our list, “pancake”, getline(v:lnum)[0] returns “p”. ==\\\\&quot;p\\\\&quot; is the second half of the equality expression. It checks if the expression you just evaluated is equal to “p”. If it is true, it returns 1. If it is false, it returns 0. In Vim, 1 is truthy and 0 is falsy. So on the lines that start with an “p”, it returns 1. Recall if a 'foldexpr' has a value of 1, then it has a fold level of 1. Ch18. Git Diffing vimdiff or vim -d {],[}c jump to next / previous diff d{p,o} or :diff{put,get} [filename] {put,obtain(get)} text from {current,another} buffer to {another,current} buffer / file. Vim As a Merge Tool Change the default merge tool to use vimdiff: 1234git config merge.tool vimdiffgit config merge.conflictstyle diff3git config mergetool.prompt falsegit config mergetool.keepBackup false # Git create a backup file in case things don't go well, so disable it. When there comes a conflict, run: 1git mergetool Vim displays four windows. LOCAL is the change in “local”, what you are merging into. BASE is the common ancestor between LOCAL and REMOTE to compare how they diverge. REMOTE is what is being merged into. The fourth window contains the git’s merge conflict texts. You cursor should be on this window. Your can run :diffget BASE or :diffget REMOTE to get the change from that. Git Inside Vim 123:!git add % &quot;Git add current file:!git checkout # &quot;Git checkout the other file:windo !git add % &quot;Add multiple files in different window Vim-fugitive vim-fugitive :Git Display a git summary window, here you can do: &lt;C-{n,p} Go up or down the file list. - Stage or unstage the file under the cursor. s Stage the file under the cursor. u Unstage the file under the cursor. &gt; / &lt; Display / Hide an inline diff of the file under the cursor. :Git blame Display a split blame window, here you can do: q Close the the blame window. A/ C / D Resize the author / commit / {date,time} column. :Gdiffsplit: Runs a ‘vimdiff’ of the current file against the index or work tree. Or run :Gdiffsplit to specify a commit. :Gwrite: Stage the changes of current file. Like git add &lt;current=file&gt; :Gread: Restore the file. Like git checkout &lt;current-file&gt;. You can undo this action. :Gclog: Display the commit history. Like git log, but this one using quickfix, so you can use :cnext and :cprevious to traverse the log information. Furthmore, you can run :Gclog arguments just like before, such as :Gclog --after=&quot;January 1&quot; --before=&quot;March 14&quot; Ch19. Compile :make Vim looks for a makefile in the current directory and execute it. It uses quickfix to store any error. :set makeprg=g++\\ %\\ -o\\ %&lt; Change the :make command. \\ is to escape the space after g++. %&lt; Represents the current file name without an extension (hello.cpp becomes hello) Add autocmd BufWritePost *.cpp make in .vimrc to auto compile cpp files on save. :compiler ruby Vim runs the $VIMRUNTIME/compiler/ruby.vim script and changes the makeprg to use the ruby. To create a simple Typescript compiler: ~/.vim/compiler/Typescript.vim12CompilerSet makeprg=tscCompilerSet errorformat=%f:\\ %m &quot;'%f' represents the error file, whereas '%m' represents the error message. Plugin: Vim-dispatch vim-dispatch Async Make :Make Vim will run make asynchronously. You can continue doing whatever your were doing. Async Dispatch :Dispatch Like the ‘:compiler’ and the ‘:!’ command. It can run any external command asynchronously. e.g. ‘:Dispatch bundle exec rspec %’ Automating Dispatch Vim-dispatch has b:dispatch buffer variable that you can configure to evaluate specific command automatically. add this in your .vimrc, each time you enter a file that ends with _spec.rb, running :Dispatch automatically executes bundle exec rspec %:~/.vimrc1autocmd BufEnter *_spec.rb let b:dispatch = 'bundle exec rspec %' Ch20. Views, Sessions, and Viminfo View View is the smallest subset of the three (View, Session, Viminfo). It is a collection of settings for one window :set viewoptions? :set viewoptions+=localoptions Remember the localoptions :set viewdir? See where did Vim save View files :{mk,load}view 1 Save / Load View, Vim let you save 9 numbered Views Automating View Creation e.g. To autosave txt files: ~/.vimrc12autocmd BufWinLeave *.txt mkviewautocmd BufWinEnter *.txt silent loadview Sessions View saves the settings of a window, Session saves the information of all windows (including the layout). :mksession [/path/to/mysession.vim] By default Vim save Session.vim in current directory :source Session.vim or $ vim -S Session.vim Load a Session. You can also load from terminal :set sessionoptions? Show session options :set sessionoptions-=terminal If you don’t want to save terminal Session Options: blank stores empty windows buffers stores buffers folds stores folds globals stores global variables (must start with an uppercase letter and contain at least one lowercase letter) options stores options and mappings resize stores window lines and columns winpos stores window position winsize stores window sizes tabpages stores tabs unix stores files in Unix format Viminfo Viminfo stores: The command-line history. The search string history. The input-line history. Contents of non-empty registers. Marks for several files. File marks, pointing to locations in files. Last search / substitute pattern (for n and &amp;). The buffer list. Global variables. :{w,r}v ~/.viminfo_extra Save / Viminfo file $ vim -i ~/.viminfo_extra Load Viminfo file from terminal. $ vim -i NONE Start Vim without Viminfo. To make it permant, you can add set viminfo=&quot;NONE&quot; in your vimrc file :set viminfo? You will get like as: 1!,'100,&lt;50,s10,h This looks cryptic. Let’s break it down: ! saves global variables that start with an uppercase letter and don’t contain lowercase letters. Recall that g: indicates a global variable. For example, if at some point you wrote the assignment let g:FOO = &quot;foo&quot;, Viminfo will save the global variable FOO. However if you did let g:Foo = &quot;foo&quot;, Viminfo will not save this global variable because it contains lowercase letters. '100 saves the local marks (a-z) of the last 100 files. 1000 is a good number to have. &lt;50 maximize 50 lines saved for each register. If you don’t give maximum line number, all lines will be saved. If you give it 0, nothing will be saved. s10 size limit (in kb) for each register. h disables highlighting (from hlsearch) when Vim starts. There are more parameters you can set: :100 stores 100 command-line history. % saves and restore the buffer list. n~/.vim/.viminfo sets Viminfo file path Multiple File Operations Different Ways to Execute a Command in Multiple Files Vim has eight ways to execute commands across multiple files: arg list (argdo) buffer list (bufdo) window list (windo) tab list (tabdo) quickfix list (cdo) quickfix list filewise (cfdo) location list (ldo) location list filewise (lfdo) Argument List :arg{s,a} file1 file2 file3 Initialize / Append argument list. Run :args standalone to view file list. Location List You may only have one quickfix list, whereas you can have as many location list as windows. Vim creates a distinct location list for each window. :l{vim,grep} /bagel/ **/*.md location list variant for the :vimgrep / :grep command :l{open,close,first,last,next,prev,make} bunch of location list vraiant commands","link":"/zh-cn/computer/2020/vim-usage/"},{"title":"cpp","text":"Notes on Cherno C++ Tutorial TODO: 重新格式化这篇文章 写在前面: 如果你在看到一半的时候, 若出现还没有讲到过的操作出现在示范代码中(比如new), 知道它基本起什么作用即可, 在后面的episodes肯定会细讲 如果你看到夹杂英文, 那是我直接copy了@Cherno的话并懒得翻译 Notice Always pass your function parameters with const if possible If an object have pointer variable inside, write a copy constructor and use it 节约内存的小技巧 由于内存最小可操作单位是 byte, 而 bool 类型只需要 1 字节即可(0 和 1)，巧妙的方法是使用 1 个 byte 表示 8 个 bool 类型变量 头文件 or inline? （inline实际上就是将函数整个代码复制到调用这个函数的函数那里） 宏使用#if和#endif作为条件判断 #if 1为true 声明为 static 的变量和函数只在它所在的 translation unit 有效 默认的浮点数是double类型的, 如果你只用float的精度, 在数据后加上&quot;f&quot;如 float a = 5.5f @Cherno 写Class的规范: m_LogLevel的&quot;m_&quot;表示变量是类内部(private)变量 public和private可以分离, 如一部分Public修饰变量, 另一部分Public修饰函数: 123456789101112131415161718192021222324252627class Log {public: const int LogLevelError = 0; const int LogLevelWarning = 1; const int LogLevelInfo = 2;private: int m_LogLevel = LogLevelInfo;public: void SetLevel(int level) { m_LogLevel = level; } void Error(const char* message){ if (m_LogLevel &gt;= LogLevelError) std::cout &lt;&lt; &quot;[Error]:&quot; &lt;&lt; message &lt;&lt; std::endl; } void Warn(const char* message){ if (m_LogLevel &gt;= LogLevelWarning) std::cout &lt;&lt; &quot;[WARNING]:&quot; &lt;&lt; message &lt;&lt; std::endl; } void Info(const char* message){ if (m_LogLevel &gt;= LogLevelInfo) std::cout &lt;&lt; &quot;[INFO]:&quot; &lt;&lt; message &lt;&lt; std::endl; }} How C++ Works Concepts: Every .cpp will compile to one .o/.obj file multiple .cpp and .h has #include with each other can compose to a translation unit Compile Process Path: Source-&gt;Compile-&gt;Linker-&gt;Executables Generate Pre-process file Pro-process file is the source code that the macro (such like #include) was parsed by the compiler. VS2015: Project Settings-&gt;Preprocessor-&gt;Preprocess to a File GCC: cpp hello.cpp &gt; hello.i Compile &amp; Assembly VS2015: Compile Only (Ctrl+F7) GCC: g++ -S main.i; as main.s -o main.o Linker Externally defined functions will be integrated in the link phase, and function declarations that never be called will be optimized away. The parameter of ld are platform specific (mainly depend on your gcc version) Use g++ -v -o hello hello.cpp we can get the parameter of the collect2 (which is an alias for ld) 1234$ g++ -v -o hello hello.cpp.../usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/collect2 -plugin /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/lto-wrapper -plugin-opt=-fresolution=/tmp/ccDNo0Hr.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -o main.exe /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/Scrt1.o /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtbeginS.o -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0 -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../.. /tmp/ccs86P3x.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtendS.o /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crtn.o... So the ld command should be 12345678910111213141516171819202122232425262728293031$ ld&gt; -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/lto-wrapper&gt; -plugin-opt=-fresolution=/tmp/ccHyR7Od.res&gt; -plugin-opt=-pass-through=-lgcc_s&gt; -plugin-opt=-pass-through=-lgcc&gt; -plugin-opt=-pass-through=-lc&gt; -plugin-opt=-pass-through=-lgcc_s&gt; -plugin-opt=-pass-through=-lgcc&gt; --build-id&gt; --eh-frame-hdr&gt; --hash-style=gnu&gt; -m elf_x86_64&gt; -dynamic-linker /lib64/ld-linux-x86-64.so.2&gt; -pie&gt; -o main /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/Scrt1.o&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crti.o&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtbeginS.o&gt; -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0&gt; -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib&gt; -L/lib/../lib&gt; -L/usr/lib/../lib&gt; -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../..&gt; main.o&gt; -lstdc++&gt; -lm&gt; -lgcc_s&gt; -lgcc&gt; -lc&gt; -lgcc_s&gt; -lgcc /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtendS.o&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crtn.o You can probably significantly shorten that link line by removing some arguments. Here’s the minimal set I came up with after some experimentation: 1234567891011$ ld&gt; -dynamic-linker /lib64/ld-linux-x86-64.so.2&gt; -o main /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/Scrt1.o&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crti.o&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtbeginS.o&gt; -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0&gt; main.o&gt; -lstdc++&gt; -lc&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtendS.o&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crtn.o Variables in C++ Main idea: The difference between C++ data types are simply the different allocated memory size and the declaration of the type of data to be stored Different memory allocation size for C++ Data Type: char 1 Byte short 2 Bytes int 4 Bytes long commonly 4 Bytes long long 8 Bytes float 4 Bytes double 8 Bytes You can use sizeof() to see the data type size. Functions in C++ Function means a function that is not in a class. Method means a function in a class. The main purpose of the function is to reduce code duplication. But don’t frequently divide your code into functions, calling a function requires creating an entire stack frame for that function. This means we have to push parameters and so on into the stack, and also, put something called the return address into the stack, so that after the function executed the PC register could return to the address before the function call. TLDR: Jumping around in memory to execute function instructions comsumes additional time. Generally we write function definitions in header files (.h) and function bodies in .cpp files. C++ Header Files #pragma once can prevent include same header file multiple times in a translation unit (e.g. your include header file b.h in a.cpp, but b.h includes andther header file c.h, while you have already include b.h before in a.cpp) The second way do the same thing as #pragma once (In CLion this is the default way): Log.h123456#ifndef _LOG_H#define _LOG_H// some sentence...#endif How to DEBUG C++ in VISUAL STUDIO The watch view in VS2015 allows you to specify the veriables to be monitored, In memory window you can search by keyword &amp;a to show the address of variable a The default value of uninitialized variables is 0xcccccccc Visual Studio Setup for C++ Use Show All Files view under Solution Explorer By default VS2015 put intermediate files in debug directory It’s recommand to set Output Directory into $(SolutionDir)bin\\$(Platform)\\$(Configuration)\\ and set Intermediate Directory into $(SolutionDir)bin\\intermediate\\$(Platform)\\$(Configuration)\\ CONDITIONS and BRANCHES in C++ In C++ 0 means false, any other numbers means true else if is equivalent to else { if(){} } Loops in C++ for can also be written in the form of while: 123456789int i = 0;bool condition = true;for ( ; condition; ){ Log(&quot;Hello World!&quot;); i++; if (!(i&lt;5)) condition = false;} POINTERS in C++ Pointer: the pointer represents a momory address, generally the data type of the pointer is used to represent the data type of the data at the target address. So if we don’t care the pointed data’s data type, just using void* Pointer to Pointer:1234567891011#include &lt;cstring&gt;// ...// Allocate a space with 8 char's and fill it with zero, then finally release the memory space.char* buffer = new char[8];memset(buffer, 0, 8);delete[] buffer;// pointer to pointerchar** ptr = &amp;buffer; In running, ptr 储存的数据为 0x00B6FED4 (即 buffer 作为变量本身的地址), 在 VS2019 自带的 Memory View 中 buffer储存的数据为f0 dd d0 00 (buffer指向8个char长度的空间地址), 由于x86的设计, 我们从 Memory View 看到的是反转的数据, 实际应该是00 d0 dd f0(即 0x00d0ddf0), 这个地址就是那8个char长度空间的所在地. Reference in C++ 函数的形式参数中 使用引用可以使代码相比指针更简洁 因为访问引用变量不使用需要去引用化符号 “*” CLASSES vs STRUCTS in C++ Struct和Class无本质区别 Struct更适合存储多个变量, 侧重于表达数据结构, 而对象侧重于表达对象 Struct中的变量默认是Public修饰. 同时, Class可以继承Struct(但编译器会报警) public: 和 private: 在类中可有多处 Static in C++ Basically just to cut to the chase (切入正题/长话短说), static outside of class means that the linkage of that symbol that you declare to be static is going to be internal meaning. It;s only going to be visible to that translation unit that you’ve defined it in. Whereas a static variable inside a class or struct means that variable is actually going to share memory with all of the instances of the class meaning that basically across all instances that you create of that class or struct, there’s only going to be one instance of that static variable and a similar thing applies to static methods in a class there is no instance of that class being passed into that method. (Cherno讲的是背后的原理) 第一种情况翻译: 由于translation unit中的(不是class中的)全局变量/函数是全局可见的, 所以加上static让全局变量只在它所在的translation unit可见. 否则在不同的translation unit声明相同符号的变量将在链接阶段报重复定义错误. 类似于translation unit的private修饰 @Cherno 的命名规范: s_开头代表变量为静态 static int s_Variable = 5; 尽量在头文件使用static变量, 因为它只是简单将内容复制到cpp文件 Local Static 使变量在局部可见的同时有static的性质 1234567891011121314void Function(){ static int i = 0; i++; std::cout &lt;&lt; i &lt;&lt; std::endl;}int main(){ Function(); Function(); Function(); Function();} Classical Singleton Singleton类在整个程序中只有一个实例 12345678910111213141516// 第一种实现class Singleton{private: static Singleton* s_Instance; Singleton() {}; // 这一行作用阻止类被实例化, 后面构造函数会讲public: static Singleton&amp; Get() { return *s_Instance; }; void Hello() { std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl; };};Singleton* Singleton::s_Instance = nullptr;int main(){ Singleton::Get().Hello(); 12345678910111213141516171819// 或者将对象实例放在局部静态变量中(好处: 相比上一种更少的代码量)class Singleton{private: Singleton() {}; // 这一行作用阻止类被实例化, 后面构造函数会讲public: static Singleton&amp; Get() { static Singleton instance; return instance; }; void Hello() { std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl; };};int main(){ Singleton::Get().Hello();}} Enum in C++ 枚举用来管理标识符, 增强代码可读性, 本质是Integer(可指定which types of integer you want to be) 如 (模式是32位Integer, 这里用unsigned char只有8位可以节约内存) 1234enum Example : unsigned char{ A, B, C}; 使用enum后的Log类 12345678910111213141516171819202122232425262728293031323334353637class Log{public: enum Level { // LevelError = 0代表从零开始递进, 当然默认就是0 LevelError = 0, LevelWarning, LevelInfo };private: Level m_LogLevel = LevelInfo;public: void SetLevel(Level level) { m_LogLevel = level; } void Error(const char* message) { if (m_LogLevel &gt;= LevelError) std::cout &lt;&lt; &quot;[Error]:&quot; &lt;&lt; message &lt;&lt; std::endl; } void Warn(const char* message) { if (m_LogLevel &gt;= LevelWarning) std::cout &lt;&lt; &quot;[WARNING]:&quot; &lt;&lt; message &lt;&lt; std::endl; } void Info(const char* message) { if (m_LogLevel &gt;= LevelInfo) std::cout &lt;&lt; &quot;[INFO]:&quot; &lt;&lt; message &lt;&lt; std::endl; }};int main() { Log log; log.SetLevel(Log::LevelWarning); log.Error(&quot;Hello&quot;); log.Warn(&quot;Hello&quot;); log.Info(&quot;Hello&quot;);} Constructors in C++ You have to manually initialize all of your primitive types otherwise they will be set to whatever was left over in that memory. 禁止实例化类, 只需要把构造函数设为Private, 或者删除构造函数 If you did not want people creating instances… 123456789101112131415161718192021class Log{Private: Log() {} // One waypublic: Log() = delete; // Another way static void Write() { }};int main(){ // Only Write() can be invoke Log::Write(); // Now you cannot access the constructor Log l;} Destructors in C++ 折构函数可以被这样调用, 但是基本上不会用到, It’s weired someClass.~someClass(); Inheritance in C++ 没啥好说的, 唯一要注意的是继承的类的大小将是: 父类所有的变量总和 + 自己声明变量总和 Use colon to inerit a class 1234class Sub_Class : Main_Class{} Virtual Function in C++ 首先我们来看为什么要有Virtual函数 1234567891011121314151617181920212223242526class Entity{public: std::string GetName() { return &quot;Entity&quot;; } };class Player : public Entity{private: std::string m_Name;public: Player(const std::string&amp; name) : m_Name(name) {} std::string GetName() { return m_Name; }};int main(){ Entity* entity = new Entity(); std::cout &lt;&lt; entity-&gt;GetName() &lt;&lt; std::endl; Player* player = new Player(&quot;Cherno&quot;); Eneity* entity2 = player; std::cout &lt;&lt; entity2-&gt;GetName() &lt;&lt; std::endl;} 输出: 12EntityEntity 发现问题了吗, 第二个输出本应是&quot;Cherno&quot; 实际上当指针类型是父类Entity时, 通过该指针调用子类Player类的重载函数GetName()并没有被调用, 而是父类定义的内容, 这会导致许多问题 C++11引入了Override关键字, 它不是必须的, 但能够避免发生拼写错误并能增强代码的可读性 正确示范: 12345678910111213141516171819202122232425262728class Entity{public: // 加上了virtual virtual std::string GetName() { return &quot;Entity&quot;; } };class Player : public Entity{private: std::string m_Name;public: Player(const std::string&amp; name) : m_Name(name) {} // 加上了override std::string GetName() override { return m_Name; }};int main(){ Entity* entity = new Entity(); std::cout &lt;&lt; entity-&gt;GetName() &lt;&lt; std::endl; Player* player = new Player(&quot;Cherno&quot;); Eneity* entity2 = player; std::cout &lt;&lt; entity2-&gt;GetName() &lt;&lt; std::endl;} 总结: If you want to override a function you have to mark the base function in the base class as virtual. 不重要的补充: 使用virtual可以减少dynamic dispatch这种操作的使用 (运行时修改对象的vtable). 很不幸virtual它不属于免费的午餐, 首先使用它会需要额外的Vtable空间以让我们能够dispatch to the correct function that includes a member pointer in the actual base class that points to the Vtable. 第二, 我们每次调用virtual函数我们都要通过那个table来决定which function to actually map to. 但是基本上区别并不明显, 所以能用就用. 除非你的程序要跑在一个性能真的非常非常差的嵌入式设备上. Interface (Pure virtual method) 在Printable中创建一个GetClassName的赋值为0的函数, 它就是一个接口 这个类也不能被直接实例化, 需要实现此方法的子类才能工作 1234class Printable{public: virtual std::string GetClassName() = 0;} 简单的示例 1234567891011121314151617181920class Player : public Entity, Printable // 子类可以继承多个接口类{public: std::string GetClassName() override { return &quot;Player&quot;; }}void Print(Printable* obj) // 通过这样的函数, 我们只需要实现这个方法, 该函数就会调用我们的实现{ std::cout &lt;&lt; obj-&gt;GetClassName() &lt;&lt; std::endl;}void main(){ Player player = new Player(); Print(player); Print(new Player); // 不要这么用, 会导致内存泄漏} Visibility in C++ The default visibility of a Class would actually be private; if its a Struct then it would be public by default. private标记的内容只有本类能访问, 子类也不行, 但是朋友类(friend class)可以, 会在以后视频中讲到. protected标记是在private基础上, 子类可以访问 Arrays in C++ Raw Arrays 举个例子int example[5] 数组名称 example 是一个指针, 指向 example[0] 的所在地址 请注意, 不能使用超出数组下标的操作(如example[-1] = 0), 那意味着访问不在当前数组许可范围内的内存; 在debug模式下它会报错, 但在release下它可能会造成不可预料的后果 还可以用指针的方式访问数组 123456789101112int example[5];int* ptr = example;for (int i = 0; i&lt; 5; i++) example[i] = 2;example[2] = 5;// equals to *(ptr + 2) = 5;// 因为这个指针是int类型, 所以每次+1都向后偏移4字节的内存地址(对指针进行加减操作是不同于普通的);// 所以也可以写成:// *(int*)((char*)ptr + 8) = 6;// 即先以1 byte的char*进行指针加法操作, 然后再转回int*// It is pretty wild line of code. 更多的, 两种不同的创建数组的方式 12345678int example[5];int* another = new int[5];// 前者是创建在stack上的并且会在函数执行完后被摧毁// 后者是创建在heap上的// 建议在类中使用前者, 在函数中使用后者// We need to delete using the square bracketsdelete[] another; 在C++中你无法动态地检查一个普通数组的大小 12345int* another = new int[5];int count = sizeof(another) / sizeof(int);// 使用这样的方式是不靠谱的// 由于another是个指针, 所以最终 count 的结果是1, 这显然不对 一个比较好的办法是管理一些记录数组大小的常量 12static const int exampleSize = 5;int example[size]; C++11 Standard Arrays 好处是能很方便地检查一个数组的大小 12345678#include &lt;array&gt;int main(){ std::array&lt;int, 5&gt; another; for (int i = 0; i &lt; another.size(); i++) eanother[i] = 2;} 两者区别是Standard Arrays 相比 Raw Array s有更多性能的开销(但是值得), 且更安全 @TheCherno 更喜欢用Raw Arrays, Because he like to live dangerously :) How Strings Work in C++ (and how to use them) C风格字符串 1const char* name = &quot;Cherno&quot;; 字符串分配的内存是fixed allocated block, 这表示想要扩充只能通过分配全新的字符串(新的地址)并删除旧的字符串来实现 同时由于这是个char指针所以这个字符串不能用delete(后面会细讲new和delete, rule of thumb is just if you don’t use ‘new’ keyword dont’t use the ‘delete’ keyword) 细节的东西 null termination character: 每个字符串末尾都会有一个null结束符0(int类型, 等价于’\\0’这个char类型) 比如 char name[7] = {'C', 'h', 'e', 'r', 'n', 'o', '\\0'}; 如果没有结束符, 那么当使用cout输出字符串时, 它会一直输出接下来的内存数据直到读到’\\0’. (表现为输出&quot;Cherno&quot;然后跟着一串乱码) 注意: Double quote “” by default it becomes a char pointer; 翻译: “Cherno” 默认表示为类型为 char* 的数据. 为什么是 const char* ? 因为字符串本质是char数组, 而数组变量本质上储存的也就是这个数组的起始地址, 所以用 const char* 没毛病, cout对const char*有特殊对待不不断地读下去直到碰到前文所说的null termination character 同时, 从Memory View看到的十六进制 cc 大概率表示we are right outside of the bounds of our allocation. C++ 标准字符串 本质上是char array 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt; // cout没有输出string类型的overload, 如果不输出可以不用includeint main(){ std::string name = &quot;Cherno&quot; + &quot; hello!&quot;; //这种方式是不对的, 因为&quot;Cherno&quot;是一个 const char* 类型 std::string name = &quot;Cherno&quot;; name += &quot; hello!&quot;; // 这种是对的, a nice easy way, because you are adding it to a string, and &quot;+=&quot; is overloaded in the string class to be able to let you do that. // 或者这样(虽然会有更多的对象拷贝操作, 大多数情况下性能影响不大) std::string name = std::string(&quot;Cherno&quot;) + &quot; hello!&quot;; std::cout &lt;&lt; name &lt;&lt; std::endl;} 简单的使用: 123456789// 判断字符串是否包含指定文字bool const contains = name.find(&quot;no&quot;) != std::string::npos // std::string::npos 代表没有找到返回的值// 因为字符串操作在c++中很普遍, 而每次都进行不必要的对象复制无疑很低效, 使用const xxx&amp;将对象直接以只读形式传入函数void PrintString(const std::string&amp; string){ string += &quot;h&quot;; std::cout &lt;&lt; string &lt;&lt; std::endl;} String literals Terminal character will actuall break the behavior of this string in many cases 1234567#include &lt;stdlib.h&gt;int main(){ const char name[8] = &quot;Che\\0rno&quot;; std::cout &lt;&lt; strlen(name) &lt;&lt; std::endl;} String literals are stored in read-only section of memory This code might not vaild for all CPP compilers. And edit this string is actually didn’t work: 12345678910int main(){ char* name = &quot;Cherno&quot;; // 这种定义是错误的, 字符串类型指针应该永远是const char* // 要想运行时修改字符串, 正确操作应是定义一个字符串数组而不是一个指针 // char name[] = &quot;Cherno&quot;; name[2] = 'a'; std::cout &lt;&lt; name &lt;&lt; std::endl;} 其他类型的字符串 1234567int main(){ const char* name = u8&quot;Cherno&quot;; // utf-8, u8前缀非必要 const char16_t* name2 = u&quot;Cherno&quot;; // two bytes per character (utf-16) const char32_t* name3 = U&quot;Cherno&quot;; // four bytes per character (utf-32) const wchar_t* name4 = L&quot;Cherno&quot;; // 由编译器决定, eitger 2 ir 4 bytes, its 2 bytes on Windows and 4 on Linux and I acpect Mac as well} C++14标准 12345678910111213int main(){ using namespace std::string_literals; std::string name0 = &quot;Cherno&quot;s + &quot; hello&quot;; std::wstring name1 = L&quot;Cherno&quot;s + L&quot; hello&quot;; std::u32string name1 = U&quot;Cherno&quot;s + U&quot; hello&quot;; // raw形式赋值, 对拷贝大篇文章时保留文章格式有用 const char* rawstring = R&quot;(Line1Line2Line3Line4)&quot;;} const in C++ const pointer 在前, you cannot change the data at that memory address 在后, you cannot reassign the actual pointer itself to point something else 1234567891011121314const inst MAX_AGE = 90;// 1. Pointer to const valueconst int* a = new int;*a = 2; // I cannot change the contents of the pointera = (int*) &amp;MAX_AGE; // But I can change the pointer itself// 2. Const pointersint* const b = new int;*b = 2;b = (int*) &amp;MAX_AGE; // but you cannot change the pointer whose value// 3. Const pointer to a const valueconst int* const c = (int*) &amp;MAX_AGE; 注意: const int* 和 int const* 是相等的, 你需要将const 放在 * 号后面 const method const 修饰的方法无法改变类中的变量 Only avaliable in class method 涉及内容: 当const方法返回指针类型时怎么做: 方法数据类型应为 “const int* const” 以 const Object&amp; 实例化的对象只能访问const方法 mutable 变量 1234567891011121314151617181920212223242526272829303132333435class Entity{private: int m_X, *m_Y, *m_Z; // 定义多个变量时指针类型要为每个单独加 '*' 号 mutable int var;public: int GetX() const { // m_X = 2; 你不能修改变量的值 var = 233; // 但我们可以在const方法中修改mutable修饰的变量 return m_X; } const int* const GetY() const // 若const方法要返回指针类型变量, 方法数据类型应为 &quot;const int* const&quot; { return m_Y; } void SetX() { m_X = 2; }}void PrintEntity (const Eneity&amp; e){ // std::cout &lt;&lt; e.SetX() &lt;&lt; endl; 常量型对象无法访问无const修饰的方法 std::cout &lt;&lt; e.GetX() &lt;&lt; endl;}int main(){ Entity e = new Entity(); PrintEneity(e);} Mutable Keyword in C++ mutalbe有两种用法, 第一种用于常量方法中, 见#const method, 第二种用于lambda, 用的不多 123456789int x = 8;auto f = [=]() mutable{ x++; std::cout &lt;&lt; x &lt;&lt; std::endl;}f();// x is still = 8, 因为[=]模式 is just copy this value into this lambda, mutable代表它能更改传递进来的值并且不让编译器报错, 但实际上8本身是个常数所以没有效果. 什么是lambda: a lambda is basically like a little throwaway function that you can write and assign to a variable quickly. Memory Initializer Lists in C++ (Constructor Initializer List) 使用构造初始化列表可以避免使用 “=” 从而实列化两次对象 12345678910111213141516171819202122232425262728293031class Example{public: Example() { std::cout &lt;&lt; &quot;Created Entity!&quot; &lt;&lt; std::endl; } Example(int x) { std::cout &lt;&lt; &quot;Create Entity with &quot; &lt;&lt; x &lt;&lt; &quot;!&quot; &lt;&lt; std::endl; }}class Entity{private: Example m_example; int x, y, z;public: Entity() : m_example(Example(8)), x(0), y(0), z(0) // m_example(Example(8)) 或者m_example(8)都行 { // m_Example = Example(8); 如果在构造函数中实列化内部变量, 该对象会实例化两次 }}int main(){ Entity e0;} Ternary Operators in C++ (Conditional Assignment) 使用三目运算符可以简化if_else语句 12345678910111213141516171819202122232425262728#include &lt;string&gt;static int s_Level = 1;static int s_Speed = 2;int main(){ s_Speed = s_Level &gt; 5 &amp;&amp; s_Level &lt; 100 ? s_Level &gt; 10 ? 15 : 10 : 5; std::cout &lt;&lt; s_Speed &lt;&lt; std::endl; // 以上式子等价于 // if (s_Level &gt; 5 &amp;&amp; s_Level &lt; 100) // { // if(s_Level &gt; 10) // { // s_Speed = 15; // } // else // { // s_Speed = 10; // } // } // else // { // s_Speed = 5; // }} How to CREATE/INSTANTIATE OBJECTS in C++ There are two main section of memory: the stack and heap Stack objects have an automatic lifespan, there lifetime is actually controlled by the scope their declared Heap: once you allocated an object in that heap, it’s gonna sit there unill you explicit delete it 栈空间一般只有1M到几M(取决于平台), 如果你需要创建一个巨大的对象, 你将不得不将他创建在堆内存上 不使用 new 关键字, 对象创建在栈空间上 123Entity entity(&quot;Cherno&quot;);// 或者Entity entity = Entity(&quot;Cherno&quot;); 使用 new 关键字, 对象创建在堆空间上 1234// new 返回的是创建对象的内存地址, 所以用 Entity*Entity* entity = new Entity(&quot;Cherno&quot;);// 你需要手动删除 new 创建的对象来释放内存delete entity; 所以用 new 创建对象很容易导致内存泄漏, 之后会讲的 智能指针 可用很好地解决这个问题 The NEW Keyword in C++ 更多new的细节 How the new keyword find free space on memory? There is something called free list which actually maintain the addresses that have bytes free. It’s obvously written in intelligent but its stll quite slow. 几点事实: new is just an operator, means that you can overload new and change its bahavious Usually calling new will call the underlying C Function malloc() delete also calls the destructor 三种 new 的不同使用方法(normal new, array new, placement new) 12345678910111213141516171819202122232425int main(){ // If we wanted an array of entries (An array which is stored 50 Objects of Entity) Entity* entity = new Entity(); delete entity; // Remember delete object // If using new with square bracket &quot;[&quot; and &quot;]&quot; // The new operator is actually a slightly differ function than normal Entity* entity2 = new Entity()[50]; // Also we need calling delete with square bracket delete[] eneity2; // Placement New is where you actually get to decide kind of where the memory comes from. // You don't really allocating memory wieh new, // you're just calling the constructor and initializing you Object in a specific memory address int* buffer = new int[50]; Entity* entity3 = new(buffer) Entity(); delete entity3; delete[] buffer; // in C there are some kinds of equivalent: // Entity* entity = (Entity*) malloc(sizeof(Entity)); // malloc() will not call the constructor so you need to call it in manual // So it's better don't use this in C++} Implicit Conversion and the Explicit Keyword in C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Entity{private: std::string m_Name; int m_Age;public: Entity(const std::string&amp; name) : m_Name(name), m_Age(-1) P{} // Use explicit keyword to disable implicit conversion explicit Entity(int age) : m_Name(&quot;Unknown&quot;), m_Age(age) {}};void PrintEntity(const Entity&amp; entity){ // Printing Statements}int main(){ // It's weird , you can't do this in other languages(such as C# or Java) // This is called implicit conversion // It implicit converting &quot;Cherno&quot; into Entity's Constructor Method: Entity(const std::string&amp; name) Entity a = std::string(&quot;Cherno&quot;); // 虽然上面是个很好的隐式转换的例子, 但是不建议用这种语法实例化对象 // You cannot do implicit conversion with explicit method anymore // This is not allowed Entity b = 22; // Correct sentence: Entity b = Entity(22); // This is not allowed Entity a = &quot;Cherno&quot;; // and PrintEntity(&quot;Cherno&quot;); // &quot;Cherno&quot; is a const char array // C++ need to do two conversions, one from const char* to std::string, and then call into Entity(const std::string&amp; name) // It's only allowed to do one implicit conversion at same time // Correct sentence: PrintEntity(std::string(&quot;Cherno&quot;); // or as normal: PrintEntity(Entity(&quot;Cherno&quot;));} OPERATORS and OPERATOR OVERLOADING in C++ In the case of operator overloading you’re allowed to define or change the behavior of operator Operators are just functions Here goes some examples: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct Vector2{ float x, y; Vector2(float x, float y) : x(x), y(y) {} // overload the function &quot;operator+()&quot; equals redefine the behavior of operator plus in this Object Vector2 operator+(const Vector2&amp; other) const { return Vector2(x + other.x, y + other.y); } // As same with above Vector2 operator*(const Vector2&amp; other) const { return Vector2(x * other.x, y * other.y); } // As same with above bool operator==(const Vector2&amp; other) const { return x == other.x &amp;&amp; y == other.y; } bool operator!=(const Vector2&amp; other) const { // We have a simple way return !operator==(other); // Or // return !(*this == other); }};// See the use case in main()std::ostream&amp; operator&lt;&lt;(std::string&amp; stream, const Vector2&amp; other){ stream &lt;&lt; other.x &lt;&lt; &quot;, &quot; &lt;&lt; other.y; return stream;}int main(){ Vector2 position(4.0f, 4.0f); Vector2 speed(0.5f, 1.5f); Vector2 powerup(1.1f, 1.1f); Vector2 result1 = position + speed * powerup; // We cannot output the variables in vector directly // We need overload the function &quot;operator&lt;&lt;&quot; std::cout &lt;&lt; result1 &lt;&lt; std::endl; // In programs such like Java we have to use equals() to compare objects // but in C++ we can simply overload the &quot;operator==&quot; if(retult1 == position) std::cout&lt;&lt; &quot;foo&quot; &lt;&lt; std::endl;} Ths “this” keyword in C++ this是一个指向当前方法所在对象的指针 避免形参名字和对象成员变量的名字一样所造成的歧义 12345678910class Entity{public: int x, y; Entity(int x, int y) { // 这里只是示范, 实际有更方便的构造参数列表来赋值 this-&gt;x = x; // or (*this).x = x; }} Object Lifetime in C++ (Stack/Scope Lifetimes) 下面的例子讲了三件事: 编写函数时不要返回在stack内存空间创建的对象 使用 {} 创建局部scope以使stack上的对象更早地被自动清理 Unique Pointer的基本原理展示 1234567891011121314151617181920212223242526272829303132333435int* CreateArray(){ // Don't write code like this // The array gets cleared as soon as we go out of scope int array[50]; return array;}class ScopedPtr{private: Entity* m_Ptr;public: ScopedPtr(Entity* ptr) : m_Ptr(ptr) {} ~ScopedPtr() { delete m_Ptr; // delete Entity when ScopedPtr get deleted }}int main(){ // scope with brace { Entity e; // the object created on stack will gets free when out of the scope // We could use something in the standard library called unique pointer which is a scoped pointer // but here we write our own to explain how it works ScopedPtr e = new Entity(); // It's implicit conversion // because the scoped pointer object gets allocated on the stack which means it will gets deleted when out of the scope and call ~ScopedPtr() // then corresponding the Entity will gets deleted }} SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr) Smart pointers mean that when you call new , you don’t have to call delete In face in many cases with smart pointers we don’t even have to call new This episode introduce: unique pointer shared pointer &amp; weak pointer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;class Entity(){public: Entity() { std::cout &lt;&lt; &quot;Created Entity!&quot; &lt;&lt; std::endl; } ~Entity() { std::cout &lt;&lt; &quot;Destoryed Entity~&quot; &lt;&lt; std::endl; } void Print() {}}int main(){ { // All smart pointer are marked as explicit std::unique_ptr&lt;Entity&gt; uniqueEntity(new Entity()); // The preferred way through to construct this would be to assign it to std::make_unique&lt;Entity&gt; // The primary that is important for unique pointers is due to exception safety std::unique_ptr&lt;Entity&gt; uniqueEntity = std::make_unique&lt;Entity&gt;(); // You can access it like you would normally uniqueEntity-&gt;Print(); // Tou cannot copy unique pointer, you will get a compile error std::unique_ptr&lt;Entity&gt; e0 = entity; // If you go to definition of unique pointer you'll see that the copy constructor // and copy assignment operator are deleted; // shared pointer is use something called reference counting // You create one shread pointer and you define another shared pointer and copy the // previous one, the reference count is now 2, // when the first one dies(out of scope), the reference count goes down 1 // and when the last one dies. the reference count goes back to zero, // and free the memory. // BTW, for shared pointer using make_shared is very recommand because its more efficient // There is something else that you can use with shared pointer is called weak pointer // weak pointer will not increase the reference count std::weak_ptr&lt;Entity&gt; weakEntity; { std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;(); weakEntity = sharedEntity2; } // The sharedEntity will still be free immediately here. } } Copying and Copy Constructors in C++ Ues “=”(called Shallow Copy) to copy an object created on heap(with new) which is without a Copy Constuctors or an object created on stack but with private pointer variables(objects created on heap) will lead to unexpected results. It’s essentially just copy the address data in pointer variable So you need a Copy Constructor which delimit the behavior of the copy operation. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class String{private: char* m_Buffer; unsigned int m_Size;public: String(const char* string) { m_Size = strlen(string); m_Buffer = new char[m_Size + 1]; // +1 for last null termination char // You can also use strcpy() memcpy(m_Buffer, string, m_Size + 1); } // Copy Consturcor String(const String&amp; other) : m_Size(other.m_Size) { m_Buffer = new char[m_Size + 1]; // Or if you want to be more exciting, you can use this instead // memcpy(this, &amp;other, sizeof(String)); } // Or you can just prevent this object to do copy operation //String(const String&amp; other) = delete; ~String() { delete[] m_Buffer; } char&amp; operator[](unsigned int index) { return m_Buffer[index]; } // make &lt;&lt;() to be a fried so it can access private variables in this object friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const String&amp; string);};std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const String&amp; string){ stream &lt;&lt; string.m_Buffer; return stream;}int main(){ String first_String = &quot;Cherno&quot;; String second_string = first_string; second_string[2] = 'a'; std::cout &lt;&lt; first_String &lt;&lt; endl; std::cout &lt;&lt; first_String &lt;&lt; endl;} The Arrow Operator in C++ Normal usage12345int main(){ Entity* entity = new Entity(); entity-&gt;x = 2; // = (*entity).x = 2;} It is actually possible to overload the Arror Operator and use it in specific class such as ScopedPtr (For more see previous chapter: SMART POINTERS in C++).12345678910111213141516171819202122232425262728293031class Entity{public: void Print() const { std::cout &lt;&lt; &quot;Hello!&quot; &lt;&lt; std::endl; }};class ScopedPtr{private: Entity* m_Obj;public: ScopedPtr(Entity* entity) : m_Obj(entity) {} ~ScopedPtr() { delete m_Obj; } Entity* operator-&gt;() { return m_Obj; }};int main(){ ScopedPtr entity = new Entity(); // Do you still remember the Implicit Conversion? entity-&gt;Print();} It can also be used to get the variable’s memory offset in an Object (In some memory hack :)123456789101112struct Vector3{ // I deliberately desrupt the naming order to make it in a different memory layout. float z, y, x;};int main(){ // Get the offset of that 'x' int offset = (int) &amp;((Vector3*)0)-&gt;x; // Or &amp;((Vector3*)nullptr)-&gt;x; std::cout &lt;&lt; offset &lt;&lt; std::endl;} Dynamic Arrays in C++ (std::vector) Vector in C++ is not mathematical vector, it’s kind of like Dynamic Arrays 1234567891011121314151617181920212223242526272829303132333435struct Vertex{ float x, y, z;};std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Vertex&amp; vertex){ stream &lt;&lt; vertex.x &lt;&lt; &quot;, &quot; &lt;&lt; vertex.y &lt;&lt; &quot;, &quot; &lt;&lt; vertex.z; return stream;}int main(){ // the '&lt;Object&gt;' is called template, will show in later chapter // For now, we only need to know this definite the type which the Dynamic Arrarys stores std::vector&lt;Vertex&gt; vertices; // It is hard to decide whether you should be using like vertex pointers // or just vertex object in this case // Which is object stored in line or fragmented in memory // Add object to the end of Dynamic Array vertices.push_back({ 1, 2, 3 }); // Note: Implicit conversion vertices.push_back({ 4, 5, 6 }); // Using range based 'for loop' to iterate the object in Dynamic Array for (const Vertex&amp; v : vertices) std::cout &lt;&lt; v &lt;&lt; sed::endl; // We can remove object in dynamic array individually // This remove the second object in dynamic array vertices.erase(vertices.begin() + 1); // Or we can clean the whole dynamic array vertices.clear();} Optimizing the usage of std::vector in C++ Two ways to reduce memory copy 12345678910111213141516171819202122232425262728293031323334353637383940414243struct Vertex{ float x, y, z; Vertex(float x, float y, float z) : x(x), y(y), z(z) { } // Copy Constructor, used to capture copied times Vertex(const Vertex&amp; v) : x(v.x), y(v.y), z(v.z) { // Output to console to see how many times copied std::cout &lt;&lt; &quot;Copied!&quot; &lt;&lt; std::endl; }};int main(){ std::vector&lt;Vertex&gt; vertices_bad; vertices_bad.push_back(Vertex(1, 2, 3)); // Make it easier to read than previous chapter vertices_bad.push_back(Vertex(4, 5, 6)); vertices_bad.push_back(Vertex(7, 8, 9)); vertices_bad.push_back(Vertex(10, 11, 12)); // Each pass parameter operation in push_back() will cause 1 copy operation // And **each push_back() called will cause memory rearrange**, // which are copy previous objects in dynamic array into new memory area. // So total copied times: 1 + (1 + 1) + (1 + 2) + (1 + 3) = 10 std::cout &lt;&lt; &quot;vertices good&quot; &lt;&lt; std::endl; std::vector&lt;Vertex&gt; vertices_good; // Below is the optimized implementation // 1. Use reserver() to prevent memory rearrange. vertices_good.reserve(4); // 2. Replace push_back() with emplace_back() to prevent parameter copy // it acts as a proxy to process you provided parameter into Constructor. vertices_good.emplace_back(1, 2, 3); vertices_good.emplace_back(4, 5, 6); vertices_good.emplace_back(7, 8, 9); vertices_good.emplace_back(10, 11, 12);} Using Libraries in C++ Preposition work: Visual Studio Setup Using GLFW as example: Create a folder called “Dependencies” under your project directory and then put your libraries into it.C:\\Users\\USERNAME\\source\\repos\\Your_Project_Directory\\12345678910Dependencies\\-&gt; GLFW\\ -&gt; include\\ -&gt; GLFW\\ glfw3.h ... -&gt; lib-vc2015\\ glfw3.dll glfw3.lib glfw3.dll.lib Open your project settings: -&gt; Configuration: All Configuration -&gt; C/C++ -&gt; Additional Include Directories: $(SolutionDir)\\Dependencies\\GLFW\\include -&gt; Linker -&gt; General -&gt; Additional Library Directories: $(SolutionDir)\\Dependencies\\GLFW\\lib-vc2015 Static linking Static linking happens at compile time, the lib intergrate into executable or a dynamic library Open your project setting -&gt; Linker -&gt; Input -&gt; Additional Dependencies: glfw3.lib;xxxxxx;balabala;... Static LinkMain.cpp123456789// quote for header in this project, regular bracket for external library#include &lt;GLFW/glfw3.h&gt;\\\\ Or `extern &quot;C&quot; int glfwInit();`\\\\ Because GLFW is actually a C library so we need `extern &quot;C&quot;`int main(){ int result = glfwInit(); std::cout &lt;&lt; result &lt;&lt; std::endl;} Dynamic linking Dynamic linking happens at runtime Some librarys like GLFW supports both static and dynamic linking in a single header file glfw3.dll.lib is basically a series of pointers into glwfw3.dll Code is basically as same as the Static linking above Open your project settings: -&gt; Linker -&gt; Input -&gt; Additional Dependencies: glfw3.dll.lib;xxxxxx;balabala;... put your dll file(glfw3.dll) to the same folder as your executable file(i.e: $(SolutionDir)\\Debug) In fact, to call a function in dynamic library, it needs a prefix called __declspec(dllimport) If you explore glfw3.h you will see there is a GLFWAPI prefix in every function definition, 123#elif defined(_WIN32) &amp;&amp; defined(GLFW_DLL)/* We are calling GLFW as a Win32 DLL */ #define GLFWAPI __declspec(dllimport) So you need to define a Macro in VS: Open your project setting: -&gt; C/C++ -&gt; Preprocessor -&gt; Preprocessor Definitions: GLFW_DLL;xxxxx;bababa... But why it seems stll work properly without the dllimport prefix? In modern windows, dllimport is not needed for functions, but dllimport is still needed for C++ classes and global variables. Making and Working with Libraries in C++ (Multiple Projects in Visual Studio) Visual Studio Setup: Create one solution with 2 projects “Game” and “Engine”, Project “Game”: -&gt; Ceneral-&gt;Project Defaults-&gt;Configuration Type: Application (.exe) -&gt; C/C++ -&gt; General -&gt; Additional include Directories: $(SolutionDir)\\Engine\\src; Project “Engine”: Ceneral-&gt;Project Defaults-&gt;Configuration Type: Static library (.lib) Right click on projects “Game” -&gt; Add -&gt; Reference -&gt; Select project “Enginx” Code for project “Engine”:Your_Project_Directory\\src\\Engine.h12345#pragma oncenamespace engine { void PrintMessage();} Your_Project_Directory\\src\\Engine.cpp12345678910#include &quot;Engine.h&quot;#include &lt;iostream&gt;namespace engine { void PrintMessage() { std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl; }} Code for project “Game”:Your_Project_Directory\\src\\Application.cpp123456#include &quot;Engine.h&quot;int main(){ engine::PrintMessage();} How to Deal with Multiple Return Values in C++ Example scenario: we have a function called ParseShader() , it needs to return two strings Return a struct cotains two strings (Cherno’s choose):123456789101112struct ShaderProgramSource{ std::string VertexSource; std::string FragmentSource;}ShaderProgramSource ParseShader(){ // Some statements that process result 'vs' and 'fs' // ... return { vs, fs };} Using reference paremeter (Probably one of the most optimal way)1234567891011121314151617181920212223242526void ParseShader(std::string&amp; outVertexSource, std::string&amp; outFragmentSource){ // Some statements that process result 'vs' and 'fs' // ... outVertexSource = vs; outFragmentSource = fs;}main(){ std::string vertexSource, fragmentSource; ParseShader(vertexSource, fragmentSource)}// Or using Pointer parameter if you want to pass nullptr(ignore the output):// void ParseShader(std::string* outVertexSource, std::string* outFragmentSource)// {// if (outVertexSource)// *outVertexSource = vs;// if (outFragmentSource)// *outFragmentSource = fs;// }// main()// {// ParseShader(nullptr, &amp;fragmentSource)// } Return a std::array or std::vector(ignored, too simple) The different is primarly the arrays can be create on the stack where as vectors gonna store its underlying storage on the heap. So technically returning a standard array would be faster.1234567891011#include &lt;array&gt;std::array&lt;std::string, 2&gt; ParseShader(){ // Some statements that process result 'vs' and 'fs' // ... std::array&lt;std::string, 2&gt; result; result[0] = vs; result[1] = fs; return result;} Using std::tuple and std::pair std:tuple (Can return more than two elements)12345678910111213141516171819202122#include &lt;tuple&gt;std::tuple&lt;std::string, int&gt; CreatePerson(){ return { &quot;Cherno&quot;, 24 }; // Implicit conversation // Or use &quot;std::make_pair()&quot;: // return std::make_pair(&quot;Cherno&quot;, 24);}int main(){ // 'auto' means automatically check the return type auto person = CreatePerson(); // Get values in std::tuple std::string&amp; name = std::get&lt;0&gt;(person); int age = std::get&lt;1&gt;(person); // Or using std::tie() std::string name2; int age2; std::tie(name2, age2) = person;} std::pair (A little bit faster than tuple)123456789101112// Show the only difference with 'std::tuple'std::pair&lt;std::string, std::string&gt; ParseShader(){ // ...}int main(){ // ... vertexSource = sources.first; vertexSource = sources.second;} Templates in C++ Template can improve code reuse rate and reduce duplicate code (for example function overload) The essence of template is similar to macros This chapter includes: template type template argument 12345678910111213141516171819// In this case, template specifying how to create methods based on your usage of them.(Automatically generate corresponding overloaded function)// So if nobody call this function, it's code will not exist in compiled file,// even if there is a grammatical error in this function code, it will still compile successfully.template&lt;typename T&gt;// exactly same with: &quot;template&lt;class T&gt;&quot;void Print(T value){ std::cout &lt;&lt; value &lt;&lt; std::endl;}int main(){ Print(5); // I actually specifying the type explicitly // The complete code should be: // Print&lt;int&gt;(5); Print(&quot;Hello&quot;); Print(5.5f);} 1234567891011121314151617181920212223// Yes, multiple template targets can be in one template definitiontemplate&lt;typename T, int N&gt;class Array{private: T m_Arry[N];public: int GetSize() const { return N; }};int main(){ Array&lt;int, 5&gt; array; // Which means its will generate the following code: // class Array // { // private: // int m_Arry[5]; // public: // int GetSize() const { return 5; } // }; std::cout &lt;&lt; array.GetSize() &lt;&lt; std::endl;} Stack vs Heap Memory in C++ Ignore… Macros in C++ Macros do text replace when preprocessor123456#define WAIT std::cin.get()int main(){ WAIT;} Macros function and combine with the environment Environment variables can be defined at: Open your project settings: C/C++ -&gt; Preprocessor -&gt; Preprocessor Definitions12345678910#ifdef PR_DEBUG#define LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl#elif defined(PR_RELEASE)#define LOG(x) // Do nothing#endifint main(){ LOG(&quot;Hello&quot;);} The “auto” keyword in C++ be careful with auto 12345678910111213std::string GetName(){ return &quot;Cherno&quot;;}int main(){ auto name = GetName(); // Call a type specific method // if the return type of GetName() changed to &quot;char*&quot; , this will be broken int a = name.size(); std::cout &lt;&lt; a &lt;&lt; std::endl;} auto’ to reduce type length12345678910111213141516171819202122class DeviceManager{private: std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt; m_Devices;public: const std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;&amp; GetDevices() const { return m_Devices; }}int main(){ DeviceManager dm; // The type is too mass const std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;&amp; devices = dm.GetDevices(); // You can use keyword &quot;using&quot; or &quot;typedef&quot; using DeviceMap = std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;; const DeviceMap&amp; devices2 = dm.GetDevices(); // Or auto const auto&amp; devices3 = dm.GetDevices();} Static Arrays in C++ (std::array) Ignore… Function Pointers in C++ 3 ways to definite a Function Pointers123456789101112131415161718void HelloWorld(int a){ std::cout &lt;&lt; &quot;Hello World! Value: &quot; &lt;&lt; a &lt;&lt; std::endl;}int main(){ auto function = HelloWorld(); // second way: // void(*function)(int) = HelloWorld(); // third way: // typedef void(*Balabala)(int); // Balabala function = HelloWorld; function(233);} A simple usage - the ForEach function:123456789101112131415161718void PrintValue(int value){ std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl;}void ForEach(const std::vector&lt;int&gt;&amp; values, void(*func)(int)){ for(int value : values) func(value);}int main(){ std::vector&lt;int&gt; values = { 1, 5, 4, 2, 3 }; ForEach(values, PrintValue); // We can use lambda to simply the function PrintValue() (see more in next episode) // ForEach(values, [](int value) { std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; })} Lambdas in C++ How to put outside variables into lambda function [=] : Pass everything in by value, the pass in variables is independent of the outside. [&amp;] : Pass everything in by reference. [a] : Pass ‘a’ by value [&amp;a] : Pass ‘a’ by reference. using mutable keyword to allow modify outside variables 12345int main(){ int a = 5; auto lambda = [=]() mutable { a = 5; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; a &lt;&lt; std::endl; };} We need to use std::function instand of raw function pointer if our callback lambda function have pass in variables.123456789101112131415161718#include&lt;functional&gt;// Here is the only difference (Use &quot;const &amp;&quot; because its an object)// &quot;void(*func)(int)&quot; to &quot;const std::function&lt;void(int)&gt;&amp; func&quot;void ForEach(const std::vector&lt;int&gt;* values, const std::function&lt;void(int)&gt;&amp; func){ // ...}int main(){ // ... int a = 5; auto lambda = [=](int value)) {std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; a &lt;&lt; std::endl; ForEach(values, lambda};} Usage of std::find_if (Returns an iterator to the first element for which callback function returns true)123std::vector&lt;int&gt; values = { 1, 5, 4, 2, 3 };auto iterator = std::find_if(values.begin(), values.end(), [](int value) { return value &gt; 3;});std::cout &lt;&lt; *iterator &lt;&lt; std::endl; Why I don’t “using namespace std” Don’t absolutely use using namespace in header files But if you must using using namespace, please use it in a small scope as possible, but NEVER EVER in a header file. For example a serious issue of implicit conversion : 123456789101112131415161718192021222324252627namespace apple{ void print(cout std::string&amp; text) { std::cout &lt;&lt; text &lt;&lt; std::endl; }}namespace orange{ void print(const char* text) { std::string temp = text; std::reverse(temp.begin(), temp.end()); std::cout &lt;&lt; temp &lt;&lt; std::endl; }}using namespace apple;using namespace orange;int main(){ print(&quot;Hello&quot;); // Which one will get called? // Answer: the orange::print() will be called, because the type of &quot;Hello&quot; is &quot;char*&quot;} Namespaces in C++ Use Namespace to avoid naming conflict: apple::print(), orange::print() avoid C library like naming: GLFW_initialize to GLFW::initialize Usage: We can set to use only specific symbol in a namespace12345678910111213141516171819namespcae apple { void print(const char* text) { //... } void print_again() { ///... }}int main(){ using apple::print; print(&quot;Hello&quot;); //We still need &quot;apple::&quot; to call print_again() apple::print_again();} Nested Namespaces can be shorten using Alias123456789101112131415namespace apple { // Or apple::functions (c++17) namespace functions { void print(const char* test) { // ... } }}int main(){ namespace a = apple::functions; a::print(&quot;Hello&quot;);} Threads in C++ If we want to do something else when we called functions that will block the current thread, we can use threads. Here is an example: We created a thread that will do loop on outputting “Working…”, and simultaneously the main() function is waiting for user input. 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;thread&gt;static bool is_Finished = false;void DoWork(){ using namespace std::literals::chrono_literals; // Or use &quot;sleep_for(std::chrono::seconds(1))&quot; below std::cout &lt;&lt; &quot;Started thread id=&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; while (!is_Finished) { std::cout &lt;&lt; &quot;Working...\\n&quot;; std::this_thread::sleep_for(1s); }}int main(){ // As soon as we create instance, it's going to immediately kick off that thread std::thread worker(DoWork); std::cin.get(); is_Finished = true; // Call main thread to wait this thread (block main thread) worker.join(); std::cout &lt;&lt; &quot;Finished.&quot; &lt;&lt; std::endl;} Timing in C++ Make a Timer for statistical time-consuming 123456789101112131415161718192021222324252627282930313233struct Timer{ std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end; std::chrono::duration&lt;float&gt; duration; Timer() { start = std::chrono::high_resolution_clock::now(); } ~Timer() { end = std::chrono::high_resolution_clock::now(); duration = end - start; float ms = duration.count() * 1000.0f; std::&lt;&lt; &quot;Timer took &quot; &lt;&lt; ms &lt;&lt; &quot;ms &quot; &lt;&lt; std::endl; }}void Function(){ // The timer will be auto delete when run out of the scope Timer timer; for (int i = 0; i &lt; 100; i++) std::cout &lt;&lt; &quot;Hello\\n&quot;; // std::endl is quiet slow} int main(){ Function();} Multidimensional Arrays in C++ 12345678910111213141516171819202122232425262728293031323334int main(){ // Allocate a 2D array to store twenty integer pointers int** a2d = new int*[20]; // We can set each of these pointers to point to an array for (int i = 0; i &lt; 20; i++) a2d[i] = new int[50]; // 3D array, you can imagine a cube with size of 20x30x40 int*** a3d = new int**[20]; for (int i = 0 i &lt; 20; i++) { a3d[i] = new int*[30]; for (int j = 0; j &lt; 20; j++) { a3d[i][j] = new int[40]: } } a3d[0][0][0] = 666; // When you want to delete this array, you have to go through inner array and delete all of those arrays from inside to out for(int i = 0; i &lt; 20; i++) { for (int j = 0; j &lt; 30; j++) { delete[] a3d[i][j]; } delete[] a3d[i]; } delete[] a3d;} The most issue is that the Multidimensional Arrays will results memory fragmentation. When iterating the array we have to jump to another location to read or write that data, and that’s results probably a cache miss which means that we’re wasting time fetching data from our actual RAM. One of the most important things you can do is just store them in a single dimensional array: 1234567891011int main(){ int* array =new int[5 * 5]; for (int x = 0; x &lt; 5; y++) { for (int y = 0; y &lt; 5; x++) { array[x * 5 + y] = 2; } }} Sorting in C++ 12345678910111213141516171819202122232425262728293031323334#include &lt;algorithm&gt;int main(){ std::vector&lt;int&gt; values = { 3, 5, 1, 4, 2 }; std::sort(values.begin(), values.end()); // Output the results for (int value : values) std::cout &lt;&lt; value &lt;&lt; std::endl; // We can define how the sorting rule the sort() dose // Such like sorting by big to small std::sort(values.begin(), values.end(), [](int a, int b) { return a &gt; b; }); // Output the results for (int value : values) std::cout &lt;&lt; value &lt;&lt; std::endl; // Or force '1' to the last of array list std::sort(values.begin(), values.end(), [](int a, int b) { // Return true equals do exchange the position of a, b if(a == 1) return false; if(b == 1) return true; return b &lt; a; });} Type Punning in C++ You can Treat an Entity struct as an int array: 12345678910111213141516struct Entity{ int x, y;}int main(){ Entity e = { 5, 8 }; int* position = (int*)&amp;e; std::cout &lt;&lt; position[0] &lt;&lt; &quot;, &quot; &lt;&lt; position[1] &lt;&lt; std::endl; // More crazy usage int y = *(int*)((char*)&amp;e + 4); std::cout &lt;&lt; y &lt;&lt; std::endl;} Unions in C++ Defined member in one Union means same memory location We have Vector2 and Vector2, but there is only one function PrintVector2() can output Vector2, what can we do? 12345678910111213141516171819202122232425262728293031323334353637struct Vector2{ float x, y;};void PrintVector2(const Vector2&amp; vector){ std::cout &lt;&lt; vector.x &lt;&lt; &quot;, &quot; &lt;&lt; vector.y &lt;&lt; std::endl;}struct Vector4{ union { // The benefit of anonymous struct is converting all variables in struct into a single member which is what the Union expects struct { float x, y, z, w; }; struct { // 'zy' will be the same memory as 'x, y', and 'zw' will be the same memory as 'z, w' Vector2 xy, zw; }; };};int main(){ Vector4 vector = { 1.0f, 2.0f, 3.0f, 4.0f }; PrintVector2(vector.xy); PrintVector2(vector.zw); std::cout &lt;&lt; &quot;------------------&quot; &lt;&lt; std::endl; vector.z = 500.0f; PrintVector2(vector.xy); PrintVector2(vector.zw);} Type Punning can do as the same result, but using Union makes it more concise. Virtual Destructors in C++ Virtual Destructors is really important if you are writing a father class, otherwise no one’s going to be able to safely delete the extend class (Because without virtual mark you are just adding a new Destructor instead of overload it) 123456789101112131415161718192021class Base{public: Base() { std::cout &lt;&lt; &quot;Base Constructor\\n&quot;; } virtual ~Base() { std::cout &lt;&lt; &quot;Base Destructor\\n&quot;; }};class Derived : public Base{public: Derived() { std::cout &lt;&lt; &quot;Derived Constructor\\n&quot;; } ~Derived() { std::cout &lt;&lt; &quot;Derived Destructor\\n&quot;; }};int main(){ // Polymorphic kind of type // without `virturl`, the &quot;~Derived()&quot; will not be called Base* poly = new Derived(); delete poly;} Casting in C++ C++ cast not do anything that C-style casts cannot do those casts do make you code more solid and looks better. Static cast (Will do compile time checking) Interpret cast (for Type Punning) Dynamic cast (Will return NULL if casting is failed) Const cast (TODO: Supplement this content) 12345678910111213141516171819202122class Base{public: Base() { } virtual ~Base() { }};class Derived : public Base{ // ...};int main(){ // Static cast double value = 5.5; double s = static_cast&lt;int&gt;(value); Base* base = new Base(); Derived* ac = dynamic_cast&lt;Derived*&gt;(base); if (!ac) { std::cout &lt;&lt; &quot;Converting failed\\n&quot;; }} Conditional and Action Breakpoints in C++ Condition Breakpoints: If I only want the breakpoint to trigger under a certain condition Action Breakpoints: Generally print something to the console when a breakpoint is hit They can prevent recompile and save time For details. please watch the video Safety in modern C++ and how to teach it You should 100% use smart pointers if you are doing serious work Precompiled Headers in C++ Look to 7:07 Dynamic Casting in C++ If we force type casting a Enemy class to Player and access data(funcions, variables) that is unique to player, the program will probablly crash. Dynamic Casting is actually does some validation for us to ensure that cast is valid 12345678910111213141516171819202122232425262728class Entity{};class Player : public Entity{};class Enemy : public Entity{};int main(){ Entity* actuallyPlayer = new Player(); Entity* actuallyEnemy = new Enemy(); // How does it know that actuallyPlayer is actually a Player and not an Enemy? // The way it does that is it stores runtime type information(RTTI) // This does add an overhead but it lets you do things like dynamic casting // Be aware that RTTI can be enabled or disabled Player* p0 = dynamic_cast&lt;Player*&gt;(actuallyPlayer); // Will return null Player* p1 = dynamic_cast&lt;Player*&gt;(actuallyEnemy); // dynamic_cast&lt;xxx*&gt;(xxx); equal to xxx instanceof xxx} BENCHMARKING in C++ (how to measure performance) Always make sure that you profile is actually meaningful in a releases because you’re not gonna be shipping code in debug anyway 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Timer{private: std::chrono::time_point&lt;std::chrono::steady_clock&gt; m_StartTime, m_EndTime;public: Timer() { m_StartTime = std::chrono::high_resolution_clock::now(); } ~Timer() { m_EndTime = std::chrono::high_resolution_clock::now(); auto start = std::chrono::time_point_cast&lt;std::chrono::microseconds&gt;(m_StartTime).time_since_epoch().count(); auto end = std::chrono::time_point_cast&lt;std::chrono::microseconds&gt;(m_EndTime).time_since_epoch().count(); auto duration = end - start; double ms = duration * 0.001; std::cout &lt;&lt; duration &lt;&lt; &quot;us (&quot; &lt;&lt; ms &lt;&lt; &quot;ms)\\n&quot; &lt;&lt; std::endl; }};int main(){ struct Vector2 { float x, y; }; std::cout &lt;&lt; &quot;Make Shared\\n&quot;; { std::array&lt;std::shared_ptr&lt;Vector2&gt;, 1000&gt; sharedPtrs; Timer timer; for (int i = 0; i &lt; sharedPtrs.size(); i++) sharedPtrs[i] = std::make_shared&lt;Vector2&gt;(); } std::cout &lt;&lt; &quot;New Shared\\n&quot;; { std::array&lt;std::shared_ptr&lt;Vector2&gt;, 1000&gt; sharedPtrs; Timer timer; for (int i = 0; i &lt; sharedPtrs.size(); i++) sharedPtrs[i] = std::shared_ptr&lt;Vector2&gt;(new Vector2()); } std::cout &lt;&lt; &quot;Make Unique\\n&quot;; { std::array&lt;std::shared_ptr&lt;Vector2&gt;, 1000&gt; sharedPtrs; Timer timer; for (int i = 0; i &lt; sharedPtrs.size(); i++) sharedPtrs[i] = std::make_shared&lt;Vector2&gt;(); }} STRUCTURED BINDINGS in C++ Only in C++17 and newer a better way compare to How to Deal with Multiple Return Values in C++ 1234567891011std::tuple&lt;std::string, int&gt; CreatePerson(){ return { &quot;Cherno&quot;, 24 };}int main(){ // Structured binding auto[name, age] = CreatePerson(); std::cout &lt;&lt; name;} How to Deal with OPTIONAL Data in C++ Multiple TYPES of Data in a SINGLE VARIABLE in C++? How to store ANY data in C++ How to make C++ run FASTER (with std::async) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;future&gt;std::vector&lt;std::std::future&lt;void&gt;&gt; m_Futures // void is the return type of the function LoadMesh()static std::mutex s_MeshesMutex;// Here we use pointer parameter because reference parameter doesn't work(Cherno not entirely sure why)static void LoadMesh(const std::vector&lt;Ref&lt;Mesh&gt;&gt;* meshes, std::string filepath){ auto mesh = Mesh::Load(filepath); // We need to lock this meshes vector while it been modify // lock the push_back() function std::lock_guard&lt;std::mutex&gt; lock(s_MeshesMutex); meshes-&gt;push_back(mesh);}void EditorLayer::LoadMeshes(){ // Get file context use c++ file stream std::ifstream stream(&quot;src/Models.txt&quot;); std::string line; std::vector&lt;std::string&gt; meshFilepaths; while (std::getLine(stream, line)) meshFilepaths.push_back(line); // m_Meshes is a vector in this class#define ASYNC 1#if ASYNC // Asynchronous for (const auto&amp; file : meshFilepaths) { // std::async() will return std::future and its really important to handle that std::future or its will be destoryed and peform the destructor to make sure the async is actually finished // that basically means it won't be parallel at all m_Futures.push_back(std::async(std::launch::async, LoadMesh, &amp;m_Meshes, file)); }#else // Sequence for (const auto&amp; file : meshFilepaths) { m_Meshes.push_back(Mesh::Load(file)); }#endif} In VS, you can use DEBUG-&gt;Windows-&gt;Parrllel Stacks (Ctrl+Shift+D) to do window parallel debugs How to make your STRINGS FASTER in C++! 1234567```## VISUAL BENCHMARKING in C++ (how to measure performance visually)## SINGLETONS in C++```C++ Small String Optimization in C++ Track MEMORY ALLOCATIONS the Easy Way in C++ 12345678910111213```## lvalues and rvalues in C++In my opinion, any data that is not being attached by a symbol(not being explicitly assigned an address) is an R-value, otherwise it's an L-value.1. L-value reference and R-value reference ```C++ int i = 10; // L-value reference can accept L-value and R-value int&amp; = i; // R-value reference can only accept R-value int&amp;&amp; = 10; const type&amp; is a special rule, realistically what happens is the compiler will probably create like a temporary variable. there are not to kind of avoid creating an L-value but rather to just kind of support both support both L-value and R-values123const int&amp; a = 10;// int temp = 10;// const int&amp; a = temp; Continuous Integration in C++ Static Analysis in C++ Static Analysis is a very important thing that even for an experienced programmer there is still going to be stuff what you miss. It can find logic errors in your code and gives you some tips to fix it clang-tidy is a free tool to do static analysis Argument Evaluation Order in C++ Move Semantics in C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class String{public: String() = default; // equals with String(){} String(const char* string) { printf(&quot;Created!\\n&quot;); m_Size = strlen(string); m_Data = new char[m_Size]; memcpy(m_Data, string, m_Size); } String(const String&amp; other) { printf(&quot;Copied!\\n&quot;); m_Size = other.m_Size; m_Data = new char[m_Size]; memcpy(m_Data, other.m_Data, m_Size); } String(String&amp;&amp; older) noexcept // use noexcept to get rid of compiler warning { printf(&quot;Moved!\\n&quot;); m_Size = older.m_Size; // This immediately presents a problem // because when the old one gets deleted // it's going to delete the m_Data with us m_Data = older.m_Data; // so this is the major thing that we need to do older.m_Size = 0; older.m_Data = nullptr; } ~String() { printf(&quot;Destroyed!\\n&quot;); delete m_Data; } void Print() { for (uint32_t i = 0; i &lt; m_Size; i++) printf(&quot;%c&quot;, m_Data[i]); printf(&quot;\\n&quot;); }private: char* m_Data; uint32_t m_Size;};class Entity{public: Entity(const String&amp; name) : m_Name(name) { } Entity(String&amp;&amp; name) : m_Name(std::move(name)) // equals to m_Name((String&amp;&amp;) name) { } void PrintName() { m_Name.Print(); }private: String m_Name;};int main(){ Entity entity(&quot;Cherno&quot;); entity.PrintName();} std::move and the Move Assignment Operator in C++ std::move actually do force casting but can make your program more search friendly Move Assignment will allow us do move operation on existing objects 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class String{public: String() = default; String(const char* string) { printf(&quot;Created!\\n&quot;); m_Size = strlen(string); m_Data = new char[m_Size]; memcpy(m_Data, string, m_Size); } String(String&amp;&amp; older) noexcept { printf(&quot;Moved!\\n&quot;); m_Size = older.m_Size; m_Data = older.m_Data; older.m_Size = 0; older.m_Data = nullptr; } // define move assignment String&amp; operator=(String&amp;&amp; older) noexcept { if (this != &amp;older) { // Because use move assignment meaning assure there already existing data in currently class // So clean the current class delete[] m_Data; printf(&quot;Moved!\\n&quot;); m_Size = older.m_Size; m_Data = older.m_Data; older.m_Size = 0; older.m_Data = nullptr; } return *this; } ~String() { printf(&quot;Destroyed!\\n&quot;); delete m_Data; } void Print() { for (uint32_t i = 0; i &lt; m_Size; i++) printf(&quot;%c&quot;, m_Data[i]); printf(&quot;\\n&quot;); }private: char* m_Data; uint32_t m_Size;};int main(){ String apple = &quot;Apple&quot;; String dest; std::cout&lt;&lt; &quot;Apple: &quot;; apple.Print(); std::cout&lt;&lt; &quot;Dest: &quot;; dest.Print(); dest = std::move(apple); std::cout&lt;&lt; &quot;Apple: &quot;; apple.Print(); std::cout&lt;&lt; &quot;Dest: &quot;; dest.Print();} ARRAY - Making DATA STRUCTURES in C++","link":"/zh-cn/learn/2020/cpp/"},{"title":"discrete-mathematics","text":"离散数学笔记 非常重要的结论叫定理 普通的结论叫性质 名词解释用需要定义来回答 命题逻辑 中文转折只能用合取来近似地表示 命题: 能判断真假的陈述句(陈述句是命题的必要但不充分条件, 比如&quot;我正在说谎&quot;) 分类: 原子命题和复合命题 原子命题: 不能再分解为更简单的陈述句 复合命题: 由原子命题、联结词和标点符号构成的命题 真值: 命题的判断结果, 真(True, T 或 1), 假(False, F, 或 0) 真值表: 列出命题所有结果的表 联结词: 否定 ┐P &quot;非&quot;运算 P ┐P T F F T 合取 P∧Q &quot;与&quot;运算 P Q P∧Q T T T T F F F T F F F F 析取 P∨Q &quot;或&quot;运算 P Q P∨Q T T T T F T F T T F F F 条件 P→Q (如果前提P为真但此时Q为假说明此条件命题无效, 值为假) P Q P→Q T T T T F F F T T F F T 双条件 P↔Q “当且仅当” 符号iff 可理解为P↔Q=(P→Q)∧(Q→P) P Q P↔Q T T T T F F F T F F F T 联结词的运算优先级: ┐, ∧, ∨, →, ↔ 命题公式(也叫合成公式) 单个命题变元是命题公式 如果 A 是命题公式, 则 ┐A 也是 如果 A, B 是命题公式, 则 A∧B, A∨B, A→B, A↔B 也是 有限次使用上面 1~3 得到的符号串都是命题公式 翻译: 汉语陈述 \\(\\rightleftharpoons\\) 命题公式 方法1: 直接根据逻辑含义 方法2: 真值表法 永真式(重言式): 给定一个命题, 无论对变元做怎样的指派, 其真值总为真 永假式(矛盾式): 给定一个命题, 无论对变元做怎样的指派, 其真值总为假 可满足: 给定一个命题, 其真值有为真的情况 等价: \\(A\\iff B\\) , 当且仅当 \\(A\\harr B\\) 是重言式(其中 A 和 B 可以是多个命题的结合) A, B 给变元任意一组真值指派, A 和 B 真值都相同 十一大等价式: 对合律 \\(\\neg\\neg P\\iff P\\) 幂等律 \\(P\\lor P\\iff P\\) , \\(P\\land P\\iff P\\) 分配律 \\((P\\lor Q)\\land R\\iff (P\\land R)\\lor(Q\\land R)\\) \\(\\mskip{2.5em} (P\\land Q)\\lor R\\iff(P\\lor R)\\land(Q\\lor R)\\) 结合律 \\((P\\lor Q)\\lor R\\iff P\\lor(Q\\lor R)\\) \\(\\mskip{2.5em} (P\\land Q)\\land R\\iff P\\land(Q\\land R)\\) 交换律 \\(P\\lor Q\\iff Q\\lor P\\) , \\(P\\land Q\\iff Q\\land P\\) 吸收律 \\(P\\lor(P\\land Q)\\iff P\\) \\(\\mskip{2.5em} P\\land(P\\lor Q)\\iff P\\) 德摩根律 \\(\\neg(P\\lor Q)\\iff \\neg P\\land\\neg Q\\) \\(\\mskip{3em} \\neg(P\\land Q)\\iff \\neg P \\lor \\neg Q\\) 同一律 \\(P\\lor \\text{F}\\iff P\\) , \\(P\\land \\text{T}\\iff P\\) 零律 \\(P\\lor \\text{T}\\iff \\text{T}\\) , \\(P\\land \\text{F}\\iff \\text{F}\\) 否定律 \\(P\\lor\\neg P\\iff \\text{T}\\) , \\(P\\land\\neg P\\iff \\text{F}\\) 条件命题等价式 \\(A\\to B \\iff \\neg A\\lor B\\) \\(\\mskip{6em} A\\harr B \\iff (A\\to B)\\land(B\\to A)\\) 置换: \\(x\\) 是 \\(A\\) 的子公式, 存在 \\(x\\iff Y\\) , 将 \\(A\\) 中所有的 \\(x\\) 置换为 \\(Y\\) 得到公式 \\(B\\) , 则 \\(B\\iff A\\) 蕴含 当且仅当 \\(P\\to Q\\) 是重言式, 称 \\(P\\) 蕴含 \\(Q\\), 符号 \\(P\\implies Q\\) 蕴含其实就是充分关系, 即左边成立则右边一定成立 反映在真值表就是 \\(P\\) 的真值表中为真的结果 \\(Q\\) 都为真, 但 \\(Q\\) 的真值表中为真的结果 \\(P\\) 不一定都为真 十四大蕴含式 化简律: \\(P\\land Q\\implies P\\) \\(\\mskip{3em}P\\land Q\\implies Q\\) 附加律: \\(P\\implies P\\lor Q\\) 变形附加律: \\(\\neg P\\implies P\\to Q\\) \\(\\mskip{5em}Q\\implies P\\to Q\\) 变形简化律: \\(\\neg(P\\to Q)\\implies P\\) \\(\\mskip{5em}\\neg(P\\to Q)\\implies\\neg Q\\) 假言推理: \\(P\\land(P\\to Q)\\implies Q\\) 拒取式: \\(\\neg Q\\land(P\\to Q)\\implies\\neg P\\) 析取三段论: \\(\\neg P\\land(P\\lor Q)\\implies Q\\) 条件三段论: \\((P\\to Q)\\land(Q\\to R)\\implies P\\to R\\) 等价三段论: \\((P\\harr Q)\\land(Q\\harr R)\\implies P\\harr R\\) 合取构造二难: \\((P\\land R)\\land(P\\to Q)\\land(R\\to S)\\implies Q\\land S\\) 析取构造二难: \\((P\\lor Q)\\land(P\\to R)\\land(Q\\to R)\\implies R\\) 其他联结词 不可兼析取(逻辑异或) \\(P\\triangledown Q\\iff \\neg(P\\harr Q)\\) 条件否定 \\(P\\underrightarrow{c} Q\\iff\\neg(P\\to Q)\\) 与非 \\(P\\uarr Q\\iff\\neg(P\\land Q)\\) 或非 \\(P\\darr Q\\iff\\neg(P\\lor Q)\\) 最小联结词化 结合德摩根律和条件命题等价式, 可以将任何公式化成只含有最小联接词组的形式 最小联接词组 \\(\\{\\neg, \\land\\}\\) , \\(\\{\\neg, \\lor\\}\\) , \\(\\{\\darr\\}\\) , \\(\\{\\uarr\\}\\) 对偶式: 一个命题公式 \\(A\\), 将 \\(\\lor\\) 换成 \\(\\land\\) , \\(\\land\\) 换成 \\(\\lor\\), 若 \\(A\\) 有 F 和 T, 将 F 换成 T, T 换成 F, 得到的 \\(A*\\) 称为 \\(A\\) 的对偶式 例: \\((P\\lor Q)\\land R\\) 的对偶式为 \\((P\\land Q)\\lor R\\) 性质: \\(A\\iff B\\) , \\(A^* \\iff B^*\\) 范式 合取范式 形式为 \\(A_1\\land A_2\\land\\dots A_n\\) , 其中 \\(A_1\\dots A_n\\) 都是由变元及其否定组成的析取式 析取范式 形式为 \\(A_1\\lor A_2\\lor\\dots A_n\\) , 其中 \\(A_1\\dots A_n\\) 都是由变元及其否定组成的合取式 主合/析取范式: 前面的合取范式和析取范式有个缺点, 他是不唯一的 小项(布尔合取): n 个变元的各种合取变换式, 其中每个变元及其否定仅出现一次. (n 个变元的小项有 \\(2^n\\) 个) 小项的编码: 设命题公式有两个变元 P 和 Q, 他有四个小项 P Q P∧Q P∧┐Q ┐P∧Q ┐P∧┐Q T T T F F F T F F T F F F T F F T F F F F F F T 将以上各个小项为真时 P 和 Q 的指派状态用二进制表示可得 11, 10, 01, 00 从而可用 \\(m_{11} , m_{10} , m_{01} , m_{00}\\) 表示以上各个小项 主析取范式 主析取范式由若干小项的析取组成, 见下面定理 定理: 任何一个命题公式, 其真值表中真值为真的指派所对应的小项们的析取就是该公式的主析取范式 大项(布尔析取): n 个变元的各种析取变换式, 其中每个变元及其否定仅出现一次. (n 个变元的小项有 \\(2^n\\) 个) 大项的编码: 设命题公式有两个变元 P 和 Q, 他有四个大项 P Q P∨Q P∨┐Q ┐P∨Q ┐P∨┐Q T T T T T F T F T T F T F T T F T T F F F T T T 将以上各个大项为假时 P 和 Q 的指派状态用二进制表示可得 00, 01, 10, 11 从而可用 \\(M_{00} , M_{01} , M_{10} , M_{11}\\) 表示以上各个大项 主合取范式 主合取范式由若干大项的合取组成, 见下面定理 定理: 任何一个命题公式, 其真值表中真值为假的指派所对应的大项们的合取就是该公式的主合取范式 有效结论: 当且仅当 \\(A\\to C\\) 为重言式, 即 \\(A\\implies C\\) , 就说 \\(C\\) 是 \\(A\\) 的有效结论 推理(也称论证): 若 \\(H_1, H_2,\\dots, H_n\\) 为真, 利用一些公认的规则, 得到一个有效结论的过程. 三种推理方法: 真值表法(万能, 但也是最笨的) 直接证法(重点) P 规则: 引入前提 T 规则: 使用等价式 E, 蕴含式 I 例: 证明 \\((P\\lor Q)\\land(P\\to R)\\land(Q\\to S)\\implies S\\lor R\\)123456789证明: 结论 理由(1) P∨Q P(2) ┐P→Q T(1), E (E代表等价式)(3) Q→S P(4) ┐P→S T(2)(3), I (I代表蕴含式) (使用了条件三段论)(5) ┐S→P T(4), E(6) P→R P(7) ┐S→R T(5)(6), I(8) S∨R T(7), E 间接证明(不要求) 反证法 \\(H_1\\land H_2\\dots H_n\\land\\neg C \\implies \\dots \\implies \\text{F}\\) CP 规则: \\(H_1\\land H_2\\dots H_n\\implies(R\\to C) \\iff H_1\\land H_2\\dots H_n\\land R\\implies C\\) 习题 指出下列语句中哪个不是命题 (C) A. 3+2=5 B. 北京是中国的首都 C. 请勿吸烟 D. 李白是唐朝的诗人 指出下列语句哪个是命题 (D) A. 这本书真好看啊! B. 上课不要迟到! C. 你吃午饭了吗? D. 李白是唐朝诗人 以下语句不是命题的是 (B) A. 明天我要上门去谢你 B. 谢谢你给了我的机会 C. 如果不说我就不谢你 D. 除非你做了我才谢你 下列句子哪些是命题? 她能歌善舞 如果我有时间, 我就来看你 你喜欢看电影吗? 小王今年20岁或21岁 别讲话了! 小王和小李是同学 (解: 1,2,4,6 是命题) 复合命题 由原子命题、联结词和标点符号构成的命题 P、Q 为两个命题, 当且仅当 P和Q都为真时 P∧Q 为真. 命题&quot;如果 1+1=0, 那么太阳从东边落下&quot;的真值为真 设 P、Q 的真值为 0, R、S 的真值为 1, 则下列命题中真值为 1 的是. (D) A. R→P B. Q∧S C. P↔S D. Q∨R 设 P: 天下雨, q: 我去新华书店, 命题&quot;除非天不下雨, 我去新华书店&quot;符号化形式为 (D) A. P→q B. q→P C. ┐q→P D. ┐P→q 若 P: 今天下雪了, Q: 路滑, 则&quot;虽然今天下雪了, 但是路不滑&quot;, 则符号化为 (D) A. (P∧Q) B. P∨┐Q C. (P→┐Q) D. P∧┐Q (中文里转折的意思只能用合取+否定的形式来表示) 设 P, Q, R 的意义如下: P: 李华坐火车, Q: 李华在看书, R: 李华在思考问题 试用日常语言复述下列命题公式. (P∧Q)∧┐R ┐(PVQ)∧R 答: 李华在坐火车和看书, 但是没有思考问题 李华没有做火车也不在看书, 但是在思考问题 (不能写成: 李华没有做火车或看书, 要把 ┐(PVQ) 化为 ┐P∧┐Q) 命题公式 A 与 B 等价是指 (D) A. A 与 B 有相同的原子变元 B. A 与 B 是可满足的 C. 当 A 的真值为真时, B 也为真 D. A 与 B 有相同的真值 \\((P\\to\\neg P)\\to\\neg P\\) 是 永真 式 (填永真, 永假, 可满足) \\((P\\land \\neg P)\\to((Q\\land \\neg Q)\\land\\neg R)\\) 是 永真 式 (填永真, 永假, 可满足) 一个命题公式如果 变元各种指派下, 其真值总为假 , 则称矛盾式 \\((P\\lor\\neg P)\\land\\neg Q\\) 是 可满足 式 (填永真, 永假, 可满足) 重言式: 给定一个命题公式, 它的变元在各种指派下, 其真值总为真 下列集合哪个是最小联结词集? (D) A. \\(\\{\\neg, \\to\\}\\) B. \\(\\{\\neg, \\harr\\}\\) C. \\(\\{\\neg, \\implies\\}\\) D. \\(\\{\\neg, \\land\\}\\) 证明 \\((P\\to R)\\lor(Q\\to R)\\iff(P\\land Q)\\to R\\) (证明思路是将左右两边最终化为由相同的最小联接词组组成的命题) 证明: \\(P\\to R\\lor(Q\\to R)\\) \\(\\iff (\\neg P\\lor R)\\lor(\\neg Q\\lor R)\\) \\(\\iff (\\neg P\\lor\\neg Q)\\lor R\\) (使用了幂等律) \\(\\iff \\neg(P\\land Q)\\lor R\\) (使用了德摩根律) \\(\\iff (P\\land Q)\\to R\\) (使用了条件命题等价式) 证毕 求 \\((P\\lor Q)\\to (P\\harr Q)\\) 的主析取范式 解: P Q P∨Q P↔Q 原式 T T T T T T F T F F F T T F F F F F T T 所以主析取范式: \\(m_0\\lor m_3 \\iff \\sum_{0,3}\\) (小项的编码表示) \\(\\iff (P\\land Q)\\lor(\\neg P\\land\\neg Q)\\) 主合取范式: \\(M_2\\lor M_1 \\iff \\pi_{2,1}\\) (大项的编码表示) \\(\\iff (\\neg P\\lor Q)\\land(P\\land\\neg Q)\\) 命题公式的对偶式: 一个命题公式 A, 将 ∨ 换成 ∧ , ∧ 换成 ∨, 若 A 有 F 和 T, 将 F 换成 T, T 换成 F, 得到的 A* 称为 A 的对偶式 任意两个大项的析取是 永真式 全体大项的合取是 永假式 求 \\(((A\\lor B)\\to C)\\to A\\) 的主析取范式和主合取范式 解: 列真值表 A B C A∨B (A∨B)→C 原式 T T T T T T T T F T F T T F T T T T T F F T F T F T T T T F F T F T F T F F T F T F F F F F T F 主析取范式: \\(\\sum_{2,4,5,6,7}\\) 主合取范式: \\(\\pi_{0,1,3}\\) 谓词逻辑 苏格拉底三段论: A. 所有人都是要死的 B. 苏格拉底是人 C. 苏格拉底是要死的 \\(A\\land B\\implies C\\) 以上命题无法用命题逻辑推理, 由此引出了谓词逻辑 谓词: 描述实体的性质或关系 例子: H() : 是人 x : 苏格拉底 H(x) : 苏格拉底是人 5大于3: L(5, 3) L() : 大于 x 称为客体变元 命题函数: 使用谓词和一些客体变元组成的表达式 个体域(论域): 变元的取值范围 全称量词: \\(\\forall\\) “所有的” “每一个” 存在量词: \\(\\exist\\) “存在一些” “至少有一个” 谓词公式: 原子谓词公式是谓词公式 如果 \\(A\\) 是谓词公式, 则 \\(\\neg A\\) 的否定也是谓词公式 \\(A\\land B\\) , \\(A\\lor B\\) , \\(A\\to B\\) , \\(A\\harr B\\) 是谓词公式 \\(\\forall x A\\) 、\\(\\exist x A\\) 是谓词公式 有限次使用以上 1~4 条得到的式子是谓词公式 翻译: 自然语言 \\(\\rightleftharpoons\\) 谓词公式 指导变元(作用变元): 紧跟量词 \\(\\forall\\) 、\\(\\exist\\) 后面的变元 作用域(辖域): 受指导变元作用的区域, 如无括号即为指导变元后至下一个联结词前的区域(如 ∀xP(x,y,z) 中的 P(x,y,z)) 约束变元: 作用域内出现的该变元叫作该指导变元的约束变元 (如 ∀xP(x,y,z) 中的 x 就是约束变元) 自由变元: 除了约束变元以外的其他变元 (如 ∀xP(x,y,z) 中的 y, z 就是自由变元) 约束变元换名: 对谓词公式中某个指导变元及其作用域内的约束变元替换为一个没有出现过的变元字母 (如 ∀xP(x,y,z) ∨ ∃xP(x) 合取前边的 x 可换名为 ∀aP(a,y,z) ∨ ∃xP(x)) 自由变元代入: 同约束变元换名一样 谓词公式的等价: A, B 对任意一组变元赋值时, 所得的命题真值相同(TLDR: 这两个命题真值表一样), 则 \\(A\\iff B\\) 谓词公式的永真式: 真值总为真 谓词公式的永假式: 真值总为假 谓词公式的可满足: 真值可为真或假 常用的谓词公式等价式: 以下内容利用这两条公式可证明 \\(\\forall x F(x)\\iff F(a_1)\\land F(a_2)\\land\\dots\\land F(a_n)\\) \\(\\exist x F(x)\\iff F(a_1)\\lor F(a_2)\\lor\\dots\\lor F(a_n)\\) 从命题公式中推广而来 注意: 仅有部分可以推广 例: \\(P\\to Q\\iff\\neg P\\lor Q\\) 可变为 \\(\\forall x(P(x)\\to Q(x))\\iff\\forall x(\\neg P(x)\\lor Q(x))\\) 例外 \\(\\exist x(A(x)\\land B(x))\\implies\\exist x A(x)\\land\\exist x B(x)\\) 量词与 \\(\\neg\\) (量词的德摩根律) \\(\\neg\\forall x P(x)\\iff\\exist x\\neg P(x)\\) \\(\\neg\\exist x P(x)\\iff\\forall x\\neg P(x)\\) 量词与 \\(\\land\\) , \\(\\lor\\) , \\(\\to\\) , \\(\\harr\\) \\(\\forall x(A(x)\\land B(x))\\iff\\forall x A(x)\\land\\forall x B(x)\\) \\(\\exist x(A(x)\\lor B(x))\\iff\\exist x A(x)\\lor\\exist x B(x)\\) (对于全称量词的析取, 存在量词的合取, 全称量词和存在量词的条件, 双条件不等价, 而是蕴含) \\(\\forall x(A(x)\\lor B(x))\\implies\\forall x A(x)\\lor\\forall x B(x)\\) \\(\\exist x(A(x)\\land B(x))\\implies\\exist x A(x)\\land\\exist x B(x)\\) \\(\\forall x (A(x)\\to B(x))\\implies\\forall x A(x)\\to\\forall x B(x)\\) \\(\\forall x (A(x)\\harr B(x))\\implies\\forall x A(x)\\harr\\forall x B(x)\\) 量词作用域的扩张与收缩 \\(\\forall x(A(x)\\lor B)\\iff\\forall x A(x)\\lor B\\) \\(\\forall x(A(x)\\land B)\\iff\\forall x A(x)\\land B\\) \\(\\exist x(A(x)\\lor B)\\iff\\exist x A(x)\\lor B\\) \\(\\exist x(A(x)\\land B)\\iff\\exist x A(x)\\land B\\) 注意: \\(\\forall x A(x)\\to B\\iff\\exist x(A(x)\\to B)\\) \\(\\exist x A(x)\\to B\\iff\\forall x(A(x)\\to B)\\) \\(B\\to \\forall x A(x)\\iff\\forall x(B\\to A(x))\\) \\(B\\to \\exist x A(x)\\iff\\exist x(B\\to A(x))\\) 量词的嵌套 对于所有x对于存在y, 和存在y对于所有x不同 (最强) \\(\\forall x\\forall y P(x,y)\\iff\\forall y\\forall x P(x,y)\\) (最弱) \\(\\exist x\\exist y P(x,y)\\iff\\exist y\\exist x P(x,y)\\) (弱) \\(\\forall x\\exist y P(x,y)\\) , \\(\\forall y\\exist x P(x,y)\\) (次强) \\(\\exist x\\forall y P(x,y)\\) , \\(\\exist y\\forall x P(x,y)\\) \\(\\forall x\\forall y\\implies\\exist y\\forall x\\) \\(\\exist y\\forall x\\implies\\forall x\\exist y\\) \\(\\forall x\\exist y\\implies\\exist y\\exist x\\) 谓词公式的推理 US 全称指定规则 \\(\\forall-\\) (比如将 \\(\\forall x P(x)\\) 指定为 \\(P(c)\\) , 其中 c 指任意的数) ES 存在指定规则 \\(\\exist-\\) (比如将 \\(\\exist x P(x)\\) 指定为 \\(P(c)\\) , 其中 c 指能使式子成立的那些数) UG 全称推广规则 \\(\\forall+\\) (比如将 \\(P(c)\\) 推广为 \\(\\forall x P(x)\\)) EG 存在推广规则 \\(\\exist+\\) (比如将 \\(P(c)\\) 推广为 \\(\\exist x P(x)\\) 习题 设 P(x) 为 “x 是大学生”, Q(x) 为 “x 不满 30 岁”, 命题&quot;所有大学生都不满 30 岁&quot;写成谓词公式为 (C) A. \\(\\forall x (P(x)\\land Q(x))\\) B. \\(\\exist x (P(x)\\land Q(x))\\) C. \\(\\forall x P(x)\\to Q(x)\\) D. \\(\\exist x P(x)\\to Q(x)\\) 设 L(x): x 是演员, J(x): x 是老师. A(x,y): x 钦佩 y , 命题 &quot;所有演员都钦佩某些老师&quot;符号化为 (B) A. \\(\\forall x(L(x)\\to A(x,y))\\) B. \\(\\forall x(L(x)\\to \\exist y(J(y)\\land A(x,y)))\\) C. \\(\\forall x\\exist y(L(x)\\land(J(y)\\land A(x,y)))\\) D. \\(\\forall x\\exist y(L(x)\\land(J(y)\\to A(x,y)))\\) D 为什么是错的, D 可化为\\(\\forall x(L(x)\\land\\exist y(J(y)\\to A(x,y)))\\) , 若 \\(x\\) 不是演员结果竟然也为假, 显然不符合命题 翻译时全称量词应和条件搭配(反之, 存在量词应和合取搭配) 已知 \\(\\forall y(R(y)\\lor B(y))\\) , 其中 \\(R(3)=B(4)=T\\) , \\(R(4)=B(3)=F\\) , 且论域是 \\(\\{3,4\\}\\) , 求该式的值 思路: \\(\\forall x F(x)\\iff F(a_1)\\land F(a_2)\\land\\dots\\land F(a_n)\\) \\(\\exist x F(x)\\iff F(a_1)\\lor F(a_2)\\lor\\dots\\lor F(a_n)\\) 解: \\(\\mskip{2.7em}\\forall y(R(y)\\lor B(y))\\) \\(\\iff (R(3)\\lor B(3))\\land(R(4)\\lor B(4))\\) \\(\\iff (T\\lor F)\\land (F\\lor T)\\) \\(\\iff T\\land T\\) \\(\\iff T\\) 谓词公式 \\(\\forall x(P(x)\\lor\\exist y R(y))\\to Q(x)\\) 中变元 \\(x\\) 是 (C) A. 自由变元 B. 约束变元 C. 既是自由变元又是约束变元 D. 既不是自由变元也不是约束变元 公式 \\(\\exist x\\forall y(P(x,y)\\land Q(z))\\) 中 \\(\\forall y\\) 的辖域是 (C) A. \\(P(x,y)\\) B. \\(\\exist x(P(x,y)\\land Q(z))\\) C. \\((P(x,y)\\land Q(z))\\) D. \\(Q(z)\\) 公式 \\(\\forall x\\forall y(P(x,y)\\land Q(x,y))\\land\\exist x P(x,y)\\) 中 \\(\\forall x\\) 的辖域是 (B) A. \\(P(x,y)\\) B. \\(P(x,y)\\land Q(x,y)\\) C. \\(Q(x,y)\\) D. \\(P(x,y)\\land Q(x,y))\\land\\exist x P(x,y)\\) 公式 \\(\\forall x F(x)\\land G(x,y)\\) 中变元 \\(y\\) 是 自由 变元. (填自由或约束) 约束变元的换名: 对谓词公式中某个指导变元及其作用域内的约束变元替换为一个没有出现过的变元字母 下列等价式不正确的是 (D) A. \\(\\neg\\forall x A\\iff \\exist x\\neg A\\) B. \\(\\forall x(B\\to A(x))\\iff B\\to\\forall x A(x)\\) C. \\(\\exist x(A(x)\\lor B(x))\\iff \\exist x A(x)\\lor\\exist x B(x)\\) D. \\(\\forall x\\forall y(A(x)\\to B(y))\\iff\\forall x A(x)\\to\\forall y B(y)\\) 与 \\(\\neg\\exist x M(x)\\) 等价的是 (D) A. \\(\\forall x M(x)\\) B. \\(\\exist x\\neg M(x)\\) C. \\(\\forall x M(x)\\) D. \\(\\forall x\\neg M(x)\\) 量词与否定之间有以下关系: \\(\\neg\\forall x Q(x)\\iff\\) ___\\(\\exist x\\neg Q(x)\\)___ 证明题 符号化并证明: 人总是要死的, 苏格拉底是人, 所以苏格拉底要死的. 翻译: H(x): x 是人; D(x): x 是要死的; s: 苏格拉底 \\(\\mskip{2em}\\forall x(H(x)\\to D(x))\\) , \\(H(s)\\implies D(s)\\) 证明: \\(\\mskip{5em}\\) 结论 \\(\\mskip{5em}\\) 理由 (1) \\(\\forall x(H(x)\\to D(x))\\mskip{3.25em}\\) P (2) \\(H(s)\\mskip{9em}\\) P (3) \\(H(s)\\to D(s)\\mskip{5em}\\) T(1), US (4) \\(D(s)\\mskip{8.7em}\\) T(2)(3), I 形式化并证明 每一个自然数是不是奇数就是偶数, 自然数是偶数当且仅当它被 2 整除, 并不是所有自然数都能被 2 整除, 因此, 有的自然数是奇数 翻译: O(x): x 是奇数; E(x): x 是偶数; D(x): x 能被 2 整除 \\(\\forall x(\\neg O(x)\\to E(x))\\) , \\(\\forall x(E(x)\\harr D(x))\\) , \\(\\neg\\forall x D(x)\\harr\\exist x O(x)\\) 证明: \\(\\mskip{5em}\\) 结论 \\(\\mskip{5em}\\) 理由 (1) \\(\\forall x(\\neg O(x)\\to E(x))\\mskip{3em}\\) P (2) \\(\\forall x(E(x)\\harr D(x))\\mskip{3.5em}\\) P (3) \\(\\neg\\forall x D(x)\\mskip{7.3em}\\) P (4) \\(\\exist x\\neg D(x)\\mskip{6.5em}\\) T(3), E (5) \\(\\neg D(a)\\mskip{7.6em}\\) T(4), ES (6) \\(E(a)\\harr D(a)\\mskip{4.6em}\\) T(2), US (7) \\(\\neg E(a)\\mskip{7.2em}\\) T(5)(6), I (8) \\(\\neg O(a)\\to E(a)\\mskip{4em}\\) T(1), US (9) \\(O(a)\\mskip{8.3em}\\) T(7)(8), I (10) \\(\\exist x O(x)\\mskip{6.6em}\\) T(9), EG 注意: 第5步和第6步不能互换, 存在指定和全称指定的变量 a 需要先经存在指定限定范围 集合论 集合: 把一些元素汇集成一个整体 集合 A, B, C. 元素 a, b, c \\(a\\in A\\) , 读作&quot;属于&quot;, \\(b\\notin\\) 读作&quot;不属于&quot; 分类 \\(\\begin{cases} \\text{有限集} \\\\ \\text{无限集} \\end{cases}\\) 表示: 列举法 \\(A=\\{1,2,3,4,5\\}\\) 描述法 \\(A=\\{x|x\\text{是自然数}\\}\\) 文氏图(venn) 相等: 当且仅当它们有相同的元素 比如: \\(\\{1,3,5,7,\\dots\\}=\\{x|x\\text{是正奇数}\\}\\) \\(\\{1,2,4\\}=\\{1,4,2\\}\\) \\(\\{1,2,4\\}=\\{1,2,2,4\\}\\) 包含于: 若 A 的每一个元素都是 B 的成员, 则称 A 是 B 的子集 记为 \\(A\\subseteq B\\) , 读作&quot;包含于&quot;, 等价于 \\(B\\supseteq A\\) (注意朝向) \\(A\\subseteq B\\iff\\forall x(x\\in A\\to x\\in B)\\) 性质: (自反性) \\(A\\subseteq A\\) (传递性) \\((A\\subseteq B)\\land(B\\subseteq C)\\implies A\\subseteq C\\) (但不满足下式对称性) \\(A\\subseteq B\\nRightarrow B\\subseteq A\\) 互为子集定理: \\(A=B\\iff(A\\subseteq B)\\land(B\\subseteq A)\\) 真包含于: A 中每一个元素都是 B 的成员, 但 B 中至少有一个元素不属于 A, 则称 A 是 B 的真子集, 记作 \\(A\\subset B\\) , 读作&quot;真包含于&quot; 空集 \\(\\varnothing\\) \\(\\varnothing\\neq\\{\\varnothing\\}\\) (前者是空集, 但后者不是. 因为它有一个元素-空集本身) \\(\\varnothing\\in\\{\\varnothing\\}\\) (正确) \\(\\varnothing\\subseteq A\\) (正确) \\(\\varnothing\\subset A\\) (不对, 因为有 \\(A=\\{\\varnothing\\}\\) 的情况) 全集: 在一定范围内, 包含所有元素的集合 \\(E=\\{x|P(x)\\lor\\neg P(x)\\}\\) \\(\\varnothing=\\{x|P(x)\\land\\neg P(x)\\}\\) 幂集: 由 A 的所有子集为元素组成的集合叫 A 的幂集, 记作 P(A) \\(P(A)=\\{B|B\\subseteq A\\}\\) (B 代表 A 的所有子集) 如: \\(A=\\{a,b,c\\}\\) , \\(P(A)=\\{\\{a\\},\\{b\\},\\{c\\},\\{a,b\\},\\{a,c\\},\\{b,c\\},\\{a,b,c\\},\\varnothing\\}\\) 若 \\(A\\) 有 \\(n\\) 个元素, \\(P(A)\\) 有 \\(2^n\\) 个元素 (推导思路, 将所有元素想象成拥有取或不取两种状态, 则能有 \\(2^n\\) 种不同的序列) 交: \\(A\\cap B=\\{x|(x\\in A)\\land(x\\in B)\\}\\) \\(A\\cap A=A\\) \\(A\\cap\\varnothing=\\varnothing\\) \\(A\\cap E=A\\) (对称性/交换律) \\(A\\cap B=B\\cap A\\) (结合律) \\((A\\cap B)\\cap C=A\\cap(B\\cap C)\\) 并: \\(A\\cup B=\\{x|(x\\in A)\\lor(x\\in B)\\}\\) \\(A\\cup A=A\\) \\(A\\cup\\varnothing=A\\) \\(A\\cup E=E\\) \\(A\\cup B=B\\cup A\\) \\((A\\cup B)\\cup C=A\\cup(B\\cup C)\\) 分配律 \\(A\\cap(B\\cup C)=(A\\cap B)\\cup(A\\cap C)\\) \\(A\\cup(B\\cap C)=(A\\cup B)\\cap(A\\cup C)\\) 吸收律 \\(A\\cup(A\\cap B)=A\\) \\(A\\cap(A\\cup B)=A\\) 差: \\(A-B=\\{x|(x\\in A)\\land(x\\notin B)\\}\\) \\(A-B=A\\cup\\sim B\\) 补: \\(\\sim A=E-A=\\{x|(x\\in E)\\land(x\\notin A)\\}\\) \\(\\sim(\\sim A)=A\\) \\(\\sim E=\\varnothing\\) \\(\\sim\\varnothing=E\\) \\(A\\cup\\sim A=E\\) \\(A\\cap\\sim A=\\varnothing\\) \\(A\\cap\\sim B=A-B\\) 定理(集合的德摩根律): \\(\\sim(A\\cup B)=\\sim A\\cap\\sim B\\) \\(\\sim(A\\cap B)=\\sim A\\cup\\sim B\\) 对称差 \\(A\\oplus B=(A-B)\\cup(B-A)=\\{x|(x\\in A)\\triangledown(x\\in B)\\}\\) 序偶: 有固定次序的两个元素 \\(&lt;a,b&gt;\\neq&lt;b,a&gt;\\) \\(&lt;a,b&gt;=&lt;u,v&gt;\\iff(a=u)\\land(b=v)\\) 推广: 三元组, 四元组, … 笛卡尔积(直积): 有序列 A、B, 若序偶的第一个成员属于 A, 序偶的第二个属于 B, 由所有这样的序偶组成的集合称为 A 与 B 的笛卡尔积 符号 \\(A\\times B=\\{&lt;x,y&gt;|(x\\in A)\\land(y\\in B)\\}\\) 例: \\(A=\\{\\alpha,\\beta\\}\\) , \\(B=\\{1,2\\}\\) \\(A\\times B=\\{&lt;\\alpha,1&gt;,&lt;\\alpha,2&gt;,&lt;\\beta,1&gt;,&lt;\\beta,2&gt;\\}\\) 性质: (笛卡尔积 对 并或交运算的分配律) \\(A\\times(B\\cup C)=(A\\times B)\\cup(A\\times C)\\) \\(A\\times(B\\cap C)=(A\\times B)\\cap(A\\times C)\\) \\((A\\cup B)\\times C=(A\\times C)\\cup(B\\times C)\\) \\((A\\cap B)\\times C=(A\\times C)\\cap(B\\times C)\\) \\(A\\times A\\times\\dots\\times A=A^n\\) 但注意, 并或交 对 笛卡尔积 不服从分配律 如 \\(A\\cup(B\\times C)\\neq(A\\cup B)\\times(A\\cup C)\\) (显而易见, 因为左边的 \\(A\\) 不是序偶) 关系\\(^1\\): 任意一个关于序偶的集合, 都是一个二元关系 \\(R\\) , 记作 \\(&lt;x,y&gt;\\in R\\) 例: \\(A=\\{1,2,3,5\\}\\) , \\(B=\\{a,b,c\\}\\) \\(R=\\{&lt;1,b&gt;&lt;2,c&gt;&lt;3,c&gt;\\}\\) 域 由 \\(&lt;x,y&gt;\\in R\\) 中所有 x 组成的集合叫作前域, 记作 \\(\\text{dom R}\\) 由 \\(&lt;x,y&gt;\\in R\\) 中所有 y 组成的集合叫作值域, 记作 \\(\\text{ran R}\\) 前域和值域一起称作域 FLD \\(\\text{FLD}R=\\text{dom R}\\cup\\text{ran R}\\) 例: \\(A=\\{1,2,3,5\\}\\) , \\(B=\\{1,2,4\\}\\) , \\(R=\\{&lt;1,2&gt;,&lt;1,4&gt;,&lt;2,4&gt;,&lt;3,4&gt;\\}\\) 求 \\(\\text{dom R}\\), \\(\\text{ran R}\\), \\(\\text{FLD}R\\) \\(\\text{dom R}=\\{1,2,3\\}\\) \\(\\text{ran R}=\\{2,4\\}\\) \\(\\text{FLD}R=\\{1,2,3,4\\}\\) 关系\\(^2\\) : \\(A\\times B\\) 的子集称作 \\(A\\) 到 \\(B\\) 的关系 恒等关系: \\(I_A=\\{&lt;a,a&gt;|a\\in A\\}\\) 全域关系: \\(A\\times B\\) 空关系: \\(\\varnothing\\) 关系的表示 列举序偶 关系矩阵 \\(R\\) 对应 \\(M_R=[r_{ij}]_{n\\times n}\\) 其中, \\(r_{ij}=\\begin{cases} 1 &amp;\\text{当}&lt;x_i,y_j&gt;\\in R \\\\ 0 &amp;\\text{当}&lt;x_i,y_j&gt;\\notin R \\end{cases}\\) 例: \\(X=\\{x_1,x_2,x_3,x_4\\}\\) , \\(Y=\\{y_1,y_2,y_3\\}\\) , \\(R=\\{&lt;x_1,y_1&gt;,&lt;x_2,y_3&gt;,&lt;x_3,y_2&gt;,&lt;x_2,y_1&gt;\\}\\) \\(M_R=\\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 \\end{bmatrix}_{4\\times 3}\\) 关系图 自反性: 设关于集合 \\(X\\) 的关系 \\(R:X\\) , 如果对于每一个 \\(x\\in X\\) , 都有 \\(xRx\\) (即 \\(&lt;x,x&gt;\\in R\\)) , 则称关系 \\(R\\) 是自反的 例: \\(A=\\{1,2,3\\}\\) , 关系 \\(R=\\{&lt;1,1&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;1,2&gt;\\}\\) 是自反的 关系矩阵主对角线上元素均为 1， 则关系 \\(R\\) 是自反的; 关系图中每个结点都有环, 则关系 \\(R\\) 是自反的. 反自反性: 设关于集合 \\(X\\) 的关系 \\(R:X\\) , 如果对于每一个 \\(x\\in X\\) , 都有 \\(x\\not Rx\\) (即 \\(&lt;x,x&gt;\\notin R\\)), 则称关系 \\(R\\) 是反自反的 例: \\(A=\\{1,2,3\\}\\) , 关系 \\(R=\\{&lt;1,2&gt;,&lt;2,1&gt;,&lt;,3,2&gt;\\}\\) 是反自反的 关系矩阵主对角线上元素均为 0， 则关系 \\(R\\) 是反自反的; 关系图中每个结点都没有环, 则关系 \\(R\\) 是反自反的. 对称性: 设关于集合 \\(X\\) 的关系 \\(R:X\\) , \\(x,y\\in X\\) , 对于每一个 \\(xRy\\) , 都有 \\(yRx\\) , 则称关系 \\(R\\) 是对称的 例: \\(A=\\{1,2,3\\}\\) , 关系 \\(R=\\{&lt;1,2&gt;,&lt;2,1&gt;,&lt;3,3&gt;\\}\\) 是对称的 关系矩阵沿主对角线对称, 则关系 \\(R\\) 是对称的 关系图中若弧是成对出现的, 则关系 \\(R\\) 是对称的 反对称性: 设关于集合 \\(X\\) 的关系 \\(R:X\\) , \\(x,y\\in X\\) , 对于每一个 \\(xRy\\) , 都有 \\(y\\not Rx\\) , 称关系 \\(R\\) 是反对称的 另一个条件: 每当 \\(xRy\\land yRx\\) , 都有 \\(x=y\\) , 也认为是反对称的 例: \\(A=\\{1,2,3\\}\\) , 关系 \\(R=\\{&lt;1,2&gt;,&lt;1,3&gt;,&lt;2,3&gt;\\}\\) 是反对称的 关系矩阵沿主对角线不对称, 则关系 \\(R\\) 是反对称的 关系图中若弧不成对出现, 则关系 \\(R\\) 是反对称的 \\(I_A\\) 是对称的, 又是反对称的 空关系 \\(\\varnothing\\) 是对称的, 又是反对称的 传递性: 设关于集合 \\(X\\) 的关系 \\(R:X\\) , \\(x,y\\in X\\) , 每当 \\(xRy\\) , \\(yRx\\) , 都有 \\(xRz\\) , 则称关系 \\(R\\) 是传递的 例: \\(X=\\{1,2,3\\}\\) , 关系 \\(R=\\{&lt;1,2&gt;,&lt;2,3&gt;,&lt;1,3&gt;,&lt;2,1&gt;\\}\\) 不是传递的 (少了\\(&lt;2,2&gt;\\) 和 \\(&lt;1,1&gt;\\)) 关系图中, 若从 a 到 b 的有向路径(路径是间接的), 存在 a 到 b 的弧(弧是直接的). 则 R 是传递的 关系的运算: 交, 并, 差, 对称差, 补(用 \\(\\tilde{R}\\) , 即 \\(\\text{全域关系}-R\\) 中的序偶) 关系的复合: 设 \\(R: X\\to Y\\) , \\(S: Y\\to Z\\) , 则复合 \\(R\\circ S=\\{&lt;x,z&gt;|x\\in X\\land z\\in Z\\land\\exist y(y\\in Y\\land&lt;x,y&gt;\\in R\\land&lt;y,z&gt;\\in S)\\}\\) 例: \\(R=\\{&lt;1,2&gt;,&lt;3,4&gt;,&lt;2,2&gt;\\}\\) \\(S=\\{&lt;4,2&gt;,&lt;2,5&gt;,&lt;3,1&gt;,&lt;1,3&gt;\\}\\) 实际计算方法就是将 \\(R\\) 中每个序偶的终端 \\(y\\) 去找 \\(S\\) 的序偶中相同的始端 \\(y\\) , 然后跟这个相同始端的序偶结合成 \\(&lt;x,z&gt;\\) \\(R\\circ S=&lt;1,5&gt;,&lt;3,2&gt;,&lt;2,5&gt;\\) \\(S\\circ R=&lt;4,2&gt;,&lt;3,2&gt;,&lt;1,4&gt;\\) 注意: 由上面例子可知复合不满足交换律. 但是复合满足: 结合律 \\(R\\circ(S\\circ P)=(R\\circ S)\\circ P\\) \\(R\\circ I=R\\) \\(R\\circ\\varnothing=\\varnothing\\) \\(R\\circ R=R^{(2)}\\) \\(R\\circ R\\circ R\\circ\\dots\\circ R=R^{(n)}\\) (关系的幂运算) 关系的逆运算: 设 \\(R:X\\to Y\\) , 则 \\(R^c (\\text{或记}R^{-1})=\\{&lt;y,x&gt;|&lt;x,y&gt;\\in R\\}\\) (即把 R 的每一个序偶中元素顺序换一下) \\((R^{-1})^{-1}=R\\) 闭包: 设 \\(R:X\\) , 如果另一个关系 \\(R’\\) 满足: \\(R’\\) 是自反的(对称的, 传递的) \\(R’\\supseteq R\\) 对于任何自反的(对称的, 传递的)关系 \\(R’‘\\) , 如果 \\(R’‘\\supseteq R\\) , 就有 \\(R’‘\\supseteq R’\\) (即 \\(R’\\) 是最小的、包含 \\(R\\) 的自反关系) 则称 \\(R’\\) 为 \\(R\\) 的自反(对称, 传递)闭包 自反闭包表示为 \\(r(R)=R\\cup I_A\\) 对称闭包表示为 \\(s(R)=R\\cup R^{-1}\\) 传递闭包表示为 \\(t(R)=\\underset{i=1}{\\overset{\\infty}{\\cup}}R^{(i)}=\\underset{i=1}{\\overset{|A|}{\\cup}}R^{(i)}\\) (\\(|A|\\) 表示集合 \\(A\\) 的基数) 覆盖: 设 \\(A\\) , \\(S=\\{S_1,S_2,\\dots,S_n\\}\\) , 若 \\(S_i\\subseteq A\\) , \\(S_i\\neq\\varnothing\\) , 且 \\(\\underset{i=1}{\\overset{n}{\\cup}}S_i=A\\) . 则称 \\(S\\) 是 \\(A\\) 的覆盖 划分: 在满足覆盖条件的基础上, 另有 \\(\\forall i\\forall j(S_i\\cap S_j)=\\varnothing\\quad(i\\neq j)\\) , 则称 \\(S\\) 是 \\(A\\) 的划分. 例: \\(A=\\{1,2,3,4,5\\}\\) \\(X=\\{\\{1,2,3\\},\\{3,4,5\\}\\}\\) 是覆盖 \\(Y=\\{\\{1,2,3\\},\\{4\\},\\{5\\}\\}\\) 是划分 \\(Z=\\{\\{1,2,3,4,5\\}\\}\\) 是最小划分(划分数最小) \\(U=\\{\\{1\\},\\{2\\},\\{3\\},\\{4\\},\\{5\\}\\}\\) 是最大划分(划分数最大) 等价关系: 设 \\(R:A\\) , 若 \\(R\\) 是自反的, 对称的, 传递的, 则称 \\(R\\) 是等价关系 等价类: 设 \\(R\\) 是 \\(A\\) 的等价关系, 则对于 \\(\\forall a\\in A\\) , 有元素 \\(a\\) 关于关系 \\(R\\) 的等价类 \\([a]_R=\\{x|xRa,x\\in A\\}\\) (即从等价关系中挑出所有与元素 \\(a\\) 有关系的元素组成的集合就是这个元素 \\(a\\) 的等价类) 例: \\(A=\\{1,2,3,4\\}\\) \\(R=\\{&lt;1,1&gt;,&lt;2,2&gt;,&lt;1,2&gt;,&lt;2,1&gt;,&lt;3,3&gt;,&lt;4,4&gt;,&lt;3,4&gt;,&lt;4,3&gt;\\}\\) 则有 \\([1]_R=\\{1,2\\}=[2]_R\\) \\([3]_R=\\{3,4\\}=[4]_R\\) 定理: 在等价关系中, \\(\\forall a,b\\in A\\) , 有 \\(aRb\\Harr[a]_R=[b]_R\\) 商集: 设 \\(R\\) 是 \\(A\\) 的等价关系, 其等价类的集合 \\(\\{[a]_R|a\\in A\\}\\) 称作 \\(A\\) 关于 R 的商集, 记作 \\(A/R\\) 定理: \\(R\\) 是 \\(A\\) 上的等价关系, 则商集 \\(A/R\\) 是 \\(A\\) 的一种划分(有关系的元素之间等价类完全相同, 所以是划分) 反之, 集合 \\(A\\) 上的任意一种划分 \\(S\\) , 也能确定 \\(A\\) 上的一种等价关系 相容关系: 设 \\(R:A\\) , 若 R 是自反的, 对称的, 则 R 是相容关系 等价关系 \\(\\subset\\) 相容关系 等价类的商集为划分, 相容类的商集为覆盖 偏序关系: \\(R:A\\), 若 R 是自反的, 反对称的, 传递的, 则 R 是偏序关系, 换成用 “\\(\\preccurlyeq\\)” 表示 (或 “\\(\\leqslant\\)” , 因为&quot;小于等于&quot;是一种典型的偏序关系) (\\(a\\preccurlyeq b=\\{&lt;a,a&gt;,&lt;b,b&gt;,&lt;a,b&gt;\\}\\)) 偏序集: 记作 \\(&lt;A,\\preccurlyeq&gt;\\) (用来表示定义在集合 A 上的一种偏序关系) 例: \\(A=\\{2,3,6,8\\}\\) , 设 D 表示整除关系(即每个序偶中后者能整除前者) \\(D=\\{&lt;2,6&gt;,&lt;2,8&gt;,&lt;3,6&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;6,6&gt;,&lt;8,8&gt;\\}\\) D 是偏序关系; 设 M 表示整倍数关系 \\(M=\\{&lt;6,2&gt;,&lt;6,3&gt;,&lt;8,2&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;6,6&gt;,&lt;8,8&gt;\\}\\) M 是偏序关系 盖住: 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\) , 如果 \\(x,y\\in A\\quad(x\\neq y)\\) , 有 \\(x\\preccurlyeq y\\) , 且不存在 \\(z\\in A\\) , 使得 \\(x\\preccurlyeq z\\) 和 \\(z\\preccurlyeq y\\) , 则称 y 盖住 x 盖住关系: \\(\\text{COV}A=\\{&lt;x,y&gt;|\\text{y盖住x}\\}\\) 例: (接着上面的例题) \\(\\text{COV}A=\\{&lt;2,6&gt;,&lt;3,6&gt;,&lt;2,8&gt;\\}\\) 哈斯图(Hasse Diagrams) 作图顺序: 用小圆圈表示元素 若 \\(x\\preccurlyeq y\\) , 将 y 画在 x 上方 若 \\(&lt;x,y&gt;\\in\\text{COV}A\\) , 则 x 和 y 之间用直线连接 例: \\(A=\\{2,3,6,12,24,36\\}\\) , 求 \\(&lt;A,\\text{整除}&gt;\\) 的哈斯图? 解: \\(\\preccurlyeq=\\{&lt;2,2&gt;,&lt;3,3&gt;,&lt;6,6&gt;,&lt;6,2&gt;,&lt;6,3&gt;,&lt;12,12&gt;,&lt;12,6&gt;,&lt;12,3&gt;, \\\\ &lt;12,2&gt;,&lt;24,24&gt;,&lt;24,12&gt;,&lt;24,6&gt;,&lt;24,3&gt;,&lt;24,2&gt;,&lt;36,36&gt;, \\\\ &lt;36,12&gt;,&lt;36,6&gt;,&lt;36,3&gt;,&lt;36,2&gt;\\}\\) \\(\\text{COV}A=\\{&lt;6,2&gt;,&lt;6,3&gt;,&lt;12,6&gt;,&lt;24,12&gt;,&lt;36,12&gt;\\}\\) 哈斯图如下: 链: 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\) , 若集合 \\(A\\) 中任何两个元素都有关系, 称 A 为链, A 的子集也是链 (若任何元素都有关系, 则前者盖住后者, 哈斯图就是链状的) 全序(线序): 设偏序集, \\(&lt;A,\\preccurlyeq&gt;\\) , 如果 \\(A\\) 是链, 则称偏序关系 \\(\\preccurlyeq\\) 为全序 极大元和极小元 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\) , \\(a\\in A\\) 如果 \\(A\\) 中没有元素 \\(x\\) 能够 \\(a\\preccurlyeq x\\) 且 \\(x\\neq a\\) (即没有元素能再盖住 \\(a\\)), 称 \\(a\\) 为 \\(A\\) 的极大元; 如果 \\(A\\) 中没有元素 \\(x\\) 能够 \\(x\\preccurlyeq a\\) 且 \\(x\\neq a\\) (即 \\(a\\) 不能盖住任何元素), 称 \\(a\\) 为 \\(A\\) 的极小元 (极大元/极小元可以有多个) 最大元和最小元 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\) , 如果\\(\\forall a\\in A\\) , 都有 \\(x\\preccurlyeq a\\) , 则称 a 为 \\(&lt;A,\\preccurlyeq&gt;\\) 的最大元; 如果 \\(\\forall a\\in A\\) , 都有 \\(a\\preccurlyeq x\\) , 则称 a 为 \\(&lt;A,\\preccurlyeq&gt;\\) 的最小元. (即最大元只在极大元数量为1的时候存在) (即最小元只在极小元数量为1的时候存在) 上界和下界 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\), 子集 \\(B\\subseteq A\\) , 如果 \\(\\exist a\\in A\\) 且 \\(\\forall x\\in B\\) , 都有 \\(x\\preccurlyeq a\\) , 则 \\(a\\) 为 \\(B\\) 的上界 如果 \\(\\exist a\\in A\\) 且 \\(\\forall x\\in B\\) , 都有 \\(a\\preccurlyeq x\\) , 则 \\(a\\) 为 \\(B\\) 的下界 最小上界(上确界)和最大下界(下确界) 设偏序集 \\(&lt;A, \\preccurlyeq&gt;\\) , \\(B\\subseteq A\\) , 若 \\(a\\) 为 \\(B\\) 的一个上界, 对于 \\(B\\) 的所有上界 \\(x\\), 都有 \\(a\\preccurlyeq x\\) , 称 \\(a\\) 为最小上界(上确界) 若 \\(b\\) 是 \\(B\\) 的一个下界, 对于 \\(B\\) 的所有下界 \\(y\\), 都有 \\(y\\preccurlyeq b\\) , 称 \\(b\\) 为最大下界(下确界) 良序: 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\) , 若对于所有 \\(B\\subseteq A\\) , \\((B\\neq\\varnothing)\\) , \\(B\\) 都存在最小元, 称此偏序为良序 拟序: 反自反且传递的关系是拟序关系 函数: 设集合 X, Y, f 是 X 到 Y 的一个关系, 如果对于 \\(\\forall x\\in X\\) , 都有唯一的 \\(y\\in Y\\) , 使得 \\(&lt;x,y&gt;\\in f\\) , 称关系 \\(f\\) 为函数 记作 \\(f:x\\to y\\) , \\(x\\in X\\) 称作自变元, \\(y\\in Y\\) 称作象 象集 \\(f(x)=\\{f(x)|x\\in X\\}\\subseteq Y\\) 函数=多对一映射 \\(|x|=m\\) , \\(|Y|=n\\) 则从 X 到 Y 的关系有 \\(2^{mn}\\) 种 (可以理解由 \\(nm\\) 个序偶组成的集合, 它的幂集的元素就有 \\(2^{mn}\\) 个) 从 X 到 Y 的函数有 \\(n^m\\) 种 (可以理解为 \\(x\\) 组成的序列, 每个 \\(x\\) 有 \\(n\\) 种可能, 共有 \\(m\\) 个 \\(x\\), 序列就有 \\(n^m\\) 种) 满射(到上映射): 设 \\(f:x\\to y\\) , 如果 \\(Y\\) 中每一个元素都是象, 则称 \\(f\\) 为满射. (即每个 \\(y\\) 都被利用) 入射(单射;一对一映射): 设 \\(f:x\\to y\\) , 如果 \\(X\\) 中没有两个元素有相同的象, 则称 \\(f\\) 为入射. (一个 \\(x\\) 对应一个 \\(y\\)) 双射(对应映射): 既是满射又是入射 逆函数: 设双射函数 \\(f:x\\to y\\) , 则 \\(f\\) 存在逆函数, 记作 \\(f^{-1}\\) 复合函数: 设 \\(f:x\\to y\\) , \\(g:w\\to z\\) , 若 \\(f(x)\\subseteq w\\) , 称 g 在 y 的左边可复合 \\(g\\circ f=g(f(x))=\\{&lt;x,z&gt;|\\exist y, y=f(x)\\land z=g(y)\\}\\) 定理: 设 \\(g\\circ f\\) 是复合函数, 若 \\(g\\) , \\(f\\) 是满射, 则 \\(g\\circ f\\) 是满射 若 \\(g\\) , \\(f\\) 是入射, 则 \\(g\\circ f\\) 是入射 若 \\(g\\) , \\(f\\) 是双射, 则 \\(g\\circ f\\) 是双射 习题 在自然数集上, 下列那种运算是不可交换的? (D) (这里 * 代表任意一种集合的运算) A. \\(a\\text{*}b=\\text{min}(a,b)\\) B. \\(a\\text{*}b=a+b\\) C. \\(a\\text{*}b=\\text{max}(a,b)\\) D. \\(a\\text{*}b=a-b\\) 若集合 A 有 101 个元素, 则 A 的幂集有___ \\(2^{101}\\) ___个元素 下列各项错误的是 (A) A. \\(\\{x\\}\\in\\{x\\}\\) B. \\(\\{x\\}\\subseteq\\{x\\}\\) C. \\(\\{x\\}\\in\\{x,\\{x\\}\\}\\) D. \\(\\{x\\}\\subseteq\\{x,\\{x\\}\\}\\) 设 \\(M=\\{x|(x\\text{是整数})\\land(1\\leqslant x\\leqslant 12)\\land(x\\text{被2整除})\\}\\) \\(N=\\{x|(x\\text{是整数})\\land(1\\leqslant x\\leqslant 12)\\land(x\\text{被3整除})\\}\\) 则 \\(M\\cap N=\\) ___ \\(\\{6,12\\}\\) ___ 证明 \\(A\\cap(B\\oplus C)=(A\\cap B)\\oplus(A\\cap C)\\) 证明: \\(\\begin{aligned} \\text{左边} &amp;=A\\cap((B-C)\\cup(C-B)) \\\\ &amp;=(A\\cap(B-C))\\cup(A\\cap(C-B)) \\end{aligned}\\) \\(\\begin{aligned} \\text{右边} &amp;=((A\\cap B)-(A\\cap C))\\cup((A\\cap C)-(A\\cap B)) \\\\ &amp;=((A\\cap B)\\cap\\sim(A\\cap C))\\cup((A\\cap C)\\cap\\sim(A\\cap B)) \\\\ &amp;=((A\\cap B)\\cap(\\sim A\\cup\\sim C))\\cup((A\\cap C)\\cap(\\sim A\\cup\\sim B)) \\enspace(\\text{分配律拆右边}) \\\\ &amp;=(A\\cap B\\cap\\sim C)\\cup(A\\cap\\sim B\\cap C) \\end{aligned}\\) 所以左边=右边 证毕 下列等式不成立的是 (A) A. \\(A\\cup(B\\times C)=(A\\cup B)\\times(A\\cup C)\\) B. \\(A\\times(B\\cup C)=(A\\times B)\\cup(A\\times C)\\) C. \\((A\\cup B)\\times C=(A\\times C)\\cup(B\\times C)\\) D. \\((A\\cap B)\\times C=(A\\times C)\\cap(B\\times C)\\) 简答: 设 A 和 B 是两个非空集合, \\(A\\times B=B\\times A\\) 吗? 答: 不相等, 除非 A=B, 则成立. 例如 \\(A=\\{1,2\\}\\) , \\(B=\\{3,4\\}\\) \\(A\\times B=\\{&lt;1,3&gt;,&lt;1,4&gt;,&lt;2,3&gt;,&lt;2,4&gt;\\}\\) \\(B\\times A=\\{&lt;3,1&gt;,&lt;3,2&gt;,&lt;4,1&gt;,&lt;4,2&gt;\\}\\) 显然 \\(A\\times B\\neq B\\times A\\) 解释二元关系: 任意集合A、B, A×B 的子集称作 A 到 B 的关系 在一个有 4 个元素的集合上, 可以定义不同的关系个数为 (D) A. \\(2^4\\) B. \\(4^4\\) C. \\(2^{4^4}\\) D. \\(2^{4^2}\\) (序偶有 \\(4^2\\) 种, 把这些序偶视作元素, 能组成 \\(2^{4^2}\\) 种集合) 设 \\(X=\\{0,1,2,3,4,5,6\\}\\) , 其上关系 \\(R=\\{&lt;x,y&gt;|(x&lt;y)\\land (x是质数)\\}\\) , 写出关系 \\(R\\) 中的元素并求出 \\(\\text{dom R}\\) , \\(\\text{ran R}\\) 以及 \\(\\text{FLDR}\\) 解: \\(R=\\{&lt;2,3&gt;,&lt;2,4&gt;,&lt;2,5&gt;,&lt;2,6&gt;,&lt;3,4&gt;,&lt;3,5&gt;,&lt;3,6&gt;,&lt;5,6&gt;\\}\\) \\(\\text{dom R}=\\{2,3,5\\}\\) \\(\\text{ran R}=\\{3,4,5,6\\}\\) \\(\\text{FLDR}=\\{2,3,4,5,6\\}\\) 设 \\(A=\\{1,3,5,7\\}\\) , 定义 A 上的二元关系 \\(R\\) , \\(&lt;a,b&gt;\\in R\\Harr a&lt;b\\) , 称 \\(R\\) 为小于关系, 记为 \\(&lt;\\) , 试求出 \\(R\\) , \\(\\text{dom R}\\) , \\(\\text{ran R}\\) 以及 \\(\\text{FLDR}\\) 解: \\(R=\\{&lt;1,3&gt;&lt;1,5&gt;,&lt;1,7&gt;,&lt;3,5&gt;,&lt;3,7&gt;,&lt;5,7&gt;\\}\\) \\(\\text{dom R}=\\{1,3,5\\}\\) \\(\\text{ran R}=\\{3,5,7\\}\\) \\(\\text{FLDR}=\\{1,3,5,7\\}\\) 设 \\(A=\\{1,2,3\\}\\) , \\(A\\) 的二元关系 \\(R=\\{&lt;2,1&gt;,&lt;2,3&gt;,&lt;1,2&gt;,&lt;3,2&gt;\\}\\) , 则 R 共有的性质是 (B) A. 自反性 B. 对称性 C. 传递性 D. 反对称性 给定 \\(A=\\{1,2,3,4\\}\\) , \\(A\\) 上的二元关系 \\(R=\\{&lt;1,3&gt;,&lt;1,4&gt;,&lt;2,3&gt;,&lt;2,4&gt;,&lt;3,4&gt;\\}\\) , 则 \\(R\\) 满足的性质是 (C) (思路, 一个一个按顺序找, 比如&lt;1,3&gt;, 接下来就找以3开头的序偶看是否满足传递性条件) A. 自反性 B. 对称性 C. 传递性 D. 不可传递性 若关系 \\(R\\) 是反对称的, 当且仅当关系矩阵中主对角线为对称的元素不能同时为1 名词解释: 对称关系 答: 设关于集合 \\(X\\) 的关系 \\(R:X\\) , \\(x,y\\in X\\) , 对于每一个 \\(xRy\\) , 都有 \\(yRx\\) , 则称关系 \\(R\\) 是对称的. 已知集合 \\(A=\\{a,b,c\\}\\) , \\(A\\) 上的二元关系 \\(R_1=\\{&lt;a,b&gt;,&lt;c,b&gt;\\}\\) , \\(R_2=\\{&lt;a,c&gt;,&lt;b,c&gt;\\}\\) , 则 \\(R_1\\circ R_2\\) (A) A. \\(\\{&lt;a,c&gt;,&lt;c,c&gt;\\}\\) B. \\(\\{&lt;a,b&gt;,&lt;b,c&gt;\\}\\) C. \\(\\{&lt;a,c&gt;,&lt;c,a&gt;\\}\\) D. \\(\\{&lt;a,a&gt;,&lt;c,b&gt;\\}\\) 设 \\(A=\\{0,1,2\\}\\) , \\(B=\\{0,2,4\\}\\) , 关系 \\(R=\\{&lt;a,b&gt;|a,b\\in A\\cap B\\}\\) 求 \\(R^{-1}\\) 以及 \\(M_{R^{-1}}\\) 答: (解答题关键步骤要写在答题纸上) \\(A\\cap B=\\{0,2\\}\\) \\(R=\\{&lt;0,0&gt;,&lt;0,2&gt;,&lt;2,0&gt;,&lt;2,2&gt;\\}\\) \\(R^{-1}=\\{&lt;0,0&gt;,&lt;2,0&gt;,&lt;0,2&gt;,&lt;2,2&gt;\\}\\) \\(M_{R^{-1}}=\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\end{bmatrix}\\) 设 \\(A=\\{a,b,c\\}\\) , \\(A\\) 上的二元关系 \\(R=\\{&lt;a,a&gt;&lt;b,b&gt;&lt;a,c&gt;\\}\\) , 则 \\(s(R)\\) 等于 (B) A. \\(R\\cup I_A\\) B. \\(R\\cup\\{&lt;c,a&gt;\\}\\) C. \\(R\\cap I_A\\) D. \\(R\\) 已知集合 \\(A=\\{a,b,c\\}\\) 上关系 \\(R=\\{&lt;a,a&gt;,&lt;a,b&gt;\\}\\) 则 \\(s(R)\\) 等于 (B) A. \\(&lt;a,a&gt;,&lt;b,a&gt;\\) B. \\(&lt;a,a&gt;,&lt;a,b&gt;,&lt;b,a&gt;\\) C. \\(&lt;a,a&gt;,&lt;b,b&gt;,&lt;c,c&gt;\\) D. \\(&lt;a,a&gt;,&lt;a,b&gt;,&lt;b,a&gt;,&lt;b,b&gt;\\) 自反闭包: 设 R:X , 如果另一个关系 R’ 满足: 1. R’ 是自反的; 2. R’⊇R; 3. 对于任何自反的关系 R’‘, 如果 R’‘⊇R , 就有 R’‘⊇R’. 则称 R’ 为 R 的自反闭包. 设 \\(A=\\{1,2,3,4\\}\\) , \\(A\\) 上等价关系 \\(R=\\{&lt;1,2&gt;,&lt;2,1&gt;,&lt;3,4&gt;,&lt;4,3&gt;\\}\\cup I_A\\) 则对应于 \\(R\\) 的 \\(A\\) 的划分是 (D) A. \\(\\{\\{1\\},\\{2,3\\},\\{4\\}\\}\\) B. \\(\\{\\{1,2\\},\\{3\\},\\{4\\}\\}\\) C. \\(\\{\\{1\\},\\{2\\},\\{3\\},\\{4\\}\\}\\) D. \\(\\{\\{1,2\\},\\{3,4\\}\\}\\) 集合 \\(A\\) 上的等价关系 \\(R\\) , 其等价类的集合称为 (C) A. \\(A\\) 与 \\(R\\) 的并集, 记作 \\(A\\cup R\\) B. \\(A\\) 与 \\(R\\) 的交集, 记作 \\(A\\cap R\\) C. \\(A\\) 与 \\(R\\) 的商集, 记作 \\(A/R\\) D. \\(A\\) 与 \\(R\\) 的差集, 记作 \\(A-R\\) 设集合 \\(X=\\{1,2,3,4\\}\\) \\(A_1=\\{\\{1,2,3\\},\\{3,4\\}\\}\\) \\(A_2=\\{\\{1,2\\},\\{3\\}\\}\\) \\(A_3=\\{\\{1\\},\\{2\\},\\{3,4\\}\\}\\) 判断 \\(A_1\\) , \\(A_2\\) , \\(A_3\\) 分别是否是 \\(A\\) 的覆盖? 划分呢? 写出 \\(X\\) 的划分所确立的等价关系 解: \\(A_1\\) , \\(A_3\\) 是覆盖, \\(A_2\\) 既不是覆盖也不是划分, \\(A_3\\) 也是划分 \\(R=\\{&lt;1,1&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;3,4&gt;,&lt;4,3&gt;,&lt;4,4&gt;\\}\\) 给定集合 \\(A\\) 上的关系 \\(R\\) , 若 \\(R\\) 是自反, 对称的, 则称 \\(R\\) 是 \\(A\\) 上的相容关系. 相容关系: 设 R:A , 若 R 是自反的、对称的, 则 R 是相容关系 设 \\(Z\\) 为整数集, 下面哪个序偶不构成偏序集 (A) A. \\(&lt;Z,&lt;&gt;\\) B. \\(&lt;Z,\\leqslant&gt;\\) C. \\(&lt;Z,\\geqslant&gt;\\) D. \\(&lt;Z,/&gt;\\) 已知集合 \\(A=\\{1,2,3,4,5,6\\}\\) , R 是 A 上的整除关系, 则 A 的极小元是 (A) A. 1 B. 2 C. 3 D. 4 设 A 是 18 的 除 1 以外的正因数组成的集合, “/” 为整除关系. 画出 &lt;A, /&gt; (整除), 的哈斯图; 若存在的话, 分别求其最小元, 最大元, 极小元, 极大元, 上界, 下界, 上确界, 下确界 解: \\(A=\\{2,3,6,9,18\\}\\) , \\(\\text{COV}A=\\{&lt;3,2&gt;,&lt;6,3&gt;,&lt;9,6&gt;,&lt;18,9&gt;\\}\\) 哈斯图: 最大元: 18 最小元: 没有 极大元: 18 极小元: 2, 3 上界: 18 下界: 没有 上确界: 18 下确界: 没有 设 \\(X=\\{1,3,4,12,24\\}\\) , R 是 X 的整除关系 求出关系 R 画哈斯图 求子集 \\(\\{3,4,12\\}\\) 的极大元, 最大元, 上界, 上确界 解: \\(R=\\{&lt;1,1&gt;,&lt;1,3&gt;,&lt;1,4&gt;,&lt;1,12&gt;,&lt;1,24&gt;,&lt;3,3&gt;,&lt;3,12&gt;, \\\\ &lt;3,24&gt;,&lt;4,4&gt;,&lt;4,12&gt;,&lt;4,24&gt;,&lt;12,12&gt;,&lt;12,24&gt;,&lt;24,24&gt;\\}\\) 哈斯图: 极大元: 12 最大元: 12 上界: 12, 24 上确界: 12 集合 A 上的拟序关系: 反自反且传递的关系是拟序关系 设 \\(X=\\{1,2,3,4\\}\\) , \\(Y=\\{a,b,c,d\\}\\) (C) (因为 B 中没有 4 的映射) 则下列哪个集合是 \\(X\\to Y\\) 的函数 A. \\(\\{&lt;1,b&gt;,&lt;2,c&gt;,&lt;3,d&gt;,&lt;3,a&gt;\\}\\) B. \\(\\{&lt;1,b&gt;,&lt;2,b&gt;,&lt;3,d&gt;\\}\\) C. \\(\\{&lt;1,b&gt;,&lt;2,d&gt;,&lt;3,a&gt;,&lt;4,d&gt;\\}\\) D. \\(\\{&lt;1,b&gt;,&lt;1,d&gt;,&lt;3,d&gt;,&lt;4,d&gt;,&lt;2,b&gt;\\}\\) 求出从 \\(A=\\{1,2\\}\\) 到 \\(B=\\{x,y\\}\\) 的所有函数, 并列出哪些双射, 哪些满射? 解: \\(f_1=\\{&lt;1,x&gt;,&lt;2,x&gt;\\}\\) \\(f_2=\\{&lt;1,x&gt;,&lt;2,y&gt;\\}\\) \\(f_3=\\{&lt;1,y&gt;,&lt;2,x&gt;\\}\\) \\(f_4=\\{&lt;1,y&gt;,&lt;2,y&gt;\\}\\) 双射: \\(f_2\\) , \\(f_3\\) 满射: \\(f_2\\) , \\(f_3\\) 设 \\(f:\\{1,2\\}\\to\\{1\\}\\) , 则 f 是 (B) A. 入射 B. 满射 C. 双射 D. 非入非满 设 \\(A=\\{0,1\\}\\) , \\(N\\) 是自然数集合, \\(f(x) \\begin{cases} 0 &amp; x\\text{是奇数} \\\\ 1 &amp; x\\text{是偶数} \\end{cases}\\) 若 \\(f:A\\to A\\) . 则 \\(f\\) 是 双射 (填&quot;入&quot;,“满”,“双”) 设 \\(A=\\{1,2,3,4\\}\\) , \\(A\\) 上的关系 \\(R_1=\\{&lt;1,2&gt;,&lt;3,4&gt;,&lt;2,3&gt;,&lt;4,1&gt;\\}\\) , \\(R_2=\\{&lt;1,2&gt;&lt;2,3&gt;,&lt;3,2&gt;\\}\\) 则 \\(R_1\\) , \\(R_2\\) 中是映射的是 (B) A. \\(R_1\\) , \\(R_2\\) B. \\(R_1\\) C. \\(R_2\\) D. 没有 一个映射 \\(f:x\\to y\\) , 如果对于任意 \\(x_i,x_j\\in X\\) . 都有 ___ \\(f(x_i)\\neq f(x_j)\\) ___, 则 \\(f\\) 是入射 设 R 是 A 的等价关系, 在什么条件下, 自然映射 \\(g:A\\to A/R\\) 是双射? 解: 因为 \\(A/R\\) 是等价关系 R 的等价类构成的集合, 即商集 要使映射 \\(g:A\\to A/R\\) 是双射, 则 \\(A/R\\) 与 A 的元素个数必须相等, 因此 R 必须是恒等关系 \\(I_A\\) 若 \\(g\\) , \\(f\\) 是满射, 则 \\(g\\circ f\\) 是满射 代数系统 代数系统: 一个非空集合 A 和定义在该集合上的若干种运算所组成的系统, 记作 \\(&lt;A,f_1,f_2,…,f_k&gt;\\) 例: \\(&lt;N^+,+&gt;\\) 在正整数集合上的加法运算 \\(&lt;P(s),\\cap,\\cup,\\sim&gt;\\) 封闭性: (对于任意的集合中的两个元素, 如果这两元素作某种运算, 运算结果仍在该集合内, 则该运算在这个集合上是封闭的) 设集合 \\(A\\) , 一个从 \\(A^n\\) 到 \\(B\\) 的映射, 称为 \\(A\\) 上的 \\(n\\) 元运算, 如果 \\(B\\subseteq A\\) , 称该 \\(n\\) 元运算是封闭的 另一种定义: 设 * 是集合 A 上的二元运算, 对于 \\(\\forall x,y\\in A\\) , 都有 \\(x*y\\in A\\) , 则称 * 在 A 是封闭的 例: \\(A=\\{2^n|n\\in N\\}\\) \\(2^a\\times2^b\\in A\\) A 是封闭的 \\(2^a+2^b\\notin A\\) A 不是封闭的 交换律: 设 * , \\(\\forall x,y\\in A\\) , 都有 \\(x*y=y*x\\) , 则称 * 是可交换的 结合律: 设 * , \\(\\forall x,y,z\\in A\\) , 都有 \\((x*y)*z=x*(y*z)\\) , 则称 * 是可结合的 分配律: 设 \\(*\\)、\\(\\Delta\\) , \\(\\forall x,y,z\\in A\\) , 都有 \\(x*(y\\Delta z)=(x*y)\\Delta(x*z)\\) , \\((y\\Delta z)*x=(y*x)\\Delta(z*x)\\) 则称 \\(*\\) 对 \\(\\Delta\\) 是可分配的 吸收律: 设 \\(*\\) , \\(\\Delta\\) 是可交换的, 如果 \\(\\forall x,y\\in A\\) , 都有 \\(x*(x\\Delta y)=x\\) \\(x\\Delta(x*y)=x\\) 则称 \\(*\\) , \\(\\Delta\\) 满足吸收律 幺元(单位元): 设 \\(*\\) , \\(\\exist e_l\\) , 对于 \\(\\forall x\\in A\\) , 都有 \\(e_l*x=x\\) , 则称 \\(e_l\\) 为左幺元 都有 \\(x*e_l=x\\) , 则称 \\(e_l\\) 为右幺元 零元: 设 \\(*\\) , 如果他 \\(\\theta_l\\in A\\) , \\(\\forall x\\in A\\) , 都有 \\(\\theta_l*x=\\theta_l\\) 则称 \\(\\theta_l\\) 为左零元 都有 \\(x*\\theta_l=\\theta_l\\) 则称 \\(\\theta_l\\) 为右零元 逆元: 设 \\(*\\) , \\(e\\) 是幺元, 若 \\(b*a=e\\) , 则称 b 是 a 的左逆元, a 是 b 的右逆元 (\\(a\\) 的逆元记作 \\(a^{-1}\\)) 若 b 既是左逆元又是右逆元, 则称 b 是逆元 设 \\(&lt;A,*&gt;\\) , 若 \\(*\\) 是可结合的, 则左逆元等于右逆元且唯一 广群: 设代数系统 \\(&lt;S,*&gt;\\) , 如果 \\(*\\) 是封闭的, 则称 \\(&lt;S,*&gt;\\) 为广群. 半群: 设代数系统 \\(&lt;S,*&gt;\\) , 如果: \\(*\\) 是封闭的 \\(*\\) 是结合的, 即 \\(\\forall a,b,c\\in S\\) , \\((a*b)*c=a*(b*c)\\) 则称 \\(&lt;S,*&gt;\\) 为半群. (半群是一种特殊的广群) 子半群: 设 \\(&lt;S,*&gt;\\) 是半群, \\(B\\subseteq S\\), 若 \\(&lt;B,*&gt;\\) 也是半群, 则 \\(&lt;B,*&gt;\\) 为 \\(&lt;S,*&gt;\\) 的子半群 独异点: 含有幺元的半群 群: 设代数系统 \\(&lt;S,*&gt;\\), 如果: \\(*\\) 是封闭的 \\(*\\) 是结合的 存在幺元 \\(e\\) \\(\\forall x\\in S\\) , 都存在逆元 \\(x^{-1}\\) 则 \\(&lt;S,*&gt;\\) 为群. 群的特性: 设群 \\(&lt;G,*&gt;\\) , 若 \\(G\\) 为有限集, 则有有限解, 若 \\(G\\) 为无限集, 则有无限解. 集合中元素的个数称为基数, 记作 \\(|G|\\) 则 \\(|G|\\) 称为有限群 \\(&lt;G,*&gt;\\) 的阶数 群中不可能有零元. (因为群中每个元素都要有逆元, 但是零元没有逆元) 概念的关系: \\(\\text{广群}\\supset\\text{半群}\\supset\\text{独异点}\\supset\\text{群}\\) 子群: 设群 \\(&lt;G,*&gt;\\) , \\(B\\subseteq G\\) , 如果 \\(&lt;B,*&gt;\\) 也是群, 则 \\(&lt;B,*&gt;\\) 为 \\(&lt;G,*&gt;\\) 的子群 格: 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\) , 如果 \\(A\\) 中每两个元素组成的子集都有最小上界和最大上界, 则称 \\(&lt;A,\\preccurlyeq&gt;\\) 为格. 例: \\(&lt;I_+,/&gt;\\) 是格, 正整数的整除关系是格 (\\(\\forall a,b\\in I_+\\) , 则 \\(a,b\\) 的最小上界是最小公倍数; 最大下界是最大公约数) \\(&lt;P(S),\\subseteq&gt;\\) (幂集上的包含于关系)也是格 格诱导的代数系统: 例: 设 \\(&lt;A,\\preccurlyeq&gt;\\) 是格, 定义运算 \\(a\\lor b\\) 为 \\(a\\) 与 \\(b\\) 的最小上界, \\(a\\land b\\) 为 \\(a\\) 与 \\(b\\) 的最大下界. 则称 \\(&lt;A,\\land,\\lor&gt;\\) 为格 \\(&lt;A,\\preccurlyeq&gt;\\) 诱导的代数系统. 分配格: 设 \\(&lt;A,\\lor,\\land&gt;\\) 是由 \\(&lt;A,\\preccurlyeq&gt;\\) 格诱导的代数系统. \\(\\forall a,b,c\\in A\\). 若 \\(a\\land(b\\lor c)=(a\\land b)\\lor(a\\land c)\\) \\(a\\lor(b\\land c)=(a\\lor b)\\land(a\\lor c)\\) 则称 \\(&lt;A,\\preccurlyeq&gt;\\) 为分配格 例: \\(A=P(S)\\) , \\(S=\\{a,b,c\\}\\) \\(&lt;A,\\cap,\\cup&gt;\\) 是由格 \\(&lt;A,\\subseteq&gt;\\) 诱导的代数系统, 且 \\(&lt;A,\\subseteq&gt;\\) 是分配的 定理: 小于五个元素的格一定是分配格 定理: 每个链都是分配格 定理: 一个格是分配格当且仅当该格不包含和钻石格或五角格同构的子格 例: 钻石格不是分配格! 图中 \\(a\\land(b\\lor c)\\neq(a\\land b)\\lor(a\\land c)\\) 五角格不是分配格! 习题 在实数域 \\(R\\) 上定义运算 \\(*\\) \\(a*b=a+b+2ab\\) , 则 \\(&lt;R,*&gt;\\) 是代数系统 \\(*\\) 满足结合律? \\(&lt;R,*&gt;\\) 有单位元, 求 \\(e\\) \\(&lt;R,*&gt;\\) 每一个元素都有逆元? 任一个元素 a 的逆元是什么? 解: \\(\\forall a,b,c\\in R\\) , 由于 \\((a*b)*c=(a+b+2ab)+c+2c(a+b+2ab)=a+b+2ab+c+2ac+2bc+4abc\\) \\(a*(b*c)=a+(b+c+2bc)+2a(b+c+2bc)=a+b+c+2bc+2ab+2ac+4abc\\) 上面两式结果相等, 所以 \\(*\\) 满足结合律 设单位元为 \\(e\\) \\(\\forall x\\in R\\) , 都有 \\(x*e=x\\) , 即 \\(x+e+2xe=x\\) , \\(e(1+2x)=0\\) , 则 \\(e=0\\) \\(\\forall a\\in R\\) , 设逆元为 \\(b\\) , 则 \\(a*b=e=0\\) , \\(a+b+2ab=0\\) , \\(b=\\frac{-a}{1+2a}\\) 若 \\(a=-\\frac{1}{2}\\) , 则 a 无逆元, 否则 \\(b=a^{-1}=\\frac{-a}{1+2a}\\) (因为这里涉及到分母为 0 的情况, 所以&quot;若 \\(*\\) 是可结合的, 则左逆元等于右逆元且唯一&quot;不适用) 如果一个独异点 \\(&lt;A,*&gt;\\) 满足 A中每个元素都有逆元. 则 \\(&lt;A,*&gt;\\) 为群. 群 \\(&lt;G,*&gt;\\) , 其中 \\(G\\) 为有限集. 则称 \\(&lt;G,*&gt;\\) 为有限群. \\(G\\) 的阶是 G 中元素的个数 设 \\(&lt;G,*&gt;\\) 是群, \\(H\\) 是 \\(G\\) 的非空子集, \\(H\\) 是 \\(G\\) 的子群当且仅当 ___ \\(&lt;H,*&gt;\\) 也是群 ___ 设 \\(G\\) 为无限群, 则 (C) A. \\(G\\) 是交换群 B. \\(G\\) 是循环群 C. \\(G\\) 中每个元素都有逆元 D. \\(G\\) 中每个元素的阶都是无限的 (交换群: 满足交换律的群; 循环群: 群中任何元素可用某一个元素来表示) 设 \\(&lt;H,*&gt;\\) 是群 \\(&lt;G,*&gt;\\) 的子群, \\(&lt;K,*&gt;\\) 是群 \\(&lt;H,*&gt;\\) 的子群. 求证: \\(&lt;K,*&gt;\\) 是 \\(&lt;G,*&gt;\\) 的子群 证明: \\(\\because &lt;H,*&gt;\\) 是群 \\(&lt;G,*&gt;\\) 的子群 \\(\\therefore H\\subseteq G\\) \\(\\because &lt;K,*&gt;\\) 是群 \\(&lt;H,*&gt;\\) 的子群 \\(\\therefore K\\subseteq H\\) \\(\\therefore K\\subseteq G\\) \\(\\because &lt;K,*&gt;\\) , \\(&lt;G,*&gt;\\) 都是群 \\(\\therefore &lt;K,*&gt;\\) 是 \\(&lt;G,*&gt;\\) 的子群 设 \\(Z_4\\) 为模 4 剩余类的集合 \\(Z_4=\\{[0],[1],[2],[3]\\}\\) \\(+_4\\) 为模 4 加法, 写出 \\(&lt;Z_4,+_4&gt;\\) 的运算表并证明 \\(&lt;Z_4,+_4&gt;\\) 为群 (模 4 剩余类即取模 4 后结果为 0、1、2、3 的那些数) (如结果为 0 的数集用 \\([0]=\\{\\dots, 0,4,8,\\dots\\}\\) 表示) 运算表: \\(+_4\\) \\([0]\\) \\([1]\\) \\([2]\\) \\([3]\\) \\([0]\\) \\([0]\\) \\([1]\\) \\([2]\\) \\([3]\\) \\([1]\\) \\([1]\\) \\([2]\\) \\([3]\\) \\([0]\\) \\([2]\\) \\([2]\\) \\([3]\\) \\([0]\\) \\([1]\\) \\([3]\\) \\([3]\\) \\([0]\\) \\([1]\\) \\([2]\\) 证明: \\(&lt;Z_4,+_4&gt;\\) 是代数系统 \\(+_4\\) 是封闭的 \\(+_4\\) 是可结合的 存在幺元 \\([0]\\) \\([0]^{-1}=[0]\\) \\([1]^{-1}=[3]\\) \\([2]^{-1}=[2]\\) \\([3]^{-1}=[1]\\) \\(\\therefore &lt;Z_4,+_4&gt;\\) 是群 设 \\(&lt;G,*&gt;\\) 为群, 定义关系 \\(R\\) 为 \\(G\\times G\\) 的子集. 其中 \\(R=\\{&lt;a,b&gt;|\\exist c\\in G, \\text{使} b=c*a*c^{-1}\\}\\) 试证 \\(R\\) 是 \\(G\\) 上的等价关系. 证明: 只需证得 \\(R\\) 具有自反性、对称性、传递性即可 \\(\\forall a\\in G\\), 有 \\(a=a*e=a*a*a^{-1}\\) 则有 \\(&lt;a,a&gt;\\in R\\) , \\(R\\) 具有自反性 对于 \\(\\forall &lt;a,b&gt;\\in R\\) , \\(\\exist c\\in G\\) , 使 \\(b=c*a*c^{-1}\\) \\(b*c=c*a*c^{-1}*c=c*a*e=c*a \\Harr c^{-1}*b*c=c^{-1}*c*a=a\\) 即 \\(a=c^{-1}*b*c\\) , 运用换元法设 \\(d=c^{-1}\\) , 则 \\(a=d*b*d^{-1}\\) , 因此 \\(&lt;b,a&gt;\\in R\\) , \\(R\\) 具有对称性 \\(\\forall a,b,c\\in G\\) , \\(&lt;a,b&gt;\\in R\\) , \\(&lt;b,c&gt;\\in R\\) 则 \\(\\exist e,f\\in G\\) , 使得 \\(b=e*a*e^{-1}\\) \\(c=f*b*f^{-1}\\) 则 \\(c=f*e*a*e^{-1}*f^{-1}=(f*e)*a*(f*e)^{-1}\\) 则 \\(&lt;a,c&gt;\\in R\\) \\(R\\) 具有传递性 综上, \\(R\\) 是等价关系. 若 \\(&lt;A,\\preccurlyeq&gt;\\) 是 偏序集, 且 A 中每两个元素都有最小上界和最大下界, 则称 \\(&lt;A,\\preccurlyeq&gt;\\) 为格. 格: 若 &lt;A,≼&gt; 是偏序集, 且 A 中每两个元素都有最小上界和最大下界, 则称 &lt;A,≼&gt; 为格. 以下格是分配格的 (C) A. 钻石格 B. 五角格 C. 少于 5 个元素的格 D. 含有与钻石格同构的格 图论 图: \\(G=(V,E)\\) , 图 \\(G\\) 是由顶点集 \\(V\\) 和边集 \\(E\\) 构成的. 其中 \\(E\\) 的每一条边连接顶点集 \\(V\\) 中的一个或两个顶点. 例如: \\(e_2\\) 与 \\(V_2\\) , \\(V_4\\) 关联的. 环(loop): 关联的边只有一个顶点 度数(deg(V)): 与顶点 V 关联的边数, \\(\\displaystyle\\sum_{v\\in V}deg(v)=2|E|\\) . 用 \\(\\Delta(G)\\) 表示图 \\(G\\) 的最大结点度数 入度(\\(deg_-(V)\\)) 出度(\\(deg_+(V)\\)) 性质 \\(\\displaystyle\\sum_{v\\in V}deg_+(v)=\\displaystyle\\sum_{v\\in V}deg_-(v)=|E|\\) 零图: \\(|E|=0\\) 平凡图: \\(|E|=0\\) , \\(|V|=1\\) 有向图(directed G/digraph): 所有的边有方向 无向图(undirected G): 所有的边没有方向 复杂图: 有的边有方向有的边无方向 简单图(无平行边/无环的图) 多重图(有平行边/有环的图) 完全图(\\(C_n^2=\\frac{n(n-1)}{2}\\) 条边 \\(K_n\\)): 所有顶点两两相连 补图(\\(G=k_n-G\\) 只对边作差): 完全图-原图 同构: 设图 G=(V,E) 和 G’=(V’,E’) 如果存在一一对应的映射 \\(g:v_i\\to v_i’\\) , 而且 \\(e=(v_i,v_j)\\) 是 G 的一条边, 当且仅当 \\(e’=(g(v_i),g(v_j))\\) 也是 \\(G’\\) 的一条边, 则称 \\(G\\) 与 \\(G’\\) 同构, 记 \\(G\\cong G’\\) 子图: 设 \\(G=(V,E)\\) , \\(G’=(V’,E’)\\) , \\(V’\\subseteq V\\) , \\(E’\\subseteq E\\) , 则 \\(G’\\) 为 \\(G\\) 的子图 例: \\(G:k_3\\) , 求子图 需要分类讨论: 1 个顶点: 3 个子图 2 个顶点: 0 条边: 3 个子图 1 条边: 3 给子图 3 个顶点: 0 条边: 1 个子图 1 条边: 3 个子图 2 条边: 3 个子图 3 条边: 1 个子图 共计 17 个子图 路: 设图 \\(G=(V,E)\\), 顶点 \\(v_0,v_1,\\dots,v_n\\in V\\) , 边 \\(e_1,e_2,\\dots,e_n\\in E\\) 从 \\(v_0\\) 出发, 沿着 \\(v_0e_1v_1e_2v_2\\dots e_iv_i\\dots e_nv_n\\) 的交替序列称为路(walk) 若 \\(v_0=v_n\\) 称为回路(closed walk) 若 \\(\\forall i\\forall jE_i\\neq E_j\\) 称为迹(trail) 若 \\(\\forall i\\forall jV_i\\neq V_j\\) 称为通路(path) 既是通路又是回路称为圈(cycle) 顶点连通性: 若顶点 \\(u\\) 和 \\(v\\) 至今存在一条路, 则称 \\(u\\) 和 \\(v\\) 是连通的 图的连通性: 给定图 \\(G=(V,E)\\) , 若 \\(\\forall u,v\\in V\\) , \\(u\\) 和 \\(v\\) 都是连通的, 则称图 \\(G\\) 是连通的 连通分支(connected component): 最大连通子图 顶点之间的距离(distance): 两个顶点之间的最短路的长度 图的直径(diameter): 图中顶点间最大距离 \\(D=\\text{max}d(u,v)\\) , \\(u,v\\in V\\) 有向图中: 可达: 从 \\(u\\) 到 \\(v\\) 存在一条路, 则称 \\(u\\) 可达 \\(v\\) 强连通图: 若简单有向图中, 任何一对顶点之间都是相互可达(能去能回)的, 则称该图为强连通图. 弱连通图: 若简单有向图不是强连通的, 但是省略边的方向得到的无向图是连通的, 称该简单有向图是弱连通的. 图的表示: 列举法 画图 矩阵 邻接矩阵 关联矩阵(不考) 可达性矩阵(不考) 邻接矩阵: 设简单图 \\(G=(V,E)\\) , \\(|V|=n\\) , 则构造 \\(A(G)=(a_{ij})_{n\\times m}\\) 为 \\(G\\) 的邻接矩阵, 其中 \\(\\begin{cases} 1 &amp; \\text{当} v_i \\text{邻接} v_j \\\\ 0 &amp; \\text{当} v_i \\text{不邻接} v_j \\end{cases}\\) 计算 \\(v_i\\) 到 \\(v_j\\) 长度为 2 的路有几条? 路的数目 \\(=a_{i0}\\cdot a_{0j}+a_{i1}\\cdot a_{1j}+\\cdots+a_{in}a_{nj}=\\displaystyle\\sum_{k=0}^{n-1} a_{ik}\\cdot a_{kj}\\) 正好可以利用矩阵乘法来算 (矩阵乘法: \\(a_{ij}=\\displaystyle\\sum_{k=0}^{n-1} a_{ik}\\cdot a_{kj}\\) ， 即矩阵中 \\(a_{ij}\\) 元素的值为前者第 i 行的每项分别乘后者第 j 列的对应项再相加) 则 \\(v_i\\) 到 \\(v_j\\) 长度为 \\(n\\) 条边的路有几条可通过 \\(A^n(G)\\) (矩阵的 n 次幂)得到 欧拉路(欧拉通路): 给定一个无向图, 经过图中每条边一次且仅一次的路称为欧拉路. 欧拉回路: 经过每条边一次且仅一次的回路称为欧拉回路. 欧拉路充要条件: 无向图 \\(G\\) 具有欧拉路当且仅当 \\(G\\) 是连通的且有零个或两个奇数度数的顶点(若存在则必须从奇数度数顶点出发). 欧拉回路充要条件: 无向图 \\(G\\) 具有欧拉回路当且仅当 \\(G\\) 是连通的且所有顶点度数都是偶数. (可从任意顶点出发) 欧拉图: 具有欧拉回路的图 平面图(Plane Graph): 设无向图 \\(G=(V,E)\\) , 如果能够把图中所有边画在一个平面上, 使任意两条边都不相交, 则称 \\(G\\) 为平面图. 例子: \\(k_{3,3}\\) (二分图)和 \\(k_5\\) 都不是平面图 库拉托夫斯基定理: 是平面图当且仅当图不包含 \\(k_{3,3}\\) 和 \\(k_5\\) 面: 设连通平面图 \\(G\\) , 若由边包围的区域不包含任何顶点和边, 则该区域称为面. 注意别忘了最外面的面包围的是外面所有区域(不是向里包围), 称为无限面 面的次数 \\(deg(r)\\) : 组成面的边数 定理: 设连通平面图 \\(G\\) , \\(|E|=e\\) , \\(\\sum deg(r)=2e\\) (所有面的次数之和等于边数的 2 倍) 欧拉定理 设 \\(G\\) 是连通平面图， 有 \\(v\\) 个顶点 , \\(e\\) 条边, \\(r\\) 个面. 则 \\(v-e+r=2\\) 定理: 设 \\(G\\) 是一个连通平面图, 有 \\(v\\) 个顶点, \\(e\\) 条边, 若 \\(v\\geqslant 3\\) , 则 \\(e\\leqslant 3v-6\\) 树: 一个连通且无回路的无向图 树叶: \\(deg(v)=1\\) 的结点 内点: \\(deg(v)&gt;1\\) 的结点 森林: 由多棵树组成的图 树的性质: \\(v=e+1\\) 无回路的树增加一条新边, 则得一个且仅一个回路 连通的树删除一条边则不连通 任何两个结点之间仅有一条路 至少有两片树叶 生成树(spanning tree): 包含图 \\(G\\) 全部结点的子图如果是树, 则称该子图为生成树. 在有权重的图中, 若它在所有的生成树中总权重最小, 则称为最小生成树. 有向树: 给树的每一条边加个方向 根树: 如果一颗有向树只有一个顶点入度为 0 其余结点入度均为 1 根: \\(deg_-(v)=0\\) 的结点 叶子: \\(deg_+(v)=0\\) 的结点 内点: \\(deg_+(v)&gt;0\\) 且 \\(deg_-(v)\\neq 0\\) 的结点 \\(n\\) 叉树(\\(m\\) 叉树): 若根树中每个结点的出度小于等于 \\(n\\), 称这颗树为 \\(n\\) 叉树. 若所有结点出度等于 \\(n\\) 或 0, 则称为完全 \\(n\\) 叉树. 习题 图: 图由顶点集 V 和边集 E 构成, 其中 E 中的边连接 V 中的一个或两个顶点 给定下列序列, 哪一个不能构成无向简单图的结点度数序列 (D) (无向简单图度数之和必为偶数) A. (1,1,2,2,4) B. (1,1,2,2,2) C. (2,1,3,3,3) D. (1,3,4,4,5) 设简单图的最大结点度数为 \\(\\Delta(G)\\) , 图中结点数为 \\(n\\) , 则 \\(\\Delta(G)\\) 与 \\(n\\) 的关系 (B) A. \\(\\Delta(G)&gt;n\\) B. \\(\\Delta(G)&lt;n\\) C. \\(\\Delta(G)=n\\) D. \\(\\Delta(G)\\) 与 \\(n\\) 没关系 由 \\(n\\) 个点 0 条边组成的图为 (A) A. 零图 B. 完全图 C. 平凡图 D. 多重图 \\(n\\) 个结点的完全无向图 \\(k_n\\) 的边数为 ___ \\(C_n^2=\\frac{n(n-1)}{2}\\) ___ 在有 3 个结点的图中, 度数是奇数的结点个数为 (D) (度数是奇数的结点个数必为偶数) A. 1 B. 3 C. 1 或 3 D. 0 或 2 不含多重边和环的图, 称为简单图 \\(n\\) 个结点的无向完全图的边数为 (D) A. \\(n(n+1)\\) B. \\(\\frac{n(n+1)}{2}\\) C. \\(n(n-1)\\) D. \\(\\frac{n(n-1)}{2}\\) 含 5 个结点, 4 条边的无向简单图(不同构)的个数为 (B) A. 1 B. 3 C. 6 D. 7 (建议画图) 在 5 阶图 G 中, 若从结点 \\(v_1\\) 到 \\(v_4\\) 存在路, 则从 \\(v_1\\) 到 \\(v_4\\) 必存在通路, 且长度小于等于 (D) (5 阶图就是顶点个数为 5) A. 1 B. 2 C. 3 D. 4 名词解释: 强连通性 有向图中任意两个顶点相互可达 给定有向图 \\(G=(V,E)\\) 如下 试求: 各顶点的出入度 写出 \\(G\\) 的邻接矩阵 利用矩阵计算从点 1 到 4 长度分别是 1,2,3 的路各有几条. 解: 顶点 1 2 3 4 出度 2 2 2 1 入度 0 3 1 3 \\(A(G)=\\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\end{bmatrix}\\) \\(A^2(G)=\\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\end{bmatrix}\\times\\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\end{bmatrix}=\\begin{bmatrix} 0 &amp; 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 2 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\end{bmatrix}\\) \\(A^3(G)=A^2(G)\\times A(G)=\\begin{bmatrix} 0 &amp; 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 2 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\end{bmatrix}\\times\\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\end{bmatrix}=\\begin{bmatrix} 0 &amp; 2 &amp; 1 &amp; 2 \\\\ 0 &amp; 1 &amp; 2 &amp; 2 \\\\ 0 &amp; 2 &amp; 1 &amp; 2 \\\\ 0 &amp; 2 &amp; 0 &amp; 1 \\end{bmatrix}\\) \\(\\therefore\\) 从顶点 1 到 4 长度是 1, 2, 3 的路分别有 1, 1, 2 条. 无向简单图的邻接矩阵: ___ \\(G=(V,E)\\) , \\(|V|=n\\), \\(A(G)=(a_{ij})_{n\\times n}\\) 其中 \\(a_{ij}=\\begin{cases} 1 &amp; v_i \\text{邻接} v_j \\\\ 0 &amp; v_i \\text{不邻接} v_j \\end{cases}\\) ___ 设 \\(M=(a_{ij})\\) 是无向图 \\(G=(V,E)\\) 的邻接矩阵, \\(M^k\\) 中第 \\(i\\) 行 第 \\(j\\) 列的元素值表示, 从 \\(v_i\\) 到 \\(v_j\\) 长度是 \\(k\\) 的路的数目 设无向图 \\(G=(V,E)\\) , 其中 \\(V=\\{1,2,3,4,5\\}\\) , \\(E=\\{(1,2),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)\\}\\) 画出 \\(G\\) 对应的图 求各顶点的度 \\(G\\) 是否具有欧拉回路, 是否具有欧拉通路, 为什么? 如有请写出. 解: 顶点 1 2 3 4 5 度 2 4 3 3 4 没有欧拉回路, 因为有两个奇数度数的顶点. 有欧拉通路. 如 3-4-2-3-5-2-1-5-4 (这里随便举一条欧拉回路即可) 存在欧拉回路的图称为欧拉图 设 \\(G\\) 是连通平面图, \\(G\\) 有 6 个顶点 8 条边, 则 \\(G\\) 的面数 (C) A. 2 B. 3 C. 4 D. 5 连通平面图 \\(G\\) 中, 所有面的次数之和 (C) A. 边数 B. 边数的一半 C. 边数的两倍 D. 边数的已被 若某连通平面图有 4 个顶点, 3 个区域, 则有5条边. 设 \\(G\\) 为一个至少三个结点的连通平面图, 试证: \\(G\\) 中至少有一个结点的度数小于等于 5 证明: (反证法) 设 \\(G=(V,E)\\) , \\(|V|=v\\) , \\(|E|=e\\) 假设 \\(G\\) 中所有结点度数大于等于 6 则 \\(\\displaystyle\\sum_{i=1}^v deg(v_i)=2e\\) (度数之和等于边数两倍) 则 \\(2e\\geqslant 6v\\) 则 \\(e\\geqslant 3v\\) 则 \\(e\\geqslant 3v-6\\) 这与连通平面图应该具有的性质 \\(e\\leqslant 3v-6\\) 矛盾. 所以假设错误 在根树中, 若每个结点的出度小于等于 m, 则称为 \\(m\\) 叉树. 设 \\(T\\) 为根树, 若每个结点的出度都小于等于 m, 则称 T 为 m 叉树. 在根树中, 如果每个结点的出度恰好等于m或零, 则称这棵树为完全 m 叉树.","link":"/zh-cn/learn/mathematics/2020/discrete-mathematics/"},{"title":"senior-high-schoool-mathematics","text":"高中数学的内容 省略了不重要的东西(比如集合、函数奇偶性, 弧度制(曲边三角形)等一些谁都懂的概念) 基于 基础版数学笔记 常见集合 自然数: \\(N\\) , 正整数 \\(N^+\\) , 整数 \\(Z\\) , 有理数 \\(Q\\) , 非零有理数 \\(Q^*\\), 实数 \\(R\\) , 复数 \\(C\\) 函数 基本初等函数 指数函数 (Exponential function) 形如: \\(y=a^x\\enspace\\) (\\(a&gt;0\\) 且 \\(a\\neq 1\\)) 性质: 指数函数恒过定点 (0, 1) \\(\\begin{cases} 0 &lt; a &lt; 1 &amp; \\text{为减函数} \\\\ a &gt; 1 &amp; \\text{为增函数} \\end{cases}\\) 注意: 比较两个数(带有次数)可利用 \\(a^0=1\\) 的特殊性 例: \\(1.7^{0.3}\\) , \\(0.9^{3.1}\\) \\(\\because 1.7^{0.3}&gt;1.7^0=1, 0.9^{3.1} &lt; 0.9^0 = 1 \\\\ \\therefore 1.7^{0.3} &gt; 0.9^{3.1}\\) 对数函数 (Logarithmic function) 形如 \\(y=\\log_ax\\enspace\\) (\\(a &gt; 0\\) , 且 \\(a\\neq 1\\)) 其中 \\(y\\) 叫做以 \\(a\\) 为底的对数, \\(x\\) 叫做真数 性质: 对数函数横过定点 (1, 0) 对数函数公式: (\\(a &gt; 0\\) 且 \\(a \\neq 1\\) , \\(M &gt; 0\\) , \\(N &gt; 0\\)) TODO: 补充这些公式的证明过程 \\(a^{\\log_ab}=b\\) \\(\\log_ab\\cdot\\log_ba=1\\) \\(log_{a^n}b^n=\\log_ab\\) \\(\\log_a(M\\cdot N)=\\log_aM+\\log_aN\\) \\(\\log_a(\\frac M N)=\\log_aM-\\log_aN\\) \\(\\log_aM^n=n\\log_aM\\enspace\\) (\\(n\\in R\\)) \\(\\log_ab=\\frac{\\log_cb}{\\log_ca}\\enspace\\) (\\(c &gt; 0\\) 且 \\(c\\neq 1\\)) (换底公式, 是重点) \\(\\log_{a^N}b^M=\\frac{M}{N}\\log_ab\\) \\(\\begin{cases} 0 &lt; a &lt; 1 &amp; \\text{为减函数} \\\\ a &gt; 1 &amp; \\text{为增函数} \\end{cases}\\) 反函数: 关于直线 \\(y=x\\) 对称的两个函数 求一个函数的反函数, 将该函数的 \\(y\\) 和 \\(x\\) 互换并整理 反函数的定义域为原函数的值域, 反函数的值域为原函数的定义域. 对数函数 \\(y=\\log_ax\\enspace\\) (\\(a&gt;0\\) 且 \\(a\\neq 1\\)) 和指数函数 \\(y=a^x\\enspace\\) (\\(a&gt;0\\) 且 \\(a\\neq 1\\)) 互为反函数 幂函数 (Power function) 幂函数: \\(y=x^a\\enspace\\) (\\(a\\) 为常数) (一般只讨论 \\(a=1,2,3,4,\\frac{1}{2},-1\\) 时的情形) 性质: 在第一象限内: 当 \\(a&gt;0\\) 时, 单调增 当 \\(a&lt;0\\) 时, 单调减 函数单调性判断, 取 \\(x_1&lt;x_2\\) , 判断 \\(f(x_2)-f(x_1)\\) 符号, 大于零为增函数, 小于零为减函数; 也可通过求导判断 函数对称性: \\(f(x)\\) 关于直线 \\(x=a\\) 对称, 则 \\(f(x)=f(2a-x)\\) \\(f(x)\\) 关于点 \\((a,b)\\) 对称, 则 \\(f(x)+f(2a-x)=2b\\) 函数与方程 二次函数 (Quadratic function) 形如 \\(y=ax^2+bx+c\\enspace\\) (\\(a \\neq 0\\)) 性质: 顶点坐标: \\((-\\frac{b}{2a},\\frac{4ac-b^2}{4a})\\) 方程根: \\((\\frac{-b - \\sqrt{\\Delta}}{2a}, 0)和(\\frac{-b + \\sqrt{\\Delta}}{2a}, 0)\\) \\(\\Delta=b^2-4ac\\) 若 \\(\\Delta&gt;0\\) , 函数与 \\(x\\) 轴交于两点 若 \\(\\Delta=0\\) , 函数与 \\(x\\) 轴交于一点 若 \\(\\Delta&lt;0\\) , 函数与 \\(x\\) 轴无公共点 零点: \\(f(x)=0\\) 的时候 \\(x\\) 的值 二分法 (Dichotomy) 对于区间 \\([a,b]\\) 上连续不断且 \\(f(a)\\cdot f(b)&lt;0\\) 的函数 \\(y=f(x)\\) , 通过不断地把函数 \\(f(x)\\) 的零点所在的区间一分为二, 使区间的两个端点逐步逼近零点, 进而得到零点近似值的方法叫二分法 零点存在性质定理: 若 \\(f(x)\\) 在 \\([a,b]\\) 上连续不断, 且 \\(f(x)\\cdot f(b)&lt;0\\) , 则在区间 \\([a,b]\\) 存在变号零点 零点与方程根的关系 (Realtionship between zero point and equation root) 函数 \\(y＝f(x)\\) 有零点说明方程 \\(f(x)＝0\\) 有实数根(几何意义为函数 \\(y＝f(x)\\) 的图象与 \\(x\\) 轴有交点) 三角函数 诱导公式 (Induction formula) “奇变偶不变, 符号看象限” \\(\\begin{cases} \\sin(2k\\pi+\\alpha)=\\sin\\alpha &amp; (k\\in Z) \\\\ \\cos(2k\\pi+\\alpha)=\\cos\\alpha &amp; (k\\in Z) \\\\ \\tan(2k\\pi+\\alpha)=\\tan\\alpha &amp; (k\\in Z) \\end{cases}\\) \\(\\begin{cases} \\sin(\\pi+\\alpha)=-\\sin\\alpha \\\\ \\cos(\\pi+\\alpha)=-\\cos\\alpha \\\\ \\tan(\\pi+\\alpha)=\\tan\\alpha \\end{cases}\\) \\(\\begin{cases} \\sin(-\\alpha)=-\\sin\\alpha \\\\ \\cos(-\\alpha)=\\cos\\alpha \\\\ \\tan(-\\alpha)=-\\tan\\alpha \\end{cases}\\) \\(\\begin{cases} \\sin(\\pi-\\alpha)=\\sin\\alpha \\\\ \\cos(\\pi-\\alpha) =-\\cos\\alpha \\\\ \\tan(\\pi-\\alpha)=-\\tan\\alpha \\end{cases}\\) \\(\\begin{cases} \\sin(\\frac{\\pi}{2}-\\alpha)=\\cos\\alpha \\\\ \\cos(\\frac{\\pi}{2}-\\alpha)=\\sin\\alpha \\\\ \\tan(\\frac{\\pi}{2}-\\alpha)=\\cot\\alpha \\end{cases}\\) \\(\\begin{cases} \\sin(\\frac{\\pi}{2}+\\alpha)=\\cos\\alpha \\\\ \\cos(\\frac{\\pi}{2}+\\alpha)=-\\sin\\alpha \\\\ \\tan(\\frac{\\pi}{2}+\\alpha)=-\\cot\\alpha \\end{cases}\\) 周期性和单调性 (Periodic and monotonic) 周期函数: 对于函数 \\(f(x)\\), 如果 \\(\\exist T\\enspace\\) (\\(T\\neq 0\\)), 使得 \\(\\forall x\\in\\) 定义域, 都有 \\(f(x+T)=f(x)\\) , 那么函数 \\(f(x)\\) 就是一个周期函数 最小正周期: \\(f(x)\\) 的所有周期长度(\\(T,2T,3T,\\dots\\)) 中的最小正数 \\(T\\) 叫做函数 \\(f(x)\\) 的最小正周期 简谐运动 (Simple harmonic motion) 形如 \\(y=A\\sin(wx+\\varphi)+k\\) 的函数 (画这类函数的图像可用五点法) \\(A\\) 为这个简谐运动的振幅(影响函数的值域), \\(k\\) 为基准(影响函数初始高度) (\\(w\\) 影响函数的周期长度)这个简谐运动的周期为 \\(T=\\frac{2\\pi}{w}\\) , 所以频率 \\(f=\\frac{1}{T}=\\frac{w}{2\\pi}\\) \\(wx+\\varphi\\) 称为相位, \\(x=0\\) 时的相位 \\(\\varphi\\) 称为初相(影响函数左右平移) 性质 \\(A=\\frac{y(\\text{max}-\\text{min})}{2}\\) (函数值域长度的一半就是波动的幅度) \\(k=\\frac{y(\\text{max}+\\text{min})}{2}\\) (函数值域的中点就是基准点) 同角三角函数基本关系式 平方关系: \\(\\sin^2\\alpha+\\cos^2\\alpha=1\\) 商关系: \\(\\frac{\\sin\\alpha}{\\cos\\alpha}=\\tan\\alpha\\enspace\\) (\\(\\alpha\\neq k\\pi+\\frac{\\pi}{2}\\) , \\(k \\in Z\\)) 三角恒等变换 和差角公式: \\(\\sin(\\alpha\\pm\\beta)=\\sin\\alpha\\cos\\beta\\pm\\cos\\alpha\\sin\\beta\\) \\(\\cos(\\alpha\\pm\\beta)=\\cos\\alpha\\cos\\beta\\mp\\sin\\alpha\\sin\\beta\\) \\(\\tan(\\alpha\\pm\\beta)=\\frac{\\tan\\alpha\\pm\\tan\\beta}{1\\mp\\tan\\alpha\\cdot\\tan\\beta}\\) 二倍角公式: \\(\\sin2\\alpha=2\\sin\\alpha\\cos\\alpha\\) \\(\\cos2\\alpha=\\cos^2\\alpha-\\sin^2\\alpha=1-2\\sin^2\\alpha=2\\cos^2\\alpha-1\\) 辅助角公式: \\(a\\sin{x}+b\\cos{x}=\\sqrt{a^2+b^2}\\sin(x+\\varphi)=\\sqrt{a^2+b^2}\\cos(x-\\varphi)\\) \\(\\tan\\varphi=\\frac{b}{a}\\) , \\(\\varphi\\) 为辅助角 解三角形 正弦定理: \\(2R=\\frac{a}{\\sin A}=\\frac{b}{\\sin B}=\\frac{c}{\\sin C}\\) 正弦定理推论: \\(2R=\\frac{a+b+c}{\\sin A+\\sin B+\\sin C}\\) , \\((\\frac{a}{\\sin A})^2=\\frac{bc}{\\sin B\\sin C}\\) , \\((\\frac{a}{\\sin A})^3=\\frac{abc}{\\sin A\\sin B\\sin C}\\) 余弦定理: \\(\\begin{cases} a^2=b^2+c^2-2bc\\cos A \\\\ b^2=a^2+c^2-2ac\\cos B \\\\ c^2=a^2+b^2-2ab\\cos C \\end{cases}\\) 余弦定理推论: \\(\\cos{A} = \\frac{b^2 + c^2 - a^2}{2bc}\\) , \\(\\cos{B} = \\frac{a^2 + c^2 - b^2}{2ac}\\) , \\(\\cos{C} = \\frac{a^2 + b^2 - c^2}{2ab}\\) 三角形面积公式: \\(S_\\triangle=\\frac{1}{2}bc\\sin A=\\frac{1}{2}ac\\sin B=\\frac{1}{2}ab\\sin C\\) 解三角形记得判断求出的该角能否为钝(锐)角 (大角对大边, 小角对小边) 导数及其应用 导数的概念及其几何意义 平均变化率: 函数 \\(y=f(x)\\) 从 \\(x_1\\) 到 \\(x_2\\) 的平均变化率为 \\(\\frac{f(x_2)-f(x_1)}{x_2-x_1}=\\frac{\\vartriangle{y}}{\\vartriangle{x}}\\) 瞬时变化率: 函数 \\(y=f(x)\\) 在 \\(x=x_0\\) 处的瞬时变化率是 \\(f^\\prime(x_0)=\\lim\\limits_{x\\to x_0}\\frac{f(x)-f(x_0)}{x-x_0}\\) 几何意义: 导数是函数曲线随 \\(x\\) 轴变化的速度 导数的计算 导数公式: \\((c)^\\prime=0\\enspace\\) (\\(c\\) 为常数) \\((x^a)^\\prime=ax^{a-1}\\enspace\\) (\\(a\\in Q^*\\)) \\((\\sin x)^\\prime=\\cos x\\) \\((\\cos x)^\\prime=-\\sin x\\) \\((a^x)^\\prime=a^x\\ln a\\) \\((\\log_a x)^\\prime=\\frac{1}{x\\ln a}=\\frac{1}{x}\\log_a e\\) \\((e^x)^\\prime=e^x\\) \\(\\ln x=\\frac{1}{x}\\) 导数运算法则: \\([f(x)\\pm g(x)]^\\prime=f^\\prime(x)\\pm g^\\prime(x)\\) \\([f(x)g(x)]^\\prime=f^\\prime(x)g(x)+f(x)g^\\prime(x)\\) \\([\\frac{f(x)}{g(x)}]^\\prime=\\frac{f^\\prime(x)g(x)-f(x)g^\\prime(x)}{[g(x)]^2}\\enspace\\) (\\(g(x)\\neq 0\\)) 复合函数: 对于两个函数 \\(y=f(u)\\) 和 \\(u=g(x)\\) . 如果通过变量 \\(u\\)、\\(y\\)可以表示成一个关于 \\(x\\) 的函数, 那么称这个函数 \\(f(g(x))\\) 为 \\(y=f(u)\\) 和 \\(u=g(x)\\) 的复合函数. 记作\\(y=f(g(x))\\) 复合函数求导: \\(f^\\prime(g(x))=f^\\prime(u)\\cdot g^\\prime(x)\\) 导数在研究函数中的作用 函数的单调性与其导函数的正负有如下关系: 存在函数 \\(y=f(x)\\) , 在某个区间 \\((a,b)\\) 内, 如果 \\(f^\\prime(x)&gt;0\\) , 则该函数在这个区间内单调递增 如果 \\(f^\\prime(x)&lt;0\\) , 则该函数在这个区间内单调递减 利用导数找函数极值点和极值: 首先得 \\(\\exist f^\\prime(a)=0\\) 极小值点: 若在点 \\(x=a\\) 附近, 左侧 \\(f^\\prime(x)&lt;0\\) , 右侧 \\(f^\\prime(x)&gt;0\\) . 则点 \\(a\\) 叫做函数的极小值点 极大值点: 若在点 \\(x=a\\) 附近, 左侧 \\(f^\\prime(x)&gt;0\\) , 右侧 \\(f^\\prime(x)&lt;0\\) . 则点 \\(a\\) 叫做函数的极大值点 求函数 \\(y=f(x)\\) 在区间 \\([a,b]\\) 的最大值与最小值的步骤如下 求函数 \\(y=f(x)\\) 在 \\((a,b)\\) 内的极值 将求到的各极值连同端点处的函数值 \\(f(a)\\)、\\(f(b)\\) 比较. 其中最大的是最大值; 最小的是最小值 定积分与微积分基本定理 微分 先来看看微分的概念 \\(\\mathrm{d}x=\\lim\\limits_{\\varDelta x\\to 0}\\varDelta x\\) 结合导数的定义, 有 \\(f^\\prime(x)=\\dfrac{\\mathrm{d}y}{\\mathrm{d}x}\\rArr\\mathrm{d}y=f^\\prime(x)\\mathrm{d}x\\) 关于微分的公式: \\(\\mathrm{d}f(x)=f^\\prime(x)\\mathrm{d}x\\) \\(\\mathrm{d}(ax+b)=a\\mathrm{d}x\\) 定积分 定积分四部曲: 分割-&gt;近似代替-&gt;求和-&gt;取极限 定积分概念: \\(\\int_a^b f(x)\\mathrm{d}x=\\lim\\limits_{n\\to\\infty}\\displaystyle\\sum_{i=1}^n\\textstyle\\frac{b-a}{n}f(\\xi_i)\\) \\(a\\) 与 \\(b\\) 分别叫做积分下限和积分上限, 组成的区间 \\([a,b]\\) 叫做积分区间 函数 \\(f(x)\\) 叫做被积函数, \\(x\\) 叫做积分变量, \\(f(x)\\mathrm{d}x\\) 叫做被积式 上式中 \\(\\mathrm{d}x\\) 与 \\(\\frac{b-a}{n}\\) 对应, 几何意义为被无穷分割的区间 \\([a,b]\\) 中的一小段, \\(\\xi_i\\) 表示这一小段对应的位置 定积分性质: (线性性质) \\(\\int_a^b kf(x)\\mathrm{d}x=k\\int_a^b f(x)\\mathrm{d}x\\) \\(\\int_a^b[f_1(x)\\pm f_2(x)]\\mathrm{d}x=\\int_a^b f_1(x)\\mathrm{d}x\\pm\\int_a^b f_2(x)\\mathrm{d}x\\) (积分区间的可加性) \\(\\int_a^b f(x)\\mathrm{d}x=\\int_a^c f(x)\\mathrm{d}x+\\int_c^b f(x)\\mathrm{d}x\\enspace\\) (\\(a&lt;c&lt;b\\)) \\(\\int_a^b f(x)\\mathrm{d}x=-\\int_b^a f(x)\\mathrm{d}x\\) 函数值大于等于零时, 积分大于零; 函数值小于等于零时, 积分小于零 \\(f(x)\\geqslant 0\\rArr\\int_a^bf(x)\\mathrm{d}x&gt;0\\) , \\(f(x)\\leqslant 0\\rArr\\int_a^b f(x)\\mathrm{d}x&lt;0\\) 若 \\(f(x)\\) 是奇函数, 则 \\(\\int_{-a}^a f(x)\\mathrm{d}x=0\\) (奇函数沿原点对称, 正好抵消) 若 \\(f(x)\\) 是偶函数, 则 \\(\\int_{-a}^a f(x)\\mathrm{d}x=2\\int_0^a f(x)\\mathrm{d}x\\) (偶函数沿 \\(y\\) 轴对称) 微积分基本定理 一般地, 如果 \\(f(x)\\) 是区间 \\([a, b]\\) 上的连续函数. 并且 \\(\\exist F^\\prime(x)=f(x)\\), 那么 \\(\\int_a^b f(x)\\mathrm{d}x=F(b)-F(a)=F(x)|_a^b=[F(x)+c]|_a^b\\) 这个结论叫做微积分基本定理, 也称牛顿⋅莱布尼茨公式. 数列 等差数列 (Arithmetic progression) 通项公式: \\(a_n=a_1+(n-1)d\\) 前 \\(n\\) 项和: \\(S_n=na_1+\\frac{(n-1)n}{2}d=\\frac{(a_1+a_n)n}{2}\\) 性质: 设等差数列 \\(A,B,C\\) , 若 \\(B\\) 为等差中项, 则有 \\(B=\\frac{A+C}{2}\\) \\(m+n=p+q\\rArr a_m+a_n=a_p+a_q\\enspace\\) (\\(m,n,p,q\\in N^+\\)) 数列的前 \\(n\\) 项和 \\(S_n\\) 和 \\(a_n\\) 的关系 \\(a_n=\\begin{cases} S_1 &amp; n=1 \\\\ S_n-S_{n-1} &amp; n\\geqslant 2 \\end{cases}\\) 等差数列前 \\(n\\) 项和性质: 等差数列 \\(\\{a_n\\}\\) 中, 连续的 \\(n\\) 项之和构成的数列(\\(S_n,S_{2n}-S_n,S_{3n}-S_{2n},S_{4n}-S_{3n},\\dots\\))构成等差为 \\(n^d\\) 的等差数列 等比数列 (Geometric progression) 通项公式: \\(a_n=a_1q^{n-1}\\) 前 \\(n\\) 项和: \\(S_n=\\frac{a_1(1-q^n)}{1-q}=\\frac{a_1-a_nq}{1-q}\\enspace\\) (\\(q\\neq 1\\)) 性质: 设等比数列 \\(A,B,C\\) , 若 \\(B\\) 为等比中项, 则有 \\(B^2=AC\\) \\(k+l=m+n\\rArr a_k\\cdot a_l=a_m\\cdot a_n\\enspace\\) (\\(k,l,m,n\\in N^+\\)) 若 \\(\\{a_n\\} , \\{b_n\\}\\) 是项数相同的等比数列, 且公比分别是 \\(p\\) 和 \\(q\\) 则 \\(\\{\\lambda a_n\\}\\) 的公比为 \\(p\\) , \\(\\{\\frac{1}{a_n}\\}\\) 的公比为 \\(\\frac{1}{p}\\) \\(\\{a_n^2\\}\\) 的公比为 \\(p^2\\) , \\(\\{a_nb_n\\}\\) 的公比为 \\(pq\\) \\(\\{\\frac{a_n}{b_n}\\}\\) 的公比为 \\(\\frac{p}{q}\\) 等比数列前 \\(n\\) 项和性质: 在公比不等于 \\(-1\\) 的等比数列 \\(\\{a_n\\}\\) 中, 连续的 \\(n\\) 项之和构成的数列(\\(S_n,S_{2n}-S_n,S_{3n}-S_{2n},S_{4n}-S_{3n},\\dots\\))构成公比为 \\(q^n\\) 的等比数列 在等比数列中, 当项数为偶数时, 比时有 \\(\\dfrac{S_偶}{S_奇}=q\\) (全部偶数项除以全部奇数项) 其他 求数列(非等差和等比数列)的前 \\(n\\) 项和一般采用错位相减法和裂项相消法. 同时还有分组求和, 并项求和, 倒序相加求和 并项求和: 如 \\(S=-1+2-3+4-5+6+(-1)^n\\) 当 \\(n\\) 为偶 \\(S_n=\\frac{n}{2}\\) 当 \\(n\\) 为奇 \\(S_n=S_{n-1}-n=\\frac{n-1}{2}-n\\) 裂项求和公式: \\(\\frac{1}{n(n+k)}=\\frac{1}{k}(\\frac{1}{n}-\\frac{1}{n+k})\\) (基本裂项式) \\(\\frac{1}{n(n+1)}=\\frac{1}{n}-\\frac{1}{n+1}\\) \\(\\frac{1}{(2n-1)(2n+1)}=\\frac{1}{2}(\\frac{1}{2n-1}-\\frac{1}{2n+1})\\) \\(\\frac{1}{n(n+1)(n+2)}=\\frac{1}{2}(\\frac{1}{n(n+1)}-\\frac{1}{(n+1)(n+2)})\\) \\(\\frac{1}{\\sqrt{a}+\\sqrt{b}}=\\frac{1}{a-b}(\\sqrt{a}-\\sqrt{b})\\) 复数 复数的概念 \\(复数域\\begin{cases} 实数 \\begin{cases} 有理数 \\\\ 无理数 \\end{cases} \\\\ 虚数 \\begin{cases} 纯虚数 \\\\ 非纯虚数 \\end{cases} \\end{cases}\\) 形如 \\(a+bi\\enspace\\) (\\(a,b\\in R\\)) 的数叫做复数, \\(i\\) 叫做复数单位 当 \\(a=0\\) 且 \\(b\\neq0\\) 时. 叫做纯虚数. 虚数 \\(i\\) 的周期性(虚数的周期为 4): \\(i^{4n+1}=i\\) \\(i^{4n+2}=-1\\) \\(i^{4n+3}=-i\\) \\(i^{4n}=1\\) 共轭复数: 一般地, 当两个复数的实部相等, 虚部互为相反数时, 这两个复数互为共轭复数(虚部不等于 0 的两个共轭复数也叫做共轭虚数) 复数的四则运算 复数的乘法运算 \\((a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i\\) 复数的除法运算 \\((a+bi)\\div(c+di)=\\frac{a+bi}{c+di}=\\frac{(a+bi)(c-di)}{(c+di)(c-di)}=\\frac{ac+bd}{c^2-d^2}+\\frac{bc-ad}{c^2-d^2}i\\) 复数的模: 设复数 \\(Z=a+bi\\enspace\\) (\\(a,b\\in R\\)) 对应复平面上的点 \\(Z\\) , 则\\(Z\\) 的模 \\(|Z|=\\|\\vec{OZ}\\|=\\sqrt{a^2+b^2}\\) (即点 \\(Z(a, b)\\) 到原点的距离) 逻辑 常用逻辑用语 命题及其关系 四种命题: 原命题: 若 \\(a\\) , 则 \\(b\\) 逆命题: 若 \\(b\\) , 则 \\(a\\) 否命题: 若非 \\(a\\) , 则非 \\(b\\) 逆否命题: 若非 \\(b\\) , 则非 \\(a\\) 原命题和逆否命题同真同假, 否命题和逆命题同真同假 命题关系: 互逆, 互否, 互为逆否 充分条件: 若 \\(p\\) 能推出 \\(q\\), 则 \\(p\\) 是 \\(q\\) 的充分但不必要条件; 表达式 \\(p\\rArr q\\) , 且 \\(p\\nLeftarrow p\\) 必要条件: 若 \\(q\\) 的结果必定有 \\(p\\) , 则 \\(p\\) 是 \\(q\\) 的必要但不充分条件; 表达式 \\(p\\lArr q\\) , 且 \\(p\\nRightarrow p\\) 逻辑连结词或\\且\\非 或: 符号 \\(p \\lor q\\) , \\(p\\) 或 \\(q\\) 其中任意一个成立, 结果为真 且: 符号 \\(p \\land q\\) , \\(p\\) 和 \\(q\\) 全部成立, 结果才为真 非: 符号 \\(\\lnot p\\), 若 \\(p\\) 不成立, 结果为真 全称量词与存在量词 全称量词: 符号 \\(\\forall\\) . 如 \\(\\forall x\\in M\\) , \\(f(x)\\) 表示&quot;对于函数的任意值(都满足某种条件)&quot; 存在量词: 符号 \\(\\exist\\) . 如 \\(\\exist x\\in M\\) , \\(f(x)\\) 表示&quot;函数存在某个值(满足某种条件)&quot; 推理与证明 合情推理与演绎推理 合情推理(结论不一定可靠) 归纳推理: 由某类事物的部分对象具有某些特征, 推出该类事物的全部对象都具有这些特征的推理, 或者由个别事实概括出一般结论的推理 (部分到整体, 个别到一致) 类比推理: 由两类对象具有某些类似特征和其中一类对象的某些已知特征, 推出另一类对象也具有这些特征的推理(特殊到特殊) 演绎推理 从一般到特殊 在大, 小前提及推理形式都正确的情况下, 结论必正确 &quot;三段论&quot;是演绎推理的一般模式, 包括 大前提(已知的一般原理) 小前提(所研究的特殊情况) 结论(根据一般原理, 对特殊情况做出的判断) 例子: 123大前提: M是P小前提: S是M结论: S是P 直接证明与间接证明 直接证明 综合法 利用已知条件和某些数学定义、公理、定理等, 经过一系列的推理论证, 最后推导出所要证明的结论成立. 特点: 由因导果(顺推) 用 \\(P\\) 表示已知条件、已有的定义、公理、定理等, \\(Q\\) 表示所要证明的结论: \\(P\\rArr Q_1\\rarr Q_1\\rArr Q_2\\rarr Q_2\\rArr Q_3\\rarr\\dots\\rarr Q_n\\rArr Q\\) 分析法 从要证明的结论出发, 逐步寻求使它成立的充分条件, 直至最后, 把要证明的结论归结为判定一个明显成立的条件(已知条件、定义、公理、定理等)为止. 特点: 由果导因(逆推) 用 \\(Q\\) 表示要证明的结论: \\(Q\\lArr P_1\\rarr P_1\\lArr P_2\\rarr P_2\\lArr P_3\\rarr\\dots\\rarr\\) [一个明显成立的条件] 间接证明 反证法 假设原命题不成立(即在原命题条件下, 结论不成立), 经过正确的推理, 最后得出矛盾. 因此说明假设错误, 从而证明了原命题成立. 三个步骤: 反设-&gt;归谬-&gt;存真 数学归纳法 用于证明一个与正整数 \\(n\\) 有关的命题 (归纳奠基)证明当 \\(n\\) 取第一个值 \\(n_0\\enspace\\) (\\(n_0\\in N^+\\)) 时命题成立 (归纳递推)假设 \\(n=k\\enspace\\) (\\(k\\geqslant n_0\\) , \\(k\\in N^+\\)) 时命题成立. 证明当 \\(n=k+1\\) 时命题也成立 算法初步 辗转相除法(求最大公约数) 例: 求 8251 与 6105 的最大公约数 \\(8251=6105\\times 1+2146\\) (6105 与 2146 的公约数也是 8251 与 6105 的公约数) \\(6105=2146\\times 2+1813\\) \\(2146=1813\\times 1+333\\) \\(1813=333\\times 5+148\\) \\(333=148\\times 2+37\\) \\(148=37\\times 4\\) \\(\\therefore\\) 37 是 148 与 37 的最大公约数, 也是 8251 与 6105 的最大公约数 更相减损术(求最大公约数) 方法: 任意给定两个正整数, 判断它们是否都是偶数. 若是, 用 2 约简; 若不是, 执行第二步 以较大的数减去较小的数, 接着把所得的差与较小的数比较, 并以大数减小数. 继续这个操作, 直到所得的数相等为止. 例: 求 98 与 63 的最大公约数 因为 63 不是偶数, 执行第二步 \\(98-63=35\\) \\(63-35=28\\) \\(35-28=7\\) \\(28-7=21\\) \\(21-7=14\\) \\(14-7=7\\) \\(\\therefore\\) 98 和 63 的最大公约数为 7 秦九韶算法 把 \\(f(x)=a_nx^n+a_{n-1}x^{n-1}+\\dots+a_1x+a_0\\) 改写成如下形式 \\(\\begin{aligned} f(x) &amp; =a_nx^n+a_{n-1}x^{n-1}+\\dots+a_1x+a_0 \\\\ &amp; =(a_nx^{n-1}+a_{n-1}x^{n-2}+\\dots+a_1)x+a_0 \\\\ &amp; =((a_nx^{n-2}+a_{n-1}x^{n-3}+\\dots+a_2)x+a_1)x+a_0 \\\\ &amp; =\\dots \\\\ &amp; =(\\dots((a_nx+a_{n-1})x+a_{n-2})x+\\dots+a_1)x+a_0 \\end{aligned}\\) 求多项式的值时, 首先计算内层内一次多项式的值 \\(v_1=a_nx+a_{n-1}\\) \\(v_2=v_1x+a_{n-2}\\) \\(v_3=v_2x+a_{n-3}\\) \\(\\dots\\) \\(v_n=v_{n-1}x+a_0\\) \\(v_n\\) 即为该式的值, 这种算法可以减少大量的幂计算 进位制: 约定满二进一, 就是二进制. 二转十通过按位权展开 十转二通过除二取余法 不等式 分式不等式解法 \\(\\frac{f(x)}{g(x)}&gt;0(\\text{或}&lt;0)\\hArr f(x)\\cdot g(x)&gt;0(\\text{或}&lt;0)\\) \\(\\frac{f(x)}{g(x)}\\geqslant 0(\\text{或}\\leqslant 0)\\hArr\\begin{cases} g(x)\\neq 0 \\\\ f(x)\\cdot g(x)\\geqslant 0(\\text{或}\\leqslant 0) \\end{cases}\\) 二元一次不等式与简单线性规划 二元一次不等式表示平面区域 一般地, 直线 \\(y=kx+b\\) 把平面分成两个部分 \\(y&gt;kx+b\\) 表示直线上方的平面区域; \\(y&lt;kx+b\\) 表示直线下方的平面区域 线性规划 把要求最值的函数称为目标函数 在线性约束条件下求线性目标函数的最值统称为线性规划(即给出一堆限定范围的不等式让你在范围内找出最值) 使目标函数取得最值的可行解叫作这个问题的最优解. “选点法”: 任选一个不在直线上的点. 若满足不等式, 则该点所在的一侧为不等式所表示的平面区域; 否则, 直线另一侧为不等式表示的平面区域 (若直线不过原点, 通常选择原点带入) 简单的线性规划问题 解题思路: 根据题目列出约束条件 (那一堆不等式) 作出目标函数 画出可行域图 (画出约束条件对应的直线, 然后确定每条线规划的平面区域, 它们的重合部分即是满足所有线性要求的区域) 一般来说目标函数的最值在该区域的顶点或边界上取到 基本不等式 定理: 若 \\(a,b\\in R\\) , 则有 \\(a^2+b^2\\geqslant 2ab\\hArr\\frac{a^2+b^2}{2}\\geqslant ab\\) (当且仅当 \\(a=b\\) 时等号成立) 若 \\(a,b&gt;0\\) , 则有 \\(a+b\\geqslant 2\\sqrt{ab}\\hArr\\frac{a+b}{2}\\geqslant\\sqrt{ab}\\) (当且仅当 \\(a=b\\) 时等号成立) 若 \\(a,b,c\\in R\\) , 则有 \\(\\frac{a+b+c}{3}\\geqslant\\sqrt[3]{abc}\\) (当且仅当 \\(a=b\\) 时等号成立) 推论: 若 \\(a,b&gt;0\\) , 则有 \\(\\sqrt{\\frac{a^2+b^2}{2}}\\geqslant\\frac{a+b}{2}\\geqslant\\sqrt{ab}\\geqslant\\frac{2}{\\frac{1}{a}+\\frac{1}{b}}(=\\frac{2ab}{a+b})\\) 基本不等式应用: “一正, 二定, 三相等” 一正 (\\(a,b\\geqslant 0\\)) 二定 (\\(\\sqrt{ab}\\) 定, \\(\\frac{a+b}{2}\\) 有最小值; 反之若 \\(\\frac{a+b}{2}\\) 定, \\(\\sqrt{ab}\\) 有最大值) 三相等 (即 \\(a=b\\)) 不等式大题一般在导数题第二问求恒成立 常用方法: TODO: 补充解法 分离参数法 变换主元法(已知参数的范围求因变量的范围) 不等式选讲 绝对值不等式 绝对值不等式解法: (\\(c&gt;0\\)) \\(|ax+b|\\leqslant c\\hArr -c\\leqslant ax+b\\leqslant c\\) \\(|ax+b|\\geqslant c\\hArr ax+b\\leqslant -c\\) 或 \\(ax+b\\geqslant c\\) 三角不等式: \\(|(|a|-|b|)|\\leqslant|a\\pm b|\\leqslant|a|+|b|\\) 柯西不等式 (Cauchy–Schwarz inequality) 代数形式: 设 \\(a,b,c\\in R\\) , 则 \\((a^2+b^2)(c^2+d^2)\\geqslant(ac+bd)^2\\enspace\\) (当且仅当 \\(ad=bc\\) 时等号成立) 向量形式: 设 \\(\\alpha\\)、\\(\\beta\\) 为平面上的两个向量, 则 \\(\\|\\alpha\\|\\cdot\\|\\beta\\|\\geqslant|\\alpha\\cdot\\beta|\\enspace\\) (当且仅当 \\(\\alpha\\)、\\(\\beta\\) 共线时等号成立) 三角形不等式: 设 \\(x_1,y_2;x_2,y_2;x_3,y_3\\in R\\) , 则 \\(\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}+\\sqrt{(x_2-x_3)^2-(y_2-y_3)^2}\\geqslant\\sqrt{(x_1-x_3)^2+(y_1-y_3)^2}\\) (几何意义为两边之长大于第三边) 柯西不等式可推广为如下一般形式: 设 \\(n\\) 为大于 \\(1\\) 的自然数, \\(a_i\\)、\\(b_i\\enspace\\) (\\(i=1,2,\\dots,n\\)) 为实数, 则 \\(a_1^2+a_2^2+\\dots+a_n^2)(b_1^2+b_2^2+\\dots+b_n^2)\\geqslant(a_1b_1+a_2b_2+\\dots+a_nb_n)^2\\) \\(\\displaystyle\\hArr\\sum_{i=1}^n a_i^2\\cdot\\sum_{i=1}^n b_i^2\\geqslant(\\sum_{i=1}^n a_ib_i)^2\\) 排序不等式 TODO: 向量递归法 设两组实数 \\(a_1,a_2,\\dots,a_n\\) 与 \\(b_1,b_2,\\dots,b_n\\) , 其中 \\(a_1\\leqslant a_2\\leqslant\\dots\\leqslant a_n\\) , \\(b_1\\leqslant b_2\\leqslant\\dots\\leqslant b_n\\) 设 \\(c_1,c_2,\\dots,c_n\\) 为 \\(b_1,b_2,\\dots,b_n\\) 的任意一个排列, 则和数 \\(a_1b_1+a_2b_2+\\dots+a_nb_n\\) 在 \\(a_1,a_2,\\dots,a_n\\) 与 \\(b_1,b_2,\\dots,b_n\\) 同序时最大, 反序时最小 即 \\(a_1b_1+a_2b_2+\\dots+a_nb_n\\geqslant a_1c_1+a_2c_2+\\dots+a_nc_n\\geqslant a_1b_n+a_2b_{n-1}+\\dots+a_nb_1\\) (当且仅当 \\(a_1=a_2=\\dots=a_n\\) 或 \\(b_1=b_2=\\dots=b_n\\) 时等号成立) 伯努利不等式 有 \\(x&gt;-1\\) 当 \\(n\\geqslant 1\\) , 则 \\((1+x)^n\\geqslant 1+nx\\) 当 \\(0\\leqslant n\\leqslant 1\\) , 则 \\((1+x)^n\\leqslant 1+nx\\) 当且仅当 \\(n=0,1\\) 或 \\(x=0\\) 时等号成立 用数学归纳法证明伯努利不等式: (只考虑 \\(n\\geqslant 1\\) 的情况) 当 \\(n=1\\) 时, 代入得 \\(1+x\\geqslant 1+x\\) 显然成立 假设 \\(n=k\\) 时 \\((1+x)^k\\geqslant 1+kx\\) 成立, 那么当 \\(n=k+1\\) 时, 有假设 \\((1+x)^{k+1}\\geqslant 1+(k+1)x\\) 将 \\((1+x)^k\\geqslant 1+kx\\) 两边乘以 \\((1+x)\\) 得到 \\((1+x)^k(1+x)\\geqslant(1+kx)(1+x)\\) 可化为 \\((1+x)^{k+1}\\geqslant kx^2 + 1 + (k+1)x\\) 显然 \\(kx^2 + 1 + (k+1)x\\geqslant 1 + (k+1)x\\) 所以假设 \\((1+x)^{k+1}\\geqslant 1+(k+1)x\\) 成立 平均值不等式 基本不等式可推广到 \\(\\frac{a_1+a_2+\\dots+a_n}{n}\\geqslant\\sqrt[n]{a_1a_2\\dots a_n}\\) (当且仅当 \\(a_1=a_2=\\dots=a_n\\) 时等号成立) \\(\\frac{a_1+a_2+\\dots+a_n}{n}\\) 称为算术平均数 \\(\\sqrt[n]{a_1a_2\\dots a_n}\\) 称为几何平均数 证明不等式的基本方法 比较法 比较法分比差法和比商法, 比差法利用基本事实 \\(a-b&gt;0\\hArr a&gt;b\\) 比商法利用基本事实 \\(\\frac{a}{b}&gt;1\\hArr a&gt;b\\enspace\\) (\\(a,b&gt;0\\)) 综合法 从已知条件出发, 利用不等式的有关性质或定理, 经过推理论证, 最终推导出所要证明的不等式成立. 分析法 从待证不等式出发, 逐步寻求使它成立的充分条件, 直到将待证不等式归结为一个已成立的不等式(已知条件、定理等). 反证法 运用反证法证明不等式, 主要有以下两个步骤: 作出与所证不等式相反的假设; 从条件和假设出发, 应用正确的推理方法, 推出矛盾的结论, 否定假设, 从而证明原不等式成立 放缩法 在证明不等式时, 有时要把所证不等式的一边适当放大或缩小以利于化简, 并使它与不等式的另一边的不等关系更为明显, 从而得出原不等式成立. 这种方法称为放缩法. 证明 \\(A&lt;B\\) , 放大 \\(A\\) , 有 \\(A\\leqslant C\\) , 使得容易证明 \\(C&lt;B\\) 或缩小 \\(B\\) , 有 \\(B\\geqslant C\\) , 使得容易证明 \\(C&gt;A\\) 统计与概率 统计 随机抽样 简单随机抽样: 设一个总体含有N个个体, 从中逐个不放回地抽取n个个体为样本, 如果每次抽取时总体上各个个体被抽到的机会相等. 就把这种抽样方法叫做简单随机抽样. 常用的简单随机抽样法有两种: 抽签法和随机数法 抽签法: 把总体中的N个个体编号, 把号码写在号签上, 将号签放在一个不透明容器中, 搅拌均匀后, 每次从中抽取一个号签. 连续抽取n次, 就得到一个容量为n的样本. 分层抽样: 在抽样时, 将总体分成互不相交的层, 然后按照一定的比例, 从各层独立地抽取一定数量的个体, 将各层取出的个体合在一起作为样本, 这种抽样方法称为分层抽样. 系统抽样: 又叫做等距抽样法. 先分段(分组), 起始段用简单随机抽样再在各段相同位置取得样本. 极差: 一组数据最大值与最小值 组数: \\(\\frac{极差}{组距}\\) 样本分析 频率分布直方图(以面积的形式反映数据落在各小组的频率情况) 小矩形的面积 \\(=\\) 组距 \\(\\times\\frac{\\text{频率}}{\\text{组距}}=\\) 频率 频率分布直方图中, 各小矩形面积之和等于 \\(1\\) 众数: 最高的矩形底边中点的横坐标 中位数: 中位数左边和右边的直方图的面积应该相等 平均数: 每个小矩形面积乘以小矩形底边中点的横坐标之和 频率分布折线图: 将频率分布直方图中各个矩形的上底边的中点连结起来, 就成了频率分布折线图 总体密度曲线: 随着样本容量的增加, 作图时所分的组数增加, 组距减小, 相应的频率折线图会越来越接近一条光滑的曲线, 统计中称这条光滑的曲线为总体密度曲线 茎叶图: 不仅能够保留原始数据, 而且能够展示数据的分布情况 “茎”: 中间的一列数, 从上到下由小到大, 一般用于存放数据中高位上的数 “叶”: 两边分别记录两个组的数据, 由外到内数越来越小, 一般用于存放数据中低位上的数 标准差 \\(S=\\sqrt{\\frac{1}{n}\\sum_{i=1}^n (x_i-\\bar{x})^2}\\enspace\\) (\\(n\\) 为样本中数据个数) 方差 \\(=S^2\\) 计数原理 分类加法和分布乘法计数 分类加法计数原理: 完成一件事可以有两类不同的方法, 方案一有 \\(m\\) 种不同的方法; 方案二有 \\(n\\) 种不同的方法. 那么完成这件事有 \\(N=m+n\\) 种不同方法. 分步乘法计数原理: 完成一件事需要两个步骤, 做第一步有 \\(m\\) 种不同的方法, 做第二步有 \\(n\\) 种不同的方法. 那么完成这件事有 \\(N=mn\\) 种不同方法. 排列与组合 排列: 从\\(n\\) 个不同元素中取出 \\(m\\enspace\\) (\\(m\\leqslant n\\)) , 按照一定的顺序排成一列 (存在互异性、有序性) 排列数: \\(A_n^m=n(n-1)(n-2)\\dots(n-m+1)=\\frac{n!}{(n-m)!}\\enspace\\) (\\(m\\leqslant n\\) ; \\(m,n\\in N^+\\)) 将 \\(n\\) 个不同元素全部取出的一个排列, 记作 \\(A_n^n=n!\\enspace\\) (规定 \\(0! = 1\\)) 组合: 从 \\(n\\) 个不同的元素中取出 \\(m\\enspace\\) (\\(m\\leqslant n\\)) 个元素合成一组(与顺序无关, 只取不排) 组合数: \\(C_n^m=\\frac{A_n^m}{A_m^m}=\\frac{n(n-1)(n-2)\\dots(n-m+1)}{m!}=\\frac{n!}{m!(n-m)!}\\enspace\\) (\\(m\\leqslant n\\) , \\(m,n\\in N^+\\)) 组合式性质公式: \\(\\begin{cases} C_n^m=C_n^{n-m} \\\\ C_{n+1}^m=C_n^m+C_n^{m-1} \\end{cases}\\) 二项式定理 二项式定理: \\((a+b)^n=C_n^0 a^n+C_n^1 a^{n-1}b+C_n^2 a^{n-2}b^2+\\dots+C_n^n b^n\\) 二项式系数的性质(结合&quot;杨辉三角&quot;研究推出) 二项式系数: \\(C_n^k\\enspace\\) (\\(k\\in 1,2,3,\\dots,n\\)) (共有 \\(n+1\\) 项) 对称性: 与首末两端&quot;等距离&quot;的两个二项式系式相等. 直线 \\(r=\\frac{n}{2}\\) 为对称轴将二项式系数所表示出的图像分成对称的两部分 增减性与最大值: \\(k&lt;\\frac{n+1}{2}\\rArr\\) 二项式系数大小递增 \\(k&gt;\\frac{n+1}{2}\\rArr\\) 二项式系数大小递减 \\(n\\) 为偶数时, 其最大的二项式系数为 \\(C_n^{\\frac{n}{2}}\\) \\(n\\) 为奇数时, 其最大的二项式系数为 \\(C_n^{\\frac{n-1}{n}}\\) 和 \\(C_n^{\\frac{n+1}{2}}\\) 各二项式系数的和 \\(C_n^0+C_n^1+C_n^2+\\dots+C_n^n=2^n\\) 统计案例 独立性检验的基本方法: 一般地, 对于两个研究对象 I 和 II, I 有两类取值, 即类 A 和类 B; II 也有两类取值, 即类 1 和类 2. 得到如下列联表所示的抽样数据: II 类1 类2 合计 I 类A a b a+b 类B c d c+d 合计 a+c b+d a+b+c+d 要推断 I 和 II 没有关系, 可按下面步骤进行 第一步提出假设 \\(H_0\\) : “I 和 II 没有关系” 第二步根据 2x2 列联表计算统计量 \\(X^2=\\frac{n(ad-bc)^2}{(a+b)(c+d)(a+c)(b+d)}\\enspace\\) (\\(n=a+b+c+d\\)) 第三步对照下面的临界值表, 作出判断: \\(P(X^2)\\) 0.50 0.40 0.25 0.15 0.10 0.05 0.025 0.010 0.005 0.001 \\(X^2\\) 0.455 0.708 1.323 2.072 2.706 3.841 5.024 6.635 7.879 10.828 若 \\(X^2&gt;10.828\\), 则有 99.9% 的把握认为&quot;I 与 II 有关系&quot;(表中表示有 0.1% 的独立性) 若 \\(X^2&gt;6.635\\), 则有 99% 的把握认为&quot;I 与 II 有关系&quot; 若 \\(X^2&gt;2.706\\), 则有 90% 的把握认为&quot;I 与 II 有关系&quot; 若 \\(X^2\\leqslant 2.706\\), 则认为没有充分的证据显示&quot;I 与 II 有关系&quot;, 但也不能作出结论 \\(H_0\\) 成立, 即 I 与 II 没有关系, 只能说证据不足 变量相关性 散点图: 将变量所对应的点在直角坐标系中标出 正相关和负相关: 依据点的散步方式, 若点排列呈现正比例直线则是正相关, 呈现反比例直线是负相关 回归直线方程 最小平方法(最小二乘法): 如果有 \\(n\\) 个样本点 \\((x_1,y_1),(x_2,y_2),\\dots,(x_n,y_n)\\) , 若要求一条最能拟合这些点的直线 \\(\\hat{y}=bx+a\\) , 可通过下面的表达式: \\([y_1-(a+bx_1)]^2+[y_2-(a+bx_2)]^2+\\dots+[y_n-(a+bx_n)]^2\\) 若上述表达式能取得最小值, 将得到的 \\(a\\)、\\(b\\) 的值带入 \\(\\hat{y}=bx+a\\) 就是所要找的最拟合直线. 线性回归方程: 将上面那条表达式使用配方法化简, 就得到了 \\(\\begin{cases} \\hat{b}=\\frac{\\sum_{i=1}^n (x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n (x_i-\\bar{x})^2}=\\frac{\\sum_{i=1}^n x_iy_i-n\\bar{x}\\bar{y}}{\\sum_{i=1}^n x_i^2-n\\bar{x}^2} \\\\ \\hat{a}=\\bar{y}-\\hat{b}\\bar{x} \\end{cases}\\) 带入即可得目标式 \\(\\hat{y}=\\hat{b}x+\\hat{a}\\) 此方程恒经过样本的 \\((\\bar{x},\\bar{y})\\) , 即样本中心点 TODO: 补充最小二乘法细节 回归分析 相关指数 \\(r\\) \\(r=\\frac{\\sum_{i=1}^n (x_i-\\bar{x})(y_i-\\bar{y})}{\\sqrt{\\sum_{i=1}^n (x_i-\\bar{x})^2\\sum_{i=1}^n (y_i-\\bar{y})^2}}=\\frac{\\sum_{i=1}^n x_iy_i-n\\bar{x}\\bar{y}}{\\sqrt{(\\sum_{i=1}^n x_i^2-n(\\bar{x}^2)(\\sum_{i=1}^n y_i^2-n(\\bar{y})^2)}}\\) \\(r\\) 的性质: \\(|r|\\leqslant 1\\) \\(|r|\\) 越接近 \\(1\\) , \\(x\\)、\\(y\\) 的线性相关程度越强 \\(|r|\\) 越接近 \\(0\\) , \\(x\\)、\\(y\\) 的线性相关程度越弱 概率I 事件与概率 随机事件: 在条件 \\(S\\) 下可能发生也可能不发生的事件 互斥事件 互斥: 若 \\(A\\cap B\\) 为不可能事件(\\(A\\cap B=\\varnothing\\)), 则称事件 \\(A\\) 与事件 \\(B\\) 互斥. (即事件 \\(A\\) 与事件\\(B\\) 不会同时发生) 对立: 若 \\(A\\cap B\\) 为不可能事件但 \\(A\\cup B\\) 为必然事件, 则称事件 \\(A\\) 与事件 \\(B\\) 互为对立事件. (事件 \\(A\\) 与事件 \\(B\\) 在任何一次试验中有且仅有一个发生) 古典概型 基本事件: 在一次实验中可能出现的每一个基本结果 基本事件的特点: 任何两个事件是互斥的 任何事件(除不可能事件)都可以表示成某个或某些基本事件的和 古典概型的两个特点: 所有的基本事件只有有限个 每个基本事件出现的可能性相等 古典概型公式: \\(P(A)=\\frac{事件 A 包含的基本事件的个数}{基本事件的总数}\\) 几何概型 几何概型公式: \\(P(A)=\\frac{构成事件 A 的区域长度}{试验的全部结果所构成的区域长度}\\) 概率II 独立性 条件概率 事件 \\(A\\) 发生的前提下 \\(B\\) 发生的概率: \\(P(B|A)=\\frac{P(AB)}{P(B)}\\) 事件独立性 若\\(P(B|A)=P(B)\\) , 则称事件 \\(A\\)、\\(B\\) 独立 事件独立性性质: 事件 \\(A\\)、\\(B\\) 相互独立, 则 \\(\\bar{A}\\) 与 \\(B\\) , \\(A\\) 与 \\(\\bar{B}\\) , \\(\\bar{A}\\) 与 \\(\\bar{B}\\) 也都相互独立 独立事件一定不互斥, 互斥事件一定不独立 离散型随机变量 随机变量: 如果随机试验的结果可以用一个变量来表示, 那么这样的变量叫做随机变量. 常用字母 \\(X,Y,\\xi,\\eta\\) 表示 离散型随机变量: 所有取值可以一一列出的随机变量 \\(n\\) 次重复试验(伯努利试验) 由 \\(n\\) 次试验构成, 且试验之间相互独立, 每次试验的结果仅有两种对立的状态. 二项分布 在 \\(n\\) 次独立重复试验中, 用 \\(X\\) 表示事件 \\(A\\) 发生的次数, 用 \\(p\\) 表示每次试验中事件 \\(A\\) 发生的概率, 则 \\(A\\) 恰好发生 \\(k\\) 次的概率为: \\(P(X=k)=C_n^k p^k(1-p)^{n-k}\\enspace\\) (\\(k=0,1,2,\\dots,n)\\) 可以理解为一个(发生 \\(k\\) 次同时不发生 \\(k-1\\) 的)事件, 再抽象理解为是一个从 \\(n\\) 个样本中抓取 \\(k\\) 的组合 此时称随机变量 \\(X\\) 服从参数为 \\(n\\)、\\(p\\) 的二项分布; 记作 \\(X\\sim B(n,p)\\) 离散均值和离散方差 一般地若离散型随机变量X的概率分布为 \\(X\\) \\(x_1\\) \\(x_2\\) \\(\\dots\\) \\(x_n\\) \\(P(X)\\) \\(p_1\\) \\(p_2\\) \\(\\dots\\) \\(p_n\\) 期望(离散均值): \\(\\displaystyle\\mu=E(X)=\\sum_{i=1}^n x_ip_i\\) 期望的性质: \\(E(aX+b)=aE(X)+b\\) \\(E(X_1+X_2)=E(X_1)+E(X_2)\\) 若 \\(X_1\\)、\\(X_2\\) 相互独立, 则 \\(E(X_1\\cdot X_2)=E(X_1)\\cdot E(X_2)\\) 两点分布期望 \\(E(X)=p\\) 超几何分布期望 \\(E(X)=\\frac{nM}{N}\\) 二项分布期望 \\(E(X)=np\\) 离散方差: \\(\\displaystyle\\sigma^2=V(X)=\\sum_{i=1}^n (x_i-\\mu)^2p_i\\) 离散方差的性质: \\(V(aX+b)=a^2V(X)\\) \\(V(X)=E(X^2)-[E(X)]^2\\) 两点分布方差 \\(V(X)=p(1-p)\\) 超几何分布 \\(V(X)=\\frac{nM(N-M)(N-n)}{N^2(N-1)}\\) 二项分布 \\(V(X)=np(1-p)\\) 超几何分布 一般地, 在含有 \\(M\\) 件次品的 \\(N\\) 件产品中, 任取 \\(n\\) 件, 其中恰有 \\(x\\) 件次品. \\(P(x=l)=\\frac{C_M^k C_{N-M}^{n-k}}{C_N^n}\\enspace\\) (\\(l=1,2,3,\\dots,n\\) ; \\(n\\leqslant N\\) , \\(M\\leqslant N\\)) 不合格数量恰有 \\(l\\) 件的概率分布表如下表所示: 其中 \\(l=\\text{min}(M,n)\\) \\(X\\) \\(0\\) \\(1\\) \\(2\\) \\(\\dots\\) \\(l\\) \\(P\\) \\(\\frac{C_M^0 C_{N-M}^n}{C_N^n}\\) \\(\\frac{C_M^1 C_{N-M}^{n-1}}{C_N^n}\\) \\(\\frac{C_M^2 C_{N-M}^{n-2}}{C_N^n}\\) \\(\\dots\\) \\(\\frac{C_M^l C_{N-M}^{n-l}}{C_N^n}\\) 此时称随机变量 \\(X\\) 服从参数为 \\(n\\)、\\(M\\)、\\(N\\) 的二项分布, 记作 \\(X\\sim H(n, M, N)\\) 正态分布 正态分布密度曲线: \\(\\varphi_{\\mu,\\sigma}(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}\\enspace\\) (\\(x\\in R\\) , \\(\\sigma&gt;0\\)) 其中实数 \\(\\mu\\) 和 \\(\\sigma\\) 为参数, 如果随机变量 \\(X\\) 服从正态分布记作 \\(X\\sim N(\\mu,\\sigma^2)\\) 正态分布的特点: 曲线位于 \\(x\\) 轴上方, 与 \\(x\\) 轴不相交. 曲线是单峰的, 关于 \\(x=\\mu\\) 对称且在 \\(x=\\mu\\) 达到峰值 \\(\\frac{1}{\\sqrt{2\\pi}\\sigma}\\) 曲线与 \\(x\\) 轴之间的面积为 1 当 \\(\\sigma\\) 一定时, 曲线的位置由 \\(\\mu\\) 确定(左右平移), \\(\\mu\\) 称为位置参数 当 \\(\\mu\\) 一定时, 曲线的形状由 \\(\\sigma\\) 确定, \\(\\sigma\\) 称为形状参数 (\\(\\sigma\\) 越小曲线越瘦高, 意味着总体分布越集中; \\(\\sigma\\) 越大曲线越矮胖, 表示总体的分布越分散) \\(P(\\mu-\\sigma&lt;x\\leqslant\\mu+\\sigma)=0.6826\\) \\(P(\\mu-2\\sigma&lt;x\\leqslant\\mu+2\\sigma)=0.9544\\) \\(P(\\mu-3\\sigma&lt;x\\leqslant\\mu+3\\sigma)=0.9974\\) 因此在实际应用中, 通常认为服从正态分布 \\(N(\\mu,\\sigma^2)\\) 的随机变量只取 \\((\\mu-3\\sigma,\\mu+3\\sigma)\\) 之间, 并简称之 \\(3\\sigma\\) 原则 标准正态分布: \\(\\mu=0,\\sigma=1\\rArr f(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}\\enspace\\) (\\(x\\in R\\)) 几何 立体几何初步 空间几何体 圆柱: \\(S=2\\pi r^2+2\\pi rl=2\\pi r(r+l)\\) , \\(V=\\pi r^2h=S_\\text{底}h\\) 圆锥: \\(S=\\pi r^2+\\pi rl=\\pi r(r+l)\\) , \\(V=\\frac{1}{3}\\pi r^2h=\\frac{1}{3}S_\\text{底}h\\) 圆台: \\(S=\\pi r^2+\\pi r^{\\prime 2}+\\frac{1}{2}(2\\pi r+2\\pi r^\\prime)l=\\pi(r^2+r^{^\\prime 2}+rl+r^\\prime l)\\) , \\(V=\\frac{1}{3}\\pi h(R^2+r^2+Rr)=\\frac{1}{3}h(S_{\\text{下底}}+S^\\prime_{\\text{上底}}+\\sqrt{S_{\\text{下底}}S^\\prime_{\\text{上底}}})\\) 球体: \\(S=4\\pi R^2\\) , \\(V=\\frac{4}{3}\\pi R^2\\) 柱体: \\(S_\\text{侧}=ch\\enspace\\) (\\(c\\) 为底面周长) 正棱锥: \\(S_\\text{侧}=\\frac{1}{2}ch^\\prime\\enspace\\) (\\(h^\\prime\\) 为斜高) 台体: \\(S_\\text{侧}=\\frac{1}{2}(c^\\prime+c)h^\\prime\\enspace\\) (\\(h^\\prime\\) 为斜高) 点线面的位置关系 四大公理 公理1: 如果一直线上两点在一个平面内, 那么这条直线在此平面内 推论: 可用于判定一条直线是否在平面内 可用于判定点是否在平面内 可用于检验平面 公理2: 过不在一直线上的三点, 有且只有一个平面 推论: 经过一条直线和这条直线上一点, 有且只有一个平面 经过两天相交直线, 有且只有一个平面 经过两条平行直线, 有且只有一个平面 公理3: 如果两个不重合的平面有一个公共点, 那么它们有且只有一条过该点的公共直线 推论: 可用于判断两个平面是否相交 可用于判断点是否在直线上: \\(A\\in\\alpha\\) , \\(A\\in\\beta\\) , \\(\\alpha\\cap\\beta=l\\) , 则 \\(A\\in l\\) 公理4 平行与同一条直线的两条直线互相平行 线面平行和垂直 定理1 空间中如果两个角的两边分别对应平行, 那么这两个角相等或互补 (直线、平面平行的判定和性质) 定理2 判定定理(直线与平面): 平面外一条直线与此平面内的一条直线平行, 则该直线与此平面平行 符号语言: \\(a\\nsubseteq\\alpha\\) , \\(b\\subset\\alpha\\) , \\(a\\parallel b\\rArr a\\parallel\\alpha\\) 定理3 判定定理(平面与平面): 一个平面内的两条相交直线与另一个平面平行, 则这两个平面平行 符号语言: \\(a\\subset\\alpha\\) , \\(b\\subset\\alpha\\) , \\(a\\cap b=p\\) , \\(a\\parallel\\beta\\)、\\(b\\parallel\\beta\\rArr\\beta\\parallel\\alpha\\) 定理4 性质定理(直线与平面): 一条直线与一个平面平行, 则过这条直线的任一平面与此平面的交线与该直线平行 符号语言: \\(a\\parallel\\alpha\\) , \\(a\\subset\\beta\\) , \\(\\alpha\\cap\\beta=b\\rArr a\\parallel b\\) 定理5 性质定理(平面与平面): 如果两个平行平面同时与第三个平面相交, 那么它们的交线平行 符号语言: \\(\\alpha\\parallel\\beta\\) , \\(\\alpha\\cap\\gamma=a\\) , \\(\\beta\\cap\\gamma=b\\rArr a\\parallel b\\) (直线、平面垂直的判定) 定理6 判定定理(直线与平面): 一条直线与另一个平面内的两条相交直线垂直, 则该直线与此平面垂直 符号语言: \\(a\\perp b\\) , \\(a\\perp c\\) , \\(b\\subset\\alpha\\) , \\(c\\subset\\alpha\\) , \\(b\\cap c=p\\rArr a\\perp\\alpha\\) 定理7 判定定理(平面与平面): 一个平面过另一个平面的垂线, 则这两个平面垂直 符号语言: \\(a\\perp\\alpha\\) , \\(a\\subset\\beta\\rArr\\alpha\\perp\\beta\\) 定理8 性质定理(直线与平面): 垂直于同一平面的两条直线平行 符号语言: \\(a\\perp\\alpha\\) , \\(b\\perp\\alpha\\rArr a\\parallel b\\) 定理9 性质定理(平面与平面): 两个平面垂直, 则一条平面内垂直于交线的直线与另一个平面垂直 符号语言: \\(\\alpha\\perp\\beta\\) , \\(a\\subset\\alpha\\) , \\(\\alpha\\cap\\beta=b\\) , \\(a\\perp b\\rArr a\\perp\\beta\\) 平面解析几何初步 直线与方程 斜率: 若 \\(A(x_1,y_1)\\) , \\(B(x_2, y_2)\\) 则 \\(AB\\) 所在直线斜率 \\(k_{AB}=\\frac{y_2-y_1}{x_2-x_1}\\) 直线方程的几种形式: 点斜式方程(适用于斜率存在的直线): \\(y-y_0=k(x-x_0)\\) 斜截式方程(适用于斜率存在的直线): \\(y=kx+b\\) 两点式方程(适用于斜率存在的直线): \\(\\frac{y-y_2}{y_1-y_2}=\\frac{x-x_2}{x_1-x_2}\\enspace\\) (\\(x_1\\neq x_2\\) , \\(y_1\\neq y_2\\)) 截距式方程(适用于不平行于坐标系和不过原点的直线): \\(\\frac{x}{a}+\\frac{y}{b}=1\\enspace\\) (\\(a\\neq 0\\) , \\(b\\neq 0\\)) 一般式方程(适用于所有直线): \\(Ax+By+C=0\\) 两点间距离公式 \\(|AB|=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}\\) 点到直线距离公式 \\(d=\\frac{|Ax_0+By_0+C|}{\\sqrt{A^2+B^2}}\\) 平行线间距离公式 设: \\(l_1:Ax+By+C_1=0\\) \\(l_2:Ax+By+C_2=0\\) 则两线距离公式为: \\(\\frac{|C_1-C_2|}{\\sqrt{(A+B)}}\\) 根据斜率判定两条直线平行或垂直 \\(l_1\\parallel l_2\\hArr k_1=k_2\\) 或斜率不存在(此时两直线倾斜角都为 90°) \\(l_1\\perp l_2\\hArr k_1\\cdot k_2=-1\\) 或其中一个斜率为 \\(1\\) , 另一个不存在(其中一条直线倾斜角为 90°) 求已知点 \\(x_1,y_1\\) 关于斜率为 \\(k_1\\) 直线的对称点: 得出与该直线垂直且过点 \\(x_1,y_1\\) 的直线然后代入即可 圆与方程 圆的标准方程: \\((x-a)^2+(y-b)^2=r^2\\rArr\\) 圆心 \\((a,b)\\) 圆的一般方程: \\(x^2+y^2+Dx+Ey+F=0\\enspace\\) (\\(D^2+E^2-4F&gt;0\\)) 半径长: \\(\\frac{1}{2}\\sqrt{D^2+E^2-4F}\\) 圆心: \\((-\\frac{D}{2},-\\frac{E}{2})\\) 直线与圆的位置关系 设有直线 \\(y=kx+b\\) , 圆 \\(x^2+y^2+Dx+Ey+F=0\\) , 点 \\(A(x_1,y_1)\\)、\\(B(x_2,y_2)\\) 为直线与圆的交点, \\((x_0,y_0)\\) 为圆上一点 则 弦长公式 \\(|AB|=\\sqrt{1+k^2}\\sqrt{(x_1+x_2)^2-4x_1x_2}=\\sqrt{1+(\\frac{1}{k})^2}\\sqrt{(y_1+y_2)^2-4y_1y_2}\\) 切线方程 \\(x_0x+y_0y=r^2\\) (圆心在原点上适用) 两圆的位置关系 设 \\(C_1:x^2+y^2+D_1x+E_1y+F_1=0\\) , \\(C_2:x^2+y^2+D_2x+E_2y+F_2=0\\) 且两圆相交于 \\(A\\)、\\(B\\) 两点 则点 \\(A\\)、\\(B\\) 所在的直线方程为: \\((D_1-D_2)x+(E_1-E_2)y+F_1-F_2=0\\) 经过两圆公共点的圆为: \\(x^2+y^2+D_1x+E_1y+F_1-\\lambda(x^2+y^2+D_2x+E_2y+F_2)=0\\enspace\\) (\\(\\lambda\\neq -1\\)) 圆锥曲线与方程 椭圆: 椭圆第二定义: 平面内到定点(焦点)的距离与到定直线(准线)距离之比为常数(离心率)的点的轨叫椭圆. 椭圆的标准方程: \\(\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1\\enspace\\) (\\(a&gt;b&gt;0\\)) , 此时焦点在 \\(x\\) 轴 (哪边分母大焦点就在哪个轴) \\(\\frac{y^2}{a^2}+\\frac{x^2}{b^2}=1\\enspace\\) (\\(a&gt;b&gt;0\\)) , 此时焦点在 \\(y\\) 轴 性质: 焦点在 \\(x\\) 轴, 定点为 \\((-c,0)\\)、\\((c,0)\\) , 顶点为 \\((-a,0)\\)、\\((a,0)\\)、\\((0,-b)\\)、\\((0,b)\\) 焦点在 \\(y\\) 轴, 定点为 \\((0,-c)\\)、\\((0,c)\\) , 顶点为 \\((0,-a)\\)、\\((0,a)\\)、\\((-b,0)\\)、\\((b,0)\\) 存在关系 \\(a^2=b^2+c^2\\) 椭圆准线方程: \\(x=\\pm\\frac{a^2}{c}\\) 或 \\(y=\\pm\\frac{a^2}{c}\\) 离心率 \\(e=\\frac{c}{a}\\enspace\\) (\\(0&lt;e&lt;1\\)) \\(e\\) 越大, 椭圆越扁; \\(e\\) 越小, 椭圆越接近于圆 当椭圆焦点不确定在哪个轴上时可设该方程为 \\(mx^2+ny^2=1\\enspace\\) (\\(m&gt;0,n&gt;0,m\\neq n)\\) 若已知椭圆上一点为 \\(P\\) , \\(\\angle{F_1PF_2}=\\theta\\) , 则有 \\(S_{\\triangle F_1PF_2}=b^2\\tan\\frac{\\theta}{2}\\) 双曲线 (这里讨论的双曲线关于 \\(x\\) 轴、\\(y\\) 轴、原点对称) 双曲线第二定义: 平面内到定点(焦点)的距离到定直线(准线)的距离之比为常数(离心率)的点的迹叫双曲线. 双曲线的标准方程: \\(\\frac{x^2}{a^2}-\\frac{y^2}{b^2}=1\\enspace\\) (\\(a&gt;0\\) , \\(b&gt;0\\)) , 此时焦点在 \\(x\\) 轴 , 渐近线方程为 \\(y=\\pm\\frac{b}{a}x\\enspace\\) (被减数是哪个焦点就在哪个上) \\(\\frac{y^2}{a^2}-\\frac{x^2}{b^2}=1\\enspace\\) (\\(a&gt;0\\) , \\(b&gt;0\\)) , 此时焦点在 \\(y\\) 轴 , 渐近线方程为 \\(y=\\pm\\frac{a}{b}x\\) 性质: 存在关系 \\(c^2=a^2+b^2\\) 离心率 \\(e=\\frac{c}{a}\\enspace\\) (\\(e&gt;1\\)) \\(e\\) 越大, 开口越大; \\(e\\) 越小, 开口越小 等轴双曲线: 实虚轴相等. 此时 \\(e=\\sqrt{2}\\) , 渐近线方程为 \\(y=\\pm x\\) 当双曲线的焦点不确定在哪个轴上时可设方程为 \\(mx^2+ny^2=1\\enspace\\) (\\(mn&lt;0\\)) 若已知双曲线的渐近线方程为 \\(\\frac{x}{a}\\pm\\frac{y}{b}=0\\) , 要求双曲线方程, 可设该双曲线方程为 \\(\\frac{x^2}{a^2}-\\frac{y^2}{b^2}=\\lambda\\enspace\\) (\\(\\lambda\\neq0\\)) 再根据题意求 \\(\\lambda\\) 的值 若已知双曲线上一点为 \\(P\\) , \\(\\angle F_1PF_2=\\theta\\) , 则有 \\(S_{\\triangle F_1PF_2}=b^2\\cot\\frac{\\theta}{2}\\) 双曲线的左(右)焦点到左(右)顶点的距离为该焦点到双曲线的最短距离 直线与双曲线位置关系的处理方法: 联立两方程, 消去 \\(y\\) (或 \\(x\\)) , 得到一元二次方程. 在二次项系数不为 \\(0\\) 的情况下考察方程的判别式 \\(\\varDelta&gt;0\\) 时, 直线与双曲线有两个交点 \\(\\varDelta=0\\) 时, 直线与双曲线有一个交点 \\(\\varDelta&lt;0\\) 时, 直线与双曲线没有交点 抛物线 定义: 抛物线上的点到焦点的距离等于该点到准线的距离 标准方程 焦点 准线 \\(y^2=2px\\enspace\\) (\\(p&gt;0\\)) \\((\\frac{p}{2},0)\\) \\(x=-\\frac{p}{2}\\) \\(y^2=-2px\\enspace\\) (\\(p&gt;0\\)) \\((-\\frac{p}{2},0)\\) \\(x=\\frac{p}{2}\\) \\(x^2=2py\\enspace\\) (\\(p&gt;0\\)) \\((0,\\frac{p}{2})\\) \\(y=-\\frac{p}{2}\\) \\(x^2=-2py\\enspace\\) (\\(p&gt;0\\)) \\((0,-\\frac{p}{2})\\) \\(y=\\frac{p}{2}\\) 性质: (设 \\(y=2px\\enspace\\) (\\(p&gt;0\\)), \\(F\\) 为其焦点, 点 \\(A(x_1,y_1)\\)、\\(B(x_2,y_2)\\) 且\\(AB\\) 为其焦点弦, 弦的倾斜角为 \\(\\theta\\)) 离心率 \\(e=1\\) 以抛物线的焦点弦为直径的圆与抛物线的准线相切 \\(x_1x_2=\\frac{p^2}{4}\\) , \\(y_1y_2=-p^2\\) \\(\\frac{1}{|AF|}+\\frac{1}{|BF|}=\\frac{2}{p}\\) \\(|AB|=x_1+x_2+p\\) \\(|AB|=\\frac{2p}{\\sin{^2\\theta}}\\) \\(S_{\\triangle ABO}=\\frac{p^2}{2\\sin{^2\\theta}}\\) 过 \\(A\\)、\\(B\\) 分别作准线的垂线, 垂足分别为 \\(A_1\\)、\\(B_1\\) 则 \\(A_1F\\perp B_1F\\) 此时 \\(A_1\\)、\\(O\\)、\\(B_1\\) 三点共线 焦点弦中, 通经最短 (指垂直于对称轴的焦点弦, 长为\\(2p\\)) 当题中只有给一个点时, 不知对称性. 可设 \\(x^2=2my\\enspace\\) (\\(m\\neq 0)\\) 或 \\(y^2=2mx\\enspace\\) (\\(m\\neq 0\\)) 向量 平面向量 向量的线性运算 加减: 有三角形法则及平行四边形法则、其满足的运算规律有交换率和结合率 数乘: 规定实数 \\(\\lambda\\) 与 \\(\\vec{a}\\) 的积是一个向量, 这种运算叫做向量的数乘. 记作 \\(\\lambda\\vec{a}\\) 性质: (设实数 \\(\\lambda\\) , 向量 \\(\\vec{a}\\)) 结合律: \\(\\lambda(\\mu\\vec{a})=(\\lambda\\mu)\\vec{a}\\) 分配律: \\((\\lambda+\\mu)\\vec{a}=\\lambda\\vec{a}+\\mu\\vec{a}\\) \\(\\lambda(\\vec{a}+\\vec{b})=\\lambda\\vec{a}+\\lambda\\vec{b}\\) \\(\\lambda(\\vec{a}-\\vec{b})=\\lambda\\vec{a}-\\lambda\\vec{b}\\) \\((-\\lambda)\\vec{a}=-(\\lambda\\vec{a})=\\lambda(-\\vec{a})\\) 向量的坐标表示和基本定理 向量的坐标表示 一个向量的坐标表示一条从原点到此坐标的有向线段(若始点坐标非零则是终点坐标减去始点坐标) 设 \\(\\vec{a}=(x_1,y_1)\\) , \\(\\vec{b}=(x_2,y_2)\\) , 则 \\(\\vec{a}+\\vec{b}=(x_1+x_2,y_1+y_2)\\) \\(\\vec{a}-\\vec{b}=(x_1-x_2,y_1-y_2)\\) \\(\\lambda\\vec{a}=(\\lambda x_1,\\lambda y_1)\\) 正交分解 把一个向量分解成两个相互垂直的向量, 叫做把向量正交分解 \\((x_i,y_i)\\hArr(x_i,0)\\) , \\((0,y_i)\\) 向量共线基本定理 \\(\\vec{a}\\) 与 \\(\\vec{b}\\) 共线(\\(\\vec{a}\\parallel\\vec{b}\\) , \\(\\vec{b}\\neq 0\\)) 当且仅当有唯一实数 \\(\\lambda\\) 使 \\(\\vec{b}=\\lambda\\vec{a}\\) 两向量平行或垂直的判定 设 \\(\\vec{a}=(x_1,y_1)\\) , \\(\\vec{b}=(x_2,y_2)\\) 若 \\(\\vec{a}\\parallel\\vec{b}\\enspace\\) (\\(\\vec{b}\\neq\\vec{0}\\)) \\(\\hArr\\frac{x_1}{x_2}=\\frac{y_1}{y_2}\\hArr x_1y_2-x_2y_1=0\\) (内项积等于外项积) 若 \\(\\vec{a}\\perp\\vec{b}\\hArr\\vec{a}\\cdot\\vec{b}=0\\hArr x_1x_2+y_1y_2=0\\) 数量积 (向量点乘) \\(\\vec{a}\\cdot\\vec{b}=\\|\\vec{a}\\|\\|\\vec{b}\\|\\cos{\\theta}\\) , 其中 \\(\\theta\\) 是 \\(\\vec{a}\\) 与 \\(\\vec{b}\\) 的夹角 性质: 交换律 \\(\\vec{a}\\cdot\\vec{b}=\\vec{b}\\cdot\\vec{a}\\) 当 \\(\\vec{a}\\) 与 \\(\\vec{b}\\) 同向时, \\(\\vec{a}\\cdot\\vec{b}=\\|\\vec{a}\\|\\|\\vec{b}\\|\\) 当 \\(\\vec{a}\\) 与 \\(\\vec{b}\\) 反向时, \\(\\vec{a}\\cdot\\vec{b}=-\\|\\vec{a}\\|\\|\\vec{b}\\|\\) 向量模长的平方 \\(\\|\\vec{a}\\|^2=\\vec{a}\\cdot\\vec{a}\\hArr\\|\\vec{a}\\|=\\sqrt{\\vec{a}\\cdot\\vec{a}}\\) \\(|\\vec{a}\\cdot\\vec{b}|\\leqslant\\|\\vec{a}\\|\\cdot\\|\\vec{b}\\|\\) 若 \\(\\vec{a}=(x_1,y_1)\\) , \\(\\vec{b}=(x_2,y_2)\\) , 则 \\(\\vec{a}\\cdot\\vec{b}=x_1x_2+y_1y_2\\) \\(\\cos\\theta=\\frac{\\vec{a}\\cdot\\vec{b}}{\\|\\vec{a}\\|\\|\\vec{b}\\|}=\\frac{x_1x_2+y_1y_2}{\\sqrt{x_1^2+y_1^2}\\sqrt{x_2^2+y_2^2}}\\) 空间向量 空间向量及其运算 向量共线定理推论: 若 \\(A\\)、\\(B\\)、\\(C\\) 三点共线. 对空间任意一点 \\(P\\) , 都有 \\(\\vec{PC}=\\vec{PA}+\\lambda\\vec{AB}=\\lambda\\vec{PB}+(1-\\lambda)\\vec{PA}\\) 向量共面定理: 若两个向量 \\(\\vec{a}\\)、\\(\\vec{b}\\) 不共线, 则向量 \\(\\vec{p}\\) 与向量 \\(\\vec{a}\\)、\\(\\vec{b}\\) 共面的充要条件是存在 \\((x,y)\\) 使 \\(\\vec{p}=x\\vec{a}+y\\vec{b}\\) 推论: 若 \\(A\\)、\\(B\\)、\\(C\\)、\\(D\\) 四点共面, \\(P\\) 为空间中任意一点 存在有序实数对 \\((x,y)\\) , 使 \\(\\vec{BA}=x\\vec{BC}+y\\vec{BD}\\) 存在有序实数对 \\((x,y)\\) , 使 \\(\\vec{PA}=\\vec{PB}+x\\vec{BC}+y\\vec{BD}\\) 存在 \\(x\\)、\\(y\\)、\\(z\\in R\\) , 使 \\(\\vec{PA}=x\\vec{PB}+y\\vec{PC}+z\\vec{PD}\\enspace\\) (\\(x+y+z=1\\)) 定理: 如果三个变量不共面, 那么对空间任一向量 \\(\\vec{p}\\) , 存在有序实数组 \\(\\{x,y,z\\}\\) 使得 \\(\\vec{p}=x\\vec{a}+y\\vec{b}+z\\vec{c}\\) . 其中集合 \\(\\{\\vec{a},\\vec{b},\\vec{c}\\}\\) 称为空间的一个基底, \\(\\vec{a},\\vec{b},\\vec{c}\\) 称为基向量 空间向量的模长: 若 \\(\\vec{a}=(x,y,z)\\) , 则 \\(\\|\\vec{a}\\|=\\sqrt{x^2+y^2+z^2}\\) 空间向量的数量积: 若 \\(\\vec{a}=(x_1,y_1,z_1)\\)、\\(\\vec{b}=(x_2,y_2,z_2)\\) , 则 \\(\\cos\\text{\\textless}\\vec{a},\\vec{b}\\text{\\textgreater}=\\frac{\\vec{a}\\cdot\\vec{b}}{\\|\\vec{a}\\|\\|\\vec{b}\\|}=\\frac{x_1x_2+y_1y_2+z_1z_2}{\\sqrt{x_1^2+y_1^2+z_1^2}+\\sqrt{x_2^2+y_2^2+z_2^2}}\\) 空间向量的应用 直线的方向向量 设 \\(\\vec{a}\\)、\\(\\vec{b}\\) 分别是直线 \\(l\\)、\\(m\\) 的方向向量 \\(\\vec{a}=\\lambda\\vec{b}\\hArr\\vec{a}\\parallel\\vec{b}\\hArr l\\parallel m\\) \\(\\vec{a}\\cdot\\vec{b}=0\\hArr\\vec{a}\\perp\\vec{b}\\hArr l\\perp m\\) 平面的法向量 如果向量 \\(\\vec{n}\\) 垂直于平面 \\(\\alpha\\), 则向量 \\(\\vec{n}\\) 叫做平面 \\(\\alpha\\) 的法向量 应用: 点面距离向量公式 \\(\\vec{n}\\) 是平面 \\(\\alpha\\) 的法向量, \\(PA\\) 是 \\(\\alpha\\) 的斜线, 则点 \\(P\\) 到 \\(\\alpha\\) 的距离 \\(d=\\frac{|\\vec{n}\\cdot\\vec{PA}|}{\\|\\vec{n}\\|}\\) 直线与平面 设 \\(\\vec{a}\\) 是 \\(l\\) 的方向向量, \\(\\vec{n}\\) 是 \\(\\alpha\\) 的法向量 \\(\\vec{a}=\\lambda\\vec{n}\\hArr\\vec{a}\\parallel\\vec{n}\\hArr l\\perp\\alpha\\) \\(\\vec{a}\\cdot\\vec{n}=0\\hArr\\vec{a}\\perp\\vec{n}\\hArr l\\parallel\\alpha\\) 平面与平面 设 \\(\\vec{u}\\)、\\(\\vec{n}\\) 分别为 \\(\\alpha\\)、\\(\\beta\\) 的法向量 \\(\\vec{u}=\\lambda\\vec{n}\\hArr\\vec{u}\\parallel\\vec{n}\\hArr\\alpha\\parallel\\beta\\) \\(\\vec{u}\\cdot\\vec{n}=0\\hArr\\vec{u}\\perp\\vec{n}\\hArr\\alpha\\perp\\beta\\) 三垂线定理 在平面内的一条直线, 如果和这个平面的一条斜线的射影垂直, 那么它也和这条斜线垂直 符号语言: \\(PO\\perp\\alpha\\) , \\(l\\subset\\alpha\\) , \\(OA\\) 是 \\(PA\\) 在 \\(\\alpha\\) 内的射影. 则 \\(l\\perp OA\\rArr l\\perp PA\\) 三垂线定理的逆定理: 在平面内的一条直线, 如果和这个平面的一条斜线垂直, 那么它也和这条直线在平面内的摄影垂直. 符号语言: \\(PO\\perp\\alpha\\) , \\(l&lt;\\alpha\\) , \\(OA\\) 是 \\(PA\\) 在 \\(\\alpha\\) 内的摄影. 则 \\(l\\perp PA\\rArr l\\perp OA\\) 空间角的求法: 异面直线所成的角 \\((0\\degree,90\\degree]\\) 异面直线 \\(a\\) 与 \\(b\\) 所成角为 \\(\\theta\\) . 且 \\(\\vec{a}\\)、\\(\\vec{b}\\) 分别 \\(a\\)、\\(b\\) 的方向向量 则 \\(\\cos\\theta=|\\cos\\text{\\textless}\\vec{a},\\vec{b}\\text{\\textgreater}|=\\frac{|\\vec{a}\\cdot\\vec{b}|}{\\|\\vec{a}\\|\\|\\vec{b}\\|}\\) 二面角 \\((0\\degree,180\\degree)\\) 二面角 \\(\\theta\\) , \\(\\vec{u}\\)、\\(\\vec{v}\\) 分别是平面 \\(\\alpha\\)、\\(\\beta\\) 的法向量 则 \\(\\cos\\theta=\\cos\\text{\\textless}\\vec{a},\\vec{b}\\text{\\textgreater}=\\frac{\\vec{u}\\cdot\\vec{v}}{\\|\\vec{u}\\|\\|\\vec{v}\\|}\\) (锐二面角) 或 \\(\\cos\\theta=-\\cos\\text{\\textless}\\vec{u},\\vec{v}\\text{\\textgreater}=-\\frac{\\vec{u}\\cdot\\vec{v}}{\\|\\vec{u}\\|\\|\\vec{v}\\|}\\) (钝二面角) 直线与平面所成角 \\((0\\degree,90\\degree]\\) 斜线 \\(PA\\) 与平面 \\(\\alpha\\) 所成角为 \\(\\theta\\) , \\(\\vec{n}\\) 为 \\(\\alpha\\) 的法向量, \\(\\vec{PA}\\) 是斜线 \\(PA\\) 的方向向量 则 \\(\\sin\\theta=|\\cos\\text{\\textless}\\vec{PA},\\vec{n}\\text{\\textgreater}|=\\frac{|\\vec{PA}\\cdot\\vec{n}|}{\\|\\vec{PA}\\|\\|\\vec{n}\\|}\\) 点到直线距离(向量法): 例: 已知直线 \\(l\\) 过点 \\(P(0,0,0)\\) , 其方向向量 \\(\\vec{a}=(1,1,1)\\) , 则点 \\(Q(3,4,5)\\) 到直线的距离为? 解: 点 \\(Q\\) 到直线 \\(l\\) 的距离为 \\(\\sqrt{PQ^2-(\\frac{\\vec{a}\\cdot\\vec{PQ}}{\\|\\vec{a}\\|})^2}=\\sqrt{2}\\) (勾股定理) 坐标系与参数方程 坐标系 伸缩变换: 设点 \\(P(x,y)\\) 是平面直角坐标系中的任意一点, 在变换 \\(\\varphi\\begin{cases} x^\\prime=\\lambda\\cdot x &amp; (\\lambda&lt;0) \\\\ y^\\prime=\\mu\\cdot y &amp; (\\mu&gt;0) \\end{cases}\\) 的作用下, 点 \\(P(x,y)\\) 对应到点 \\(P^\\prime(x^\\prime,y^\\prime)\\) 称 \\(\\varphi\\) 为平面直角坐标系中的坐标伸缩变换, 简称伸缩变换 经过伸缩变换后得到一条关于 \\(x^\\prime,y^\\prime\\) 的曲线方程, 最后要将 \\(x^\\prime,y^\\prime\\) 分别转化为具有普遍意义的 \\(x,y\\), 得到一条关于 \\(x,y\\) 的全新的曲线方程. 极坐标: 在平面内取一个定点 \\(O\\), 叫做极点, 自极点 \\(O\\) 引一条射线 \\(OX\\) , 叫做极轴, 再确定单位长度、角度单位、正方向, 就建立了一个极坐标系. 一般地, 极坐标 \\((P,\\theta)\\) 与 \\((P,\\theta+2k\\pi)\\enspace\\) (\\(k\\in Z\\)) 表示同一个点 特别地, 极点 \\(O\\) 的坐标为 \\((0,\\theta)\\enspace\\) (\\(\\theta\\in R\\)) 和直角坐标系不同, 平面内一个点的极坐标有无数种表示 极坐标与直角坐标的互允公式 互化公式的应用条件: 极点与直角坐标系的原点重合 极轴与直角坐标系的 \\(x\\) 轴正半轴重合 两个坐标系的单位长度相同 极坐标化为直角坐标 \\(\\begin{cases} x=\\rho\\cos\\theta \\\\ y=\\rho\\sin\\theta \\end{cases}\\) 直角坐标化为极坐标: \\(\\begin{cases} \\rho^2=x^2+y^2 \\\\ \\tan\\theta=\\frac{y}{x} \\end{cases}\\) 极坐标内两点的距离公式: 若 \\(A(\\rho_1,\\theta_1)\\) , \\(B(\\rho_2,\\theta_2)\\), 则 \\(|AB|=\\sqrt{\\rho_1^2+\\rho_2^2-2\\rho_1\\rho_2\\cos(\\theta_1-\\theta_2)}\\) 某些题目给出相关信息求极坐标方程可用三角函数进行求解. 取要求的曲线上任一点设为 \\(M(\\rho,\\theta)\\). 结合题意表示出关于变量 \\(\\rho,\\theta\\) 的极坐标方程, 即为题目所求的极坐标方程. 可用此方法推导得出: 设圆心为 \\((\\rho_0,\\theta_0)\\) , 半径为 \\(r\\). 则圆的极坐标方程为 \\(\\rho^2+\\rho_0^2-2\\rho_0\\rho\\cos(\\theta-\\theta_0)=r^2\\) 过点 \\(P(\\rho_1,\\theta_1)\\) 且与极轴所成的角为 \\(\\alpha\\) 的直线的极坐标方程为 \\(\\rho\\sin(\\alpha-\\theta)=\\rho_1\\sin(\\alpha-\\theta_1)\\) 参数方程 参数方程的求法: 建系, 设点 \\((x,y)\\) 选取参数 求出 \\(x,y\\) 与参数之间的表达式 结论 参数方程化为普通方程: 要把参数消去, 还要注意 \\(x,y\\) 的取值范围, 即在消去参数的过程中一定要注意普通方程与参数方程的等价性. 常用的消参技巧: 带入消元, 加减消元, 平方和(差)消元, 三角恒等式消元等 常用消参公式: \\(\\sin^2\\alpha+\\cos^2\\alpha=1\\) , \\((t+\\frac{1}{t})^2-(t-\\frac{1}{t})^2=4\\) 直线的参数方程 经过点 \\(P_0(\\rho_0,\\theta_0)\\) , 且倾斜角为 \\(\\alpha\\) 的直线的标准参数方程为 \\(\\begin{cases} x=x_0+t\\cos\\alpha \\\\ y=y_0+t\\sin\\alpha \\end{cases}\\) (\\(t\\) 为参数) 参数 \\(t\\) 的几何意义是有向线段 \\(P_0P\\) 的位置下标. 即 \\(|t|=P_0P\\) 另一种: 直线的方向向量为 \\(\\vec{P_0P}=(x_0,y_0)\\) , \\(\\begin{cases} x=x_0+at \\\\ y=y_0+bt \\end{cases}\\) (\\(t\\) 为参数) 且\\(|P_0P|=\\sqrt{a^2+b^2}|t|\\) 当 \\(a^2+b^2=1\\) , \\(t=|P_0P|\\) 当 \\(a^2+b^2\\neq 1\\) , \\(t\\) 无明确意义 圆的参数方程 圆心坐标为 \\(M(a,b)\\), 半径 \\(r_0\\) 以圆心为顶点且与 \\(x\\) 轴同向的射线按逆时针方向旋转至角 \\(\\alpha\\) 为参数的圆的参数方程为: \\(\\begin{cases} x=a+r\\cos\\alpha \\\\ y=b+r\\sin\\alpha \\end{cases}\\) (\\(\\alpha\\in[0,2\\pi)\\)) 圆锥曲线的参数方程 椭圆(\\(\\varphi\\) 为离心角) \\(\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1\\enspace\\) (\\(a&gt;b&gt;0\\)) 的一个参数方程为 \\(\\begin{cases} x=a\\cos\\varphi \\\\ y=b\\sin\\varphi \\end{cases}\\) (\\(\\varphi\\) 为参数, \\(a&gt;b&gt;0\\)) \\(\\frac{x^2}{b^2}+\\frac{y^2}{a^2}=1\\enspace\\) (\\(a&gt;b&gt;0\\)) 的一个参数方程为 \\(\\begin{cases} x=b\\cos\\varphi \\\\ y=a\\sin\\varphi \\end{cases}\\) (\\(\\varphi\\) 为参数, \\(a&gt;b&gt;0\\)) 双曲线 \\(\\frac{x^2}{a^2}-\\frac{y^2}{b^2}=1\\enspace\\) (\\(a,b&gt;0\\)) 的一个参数方程为 \\(\\begin{cases} x=a\\sec\\varphi=\\frac{a}{\\cos\\varphi} \\\\ y=b\\tan\\varphi \\end{cases}\\) (\\(\\varphi\\) 为参数, \\(a,b&gt;0\\)) \\(\\frac{y^2}{a^2}-\\frac{x^2}{b^2}=1\\enspace\\) (\\(a,b&gt;0\\)) 的一个参数方程为 \\(\\begin{cases} x=b\\tan\\varphi \\\\ y=a\\sec\\varphi=\\frac{a}{\\cos\\varphi} \\end{cases}\\) (\\(\\varphi\\) 为参数, \\(a,b&gt;0\\)) 抛物线 \\(y^2=2px\\) 的一个参数方程 \\(\\begin{cases} x=2pt^2 \\\\ y=2pt \\end{cases}\\) (\\(t\\) 为参数) 平摆线和渐开线 平摆线: 某一个车轮上的一点 \\(P\\) 因车轮滚动而绘制的轨迹(或称旋轮线) 半径为 \\(r\\) 的车轮周上一点 \\(P\\) 的轨迹的参数方程是 \\(\\begin{cases} x=r(\\theta-\\sin\\theta) \\\\ y=r(1-\\cos\\theta) \\end{cases}\\) (\\(\\theta\\) 为参数) 渐开线: 一条动直线(发生线)沿着一个固定的圆(基圆)作纯滚动时，此动直线上一点的轨迹 参数方程为 \\(\\begin{cases} x=r(\\cos\\theta+\\theta\\sin\\theta) \\\\ y=r(\\sin\\theta-\\theta\\cos\\theta) \\end{cases}\\) (\\(\\theta\\) 为参数)","link":"/zh-cn/learn/mathematics/2020/senior-high-schoool-mathematics/"},{"title":"postgraduate-advanced-mathematics-2","text":"同济高等数学笔记整合(下) 考研用 基于 wmathor/Postgraduate-Advanced-Mathematics 建议先看一看 Introduction to Linear Algebra - Determinant 补充了级数部分的内容 向量代数与空间解析几何 向量及其线性运算 定义 向量: 有大小, 有方向. 向量由大小(长度)及方向唯一确定, 与位置无关的向量称为自由向量 向量相等: 若 \\(\\vec{a}\\)、\\(\\vec{b}\\) 方向相同且长度相同, 称 \\(\\vec{a}\\)、\\(\\vec{b}\\) 相等, 记 \\(\\vec{a}\\)、\\(\\vec{b}\\) 向量的模: 设 \\(\\vec{a}\\) 为一个向量, 其长度记为 \\(|\\vec{a}|\\) 若 \\(|\\vec{a}|=0\\) , 称 \\(\\vec{a}\\) 为零向量, 记 \\(\\vec{a}=\\vec{0}\\) (零向量的方向不确定) 若 \\(|\\vec{a}|=1\\) , 称 \\(\\vec{a}\\) 为单位向量 向量的夹角: 设 \\(\\vec{a}\\)、\\(\\vec{b}\\) , 如图 \\(\\vec{a}\\)、\\(\\vec{b}\\) 夹角为 \\(\\theta\\) , 记 \\((\\widehat{\\vec{a},\\vec{b}})=\\theta\\enspace\\) (\\(0\\leqslant\\theta\\leqslant\\pi\\)) 向量的线性运算 加法: \\(\\vec{a}+\\vec{b}=\\vec{b}+\\vec{a}\\) \\(\\vec{a}+(\\vec{b}+\\vec{c})=(\\vec{a}+\\vec{b})+\\vec{c}\\) 平行四边形法则和三角形法则: 减法: \\(\\vec{a}-\\vec{b}=\\vec{a}+(-\\vec{b})\\) 空间直角坐标系 \\(x\\)、\\(y\\)、\\(z\\) 顺序无所谓, 但必须逆时针排列 \\(z&gt;0\\) \\(z&lt;0\\) \\(x-y\\) 平面 第一卦限 第五卦限 \\(x&gt;0\\) , \\(y&gt;0\\) 第二卦限 第六卦限 \\(x&lt;0\\) , \\(y&gt;0\\) 第三卦限 第七卦限 \\(x&lt;0\\) , \\(y&lt;0\\) 第四卦限 第八卦限 \\(x&gt;0\\) , \\(y&lt;0\\) 空间向量的正交分解: 则有 \\(\\overrightarrow{OM}=\\{a,b,c\\}=a\\vec{i}+b\\vec{j}+c\\vec{k}\\) \\(\\vec{i}\\) 为 \\(x\\) 轴正方向的单位向量 \\(\\overrightarrow{OA}=a\\vec{i}\\) \\(\\vec{j}\\) 为 \\(y\\) 轴正方向的单位向量 \\(\\overrightarrow{OB}=b\\vec{j}\\) \\(\\vec{k}\\) 为 \\(z\\) 轴正反向的单位向量 \\(\\overrightarrow{OC}=c\\vec{k}\\) 向量线性运算的代数描述 设 \\(\\vec{a}=\\{a_1,b_1,c_1\\}\\) , \\(\\vec{b}=\\{a_2,b_2,c_2\\}\\) \\(\\vec{a}+\\vec{b}=\\{a_1+a_2,b_1+b_2,c_1+c_2\\}\\) \\(\\vec{a}-\\vec{b}=\\{a_1-a_2,b_1-b_2,c_1-c_2\\}\\) \\(k\\vec{a}=\\{ka_1,kb_1,kc_1\\}\\) 向量的模, 方向角, 方向余弦. 在坐标轴上的投影 向量的模 设 \\(\\vec{a}=\\{a_1,b_1,c_1\\}\\), 则 \\(\\vec{a}\\) 的模 \\(|\\vec{a}|=\\sqrt{a_1^2+b_1^2+c_1^2}\\) (空间勾股定理) 对应单位向量 设 \\(\\vec{a}=\\{a_1,b_1,c_1\\}\\neq\\vec{0}\\) , \\(\\vec{a}\\) 对应的单位向量记为 \\(\\vec{a}^0\\) \\(\\vec{a}^0=\\frac{1}{|\\vec{a}|}\\cdot\\vec{a}=\\frac{1}{\\sqrt{a_1^2+b_1^2+c_1^2}}\\cdot\\{a_1,b_1,c_1\\}=\\{\\frac{a_1}{\\sqrt{a_1^2+b_1^2+c_1^2}},\\frac{b_1}{\\sqrt{a_1^2+b_1^2+c_1^2}},\\frac{c_1}{\\sqrt{a_1^2+b_1^2+c_1^2}}\\}\\) 方向角和方向余弦 设 \\(\\vec{a}=\\{a_1,b_1,c_1\\}\\neq\\vec{0}\\) , \\(\\vec{a}\\) 与 \\(x\\)、\\(y\\)、\\(z\\) 轴正方向的夹角称为方向角, 记 \\(\\alpha\\)、\\(\\beta\\)、\\(\\gamma\\) 称 \\(\\cos\\alpha\\)、\\(\\cos\\beta\\)、\\(\\cos\\gamma\\) 为 \\(\\vec{a}\\) 的方向余弦 \\(\\because\\cos\\alpha=\\frac{a_1}{|\\vec{a}|}=\\frac{a_1}{\\sqrt{a_1^2+b_1^2+c_1^2}},\\cos\\beta=\\frac{b_1}{|\\vec{a}|}=\\frac{b_1}{\\sqrt{a_1^2+b_1^2+c_1^2}},\\cos\\gamma=\\frac{c_1}{|\\vec{a}|}=\\frac{c_1}{\\sqrt{a_1^2+b_1^2+c_1^2}}\\) \\(\\therefore\\{\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\}=\\vec{a}^0=\\frac{\\vec{a}}{|\\vec{a}|}\\) 推论: \\(\\cos^2\\alpha+\\cos^2\\beta+\\cos^2\\gamma=1\\) 向量在坐标轴上的投影 \\(\\overrightarrow{A_1B_1}\\) 称为 \\(\\overrightarrow{AB}\\) 在 \\(u\\) 轴上的投影向量, \\(\\overrightarrow{A_1B_1}=(x_2-x_1)\\vec{e}\\) \\(A_1B_1=x_2-x_1\\) 称为 \\(\\overrightarrow{AB}\\) 在 \\(u\\) 轴上的投影, 记 \\(Pr j_u\\overrightarrow{AB}\\) 设 \\(\\overrightarrow{AB}\\) 与 \\(u\\) 轴夹角为 \\(\\theta\\) , 则 \\(Pr j_u\\overrightarrow{AB}=|\\overrightarrow{AB}|\\cdot\\cos\\theta\\) 向量的数量积与向量积 向量的数量积(参与运算的是向量, 结果是数) 产生的背景: 做功 \\(W=|\\vec{F}|\\cdot\\cos\\theta\\cdot|\\overrightarrow{AB}|=|\\vec{F}|\\cdot|\\overrightarrow{AB}|\\cdot\\cos(\\widehat{\\overrightarrow{AB},\\vec{F}})\\hArr\\vec{F}\\cdot\\overrightarrow{AB}\\) 向量的数量积定义(几何) \\(\\vec{a}\\cdot\\vec{b}\\) 称为 \\(\\vec{a}\\) 与 \\(\\vec{b}\\) 的数量积 \\(\\vec{a}\\cdot\\vec{b}=|\\vec{a}|\\cdot|\\vec{b}|\\cdot\\cos(\\widehat{\\vec{a},\\vec{b}})\\) 性质 \\(\\vec{a}\\cdot\\vec{b}=\\vec{b}\\cdot\\vec{a}\\) \\(\\vec{a}\\cdot\\vec{a}=|\\vec{a}|^2\\) \\(\\vec{a}\\cdot\\vec{b}=0\\hArr\\vec{a}\\perp\\vec{b}\\) \\(\\vec{a}\\cdot\\vec{a}=0\\hArr\\vec{a}=\\vec{0}\\) 向量数量积的代数描述 设 \\(\\vec{a}=\\{a_1,b_1,c_1\\}=a_1\\vec{i}+b_1\\vec{j}+c_1\\vec{k}\\) \\(\\vec{b}=\\{a_2,b_2,c_2\\}=a_2\\vec{i}+b_2\\vec{j}+c_2\\vec{k}\\) 则 \\(\\vec{a}\\cdot\\vec{b}=(a_1\\vec{i}+b_1\\vec{j}+c_1\\vec{k})\\cdot(a_2\\vec{i}+b_2\\vec{j}+c_2\\vec{k})=a_1a_2+b_1b_2+c_1c_2\\) (推导思路: \\(\\vec{i}\\)、\\(\\vec{j}\\)、\\(\\vec{k}\\) 三个向量为正交单位向量, 互相乘的值为零) 推论: \\(\\vec{a}\\cdot\\vec{b}=0\\hArr\\vec{a}\\perp\\vec{b}\\hArr a_1a_2+b_1b_2+c_1c_2=0\\) 向量的向量积(参与运算的是向量, 结果还是向量) 产生的背景: 法向量(垂直于某一平面的向量) 向量的向量积定义 \\(\\vec{a}\\times\\vec{b}\\) 称为 \\(\\vec{a}\\)、\\(\\vec{b}\\) 的向量积 几何刻划: \\(\\vec{a}\\times\\vec{b}\\begin{cases} \\text{方向:右手准则(拇指食指中指分别对应}\\vec{a},\\vec{b},\\vec{c}) \\\\ \\text{大小:}|\\vec{a}\\times\\vec{b}|=|\\vec{a}|\\cdot|\\vec{b}|\\cdot\\sin(\\widehat{\\vec{a},\\vec{b}}) \\end{cases}\\) 代数刻划: 设 \\(\\vec{a}=\\{a_1,b_1,c_1\\}=a_1\\vec{i}+b_1\\vec{j}+c_1\\vec{k}\\) \\(\\vec{b}=\\{a_2,b_2,c_2\\}=a_2\\vec{i}+b_2\\vec{j}+c_2\\vec{k}\\) 则 $$ \\vec{a}\\times\\vec{b}=\\{b_1c_2-b_2c_1,a_2c_1-a_1c_2,a_1b_2-a_2b_1\\}=\\{ \\begin{vmatrix} b_1 & c_1 \\\\ b_2 & c_2 \\end{vmatrix} ,\\begin{vmatrix} c_1 & a_1 \\\\ c_2 & a_2 \\end{vmatrix} ,\\begin{vmatrix} a_1 & b_1 \\\\ a_2 & b_2 \\end{vmatrix}\\} $$ 推导: $$ \\begin{aligned} \\vec{a}\\times\\vec{b} & =(a_1\\vec{i}+b_1\\vec{j}+c_1\\vec{k})\\times(a_2\\vec{i}+b_2\\vec{j}+c_2\\vec{k}) \\\\ & =\\mskip{1.2em}a_1a_2\\vec{i}\\times\\vec{i}+a_1b_2\\vec{i}\\times\\vec{j}+a_1c_2\\vec{i}\\times\\vec{k} \\\\ & \\mskip{1.2em}+b_1a_2\\vec{j}\\times\\vec{i}+b_1b_2\\vec{j}\\times\\vec{j}+b_1c_2\\vec{j}\\times\\vec{k} \\\\ & \\mskip{1.2em}+c_1a_2\\vec{k}\\times\\vec{i}+c_1b_2\\vec{k}\\times\\vec{j}+c_1c_2\\vec{k}\\times\\vec{k} \\\\ & =\\mskip{1.2em}a_1b_2\\vec{i}\\times\\vec{j}+a_1c_2\\vec{i}\\times\\vec{k} \\\\ & \\mskip{1.2em}+b_1a_2\\vec{j}\\times\\vec{i}+b_1c_2\\vec{j}\\times\\vec{k} \\\\ & \\mskip{1.2em}+c_1a_2\\vec{k}\\times\\vec{i}+c_1b_2\\vec{k}\\times\\vec{j} \\\\ & =a_1b_2\\vec{k}-a_1c_2\\vec{j}-b_1a_2\\vec{k}+b_1c_2\\vec{i}+c_1a_2\\vec{j}-c_1b_2\\vec{i} \\enspace(\\text{结合下面性质3和4}) \\\\ & =(a_1b_2-b_1a_2)\\vec{k}+(c_1a_2-a_1c_2)\\vec{j}+(b_1c_2-c_1b_2)\\vec{i} \\\\ & =\\{b_1c_2-b_2c_1,a_2c_1-a_1c_2,a_1b_2-a_2b_1\\} \\end{aligned} $$ 性质 \\(\\vec{a}\\times\\vec{b}=\\vec{0}\\hArr\\vec{a}\\parallel\\vec{b}\\) \\(\\vec{a}\\times\\vec{b}\\perp\\vec{a},\\vec{b}\\) \\(\\vec{a}\\times\\vec{b}=-\\vec{b}\\times\\vec{a}\\) \\(\\begin{cases} \\vec{i}\\times\\vec{i}=\\vec{0},\\vec{j}\\times\\vec{j}=\\vec{k}\\times\\vec{k}=\\vec{0} \\\\ \\vec{i}\\times\\vec{j}=\\vec{k},\\vec{k}\\times\\vec{i}=\\vec{j},\\vec{j}\\times\\vec{k}=\\vec{i} \\end{cases}\\) \\(|\\vec{a}\\times\\vec{b}|=2S_\\Delta\\) 推导: \\(\\begin{aligned} S_\\Delta &amp; =\\frac{1}{2}|\\vec{a}|\\cdot|\\vec{b}|\\cdot\\sin(\\widehat{\\vec{a},\\vec{b}}) \\\\ &amp; =\\frac{1}{2}|\\vec{a}\\times\\vec{b}| \\end{aligned}\\) 空间曲面及方程 空间曲面 设 \\(F(x,y,z)=0\\) 为一个三元方程, \\(\\Sigma\\) 为曲面 若 \\(F(x,y,z)=0\\) 的任一解 \\((x_0,y_0,z_0)\\) 对应的点 \\(M_0(x_0,y_0,z_0)\\) 在曲面 \\(\\Sigma\\) 上 或者说曲面 \\(\\Sigma\\) 上存在点 \\(M(x_0, y_0, z_0)\\) 使得 \\(F(x_0,y_0,z_0)=0\\) 称 \\(F(x,y,z)=0\\) 为曲面 \\(\\Sigma\\) 的方程, \\(\\Sigma\\) 为方程 \\(F(x,y,z)=0\\) 对应的曲面 记 \\(\\Sigma:F(x,y,z)=0\\) 柱面 \\(\\Sigma:F(x,y)=0\\) 为母线(延伸方向)平行于 \\(z\\) 轴的柱面 \\(\\Sigma:G(y,z)=0\\) 为母线平行于 \\(x\\) 轴的柱面 \\(\\Sigma:H(x,z)=0\\) 为母线平行于 \\(y\\) 轴的柱面 例: 同一个方程 \\(x^2+y^2=4\\) , 在二维坐标系中是一个半径为 2 的圆(称作母线); 在三维坐标系中在 \\(z\\) 轴无限延申, 成为了到 \\(z\\) 轴的距离为 2 的点形成的曲面 设 \\(T(0,0,z)\\) 为 \\(z\\) 轴上一点, \\(\\forall M(x,y,z)\\in\\Sigma\\) 有 \\(|MT|=2\\rArr\\sqrt{(x-0)^2+(y-0)^2+(z-z)^2}=2\\rArr x^2+y^2=4\\) \\(\\therefore\\Sigma:x^2+y^2=4\\) 柱面 \\(\\Sigma:F(x,y)=0\\) 在 \\(xOy\\) 面内的投影曲线为 \\(L:\\begin{cases} F(x,y)=0 \\\\ z=0 \\end{cases}\\) 旋转曲面 设 \\(L:\\begin{cases} F(x,y)=0 \\\\ z=0 \\end{cases}\\) 设 \\(L\\) 绕 \\(x\\) 轴旋转一周形成的曲面为 \\(\\Sigma_x\\) \\(\\forall M(x,y,z)\\in\\Sigma_x\\) , \\(M_0(x,y_0,0)\\in L\\) , \\(T(x, 0, 0)\\) 由 \\(|M_0T|=|MT|\\) 得 \\(\\sqrt{(x-x)^2+(y_0-0)^2+(0-0)^2}=\\sqrt{(x-x)^2+(y-0)^2+(z-0)^2}\\) \\(\\hArr\\sqrt{y_0^2}=\\sqrt{y^2+z^2}\\) \\(\\hArr y_0=\\pm\\sqrt{y^2+z^2}\\) \\(\\because M_0\\in L\\) \\(\\therefore F(x,y_0)=0\\) \\(\\therefore\\Sigma_x:F(x,\\pm\\sqrt{y^2+z^2})=0\\) 设 \\(L\\) 绕 \\(y\\) 轴旋转一周形成的曲面为 \\(\\Sigma_y\\) \\(\\Sigma_y:f(\\pm\\sqrt{x^2+z^2},y)=0\\) (参考绕 \\(x\\) 轴) 空间平面(空间曲面的特殊情形) 平面的点法式方程 设曲面某点 \\(M_0(x_0,y_0,z_0)\\in\\pi\\) , 法向量 \\(\\vec{n}=\\{A,B,C\\}\\perp\\pi\\) \\(\\forall M(x,y,z)\\in\\pi\\rArr\\vec{n}\\perp\\overrightarrow{M_0M}\\rArr\\vec{n}\\cdot\\overrightarrow{M_0M}=0\\) 代入 \\(\\overrightarrow{M_0M}=\\{x-x_0,y-y_0,z-z_0\\}\\) 得到 \\(\\pi:A(x-x_0)+B(y-y_0)+C(z-z_0)=0\\) 截距式方程 \\(\\overrightarrow{AB}=\\{-a,b,0\\}\\) , \\(\\overrightarrow{AC}=\\{-a,0,c\\}\\) 平面 \\(ABC\\) 的法向量 \\(\\vec{n}=\\overrightarrow{AB}\\times\\overrightarrow{AC}=\\{bc,ac,ab\\}\\) 将点 \\(C\\) 代入点法式方程: \\(\\pi:bc(x-a)+ac(y-0)+an(z-0)=0\\rArr bc(x-a)+acy+abz=0\\) \\(\\hArr bcx+acy+abz=abc\\hArr\\frac{x}{a}+\\frac{y}{b}+\\frac{z}{c}=1\\) 即 \\(\\pi:\\frac{x}{a}+\\frac{y}{b}+\\frac{z}{c}=1\\) 一般式方程 \\(\\pi:Ax+By+Cz+D=0\\) , 法向量 \\(\\vec{n}=\\{A,B,C\\}\\) 两个平面夹角 \\(\\pi_1:A_1x+B_1y+C_1z+D_1=0\\) , \\(\\vec{n_1}=\\{A_1,B_1,C_1\\}\\) \\(\\pi_2:A_2x+B_2y+C_2z+D_2=0\\) , \\(\\vec{n_2}=\\{A_2,B_2,C_2\\}\\) 若 \\((\\widehat{\\vec{n_1},\\vec{n_2}})\\in[0,\\frac{\\pi}{2}]\\) , 则平面夹角 \\(\\theta=(\\widehat{\\vec{n_1},\\vec{n_2}})\\) 有 \\(\\cos\\theta=\\cos(\\widehat{\\vec{n_1},\\vec{n_2}})=\\frac{\\vec{n_1}\\cdot\\vec{n_2}}{|\\vec{n_1}|\\cdot|\\vec{n_2}|}\\) 若 \\((\\widehat{\\vec{n_1},\\vec{n_2}})\\in(\\frac{\\pi}{2},\\pi]\\) , 则平面夹角 \\(\\theta=\\pi-(\\widehat{\\vec{n_1},\\vec{n_2}})\\) 有 \\(\\cos\\theta=\\cos(\\pi-(\\widehat{\\vec{n_1},\\vec{n_2}}))=-\\cos(\\widehat{\\vec{n_1},\\vec{n_2}})=-\\frac{\\vec{n_1}\\cdot\\vec{n_2}}{|\\vec{n_1}|\\cdot|\\vec{n_2}|}\\) 平面夹脚应是锐角, 因此综合 1、2 得: \\(\\cos\\theta=|\\frac{\\vec{n_1}\\vec{n_2}}{|\\vec{n_1}|\\cdot|\\vec{n_2}|}|\\) 空间曲线及方程 空间曲线的形式 一般形式 (两个空间曲面的交点集合是一条空间曲线) \\(L:\\begin{cases} F(x,y,z)=0 \\\\ G(x,y,z)=0 \\end{cases}\\) 参数式 \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\\\ z=\\omega(t) \\end{cases}\\) 如: \\(L:\\begin{cases} x^2+y^2=1 \\\\ x+y-z-2=0 \\end{cases}\\rArr\\) 化为参数式 \\(L:\\begin{cases} x=\\cos t \\\\ y=\\sin t \\\\ z=\\sin t+\\cos t-2 \\end{cases}\\) 空间直线(空间曲线的特殊情形) 点向式(对称式)方程: \\(L:\\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}\\) 设 \\(M_0(x_0,y_0,z_0)\\in L\\) , \\(\\vec{S}=\\{m,n,p\\}\\parallel L\\) \\(\\forall M(x,y,z)\\in L\\), 有 \\(\\overrightarrow{M_0M}=\\{x-x_0,y-y_0,z-z_0\\}\\) 且 \\(\\overrightarrow{M_0M}\\parallel\\vec{S}\\) \\(\\because\\overrightarrow{M_0M}\\parallel\\vec{S}\\hArr\\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}\\) \\(\\therefore L:\\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}\\) 参数式方程: 若 \\(\\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}=t\\) 则 \\(L:\\begin{cases} x=mt+x_0 \\\\ y=nt+y_0 \\\\ z=pt+z_0 \\end{cases}\\) 一般式 \\(L:\\begin{cases} A_1x+B_1y+C_1z+D_1=0 \\\\ A_2x+B_2y+C_2z+D_2=0 \\end{cases}\\) (两平面相交得到一条直线) 投影曲线 设 \\(L:\\begin{cases} F(x,y,z)=0 \\\\ G(x,y,z)=0 \\end{cases}\\) 曲线 \\(L\\) 向 \\(xOy\\) 面铅直投影得到投影曲线 \\(L_0\\) 由 \\(\\begin{cases} F(x,y,z)=0 \\\\ G(x,y,z)=0 \\end{cases}\\xRightarrow{\\text{消}\\large z}H(x,y)=0\\) 得到 \\(L_0:\\begin{cases} H(x,y)=0 \\\\ z=0 \\end{cases}\\) 杂知识点 夹角 两向量的夹角: 设向量 \\(\\vec{a}=\\{a_1,b_1,c_1\\}\\) , \\(\\vec{b}=\\{a_2,b_2,c_2\\}\\) , \\((\\widehat{\\vec{a},\\vec{b}})=\\theta \\enspace\\) (\\(0\\leqslant\\theta\\leqslant\\pi\\)) 由 \\(\\vec{a}\\cdot\\vec{b}=|\\vec{a}|\\cdot|\\vec{b}|\\cdot\\cos\\theta\\) 得 \\(\\cos\\theta=\\frac{\\vec{a}\\cdot\\vec{b}}{|\\vec{a}||\\vec{b}|}=\\frac{a_1a_2+b_1b_2+c_1c_2}{\\sqrt{a_1^2+b_1^2+c_1^2}\\sqrt{a_2^2+b_2^2+c_2^2}}\\) 两平面夹角: \\(\\pi_1:A_1x+B_1y+C_1z+D_1=0\\) \\(\\pi_2:A_2x+B_2y+C_2z+D_2=0\\) 设 \\(\\pi_1\\) , \\(\\pi_2\\) 夹角为 \\(\\theta\\) \\((\\widehat{\\vec{n_1},\\vec{n_2}})\\in[0,\\frac{\\pi}{2}]\\) 时 \\(\\theta=(\\widehat{\\vec{n_1},\\vec{n_2}})\\) \\((\\widehat{\\vec{n_1},\\vec{n_2}})\\in(\\frac{\\pi}{2},\\pi]\\) 时 \\(\\theta=\\pi-(\\widehat{\\vec{n_1},\\vec{n_2}})\\) 综合得 \\(\\cos\\theta=|\\cos(\\widehat{\\vec{n_1},\\vec{n_2}})|=\\frac{|\\vec{n_1}\\cdot\\vec{n_2}|}{|\\vec{n_1}||\\vec{n_2}|}=\\frac{|A_1A_2+B_1B_2+C_1C_2|}{\\sqrt{A_1^2+B_1^2+C_1^2}\\sqrt{A_2^2+B_2^2+C_2^2}}\\) 两直线夹角: \\(L_1:\\frac{x-x_1}{m_1}=\\frac{y-y_1}{n_1}=\\frac{z-z_1}{p_1}\\) \\(L_2:\\frac{x-x_2}{m_2}=\\frac{y-y_2}{n_2}=\\frac{z-z_1}{p_2}\\) 设 \\(L_1\\) , \\(L_2\\) 夹脚为 \\(\\theta\\enspace\\) (\\(0\\leqslant\\theta\\leqslant\\frac{\\pi}{2}\\)) \\((\\widehat{\\vec{s_1},\\vec{s_2}})\\in[0,\\frac{\\pi}{2}]\\) , 则 \\(\\theta=(\\widehat{\\vec{s_1},\\vec{s_2}})\\) \\((\\widehat{\\vec{s_1},\\vec{s_2}})\\in(\\frac{\\pi}{2},\\pi]\\) , 则 \\(\\theta=\\pi-(\\widehat{\\vec{s_1},\\vec{s_2}})\\) 综合得 \\(\\cos\\theta=|\\cos(\\widehat{\\vec{s_1},\\vec{s_2}})|=\\frac{|\\vec{s_1}\\cdot\\vec{s_2}|}{|\\vec{s_1}||\\vec{s_2}|}=\\frac{|m_1m_2+n_1n_2+p_1p_2|}{\\sqrt{m_1^2+n_1^2+p_1^2}\\sqrt{m_2^2+n_2^2+p_2^2}}\\) 直线与平面夹角: \\(L:\\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}\\) , \\(\\vec{s}=\\{m,n,p\\}\\parallel L\\) \\(\\pi:Ax+By+Cz+D=0\\) , \\(\\vec{n}=\\{A,B,C\\}\\) 若 \\((\\widehat{\\vec{n},\\vec{s}})\\in[0,\\frac{\\pi}{2}]\\) 则 \\(\\varphi+(\\widehat{\\vec{n},\\vec{s}})=\\frac{\\pi}{2}\\rArr\\varphi=\\frac{\\pi}{2}-(\\widehat{\\vec{n},\\vec{s}})\\) \\(\\therefore\\sin\\varphi=\\cos(\\widehat{\\vec{n},\\vec{s}})\\) 若 \\((\\widehat{\\vec{n},\\vec{s}})\\in(\\frac{\\pi}{2},\\pi]\\) 则 \\((\\widehat{\\vec{n},\\vec{s}})=\\frac{\\pi}{2}+\\varphi\\rArr\\varphi=-(\\frac{\\pi}{2}-(\\widehat{\\vec{n},\\vec{s}}))\\) \\(\\therefore\\sin\\varphi=-\\cos(\\widehat{\\vec{n},\\vec{s}})\\) 综合 1、2 得 \\(\\sin\\varphi=|\\cos(\\vec{n},\\vec{s})|=\\frac{|\\vec{n}\\cdot\\vec{s}|}{|\\vec{n}|\\cdot|\\vec{s}|}\\) 距离 两点距离: 设 \\(A(x_1,y_1,z_1)\\) , \\(B(x_2,y_2,z_2)\\) 则 \\(AB\\) 距离 \\(d=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2+z_1)^2}\\) 点到平面距离 设 \\(\\pi:Ax+By+Cz+D=0\\) , \\(M_0(x_0,y_0,z_0)\\notin\\pi\\) , \\(\\forall M_1(x_1, y_1, z_1)\\in\\pi\\) 有 \\(\\overrightarrow{M_0M_1}=\\{x_1-x_0, y_1-y_0, z_1-z_0\\}\\) $$ \\begin{aligned} Prj_{\\vec{n}}\\overrightarrow{M_0M_1}=\\frac{\\vec{n}\\cdot\\overrightarrow{M_0M_1}}{|\\vec{n}|} & =\\frac{A(x_1-x_0)+B(y_1-y_0)+C(z_1-z_0)}{\\sqrt{A^2+B^2+C^2}} \\\\ & =\\frac{(Ax_1+By_1+Cz_1)-(Ax_0+By_0+Cz_0)}{\\sqrt{A^2+B^2+C^2}} \\end{aligned} $$ 将 \\(M_1\\) 代入平面 \\(\\pi\\) 得 \\(Ax_1+By_1+Cz_1=-D\\) \\(\\therefore Prj_{\\vec{n}}\\overrightarrow{M_0M_1}=-\\frac{Ax_0+By_0+Cz_0+D}{\\sqrt{A^2+B^2+C^2}}\\) \\(\\therefore d=|Prj_{\\vec{n}}\\overrightarrow{M_0M_1}|=\\frac{|Ax_0+By_0+Cz_0+D|}{\\sqrt{A^2+B^2+C^2}}\\) 平面束 \\(L\\) 为直线, 经过 \\(L\\) 的所有平面称为平面束 设 \\(L:\\begin{cases} A_1x+B_1y+C_1z+D_1=0 \\\\ A_2x+B_2y+C_2z+D_2=0 \\end{cases}\\) 过 \\(L\\) 的平面束为 \\(\\pi:A_1x+B_1y+C_1z+D_1+\\lambda(A_2x+B_2y+C_2z+D_2)=0\\) \\(\\hArr\\pi:(A_1+A_2\\lambda)x+(B_1+B_2\\lambda)y+(C_1+C_2\\lambda)z+(D_1+D_2\\lambda)=0\\) 例: 求直线 \\(\\begin{cases} x+y-z-1=0 \\\\ x-y+z+1=0 \\end{cases}\\) 在平面 \\(x+y+z=0\\) 上的投影直线 解: 过直线 \\(L\\) 的平面束为 \\(\\pi:x+y-z-1+\\lambda(x-y+z+1)=0\\) 即 \\(\\pi:(\\lambda+1)x+(1-\\lambda)y+(\\lambda-1)z+\\lambda-1=0\\) 在平面束 \\(\\pi\\) 中找一个平面 \\(\\pi_0\\) , 使其与平面 \\(x+y+z=0\\) 垂直, \\(\\pi_0\\) 与 \\(x+y+z=0\\) 相交的直线即为 \\(L\\) 的投影直线 \\(\\{(\\lambda+1),(1-\\lambda),(\\lambda-1)\\}\\cdot\\{1,1,1\\}=0\\rArr \\lambda=-1\\) 投影直线 \\(L_0:\\begin{cases} 2y-2z-2=0 \\\\ x+y+z=0 \\end{cases}\\) 多元函数微分学及应用 多元函数的基本概念 平面点集 邻域: 设 \\(M_0(x_0, y_0)\\in D\\) , \\(\\delta&gt;0\\) 称 \\(\\{(x, y)|\\sqrt{(x-x_0)^2+(y-y_0)^2}&lt;\\delta\\}\\) 为 \\(M_0\\) 的 \\(\\delta\\) 邻域, 记 \\(\\bigcup(M_0, \\delta)\\) 称 \\(\\{(x, y)|0&lt;\\sqrt{(x-x_0)^2+(y-y_0)^2}&lt;\\delta\\}\\) 为 \\(M_0\\) 的去心 \\(\\delta\\) 邻域, 记 \\(\\mathring{\\bigcup}(M_0, \\delta)\\) 开集: 设 \\(D\\) 为 \\(xOy\\) 面上的点集, 若 \\(\\forall M_0(x_0,y_0)\\in D\\) , \\(\\exist\\delta&gt;0\\) 使 \\(\\bigcup(M_0,\\delta)\\subset D\\) , 称 \\(D\\) 为开集 区域: 连通的开集称为区域(开区域) 闭区域: 开区域连同边界称为闭区域 多元函数的概念(空间中的一个曲面) 设 \\(D\\) 为区域, \\(x,y,z\\) 为变量, 若 \\(\\forall(x,y)\\in D\\) , \\(\\exist z\\) 与 \\((x,y)\\) 对应, 称 \\(z\\) 为 \\((x,y)\\) 的函数, 记 \\(z=f(x,y)\\) \\(D\\) 为定义域, 值域 \\(R=\\{z|z=f(x,y),(x,y)\\in D\\}\\) 多元函数的极限 回顾一元函数极限定义: 设 \\(y=f(x)\\enspace\\) (\\(x\\in D\\)) 若 \\(\\forall\\varepsilon&gt;0\\) , \\(\\exist\\delta&gt;0\\) , 当 \\(0&lt;|x-x_0|&lt;\\delta\\) 时, 有 \\(|f(x)-A|&lt;\\varepsilon\\) 称 \\(A\\) 为 \\(f(x)\\) 当 \\(x\\to x_0\\) 的极限, 记 \\(\\lim\\limits_{x\\to x_0}f(x)=A\\) 二元函数极限定义: 设 \\(z=f(x,y)\\enspace\\) (\\((x,y)\\in D\\)) , \\(M_0(x_0,y_0)\\in D\\) 若 \\(\\forall\\varepsilon&gt;0\\) , \\(\\exist\\delta&gt;0\\) , 当 \\(0&lt;\\sqrt{(x-x_0)^2-(y-y_0)^2}&lt;\\delta\\) 时, 有 \\(|f(x, y)-A|&lt;\\varepsilon\\) 称 \\(A\\) 为 \\(f(x,y)\\) 当 \\((x,y)\\to(x_0,y_0)\\) 的极限, 记 \\(\\lim\\limits_{\\substack{x\\to x_0 \\\\ y\\to y_0}}f(x,y)=A\\) 多元函数连续性与性质 设 \\(z=f(x,y)\\enspace\\) (\\((x,y)\\in D\\)) , \\(M_0(x_0,y_0)\\in D\\) 若 \\(\\lim\\limits_{\\substack{x\\to x_0 \\\\ y\\to y_0}}f(x,y)=f(x_0,y_0)\\) , 称 \\(f(x,y)\\) 在 \\((x_0,y_0)\\) 处连续 多元函数在有界闭区域上的性质 最值定理 设 \\(D\\) 为有界闭区域, \\(f(x,y)\\) 在 \\(D\\) 上连续 则 \\(f(x,y)\\) 在 \\(D\\) 上取到最小值 \\(m\\) 和最大值 \\(M\\) 有界定理 设 \\(D\\) 为有界闭区域, \\(f(x,y)\\) 在 \\(D\\) 上连续 则 \\(\\exist k&gt;0,\\forall(x,y)\\in D\\) , 有 \\(|f(x,y)|\\leqslant k\\) 介值定理 设 \\(D\\) 为有界闭区域, \\(f(x,y)\\) 在 \\(D\\) 上连续 则 \\(\\forall\\delta\\in[m,M]\\) , \\(\\exist(\\xi,\\eta)\\in D\\) 使 \\(f(\\xi,\\eta)=\\delta\\) 偏导数 定义 设 \\(z=f(x,y)\\enspace\\) (\\((x,y)\\in D)\\) , \\(M_0(x_0,y_0)\\in D\\) 偏增量 \\(f(x,y)\\) 在 \\(M_0\\) 处关于 \\(x\\) 的偏增量: \\(\\Delta z_x=f(x_0+\\Delta x,y_0)-f(x_0,y_0)=f(x,y_0)-f(x_0,y_0)\\) \\(f(x,y)\\) 在 \\(M_0\\) 处关于 \\(y\\) 的偏增量: \\(\\Delta z_y=f(x_0, y_0+\\Delta y)-f(x_0, y_0)=f(x_0,y)-f(x_0,y_0)\\) \\(f(x,y)\\) 在 \\(M_0\\) 处的全增量: \\(\\Delta z=f(x_0+\\Delta x,y_0+\\Delta y)-f(x_0,y_0)=f(x,y)-f(x_0,y_0)\\) 偏导数 若 \\(\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta z_x}{\\Delta x}\\) 存在, 称 \\(f(x,y)\\) 在 \\(M_0\\) 处关于 \\(x\\) 可偏导, 该极限称为 \\(f(x,y)\\) 在 \\(M_0\\) 处关于 \\(x\\) 的偏导数, 记 \\(f_x^\\prime(x_0,y_0)\\) 或 \\(\\frac{\\partial z}{\\partial x}|_{(x_0,y_0)}\\) 若 \\(\\lim\\limits_{\\Delta y\\to 0}\\frac{\\Delta z_y}{\\Delta y}\\) 存在, 称 \\(f(x,y)\\) 在 \\(M_0\\) 处关于 \\(y\\) 可偏导, 该极限称为 \\(f(x,y)\\) 在 \\(M_0\\) 处关于 \\(y\\) 的偏导数, 记 \\(f_y^\\prime(x_0,y_0)\\) 或 \\(\\frac{\\partial z}{\\partial y}|_{(x_0,y_0)}\\) 若 \\(\\forall(x,y)\\in D\\) , \\(f(x,y)\\) 对 \\(x\\)、\\(y\\) 皆可偏导, 称 \\(f_x^\\prime(x,y)\\)、\\(f_y^\\prime(x,y)\\) 为 \\(f(x,y)\\) 对 \\(x\\)、\\(y\\) 的偏导数 高阶偏导数 设 \\(z=f(x,y)\\) 在 \\(D\\) 内对 \\(x\\)、\\(y\\) 可偏导, \\(f_x^\\prime(x,y)=\\frac{\\partial z}{\\partial x}\\) 为 \\(f(x,y)\\) 对 \\(x\\) 偏导数, \\(f_y^\\prime(x,y)=\\frac{\\partial z}{\\partial y}\\) 为 \\(f(x,y)\\) 对 \\(y\\) 偏导数. 若 \\(f_x^\\prime(x,y)\\) 对 \\(x\\) 可偏导, 其对 \\(x\\) 的偏导数称为 \\(f(x,y)\\) 对 \\(x\\) 的二阶偏导数, 记 \\(f_{xx}^{\\prime\\prime}\\) 或 \\(\\frac{\\partial^2z}{\\partial x^2}\\) 若 \\(f_y^\\prime(x,y)\\) 对 \\(y\\) 可偏导, 其对 \\(y\\) 的偏导数称为 \\(f(x,y)\\) 对 \\(y\\) 的二阶偏导数, 记 \\(f_{yy}^{\\prime\\prime}\\) 或 \\(\\frac{\\partial^2z}{\\partial y^2}\\) 若 \\(f_x^\\prime(x,y)\\) 对 \\(y\\) 可偏导, 其对 \\(y\\) 的偏导数称为 \\(f(x,y)\\) 对 \\(x\\)、\\(y\\) 的二阶混合偏导数, 记 \\(f_{xy}^{\\prime\\prime}(x,y)\\) 或 \\(\\frac{\\partial^2z}{\\partial x\\partial y}\\) 若 \\(f_y^\\prime(x,y)\\) 对 \\(x\\) 可偏导, 其对 \\(x\\) 的偏导数称为 \\(f(x,y)\\) 对 \\(y\\)、\\(x\\) 的二阶混合偏导数, 记 \\(f_{yx}^{\\prime\\prime}(x,y)\\) 或 \\(\\frac{\\partial^2z}{\\partial y\\partial x}\\) 定理: 若 \\(z=f(x,y)\\) 的二阶混合偏导数 \\(\\frac{\\partial^2z}{\\partial x\\partial y}\\)、\\(\\frac{\\partial^2z}{\\partial y\\partial x}\\) 皆连续, 则 \\(\\frac{\\partial^2z}{\\partial x\\partial y}=\\frac{\\partial^2z}{\\partial y\\partial x}\\) , 即 \\(f_{xy}^{\\prime\\prime}=f_{yx}^{\\prime\\prime}\\) 全微分 二元函数全微分定义 设 \\(z=f(x,y)\\enspace\\) (\\((x,y)\\in D\\)) , \\(M_0(x_0,y_0)\\in D\\) , 全增量 \\(\\Delta z=f(x_0+\\Delta x,y_0+\\Delta y)-f(x_0,y_0)=f(x,y)-f(x_0,y_0)\\) 若 \\(\\Delta z=A\\Delta x+B\\Delta y+\\circ(\\rho)\\) , \\(\\rho=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}\\) 称 \\(f(x,y)\\) 在 \\((x_0,y_0)\\) 处可全微, \\(A\\Delta x+B\\Delta y\\) 为 \\(f(x,y)\\) 在 \\((x_0,y_0)\\) 处的全微分, 记 \\(\\mathrm{d}z|_{(x_0,y_0)}=A\\mathrm{d}x+B\\mathrm{d}y\\) 全微分: \\(\\mathrm{d}z|_{(x_0,y_0)}=f_x^\\prime(x_0,y_0)\\mathrm{d}x+f_y^\\prime(x_0,y_0)\\mathrm{d}y=\\frac{\\partial z}{\\partial x}\\mathrm{d}x+\\frac{\\partial z}{\\partial y}\\mathrm{d}y\\) 性质 设 \\(z=f(x,y)\\enspace\\) (\\((x, y)\\in D\\)) , \\(M_0(x_0,y_0)\\in D\\) 若 \\(f(x,y)\\) 在 \\(M_0\\) 处可微, 则 \\(f(x,y)\\) 在 \\(M_0\\) 连续且可偏导, 反之不对 可微充分条件: 若 \\(z=f(x,y)\\) 连续可偏导, 则 \\(f(x,y)\\) 可微 例: \\(z=f(x,y)=|x|+|y|\\) 在 \\((0,0)\\) 连续, 证 \\(f(x,y)\\) 在 \\((0,0)\\) 不可微 证: \\(\\lim\\limits_{x\\to 0}\\frac{f(x,0)-f(0,0)}{x}=\\lim\\limits_{x\\to 0}\\frac{|x|}{x}\\) 不存在 \\(\\rArr f(x,y)\\) 在 \\((0,0)\\) 对 \\(x\\) 不可偏导. 同理 \\(f(x,y)\\) 在 \\((0,0)\\) 不可偏导 \\(\\therefore f(x,y)\\) 在 \\((0,0)\\) 不可微 多元复合函数求导法则 情形一: \\(z=f(u,v)\\) , \\(\\begin{cases} u=\\varphi(t) \\\\ v=\\psi(t) \\end{cases}\\rArr z=f[\\varphi(t),\\psi(t)]\\) 若 \\(z=f(u,v)\\) 关于 \\(u\\)、\\(v\\) 连续可偏导, \\(\\varphi(t)\\) , \\(\\psi(t)\\) 可导, 则 \\(z=f[\\varphi(t),\\psi(t)]\\) 可导, 且 \\(\\frac{\\mathrm{d}z}{\\mathrm{d}t}=\\frac{\\partial f}{\\partial u}\\cdot\\frac{\\mathrm{d}u}{\\mathrm{d}t}+\\frac{\\partial f}{\\partial v}\\cdot\\frac{\\mathrm{d}v}{\\mathrm{d}t}=f_{u}^\\prime\\cdot\\varphi(t)^\\prime+f_{v}^\\prime\\cdot\\psi^\\prime(t)\\) 证明: (\\(\\Delta u=\\varphi(t+\\Delta t)-\\varphi(t)\\) , \\(\\Delta v=\\psi(t+\\Delta t)-\\psi(t)\\)) \\(\\because z=f(u,v)\\) 关于 \\(u\\)、\\(v\\) 连续可偏导 \\(\\therefore z=f(u,v)\\) 可微 \\(\\therefore\\Delta z=\\frac{\\partial f}{\\partial u}\\Delta u+\\frac{\\partial f}{\\partial v}\\Delta v+\\circ(\\rho)\\) , \\(\\rho=\\sqrt{(\\Delta u)^2+(\\Delta v)^2}\\) \\(\\rArr\\frac{\\Delta z}{\\Delta t}=\\frac{\\partial f}{\\partial u}\\frac{\\Delta u}{\\Delta t}+\\frac{\\partial f}{\\partial v}\\frac{\\Delta v}{\\Delta t}+\\frac{\\circ(\\rho)}{\\Delta t}\\) \\(\\rArr\\frac{\\mathrm{d}z}{\\mathrm{d}t}=\\frac{\\partial f}{\\partial u}\\cdot\\frac{\\mathrm{d}u}{\\mathrm{d}t}+\\frac{\\partial f}{\\partial v}\\cdot\\frac{\\mathrm{d}v}{\\mathrm{d}t}=f_{u}^\\prime\\cdot\\varphi(t)^\\prime+f_{v}^\\prime\\cdot\\psi^\\prime(t)\\) 情形二: \\(z=f(u,v)\\) , \\(\\begin{cases} u=\\varphi(x,y) \\\\ v=\\psi(x,y) \\end{cases}\\rArr z=f[\\varphi(x,y),\\psi(x,y)]\\) \\(z=f(u,v)\\) 关于 \\(u\\)、\\(v\\) 连续可偏导, \\(\\begin{cases} u=\\varphi(x,y) \\\\ v=\\psi(x,y) \\end{cases}\\) 对 \\((x,y)\\) 可偏导 则 \\(z=f[\\varphi(x,y),\\psi(x,y)]\\) 关于 \\(x\\)、\\(y\\) 可偏导, 且 \\(\\frac{\\partial z}{\\partial x}=\\frac{\\partial f}{\\partial u}\\cdot\\frac{\\partial u}{\\partial x}+\\frac{\\partial f}{\\partial v}\\cdot\\frac{\\partial v}{\\partial x}\\) \\(\\frac{\\partial z}{\\partial y}=\\frac{\\partial f}{\\partial u}\\cdot\\frac{\\partial u}{\\partial y}+\\frac{\\partial f}{\\partial v}\\cdot\\frac{\\partial v}{\\partial y}\\) 隐函数求导法则 一个约束条件的情形 隐函数显式化: \\(f(x,y)=0\\rArr y=\\varphi(x)\\) 定理一: 设 \\(F(x,y)\\) 在点 \\(M_0(x_0,y_0)\\) 邻域内连续可偏导且 \\(F(x_0,y_0)=0\\) , 若 \\(F_y^\\prime(x_0,y_0)\\neq 0\\enspace\\) 则由 \\(F(x,y)=0\\) 在 \\(M_0\\) 邻域内确定唯一连续可导函数 \\(y=f(x)\\) 使 \\(y_0=f(x_0)\\) (隐函数显式化), 则 \\(\\dfrac{\\mathrm{d}y}{\\mathrm{d}x}=-\\dfrac{F_x^\\prime}{F_y^\\prime}\\) 证明: \\(F(x,y)=0\\) , 把 \\(y\\) 看成 \\(x\\) 的函数 \\(f(x)\\) , 则 \\(F(x,f(x))=0\\) 两边对 \\(x\\) 求导, \\(F_x^\\prime+F_y^\\prime f^\\prime(x)=F_x^\\prime+F_y^\\prime\\frac{\\mathrm{d}y}{\\mathrm{d}x}=0\\rArr\\frac{\\mathrm{d}y}{\\mathrm{d}x}=-\\frac{F_x^\\prime}{F_y^\\prime}\\) 定理二: 设 \\(F(x,y,z)\\) 在 \\(M_0(x_0,y_0,z_0)\\) 邻域内连续可偏导且 \\(F(x_0,y_0,z_0)=0\\) 若 \\(F_z^\\prime(x_0,y_0,z_0)\\neq 0\\enspace\\) 则由 \\(F(x,y,z)=0\\) 在 \\(M_0\\) 邻域内确定唯一连续可偏导函数 \\(z=\\varphi(x,y)\\) 使 \\(z_0=\\varphi(x_0,y_0)\\) , 则 \\(\\dfrac{\\partial z}{\\partial x}=-\\dfrac{F_x^\\prime}{F_z^\\prime}\\) , \\(\\dfrac{\\partial z}{\\partial y}=-\\dfrac{F_y^\\prime}{F_z^\\prime}\\) 证明: \\(F(x,y,z)=0\\rArr z=\\varphi(x,y)\\) 两边对 \\(x\\) 求偏导, \\(F_x^\\prime+F_z^\\prime\\frac{\\partial z}{\\partial x}=0\\rArr\\frac{\\partial z}{\\partial x}=-\\frac{F_x^\\prime}{F_z^\\prime}\\) 两边对 \\(y\\) 求偏导, \\(F_y^\\prime+F_z^\\prime\\frac{\\partial z}{\\partial y}=0\\rArr\\frac{\\partial z}{\\partial y}=-\\frac{F_y^\\prime}{F_z^\\prime}\\) 多元函数微分学的几何应用 空间曲线(求曲线切线和法平面) 设 \\(M_0(x_0,y_0,z_0)\\in L\\) , \\(M(x_0+\\Delta x,y_0+\\Delta y,z_0+\\Delta z)\\in L\\) \\(\\overrightarrow{M_0M}=\\{\\Delta x,\\Delta y,\\Delta z\\}\\) 直线 \\(\\overline{M_0M}:\\frac{x-x_0}{\\Delta x}=\\frac{y-y_0}{\\Delta y}=\\frac{z-z_0}{\\Delta z}\\) 情况一 \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\\\ z=\\omega(t) \\end{cases}\\) , \\(M_0(x_0,y_0,z_0)\\hArr t=t_0\\) , \\(M(x_0+\\Delta x,y_0+\\Delta y,z_0+\\Delta z)\\hArr t=t_0+\\Delta t\\) \\(\\overline{M_0M}=\\frac{x-x_0}{\\Delta x}=\\frac{y-y_0}{\\Delta y}=\\frac{z-z_0}{\\Delta z}\\hArr\\frac{x-x_0}{\\frac{\\Delta x}{\\Delta t}}=\\frac{y-y_0}{\\frac{\\Delta y}{\\Delta t}}=\\frac{z-z_0}{\\frac{\\Delta z}{\\Delta t}}\\) 当 \\(\\Delta t\\to 0\\) 时, \\(\\overline{M_0M}\\) 即为切线 \\(\\therefore\\) 切线: \\(\\frac{x-x_0}{\\varphi^\\prime(t_0)}=\\frac{y-y_0}{\\psi^\\prime(t_0)}=\\frac{z-z_0}{\\omega^\\prime(t_0)}\\) , 曲线方向向量 \\(\\vec{T}=\\{\\varphi^\\prime,\\psi^\\prime,\\omega^\\prime\\}\\) , 法平面 \\(\\varphi^\\prime(x-x_0)+\\psi^\\prime(y-y_0)+\\omega^\\prime(z-z_0)=0\\) 情况二 \\(L:\\begin{cases} F(x,y,z)=0 \\\\ G(x,y,z)=0 \\end{cases}\\) , \\(M_0(x_0,y_0,z_0)\\in L\\) 曲线方向向量 \\(\\vec{T}=\\{\\begin{vmatrix} F_y^\\prime &amp; F_z^\\prime \\\\ G_y^\\prime &amp; G_z^\\prime \\end{vmatrix},\\begin{vmatrix} F_z^\\prime &amp; F_x^\\prime \\\\ G_z^\\prime &amp; G_x^\\prime \\end{vmatrix},\\begin{vmatrix} F_x^\\prime &amp; F_y^\\prime \\\\ G_x^\\prime &amp; G_y^\\prime \\end{vmatrix}\\}\\) 将曲线方向向量代入切线和法平面方程即可(方程参考情况一) 空间曲面(求曲面切平面和法线) 求空间曲面上某一点的法向量: 设曲面 \\(\\Sigma:F(x,y,z)=0\\) , \\(M_0(x_0,y_0,z_0)\\in\\Sigma\\) 在 \\(\\Sigma\\) 内过 \\(M_0\\) 任取一曲线 \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\\\ z=\\omega(t) \\end{cases}\\) , \\(M_0\\hArr t=t_0\\) \\(\\because L\\subset\\Sigma\\) \\(\\therefore F[\\varphi(t),\\psi(t),\\omega(t)]=0\\) 两边对 \\(t\\) 求导: \\(F_x^\\prime[\\varphi(t),\\psi(t),\\omega(t)]\\cdot\\varphi^\\prime(t)+F_y^\\prime[\\varphi(t),\\psi(t),\\omega(t)]\\psi^\\prime(t)+F_z^\\prime[\\varphi(t),\\psi(t),\\omega(t)]\\omega^\\prime(t)=0\\enspace\\) (多元复合函数求导情形一) 将 \\(t=t_0\\) 代入: \\(F_x^\\prime(x_0,y_0,z_0)\\varphi^\\prime(t_0)+F_y^\\prime(x_0,y_0,z_0)\\psi^\\prime(t_0)+F_z^\\prime(x_0,y_0,z_0)\\omega^\\prime(t_0)=0\\) 可拆为两个向量点乘: \\(\\{F_x^\\prime,F_y^\\prime,F_z^\\prime\\}_{M_0}\\cdot\\{\\varphi^\\prime(t_0),\\psi^\\prime(t_0),\\omega^\\prime(t_0)\\}=0\\) 则法向量 \\(\\vec{n}=\\{F_x^\\prime,F_y^\\prime,F_z^\\prime\\}_{M_0}\\) (后者是曲线在点 \\(M_0\\) 的方向向量, 那么与之垂直的前者就是法向量了) 方向导数与梯度 方向导数 定义 二元函数 设 \\(z=f(x,y)\\enspace\\) (\\((x,y)\\in D\\)) , \\(M_0(x_0,y_0)\\in D\\) 在 \\(xOy\\) 面内过 \\(M_0\\) 作射线 \\(L\\) , 取 \\(M(x_0+\\Delta x,y_0+\\Delta y)\\in L\\) , \\(\\rho=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}\\) \\(\\Delta z=f(x_0+\\Delta x,y_0+\\Delta y)-f(x_0,y_0)\\) 若 \\(\\lim\\limits_{\\rho\\to 0}\\frac{\\Delta z}{\\rho}\\) 存在, 称此极限为函数 \\(z=f(x,y)\\) 在 \\(M_0\\) 处沿射线 \\(L\\) 的方向导数, 记 \\(\\frac{\\partial z}{\\partial L}|_{M_0}\\) 三元函数 设 \\(u=f(x,y,z)\\enspace\\) (\\((x,y,z)\\in\\Omega\\)) , \\(M_0(x_0,y_0,z_0)\\in\\Omega\\) 过 \\(M_0\\) 作射线 \\(L\\), 取 \\(M(x_0+\\Delta x,y_0+\\Delta y,z_0+\\Delta z)\\in L\\) , \\(\\rho=\\sqrt{(\\Delta x)^2+(\\Delta y)^2+(\\Delta z)^2}\\) \\(\\Delta u=f(x_0+\\Delta x,y_0+\\Delta y,z_0+\\Delta z)-f(x_0,y_0,z_0)\\) 若 \\(\\lim\\limits_{\\rho\\to 0}\\frac{\\Delta u}{p}\\) 存在, 称此极限为 \\(u=f(x,y,z)\\) 在 \\(M_0\\) 处沿射线 \\(L\\) 的方向导数, 记 \\(\\frac{\\partial u}{\\partial L}|_{M_0}\\) 方向导数计算方法 二元函数 \\(z=f(x,y)\\) 在 \\(M_0(x_0,y_0)\\) 可微, 在 \\(xOy\\) 面内过 \\(M_0\\) 作射线 \\(L\\) , 方向角为 \\(\\alpha\\)、\\(\\beta\\) , 则 \\(\\frac{\\partial z}{\\partial L}|_{M_0}=f_x^\\prime(x_0,y_0)\\cdot\\cos\\alpha+f_y^\\prime(x_0,y_0)\\cos\\beta\\) 三元函数 \\(u=f(x, y, z)\\) 在 \\(M_0(x_0, y_0, z_0)\\) 可微, 过 \\(M_0\\) 作射线 \\(L\\) , 方向角为 \\(\\alpha\\)、\\(\\beta\\)、\\(\\gamma\\) , 则 \\(\\frac{\\partial u}{\\partial L}|_{M_0}=\\frac{\\partial u}{\\partial x}|_{M_0}\\cos\\alpha+\\frac{\\partial u}{\\partial y}|_{M_0}\\cos\\beta+\\frac{\\partial u}{\\partial z}|_{M_0}\\cos\\gamma\\) 梯度 \\(u=f(x,y,z)\\) , \\(M_0(x_0,y_0,z_0)\\in\\Omega\\) , 过 \\(M_0\\) 作射线 \\(L\\) , 方向角为 \\(\\alpha\\)、\\(\\beta\\)、\\(\\gamma\\) 则有方向导数 \\(\\frac{\\partial u}{\\partial L}|_{M_0}=\\frac{\\partial u}{\\partial x}|_{M_0}\\cos\\alpha+\\frac{\\partial u}{\\partial y}|_{M_0}\\cos\\beta+\\frac{\\partial u}{\\partial z}|_{M_0}\\cos\\gamma\\) 上式可分离为两个向量点乘: \\(\\frac{\\partial u}{\\partial L}|_{M_0}=\\{\\frac{\\partial u}{\\partial x},\\frac{\\partial u}{\\partial y},\\frac{\\partial u}{\\partial z}\\}|_{M_0}\\cdot\\{\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\}\\) 这两个向量中前者称作梯度, 即函数 \\(u\\) 的梯度: \\(\\nabla u=\\{\\frac{\\partial u}{\\partial x}, \\frac{\\partial u}{\\partial y}, \\frac{\\partial u}{\\partial z}\\}|_{M_0}\\) 后者是与 \\(L\\) 同向的单位向量, 记 \\(\\vec{e}=\\{\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\}\\) 则 \\(\\frac{\\partial u}{\\partial L}|_{M_0}=\\nabla u\\cdot\\vec{e}=\\sqrt{(\\frac{\\partial u}{\\partial x})^2+(\\frac{\\partial u}{\\partial y})^2+(\\frac{\\partial u}{\\partial z})^2}\\cdot1\\cdot\\cos\\theta\\enspace\\) (\\(\\theta\\) 为 \\(\\nabla u\\) 与 \\(\\vec{e}\\) 间的夹角) 由该式可知当 \\(\\cos\\theta=1\\) , 即 \\(\\theta=0\\) 时, 这个点的方向导数 \\(\\frac{\\partial u}{\\partial L}|_{M_0}\\) 取最大值 因此梯度的方向即函数增大速度最快的方向, 或方向导数取最大值的方向 代数应用–多元函数的极值 定义: 设\\(z=f(x,y)\\enspace\\) (\\((x, y)\\in D\\)) , \\(M_0(x_0,y_0)\\in D\\) 若 \\(\\exist\\delta&gt;0\\) , \\(\\forall (x,y)\\in\\mathring{\\bigcup}(M_0,\\delta)\\) \\(f(x,y)&gt;f(x_0,y_0)\\) , 称 \\((x_0,y_0)\\) 为极小点 \\(f(x,y)&lt;f(x_0,y_0)\\) , 称 \\((x_0,y_0)\\) 为极大点 无条件极值 设 \\(z=f(x,y)\\enspace\\) (\\((x, y)\\in D\\)) , \\(D\\) 为开区域 求 \\(z=f(x,y)\\) 在 \\(D\\) 内的极值称为无条件极值 通过令 \\(\\begin{cases} \\frac{\\partial z}{\\partial x}=0 \\\\ \\frac{\\partial z}{\\partial y}=0 \\end{cases}\\) 求对应 \\(x\\)、\\(y\\) 值 判别法 设 \\((x_0,y_0)\\) 为驻点, \\(A=f_{xx}^{\\prime\\prime}(x_0,y_0)\\) , \\(B=f_{xy}^{\\prime\\prime}(x_0,y_0)\\) , \\(C=f_{yy}^{\\prime\\prime}(x_0,y_0)\\) 若 \\(AC-B^2&gt;0\\rArr(x_0,y_0)\\) 为极值点 \\(A&lt;0\\rArr(x_0,y_0)\\) 为极大点 \\(A&gt;0\\rArr(x_0,y_0)\\) 为极小点 若 \\(AC-B^2&lt;0\\rArr(x_0,y_0)\\) 不是极值点 条件极值 二元函数: \\(z=f(x,y)\\) , 约束条件 \\(\\varphi(x,y)=0\\) 解法: 设 \\(F=f(x,y)+\\lambda\\varphi(x,y)\\) 令 \\(\\begin{cases} F_x^\\prime=\\frac{\\partial F}{\\partial x}=f_x^\\prime+\\lambda\\varphi_x^\\prime=0 \\\\ F_y^\\prime=\\frac{\\partial F}{\\partial y}=f_y^\\prime+\\lambda\\varphi_y^\\prime=0 \\\\ F_\\lambda^\\prime=\\frac{\\partial F}{\\partial\\lambda}=\\varphi(x,y)=0 \\end{cases}\\) 解方程组, 求出 \\(x\\)、\\(y\\) 值 (之后的就不必多说了吧, 懂得都懂) 三元函数(以及更多元): \\(u=f(x,y,z)\\) , 约束条件 \\(\\begin{cases} \\varphi(x,y,z)=0 \\\\ \\psi(x,y,z)=0 \\end{cases}\\) 解法: 设 \\(F=f+\\lambda\\varphi+\\mu\\psi\\) 令 \\(\\begin{cases} F_x^\\prime=0 \\\\ F_y^\\prime=0 \\\\ F_z^\\prime=0 \\\\ F_\\lambda^\\prime=0 \\\\ F_\\mu^\\prime=0 \\end{cases}\\) 解方程组, 求出 \\(x\\)、\\(y\\)、\\(z\\) 值 重积分 二重积分的概念与性质 二重积分的定义 设 \\(f(x,y)\\) 在 \\(xOy\\) 面有限闭区域 \\(D\\) 内有界 \\(D\\) 可划分为 \\(\\Delta\\sigma_1,\\Delta\\sigma_2,\\dots,\\Delta\\sigma_n\\) \\(\\forall(\\xi_i,\\eta_i)\\in\\Delta\\sigma_i\\) 作 \\(\\displaystyle\\sum_{i=1}^n f(\\xi_i,\\eta_i)\\Delta\\sigma_i\\enspace\\) (\\(\\Delta\\sigma_i\\) 可视为底面面积) \\(\\lambda\\) 为 \\(\\Delta\\sigma_1,\\Delta\\sigma_2,\\dots,\\Delta\\sigma_n\\) 中的最大值 若 \\(\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n f(\\xi_i,\\eta_i)\\Delta\\sigma_i\\) 存在, 称此极限为 \\(f(x,y)\\) 在 \\(D\\) 上的二重积分, 记 \\(\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\) 二重积分的性质 设 \\(f(x,y)\\)、\\(g(x,y)\\) 在区域 \\(D\\) 上可积, 则 \\(\\iint\\limits_D[af(x,y)+bg(x,y)]\\mathrm{d}\\sigma=a\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma+b\\iint\\limits_D g(x,y)\\mathrm{d}\\sigma\\) 若 \\(D=D_1+D_2\\) 且 \\(D_1\\cap D_2=\\varnothing\\) , 则 \\(\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma=\\iint\\limits_{D_1}f(x,y)\\mathrm{d}\\sigma+\\iint\\limits_{D_2}f(x,y)\\mathrm{d}\\sigma\\) \\(\\iint\\limits_D 1\\mathrm{d}\\sigma=A\\) 若 \\(f(x,y)\\geqslant g(x,y)\\enspace\\) (\\((x, y)\\in D\\)) 则 \\(\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\geqslant\\iint\\limits_D g(x,y)\\mathrm{d}\\sigma\\) 若 \\(f(x,y)\\) 和 \\(|f(x,y)|\\) 在 \\(D\\) 上可积, 则 \\(|\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma|\\leqslant\\iint\\limits_D|f(x,y)|\\mathrm{d}\\sigma\\) 二重积分中值定理 \\(D\\) 为有限闭区域, \\(f(x,y)\\) 在 \\(D\\) 上连续 则 \\(\\exist(\\xi,\\eta)\\in D\\) , 使 \\(\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma=f(\\xi,\\eta)A\\enspace\\) (\\(A\\) 为区域 \\(D\\) 的面积) 证明: \\(\\because f(x,y)\\in c(D)\\) \\(\\therefore f(x,y)\\) 在 \\(D\\) 上有上下界 \\(m\\)、\\(M\\) , 使 \\(m\\leqslant f(x,y)\\leqslant M\\) \\(\\therefore \\iint\\limits_D m\\mathrm{d}\\rho\\leqslant\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\leqslant \\iint\\limits_D M\\mathrm{d}\\rho\\) \\(\\rArr m\\iint\\limits_D 1\\mathrm{d}\\rho\\leqslant\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\leqslant M\\iint\\limits_D 1\\mathrm{d}\\rho\\) \\(\\rArr mA\\leqslant\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\leqslant MA\\) \\(\\rArr m\\leqslant\\frac{1}{A}\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\leqslant M\\) \\(\\exist(\\xi,\\eta)\\in D\\) , 使 \\(f(\\xi,\\eta)=\\frac{1}{A}\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\rArr\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma=f(\\xi,\\eta)A\\) 二重积分的计算法 直角坐标法计算二重积分 情况1 (沿着 \\(x\\) 轴扫 \\(y\\) 轴) \\(D=\\{(x,y)|a\\leqslant x\\leqslant b,\\varphi_1(x)\\leqslant y\\leqslant \\varphi_2(x)\\}\\) 则 \\(\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma=\\int_a^b[\\int_{\\varphi_1(x)}^{\\varphi_2(x)}f(x,y)\\mathrm{d}y]\\mathrm{d}x\\) 情况2 (沿着 \\(y\\) 轴扫 \\(x\\) 轴) \\(D=\\{(x,y)|c\\leqslant y\\leqslant d,\\varphi_1(y)\\leqslant x\\leqslant\\varphi_2(y)\\}\\) 则 \\(\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma=\\int_c^d[\\int_{\\varphi_1(y)}^{\\varphi_2(y)}f(x,y)\\mathrm{d}x]\\mathrm{d}y\\) 极坐标法计算二重积分 特征: 区域 \\(D\\) 的边界含 \\(x^2+y^2\\) \\(f(x,y)\\) 含 \\(x^2+y^2\\) 变换: \\(\\begin{cases} x=r\\cos\\theta \\\\ y=r\\sin\\theta \\end{cases}\\) , \\(\\alpha\\leqslant\\theta\\leqslant\\beta\\) , \\(r_1(\\theta)\\leqslant r\\leqslant r_2(\\theta)\\) \\(\\mathrm{d}\\sigma\\) 取 \\([\\theta,\\theta+\\mathrm{d}\\theta]\\) 取 \\([r,r+\\mathrm{d}x]\\) 则 \\(\\mathrm{d}\\sigma=\\mathrm{d}r\\cdot r\\mathrm{d}\\theta\\) \\(\\therefore\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma=\\int_\\alpha^\\beta[\\int_{r_1(\\theta)}^{r_2(\\theta)}r\\cdot f(r\\cos\\theta, r\\sin\\theta)\\mathrm{d}r]\\mathrm{d}\\theta\\) 三重积分 三重积分的定义 设 \\(\\Omega\\) 为空间有限几何体, \\(f(x,y,z)\\) 在 \\(\\Omega\\) 上有界 将 \\(\\Omega\\) 划分为 \\(\\Delta V_1,\\Delta V_2,\\dots,\\Delta V_n\\) \\(\\forall(\\xi_i,\\eta_i,\\zeta_i)\\in\\Delta V_i\\) , 作 \\(\\displaystyle\\sum_{i=1}^n f(\\xi_i,\\eta_i,\\zeta_i)\\Delta V_i\\) \\(\\lambda\\) 为 \\(\\Delta V_1,\\Delta V_2,\\dots,\\Delta V_n\\) 直径最大值 若 \\(\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n f(\\xi_i,n_i,\\zeta_i)\\Delta V_i\\) 存在, 称此极限为 \\(f(x,y,z)\\) 在 \\(\\Omega\\) 上的三重积分, 记 \\(\\iiint\\limits_\\Omega f(x,y,z)\\mathrm{d}v\\) 即 \\(\\iiint\\limits_\\Omega f(x,y,z)\\mathrm{d}v=\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n f(\\xi_1,\\eta_i,\\zeta_i)\\Delta V_i\\) (三重积分的几何意义是空间几何体的质量) 三重积分的性质 \\(\\iiint\\limits_\\Omega 1\\mathrm{d}v=V\\) 三重积分中值定理: \\(\\Omega\\) 为有限闭区域, \\(f(x,y,z)\\) 在 \\(\\Omega\\) 上连续, 则 \\(\\exist(\\xi,\\eta,\\zeta)\\in\\Omega\\) 使 \\(\\iiint\\limits_\\Omega f(x,y,z)\\mathrm{d}v=f(\\xi,\\eta,\\zeta)V\\) 三重积分的计算方法 直角坐标法 铅直投影法 (\\(\\Sigma_1\\) 为下半球曲面, \\(\\Sigma_2\\) 为上半球曲面) \\(\\Omega=\\{(x,y,z)|(x,y)\\in Dxy,\\varphi_1(x,y)\\leqslant z\\leqslant\\varphi_2(x,y)\\}\\) \\(\\iiint\\limits_\\Omega f(x,y,z)\\mathrm{d}v=\\iint\\limits_{Dxy}[\\int_{\\varphi_1(x,y)}^{\\varphi_2(x,y)}f(x,y,z)\\mathrm{d}z]\\mathrm{d}x\\mathrm{d}y\\) 切片法 (每层切片的 \\(D\\) 都不同, 用 \\(Dz\\) 表示) \\(\\Omega=\\{(x,y,z)|(x,y)\\in Dz, c\\leqslant z\\leqslant d\\}\\) \\(\\iiint\\limits_\\Omega f(x,y,z)\\mathrm{d}v=\\int_c^d[\\iint\\limits_{Dz} f(x,y,z)\\mathrm{d}x\\mathrm{d}y]\\mathrm{d}z\\) 柱面坐标变换法(柱面坐标=极坐标+\\(z\\) 轴) 特征: 区域 \\(\\Omega\\) 的边界含 \\(x^2+y^2\\) \\(f(x,y,z)\\) 含 \\(x^2+y^2\\) 变换: \\(\\Omega=\\{(x,y,z)|(x,y)\\in Dxy,\\varphi_1(x,y)\\leqslant z\\leqslant\\varphi_2(x,y)\\}\\) 令 \\(\\begin{cases} x=r\\cos\\theta \\\\ y=r\\sin\\theta \\\\ z=z \\end{cases}\\) , 其中 \\(\\alpha\\leqslant\\theta\\leqslant\\beta\\) , \\(r_1(\\theta)\\leqslant r\\leqslant r_2(\\theta)\\) , \\(\\varphi_1(r\\cos\\theta,r\\sin\\theta)\\leqslant z\\leqslant\\varphi_2(r\\cos\\theta,r\\sin\\theta)\\) \\(\\mathrm{d}v\\) \\(\\mathrm{d}v=\\mathrm{d}r\\cdot r\\mathrm{d}\\theta\\cdot\\mathrm{d}z\\) (再乘上 \\(z\\) 轴的微分) \\(\\iiint\\limits_{\\Omega}f(x,y,z)\\mathrm{d}v=\\int_\\alpha^\\beta\\mathrm{d}\\theta\\int_{r_1(\\theta)}^{r_2(\\theta)}\\mathrm{d}r\\int_{\\varphi_1(r\\cos\\theta,r\\sin\\theta)}^{\\varphi_2(r\\cos\\theta,r\\sin\\theta)}r\\cdot f(r\\cos\\theta, r\\sin\\theta,z)\\mathrm{d}z\\) 球面坐标变换法 特征: \\(\\Omega\\) 的表面含 \\(x^2+y^2+z^2\\) \\(f(x,y,z)\\) 含 \\(x^2+y^2+z^2\\) 变换 (\\(OM\\) 跟 \\(Ox\\) 方向的夹角为 \\(\\theta\\) ; 跟 \\(Oz\\) 方向的夹角为 \\(\\varphi\\)) \\(\\begin{cases} x=r\\cos\\theta\\sin\\varphi \\\\ y=r\\sin\\theta\\sin\\varphi \\\\ z=r\\cos\\varphi \\end{cases}\\) \\(\\mathrm{d}v\\) \\([\\theta,\\theta+\\mathrm{d}\\theta]\\) \\([\\varphi,\\varphi+\\mathrm{d}\\varphi]\\) \\([r,r+\\mathrm{d}r]\\) (\\(\\mathrm{d}v\\) 是一个立方体) \\(\\mathrm{d}v=\\mathrm{d}r\\cdot r\\mathrm{d}\\varphi\\cdot r\\sin\\varphi\\mathrm{d}\\theta=r^2\\sin\\varphi\\mathrm{d}r\\mathrm{d}\\theta\\mathrm{d}\\varphi\\) 重积分的应用 几何应用 面积 \\(D\\) 为 \\(xOy\\) 面内有限闭区域, 则 \\(D\\) 的面积为 \\(A=\\iint\\limits_D 1\\mathrm{d}\\sigma\\) 空间曲面的面积 \\(\\Sigma:z=f(x,y)\\enspace\\) (\\((x,y)\\in Dxy\\)) \\(\\forall\\mathrm{d}\\sigma\\subset Dxy\\) 法向量 \\(\\vec{n}=\\{-f_x^\\prime,-f_y^\\prime,1\\}\\) 推导: (来自多元函数微分学的几何应用-空间曲面上某一点的法向量) 若 \\(\\Sigma:F(x,y,z)=0\\), 法向量 \\(\\vec{n}=\\{F_x^\\prime,F_y^\\prime,F_z^\\prime\\}_{M_0}\\) 这里 \\(\\Sigma:z=f(x,y)\\rArr F(x,y,z)=z-f(x,y)=0\\) 因此 \\(\\vec{n}=\\{-f_x^\\prime,-f_y^\\prime,1\\}\\) \\(\\mathrm{d}s=\\sqrt{1+f_x^{\\prime 2}+f_y^{\\prime 2}}\\mathrm{d}\\sigma\\) 推导: \\(\\cos\\gamma=\\frac{1}{\\sqrt{1+f_x^{\\prime 2}+f_y^{\\prime 2}}}\\) (法向量和 \\(z\\) 轴夹角, 参见向量及其线性运算-向量方向角和方向余弦) \\(\\because\\mathrm{d}s\\cos\\gamma=\\mathrm{d}\\sigma\\) \\(\\therefore\\mathrm{d}s=\\sqrt{1+f_x^{\\prime 2}+f_y^{\\prime 2}}\\mathrm{d}\\sigma\\) 面积 \\(A=\\iint\\limits_{Dxy}\\mathrm{d}s=\\iint\\limits_{Dxy}\\sqrt{1+f_x^{\\prime 2}+f_y^{\\prime 2}}\\mathrm{d}\\sigma\\) 物理应用 质心 二维 \\(m=\\iint\\limits_D\\rho(x,y)\\mathrm{d}\\sigma\\) \\(\\bar{x}=\\frac{\\iint\\limits_D x\\rho(x,y)\\mathrm{d}\\sigma}{\\iint\\limits_D\\rho(x,y)\\mathrm{d}\\sigma}\\) , \\(\\bar{y}=\\frac{\\iint\\limits_D y\\rho(x,y)\\mathrm{d}\\sigma}{\\iint\\limits_D\\rho(x,y)\\mathrm{d}\\sigma}\\) 三维 \\(m=\\iiint\\limits_\\Omega\\rho(x,y,z)\\mathrm{d}v\\) \\(\\bar{x}=\\frac{\\iiint\\limits_\\Omega x\\rho(x,y,z)\\mathrm{d}v}{\\iiint\\limits_\\Omega\\rho(x,y,z)\\mathrm{d}v}\\) , \\(\\bar{y}=\\frac{\\iiint\\limits_\\Omega y\\rho(x,y,z)\\mathrm{d}v}{\\iiint\\limits_\\Omega\\rho(x,y,z)\\mathrm{d}v}\\) , \\(\\bar{z}=\\frac{\\iiint\\limits_\\Omega z\\rho(x,y,z)\\mathrm{d}v}{\\iiint\\limits_\\Omega\\rho(x,y,z)\\mathrm{d}v}\\) 转动惯量(刚体绕轴转动时的惯性, 大小为质量乘以距离的平方 \\(I=mr^2\\)) 二维 绕直线 \\(L\\) 旋转: \\(I_L=\\iint\\limits_D d^2\\rho(x,y)\\mathrm{d}\\sigma\\) 绕 \\(x\\) 轴旋转: \\(I_x=\\iint\\limits_D y^2\\rho(x,y)\\mathrm{d}\\sigma\\) 绕 \\(y\\) 轴旋转: \\(I_y=\\iint\\limits_D x^2\\rho(x,y)\\mathrm{d}\\sigma\\) 绕原点旋转: \\(I_o=\\iint\\limits_D(x^2+y^2)\\rho(x,y)\\mathrm{d}\\sigma\\) 三维 \\(I_x=\\iiint\\limits_\\Omega(y^2+z^2)\\rho(x,y,z)\\mathrm{d}v\\) \\(I_y=\\iiint\\limits_\\Omega(x^2+z^2)\\rho(x,y,z)\\mathrm{d}v\\) \\(I_z=\\iiint\\limits_\\Omega(x^2+y^2)\\rho(x,y,z)\\mathrm{d}v\\) 引力 求到质量为 \\(m\\) 的点 \\((0,0,c)\\) 的引力: \\(\\forall\\mathrm{\\sigma}\\subset D\\) \\(\\mathrm{d}|\\vec{F}|=k\\frac{m\\cdot\\rho\\mathrm{d}\\sigma}{x^2+y^2+c^2}\\) (\\(k\\) 为引力常数) \\(\\mathrm{d}|\\vec{F_x}|=\\mathrm{d}|\\vec{F}|\\cdot\\cos\\theta\\cdot\\cos\\alpha\\) \\(\\mskip{2.5em}=\\mathrm{d}|\\vec{F}|\\cdot\\frac{\\sqrt{x^2+y^2}}{\\sqrt{x^2+y^2+c^2}}\\cdot\\frac{x}{\\sqrt{x^2+y^2}}\\) \\(\\mskip{2.5em}=\\frac{km\\cdot\\rho(x,y)\\cdot x}{(x^2+y^2+c^2)^{\\frac{3}{2}}}\\mathrm{d}\\sigma\\) \\(x\\) 轴的分力 \\(|\\vec{F_x}|=\\iint\\limits_{D}\\mathrm{d}|\\vec{F_x}|=km\\iint\\limits_{D}\\frac{x\\rho(x,y)}{(x^2+y^2+c^2)^{\\frac{3}{2}}}\\mathrm{d}\\sigma\\) 曲线积分与曲面积分 对弧长的曲线积分 背景: \\(\\rho(x,y)\\) 为线密度函数 经典积分思想: \\(L\\) 划分为 \\(\\Delta S_1,\\dots,\\Delta S_n\\) \\(\\forall(\\xi_i,\\eta_i)\\in\\Delta S_i\\) \\(\\Delta m_i=\\rho(\\xi_i,\\eta_i)\\Delta S_i\\) 令 \\(\\lambda\\) 为 \\(\\Delta S_1,\\dots,\\Delta S_n\\) 最大值 曲线总质量 \\(m=\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n\\rho(\\xi_i,\\eta_i)\\Delta S_i\\) 元素法思想: \\(\\forall\\mathrm{d}s\\subset L\\) \\(\\mathrm{d}m=\\rho(x,y)\\mathrm{d}s\\) \\(m=\\int_L\\mathrm{d}m=\\int_L\\rho(x,y)\\mathrm{d}s\\) 对弧长曲线积分定义: \\(\\int_L f(x,y)\\mathrm{d}s\\) 性质 \\(\\int_L\\alpha f+\\beta g\\mathrm{d}s=\\alpha\\int_L f\\mathrm{d}s+\\beta\\int_L g\\mathrm{d}s\\) \\(L=L_1+L_2\\) 且 \\(L_1\\cap L_2=\\varnothing\\) , 则 \\(\\int_L f(x,y)\\mathrm{d}s=\\int_{L_1} f(x,y)\\mathrm{d}s+\\int_{L_2} f(x,y)\\mathrm{d}s\\) \\(\\int_L 1\\mathrm{d}s=L\\) 若在 \\(L\\) 上 \\(f(x,y)\\leqslant g(x,y)\\) , 则 \\(\\int_L f(x,y)\\mathrm{d}s\\geqslant\\int_L g(x,y)\\mathrm{d}s\\) \\(|\\int_L f(x,y)\\mathrm{d}s|\\leqslant\\int_L|f(x,y)|\\mathrm{d}s\\) 对弧长曲线积分计算方法 \\(L\\) 为直角坐标形式 \\(L:y=\\varphi(x)\\enspace\\) (\\(a\\leqslant x\\leqslant b)\\) \\(\\mathrm{d}s=\\sqrt{(\\mathrm{d}x)^2+(\\mathrm{d}y)^2}=\\sqrt{1+(\\frac{\\mathrm{d}y}{\\mathrm{d}x})^2}\\mathrm{d}x=\\sqrt{1+[f^\\prime(x)]^2}\\mathrm{d}x\\) \\(\\int_L f(x,y)\\mathrm{d}s=\\int_a^b f[x,\\varphi(x)]\\sqrt{1+[f^\\prime(x)]^2}\\mathrm{d}x\\) \\(L\\) 为参数形式 \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\end{cases}\\enspace\\) (\\(\\alpha\\leqslant t\\leqslant\\beta\\)) \\(\\mathrm{d}s=\\sqrt{[\\varphi^\\prime(t)]^2+[\\psi^\\prime(t)]^2}\\mathrm{d}t\\) \\(\\int_L f(x,y)\\mathrm{d}s=\\int_\\alpha^\\beta f[\\varphi(t),\\psi(t)]\\cdot\\sqrt{[\\varphi^\\prime(t)]^2+[\\psi^\\prime(t)]^2}\\mathrm{d}t\\) 对坐标的曲线积分(第二类曲线积分) 背景: 做功(力的正交分解) 二维 \\(\\vec{F}=\\{P(x,y),Q(x,y)\\}\\) \\(\\forall\\vec{\\mathrm{d}s}\\subset L\\) \\(\\vec{\\mathrm{d}s}=\\{\\mathrm{d}x,\\mathrm{d}y\\}\\) \\(\\mathrm{d}w=\\vec{F}\\cdot\\vec{\\mathrm{d}s}=P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y\\) \\(w=\\int_L\\mathrm{d}w=\\int_L p(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y\\) 三维 \\(\\forall\\vec{d}s\\subset L\\) \\(\\vec{d}s=\\{\\mathrm{d}x,\\mathrm{d}y,\\mathrm{d}z\\}\\) \\(\\mathrm{d}w=\\vec{F}\\cdot\\vec{\\mathrm{d}s}=P\\mathrm{d}x+Q\\mathrm{d}y+R\\mathrm{d}z\\) \\(w=\\int_L\\mathrm{d}w=\\int_L P\\mathrm{d}x+Q\\mathrm{d}y+R\\mathrm{d}z\\) 对坐标的曲线积分定义 二维: \\(\\int_L P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y\\) 其中 \\(\\int_L P(x,y)\\mathrm{d}x\\) 称为函数 \\(P(x,y)\\) 在有向曲线段 \\(L\\) 上对坐标 \\(x\\) 的曲线积分. 三维: \\(\\int_L P(x,y,z)\\mathrm{d}x+Q(x,y,z)\\mathrm{d}y+R(x,y,z)\\mathrm{d}z\\) 性质 \\(\\int_L [af_1(x,y)+bf_2(x,y)]\\mathrm{d}x=a\\int_L f_1(x,y)\\mathrm{d}x+b\\int_L f_2(x,y)\\mathrm{d}x\\) \\(\\int_{L^-}P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y=-\\int_L P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y\\) 对坐标的曲线积分基本计算法(二维) 直角坐标法 对 \\(\\int_L P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y\\) \\(L:y=\\varphi(x)\\enspace\\) (\\(x\\in[a,b]\\)) \\(\\int_L P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y=\\int_a^b P[x,\\varphi(x)]\\mathrm{d}x+Q[x,\\varphi(x)]\\cdot\\varphi^\\prime(x)\\mathrm{d}x\\) 参数方程法 \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\end{cases}\\enspace\\) (\\(t\\in[\\alpha,\\beta]\\)) \\(\\int_L P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y=\\int_\\alpha^\\beta P[\\varphi(t),\\psi(t)]\\varphi^\\prime(t)\\mathrm{d}t+Q[\\varphi(t),\\psi(t)]\\psi^\\prime(t)\\mathrm{d}t\\) 格林公式及应用 二维区域的边界 (单连通区域边界逆时针为正向; 多连通区域外边界逆时针为正向, 内边界顺时针为正向) 格林公式: 设 \\(D\\) 为连通区域, \\(L\\) 为 \\(D\\) 的正向边界 若 \\(P(x,y)\\)、\\(Q(x,y)\\) 在 \\(D\\) 上连续可偏导, 则 \\(\\oint_L P\\mathrm{d}x+Q\\mathrm{d}y=\\iint\\limits_D(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y})\\mathrm{d}\\sigma\\enspace\\) (\\(\\oint\\) 表示封闭边界, 即边界是闭合的. 依旧用 \\(\\int\\) 也行) 证明: 单连通区域 \\(\\oint_L P\\mathrm{d}x=-\\iint\\limits_D\\frac{\\partial P}{\\partial y}\\mathrm{d}\\sigma\\) \\(\\oint_L P\\mathrm{d}x=\\int_{L_1}P\\mathrm{d}x+\\int_{L_2}P\\mathrm{d}x\\) \\(=\\int_a^b P[x,\\varphi_1(x)]\\mathrm{d}x+\\int_b^a P[x,\\varphi_2(x)]\\mathrm{d}x\\) \\(=\\int_a^b\\{P[x,\\varphi_1(x)]-P[x,\\varphi_2(x)]\\}\\mathrm{d}x\\) \\(\\iint\\limits_D\\frac{\\partial P}{\\partial y}d\\sigma=\\int_a^b\\mathrm{d}x\\int_{\\varphi_1(x)}^{\\varphi_2(x)}\\frac{\\partial P}{\\partial y}\\mathrm{d}y\\) \\(=\\int_a^b P(x,y)|_{\\varphi_1(x)}^{\\varphi_2(x)}\\mathrm{d}x=\\int_a^b\\{P[x,\\varphi_2(x)]-P[x,\\varphi_1(x)]\\}\\mathrm{d}x\\) \\(\\therefore\\oint_L P\\mathrm{d}x=-\\iint\\limits_D\\frac{\\partial P}{\\partial y}\\mathrm{d}\\sigma\\) \\(\\oint_L Q\\mathrm{d}y=\\iint\\limits_{D}\\frac{\\partial Q}{\\partial x}\\mathrm{d}\\sigma\\) \\(\\oint_L Q\\mathrm{d}y=\\int_{L_1}Q\\mathrm{d}y+\\int_{L_2}Q\\mathrm{d}y\\) \\(=\\int_d^c Q[\\psi_1(y),y]\\mathrm{d}y+\\int_c^d Q[\\psi_2(y),y]\\mathrm{d}y\\) \\(=\\int_c^d\\{Q[\\psi_2(y),y]-Q[\\psi_1(y),y]\\}\\mathrm{d}y\\) \\(\\iint\\limits_{D}\\frac{\\partial Q}{\\partial x}\\mathrm{d}\\sigma=\\int_c^d\\mathrm{d}y\\int_{\\psi_1(y)}^{\\psi_2(y)}\\frac{\\partial Q}{\\partial x}\\mathrm{d}x\\) \\(=\\int_c^d Q(x,y)|_{\\psi_1(y)}^{\\psi_2(y)}\\mathrm{d}y=\\int_c^d\\{Q[\\psi_2(y),y]-Q[\\psi_1(y),y]\\}\\mathrm{d}y\\) \\(\\therefore\\oint_L Q\\mathrm{d}y=\\iint\\limits_{D}\\frac{\\partial Q}{\\partial x}\\mathrm{d}\\sigma\\) \\(\\oint_L P\\mathrm{d}x+Q\\mathrm{d}y=\\iint\\limits_D(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y})\\mathrm{d}\\sigma\\enspace\\) 多联通区域 \\(\\oint\\limits_{\\overline{AMB}+\\overline{BD}+\\overline{DEC}+\\overline{CA}}P\\mathrm{d}x+Q\\mathrm{d}y=\\iint\\limits_{D_1}(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y}\\mathrm{d}\\sigma)\\) \\(\\oint\\limits_{\\overline{AC}+\\overline{CFD}+\\overline{DB}+\\overline{BNA}}P\\mathrm{d}x+Q\\mathrm{d}y=\\iint\\limits_{D_2}(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y})\\mathrm{d}\\sigma\\) \\(\\because(\\overline{AMB}+\\overline{BD}+\\overline{DEC}+\\overline{CA})+(\\overline{AC}+\\overline{CFD}+\\overline{DB}+\\overline{BNA})\\) \\(\\mskip{1em}=\\overline{AMB}+\\overline{DEC}+\\overline{CFD}+\\overline{BNA}=L_1+L_2=L\\) \\(\\therefore\\oint_{L}P\\mathrm{d}x+Q\\mathrm{d}y=\\iint\\limits_{D}(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y})\\mathrm{d}\\sigma\\) 对面积的曲面积分 背景 经典积分思想: \\(\\Sigma\\) 划分为 \\(\\Delta S_1,\\dots,\\Delta S_n\\) \\(\\forall(\\xi_i,\\eta_i,\\zeta_i)\\in\\Delta S_i\\) \\(\\Delta m_i\\approx \\rho(\\xi_i,\\eta_i,\\zeta_i)\\Delta S_i\\) 令 \\(\\lambda\\) 为 \\(\\Delta S_1,\\dots,\\Delta S_n\\) 直径最大值 曲面总质量 \\(m=\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n\\rho(\\xi_i,\\eta_i,\\zeta_i)\\Delta S_i\\) 元素法思想: \\(\\forall\\mathrm{d}s\\subset\\Sigma\\) \\(\\mathrm{d}m=\\rho(x,y,z)\\mathrm{d}s\\) \\(m=\\iint\\limits_{\\Sigma}\\rho(x,y,z)\\mathrm{d}s\\) 对面积的曲面积分的定义: \\(\\iint\\limits_{\\Sigma}f(x,y,z)\\mathrm{d}s\\) 计算方法: 二重积分法 \\(\\Sigma:z=\\varphi(x,y)\\enspace\\) (\\((x,y)\\in Dxy\\)) \\(\\mathrm{d}s=\\sqrt{1+z_x^{\\prime 2}+z_y^{\\prime^2}}\\mathrm{d}\\sigma\\) (参见重积分应用-空间曲面的面积) 面积 \\(\\iint\\limits_\\Sigma f(x,y,z)\\mathrm{d}s=\\iint\\limits_{Dxy} f[x,y,\\varphi(x,y)]\\cdot\\sqrt{1+\\varphi_x^{\\prime 2}+\\varphi_y^{\\prime 2}}\\mathrm{d}\\sigma\\) 对坐标的曲面积分 曲面分有侧和无侧(如莫比乌斯环) 背景: 求流体的流量 流速 \\(\\vec{v}=\\{P(x,y,z),Q(x,y,z),R(x,y,z)\\}\\) 则有通量 \\(\\Phi=\\vec{v}\\cdot\\vec{s}=|\\vec{v}|\\mathrm{d}s\\cdot\\cos\\theta\\) 对坐标的曲面积分的定义 设有侧曲面块 \\(\\Sigma\\) , \\(P(x,y,z)\\)、\\(Q(x,y,z)\\)、\\(R(x,y,z)\\) 在有侧曲面上有界 \\(\\Sigma\\) 分为 \\(\\overrightarrow{\\Delta s_1},\\dots,\\overrightarrow{\\Delta s_n}\\) \\(\\overrightarrow{\\Delta S_i}\\) 在 \\(yOz\\) 面、\\(xOz\\) 面、\\(xOy\\) 面投影为 \\((\\Delta s_i)_{yz}\\)、\\((\\Delta s_i)_{xz}\\)、\\((\\Delta s_i)_{xy}\\) , \\(\\forall(\\xi_i,\\eta_i,\\zeta_i)\\in\\overrightarrow{\\Delta S_i}\\) , 作 \\(\\displaystyle\\sum_{i=1}^n P(\\xi_i,\\eta_i,\\zeta_i)(\\Delta s_i)_{yz}\\) \\(\\displaystyle\\sum_{i=1}^n Q(\\xi_i,\\eta_i,\\zeta_i)(\\Delta s_i)_{xz}\\) \\(\\displaystyle\\sum_{i=1}^n R(\\xi_i,\\eta_i,\\zeta_i)(\\Delta s_i)_{xy}\\) 令 \\(\\lambda\\) 为 \\(\\overrightarrow{\\Delta s_1},\\dots,\\overrightarrow{\\Delta s_n}\\) 直径最大值 (前提是极限存在) \\(\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n P(\\xi_i,\\eta_i,\\zeta_i)(\\Delta s_i)_{yz}=\\iint\\limits_\\Sigma P(x,y,z)\\mathrm{d}y\\mathrm{d}z\\enspace\\) (称为 \\(P\\) 在有侧曲面 \\(\\Sigma\\) 上对坐标 \\(y\\)、\\(z\\) 的曲面积分) \\(\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n Q(\\xi_i,\\eta_i,\\zeta_i)(\\Delta s_i)_{xz}=\\iint\\limits_\\Sigma Q(x,y,z)\\mathrm{d}x\\mathrm{d}z\\enspace\\) (称为 \\(P\\) 在有侧曲面 \\(\\Sigma\\) 上对坐标 \\(x\\)、\\(z\\) 的曲面积分) \\(\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n R(\\xi_i,\\eta_i,\\zeta_i)(\\Delta s_i)_{xy}=\\iint\\limits_\\Sigma R(x,y,z)\\mathrm{d}x\\mathrm{d}y\\enspace\\) (称为 \\(P\\) 在有侧曲面 \\(\\Sigma\\) 上对坐标 \\(x\\)、\\(y\\) 的曲面积分) 因此有 \\(\\iint\\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+\\iint\\limits_\\Sigma Q\\mathrm{d}x\\mathrm{d}z+\\iint\\limits_\\Sigma R\\mathrm{d}x\\mathrm{d}y=\\iint\\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}x\\mathrm{d}z+R\\mathrm{d}x\\mathrm{d}y\\) 性质: \\(\\iint\\limits_\\Sigma=\\iint\\limits_{\\Sigma_1}+\\iint\\limits_{\\Sigma_2}\\) \\(\\iint\\limits_{\\Sigma^-}=-\\iint\\limits_\\Sigma\\) (\\(\\Sigma^-\\) 代表曲面的另一侧) 两类曲面积分关系 对 \\(\\iint\\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}z\\mathrm{d}x+R\\mathrm{d}x\\mathrm{d}y\\) , 有 \\(\\mathrm{d}y\\mathrm{d}z=\\mathrm{d}s\\cdot\\cos\\alpha\\) \\(\\mathrm{d}x\\mathrm{d}z=\\mathrm{d}s\\cdot\\cos\\beta\\) \\(\\mathrm{d}x\\mathrm{d}y=\\mathrm{d}s\\cdot\\cos\\gamma\\) \\(\\iint\\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}x\\mathrm{d}z+R\\mathrm{d}x\\mathrm{d}y=\\iint\\limits_\\Sigma (P\\cos\\alpha+Q\\cos\\beta+R\\cos\\gamma)\\mathrm{d}s\\) 计算方法: 二重积分法 \\(\\Sigma:z=\\varphi(x,y)\\enspace\\) (\\((x,y)\\in Dxy\\)) \\(\\iint\\limits_\\Sigma R(x,y,z)\\mathrm{d}x\\mathrm{d}y=\\pm\\iint\\limits_{Dxy}R[x,y,\\varphi(x,y)]\\mathrm{d}x\\mathrm{d}y\\) (\\(\\Sigma\\) 取上侧为正, \\(\\Sigma\\) 取下侧为负) 高斯公式 定义: \\(\\Omega\\) 为几何体, 曲面 \\(\\Sigma\\) 为 \\(\\Omega\\) 的外表面 函数 \\(P\\)、\\(Q\\)、\\(R\\) 在 \\(\\Omega\\) 上连续可偏导, 则 \\(\\oiint\\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}z\\mathrm{d}x+R\\mathrm{d}x\\mathrm{d}y=\\iiint\\limits_\\Omega(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z})\\mathrm{d}v\\) (\\(\\oiint\\) 表示封闭曲面, 依旧用 \\(\\iint\\) 同样可行) 证明: (仅证 \\(\\oiint\\limits_\\Sigma R\\mathrm{d}x\\mathrm{d}y=\\iiint\\limits_\\Omega\\frac{\\partial R}{\\partial z}\\mathrm{d}v\\)) \\(\\oiint\\limits_\\Sigma R\\mathrm{d}x\\mathrm{d}y=\\iint\\limits_{\\Sigma_1}R\\mathrm{d}x\\mathrm{d}y-\\iint\\limits_{\\Sigma_2}R\\mathrm{d}x\\mathrm{d}y\\) \\(\\iint\\limits_{\\Sigma_1} R\\mathrm{d}x\\mathrm{d}y=-\\iint\\limits_{Dxy}R[x,y,\\varphi_1(x,y)]\\mathrm{d}x\\mathrm{d}y\\) \\(\\iint\\limits_{\\Sigma_2} R\\mathrm{d}x\\mathrm{d}y=\\iint\\limits_{Dxy}R[x,y,\\varphi_2(x,y)]\\mathrm{d}x\\mathrm{d}y\\) \\(\\therefore\\oiint\\limits_\\Sigma R\\mathrm{d}x\\mathrm{d}y=\\iint\\limits_{Dxy}\\{R[x,y,\\varphi_2(x,y)]-R[x,y,\\varphi_1(x,y)]\\}\\mathrm{d}x\\mathrm{d}y\\) \\(\\Omega=\\{(x,y,z)|(x,y)\\in Dxy,\\varphi_1(x,y)\\leqslant z\\leqslant\\varphi_2(x,y)\\}\\) \\(\\iiint\\limits_\\Omega\\frac{\\partial R}{\\partial z}\\mathrm{d}v=\\iint\\limits_{Dxy}\\mathrm{d}x\\mathrm{d}y\\int_{\\varphi_1(x,y)}^{\\varphi_2(x,y)}\\frac{\\partial R}{\\partial z}\\mathrm{d}z\\) \\(=\\iint\\limits_{Dxy}R(x,y,z)|_{\\varphi_1(x,y)}^{\\varphi_2(x,y)}\\mathrm{d}x\\mathrm{d}y\\) \\(=\\iint\\limits_{Dxy}\\{R(x,y,\\varphi_1(x,y))-R(x,y,\\varphi_2(x,y))\\}\\mathrm{d}x\\mathrm{d}y\\) \\(\\therefore\\oiint\\limits_\\Sigma R\\mathrm{d}x\\mathrm{d}y=\\iiint\\limits_\\Omega\\frac{\\partial R}{\\partial z}\\mathrm{d}v\\) 斯托克斯公式 定义: \\(\\Sigma\\) 为光滑曲面块, \\(\\Gamma\\) 为 \\(\\Sigma\\) 的界, \\(\\Sigma\\) 的侧与 \\(\\Gamma\\) 的方向按右手确定 函数 \\(P, Q, R\\) 在 \\(\\Sigma\\) 连续可偏导, 则 $$ \\oint_L P\\mathrm{d}x+Q\\mathrm{d}y+R\\mathrm{d}z=\\iint\\limits_\\Sigma \\begin{vmatrix} \\mathrm{d}y\\mathrm{d}z & \\mathrm{d}z\\mathrm{d}x & \\mathrm{d}x\\mathrm{d}y \\\\ \\frac{\\partial}{\\partial x} & \\frac{\\partial}{\\partial y} & \\frac{\\partial}{\\partial z} \\\\ P & Q & R \\end{vmatrix} =\\iint\\limits_\\Sigma \\begin{vmatrix} \\cos\\alpha & \\cos\\beta & \\cos\\gamma \\\\ \\frac{\\partial}{\\partial x} & \\frac{\\partial}{\\partial y} & \\frac{\\partial}{\\partial z} \\\\ P & Q & R \\end{vmatrix}\\mathrm{d}s $$ 其中 \\(\\cos\\alpha, \\cos\\beta, \\cos\\gamma\\) 为曲面 \\(\\Sigma\\) 法向量的方向余弦 无穷级数 常数项级数的概念和性质 定义: 设常数列 \\({a_n}\\) , 称 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 为常数项级数 \\(S_n=a_1+\\dots+a_n\\) 为部分和 若 \\(\\lim\\limits_{n\\to\\infty}S_n=S\\) 称级数收敛于 \\(S\\) ; 若极限不存在, 称级数发散 \\(S_n\\neq\\displaystyle\\sum_{n=1}^\\infty a_n\\) , \\(\\lim\\limits_{n\\to\\infty}S_n=\\displaystyle\\sum_{n=1}^\\infty a_n\\) 常数项级数性质: \\(\\displaystyle\\sum_{n=1}^\\infty a_n=A\\) , \\(\\displaystyle\\sum_{n=1}^\\infty b_n=B\\) , 则 \\(\\begin{cases} \\displaystyle\\sum_{n=1}^\\infty (a_n+b_n)=A+B \\\\ \\displaystyle\\sum_{n=1}^\\infty (a_n-b_n)=A-B \\end{cases}\\) \\(\\displaystyle\\sum_{n=1}^\\infty ka_n=kS\\) 级数中添加、减少、改变有限项, 级数的收敛性不变 添加括号后收敛性不降低(即收敛性可能会提高) 如 \\(S_n=1-1+1-1+\\dots\\) 发散 但 \\(S_n=(1-1)+(1-1)+\\dots\\) 收敛于0 收敛必要条件: 设 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 收敛, 则 \\(\\lim\\limits_{n\\to\\infty} a_n=0\\) , 反之不对(如调和级数) 几何级数: \\(\\displaystyle\\sum_{n=1}^\\infty aq^n\\begin{cases} |q|\\geqslant1 &amp; \\text{发散} \\\\ |q|&lt;1 &amp; =\\frac{\\text{首项}}{1-\\text{公比}} \\end{cases}\\) (公式推导参考等比数列) 常数项级数的审敛法 正向级数及审敛法 定义: 设 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) , 若 \\(\\forall n\\) , \\(a_n\\geqslant0\\) , 称 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 为正向级数 若 \\(S_1\\leqslant S_2\\leqslant S_3\\leqslant\\dots\\) , 记 \\(\\{S_n\\}\\uarr\\) (表示 \\(S_n\\) 单调递增); 情况1：\\(\\{S_n\\}\\) 无上界 \\(\\rArr \\lim\\limits_{n\\to\\infty} S_n=+\\infty \\rArr \\displaystyle\\sum_{n=1}^\\infty a_n\\) 发散 情况2: \\(S_n\\leqslant M\\rArr\\lim\\limits_{n\\to\\infty}S_n\\) 存在 \\(\\rArr\\displaystyle\\sum_{n=1}^\\infty a_n\\) 收敛 审敛法 比较法 \\(a_n\\leqslant b_n\\) 且 \\(\\displaystyle\\sum_{n=1}^\\infty b_n\\) 收敛, 则 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 收敛 \\(a_n\\geqslant b_n\\) 且 \\(\\displaystyle\\sum_{n=1}^\\infty b_n\\) 发散, 则 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 发散 比较法(极限形式) 设正项级数 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\)、\\(\\displaystyle\\sum_{n=1}^\\infty b_n\\) 若 \\(\\lim\\limits_{n\\to\\infty}\\frac{b_n}{a_n}=l\\enspace\\) (\\(0&lt;l&lt;+\\infty\\)) 则 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 与 \\(\\displaystyle\\sum_{n=1}^\\infty b_n\\) 敛散性相同 比值法 设正项级数 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 若 \\(\\lim\\limits_{n\\to\\infty}\\dfrac{a_{n+1}}{a_n}=\\rho\\) 则 \\(\\rho&lt;1\\) 时, 级数收敛; \\(\\mskip{1em}\\rho&gt;1\\) 时, 级数发散. 根值法 设正项级数 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 若 \\(\\lim\\limits_{n\\to\\infty}\\sqrt[n]{a_n}=\\rho\\) 则 \\(\\rho&lt;1\\) 时, 级数收敛; \\(\\mskip{1em}\\rho&gt;1\\) 时, 级数发散. \\(p-\\)级数: \\(\\displaystyle\\sum_{n=1}^\\infty \\frac{1}{n^p}\\) 称为 \\(p-\\)级数 若 \\(p=1\\) , 称 \\(\\displaystyle\\sum_{n=1}^\\infty \\frac{1}{n}\\) 为调和级数 \\(\\displaystyle\\sum_{n=1}^\\infty \\frac{1}{n^p} \\begin{cases} p&gt;1 &amp; \\text{收敛} \\\\ p\\leqslant 1 &amp; \\text{发散} \\end{cases}\\) (审敛法使用根值法) 交错级数及审敛法 交错级数: 形如 \\(a_1-a_2+a_3-a_4+\\dots\\) 或 \\(-a_1+a_2-a_3+a_4-\\dots\\enspace\\) (\\(\\forall n, a_n\\geqslant 0\\)) 即 \\(\\displaystyle\\sum_{n=1}^\\infty (-1)^{n-1}a_n\\) 或 \\(\\displaystyle\\sum_{n=1}^\\infty(-1)^n a_n\\enspace(\\forall n,a_n\\geqslant 0)\\) 莱布尼茨审敛法 对于 \\(\\displaystyle\\sum_{n=1}^\\infty(-1)^{n-1}a_n\\enspace\\) (\\(\\forall n,a_n\\geqslant 0\\)) 若 \\(\\{a_n\\}\\darr\\) 且 \\(\\lim\\limits_{n\\to\\infty}a_n=0\\) 则 \\(\\displaystyle\\sum_{n=1}^\\infty(-1)^{n-1}a_n\\) 收敛, 且 \\(S\\leqslant a_1\\) 绝对收敛与条件收敛 取绝对值(提高发散性): \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\rarr\\displaystyle\\sum_{n=1}^\\infty|a_n|\\) 定义 当 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 收敛, 而 \\(\\displaystyle\\sum_{n=1}^\\infty|a_n|\\) 发散, 称 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 条件收敛 如 \\(\\displaystyle\\sum_{n=1}^\\infty\\frac{(-1)^{n-1}}{n}=1-\\frac{1}{2}+\\frac{1}{3}-\\frac{1}{4}+\\dots\\) 收敛 但 \\(\\displaystyle\\sum_{n=1}^\\infty|\\frac{(-1)^{n-1}}{n}|=\\displaystyle\\sum_{n=1}^\\infty\\frac{1}{n}\\) 发散 (\\(p-\\)级数) 当 \\(\\displaystyle\\sum_{n=1}^\\infty|a_n|\\) 收敛, 称 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 绝对收敛 结论: 若 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 绝对收敛, 则 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 收敛 幂级数的概念与分析性质 函数项级数的概念 设函数数列 \\(\\{u_n(x)\\}\\) , 称 \\(\\displaystyle\\sum_{n=1}^\\infty u_n(x)\\) 为函数项级数 若 \\(x=x_0\\) 时 \\(\\displaystyle\\sum_{n=1}^\\infty u_n(x_0)\\) 收敛, 称 \\(x=x_0\\) 为收敛点 若 \\(x=x_1\\) 时 \\(\\displaystyle\\sum_{n=1}^\\infty u_n(x_1)\\) 发散, 称 \\(x=x_1\\) 为发散点 例: \\(x+x^2+x^3+x^4+\\dots=\\displaystyle\\sum_{n=1}^\\infty x^n\\) 当 \\(x=\\frac{2}{3}\\) 时收敛; 当 \\(x=2\\) 时发散. 幂级数概念与基本定理 幂级数定义: \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n=a_0+a_1x+a_2x^2+\\dots\\) 或 \\(\\displaystyle\\sum_{n=0}^\\infty a_n(x-x_0)^n=a_0+a_1(x-x_0)+a_2(x-x_0)^2+\\dots\\) 基本定理(Abel定理) 若 \\(x=x_0(\\neq 0)\\) 时 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x_0^n\\) 收敛. 则当 \\(|x|&lt;|x_0|\\) 时, \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n\\) 绝对收敛 若 \\(x=x_1\\) 时 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x_1^n\\) 发散. 则当 \\(|x|&gt;|x_1|\\) 时, \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n\\) 发散 收敛半径与收敛域 \\(\\displaystyle\\sum_{n=1}^\\infty u_n(x)\\) 的所有收敛点组成的集合称为收敛域, 记为 \\(D\\) 收敛半径 \\((-R,R)\\) 内级数绝对收敛, \\((-\\infty,-R)\\cup(R,+\\infty)\\) 内级数发散, \\(x=\\pm R\\) 时可能收敛可能发散 定理1: 对于 \\(\\displaystyle\\sum_{n=0}^\\infty a_nx^n\\) 若 \\(\\lim\\limits_{n\\to\\infty}|\\dfrac{a_{n+1}}{a_n}|=\\rho\\) \\(\\rho=0\\rArr R=+\\infty\\) \\(\\rho=+\\infty\\rArr R=0\\) \\(0&lt;\\rho&lt;+\\infty\\rArr R=\\frac{1}{\\rho}\\) 定理2: 对于 \\(\\displaystyle\\sum_{n=0}^\\infty a_nx^n\\) 若 \\(\\lim\\limits_{n\\to\\infty}\\sqrt[n]{|a_n|}=\\rho\\) \\(\\rho=0\\rArr R=+\\infty\\) \\(\\rho=+\\infty\\rArr R=0\\) \\(0&lt;\\rho&lt;+\\infty\\rArr R=\\frac{1}{\\rho}\\) 对于 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^{2n+1}=a_0x+a_1x^3+a_2x^5+\\dots\\) \\(\\lim\\limits_{n\\to\\infty}|\\frac{a_{n+1}}{a_n}|=\\rho\\) \\(\\rho=0\\rArr R=+\\infty\\) \\(\\rho=+\\infty\\rArr R=0\\) \\(0&lt;\\rho&lt;+\\infty\\rArr R=\\sqrt{\\frac{1}{\\rho}}\\) 幂级数和函数的分析性质 \\(\\forall x\\in D\\) , 和函数 \\(S(x)=\\displaystyle\\sum_{n=1}^\\infty u_n(x)\\) 逐项可积性 若 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n\\) 的和函数 \\(S(x)\\) 在其收敛域上可积 则 \\(\\int_0^x S(x)\\mathrm{d}x=\\int_0^x (\\displaystyle\\sum_{n=0}^\\infty a_n x^n)\\mathrm{d}x=\\displaystyle\\sum_{n=0}^\\infty\\int_0^x a_nx^n\\mathrm{d}x=\\displaystyle\\sum_{n=0}^\\infty\\dfrac{a_n}{n+1}x^{n+1}\\) 且 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n\\) 与 \\(\\displaystyle\\sum_{n=0}^\\infty \\dfrac{a_n}{n+1}x^{n+1}\\) 收敛半径相同 逐项可导性 若 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n\\) 的和函数 \\(S(x)\\) 在其收敛域上可导 则 \\((\\displaystyle\\sum_{n=0}^\\infty a_n x^n)^\\prime=\\displaystyle\\sum_{n=0}^\\infty(a_n x^n)^\\prime=\\displaystyle\\sum_{n=1}^\\infty n a_n x^{n-1}\\) 且 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n\\) 与 \\(\\displaystyle\\sum_{n=1}^\\infty n a_n x^{n-1}\\) 收敛半径相同 函数展开成幂级数 直接法 设 \\(f(x)\\) 在 \\(x=x_0\\) 邻域内任意阶可导. 则 \\(f(x)\\) 在 \\(x=x_0\\) 邻域内展成 \\(\\displaystyle\\sum_{n=0}^\\infty\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\\) 的充要条件是 \\(\\lim\\limits_{n\\to\\infty} R_n(x)=0\\) \\(x=0\\) 时, \\(\\displaystyle\\sum_{n=0}^\\infty\\frac{f^{(n)}(0)}{n!}(x-x_0)^n\\) 称作麦克劳林级数 (参见泰勒级数) 间接法 (基于直接法推导出来的已有公式进行展开) 常用公式: (注意后面的值域范围) \\(e^x=\\displaystyle\\sum_{n=0}^\\infty\\frac{x^n}{n!}=1+x+\\frac{x^2}{2!}+\\dots+\\frac{x^n}{n!}+\\circ(x^n)\\enspace\\) (\\(-1&lt;x&lt;1\\)) \\(\\sin x=\\displaystyle\\sum_{n=0}^\\infty\\frac{(-1)^n}{(2n+1)!}x^{2n+1}=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}+\\dots+(-1)^n\\frac{x^{2n+1}}{(2n+1)!}+\\circ(x^{2n+1})\\enspace\\) (\\(-\\infty&lt;x&lt;+\\infty\\)) \\(\\cos x=\\displaystyle\\sum_{n=0}^\\infty\\frac{(-1)^n}{(2n)!}x^{2n}=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+\\dots+(-1)^n\\frac{x^{2n}}{(2n)!}+\\circ(x^{2n})\\enspace\\) (\\(-\\infty&lt;x&lt;+\\infty\\)) \\(\\frac{1}{1-x}=\\displaystyle\\sum_{n=0}^\\infty x^n=1+x+x^2+x^3+\\dots+x^n+\\circ(x^n)\\enspace\\) (\\(-1&lt;x&lt;1\\)) \\(\\frac{1}{1+x}=\\displaystyle\\sum_{n=0}^\\infty (-1)^n x^n=1-x+x^2-x^3+\\dots+(-1)^nx^n+\\circ(x^n)\\enspace\\) (\\(-1&lt;x&lt;1\\)) \\(\\ln(1+x)=\\displaystyle\\sum_{n=1}^\\infty\\frac{(-1)^{n-1}}{n}x^n=x-\\frac{x^2}{2}+\\frac{x^3}{3}-\\frac{x^4}{4}+\\dots+(-1)^{n-1}\\frac{x^n}{n}+\\circ(x^n)\\enspace\\) (\\(-1&lt;x\\leqslant1\\)) \\(-\\ln(1-x)=\\displaystyle\\sum_{n=1}^\\infty\\frac{x^n}{n}=x+\\frac{x^2}{2}+\\frac{x^3}{3}+\\frac{x^4}{4}+\\dots+\\frac{x^n}{n}+\\circ(x^n)\\enspace\\) (\\(-1\\leqslant x&lt;1\\)) 欧拉公式: \\(e^{i\\theta}=\\cos\\theta+i\\sin\\theta\\) 利用幂级数和函数的逐项可导、可积性 傅里叶级数 背景 单一周期信号: \\(a_n\\cos n\\omega t+b_n\\sin n\\omega t\\) 设 \\(f(x)\\) 是以 \\(2\\pi\\) 为周期的信号 Q1: \\(f(x)\\) 可否分解为 \\(\\dfrac{a_0}{2}+\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)\\) 的形式? \\(a_0=\\text{?}\\enspace a_n=\\text{?}\\enspace b_n=\\text{?}\\) \\(\\dfrac{a_0}{2}\\) 称为直流成份 \\(a_1\\cos x+b_1\\sin x\\) 称为一次谐波 \\(a_2\\cos 2x+b_2\\sin 2x\\) 称为二次谐波 Q2: \\(f(x)\\) 与 \\(\\dfrac{a_0}{2}+\\underbrace{\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)}_{\\text{三角级数}}\\) 什么关系? 三角函数系及正交性 三角函数系: \\(1(=\\cos 0x=\\sin 0x),\\cos x,\\sin x,\\cos 2x,\\sin 2x,\\dots,\\cos(nx),\\sin(nx)\\) 正交性: \\(\\int_{-\\pi}^\\pi 1\\cdot\\cos nx\\mathrm{d}x=0\\enspace\\) (\\(n=1,2,3,\\dots\\)) \\(\\int_{-\\pi}^\\pi 1\\cdot\\cos nx\\mathrm{d}x=0\\enspace\\) (\\(n=1,2,3,\\dots\\)) \\(\\int_{-\\pi}^\\pi\\sin mx\\cos nx\\mathrm{d}x=0\\enspace\\) (\\(m\\)、\\(n=1,2,3,\\dots\\)) \\(\\int_{-\\pi}^\\pi\\cos mx\\cos nx\\mathrm{d}x=\\begin{cases} 2\\pi &amp; m=n=0 \\\\ \\pi &amp; m=n\\geqslant 1 \\\\ 0 &amp; m\\neq n \\end{cases}\\) \\(\\int_{-\\pi}^\\pi\\sin mx\\sin nx\\mathrm{d}x=\\begin{cases} \\pi &amp; m=n\\geqslant 1 \\\\ 0 &amp; m\\neq n \\end{cases}\\) 推导思路: 第三个可用和差角公式的变换 \\(\\sin\\alpha\\cos\\beta=\\frac{1}{2}[\\sin(\\alpha+\\beta)+\\sin(\\alpha-\\beta)]\\) 第四个变体二(\\(m=n\\geqslant 1\\)) 可用二倍角公式的变换 \\(\\cos^2\\alpha=\\frac{1}{2}(1+\\cos 2\\alpha)\\) 第四个变体三同样可用和差叫公式的变换 \\(\\cos\\alpha\\cos\\beta=\\frac{1}{2}[\\cos(\\alpha+\\beta)+\\cos(\\alpha-\\beta)]\\) 第五个变体二同样可用和差叫公式的变换 \\(\\sin\\alpha\\sin\\beta=\\frac{1}{2}[\\cos(\\alpha-\\beta)x-\\cos(\\alpha+\\beta)]\\) 周期为 \\(2π\\) 的函数展开成傅里叶级数 Dirichlet 充分条件: 设 \\(f(x)\\) 是以 \\(2\\pi\\) 为周期的周期级数. 若满足: \\(f(x)\\) 在 \\([-\\pi,\\pi]\\) 内连续或存在有限个第一类间断点 \\(f(x)\\) 在 \\([-\\pi,\\pi]\\) 内仅有有限个极值点 则: \\(f(x)\\) 可以展成 \\(\\frac{a_0}{2}+\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)\\) . 且 \\(a_0=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\mathrm{d}x\\) \\(a_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\cos nx\\mathrm{d}x\\enspace\\) (\\(n=1,2,3,\\dots)\\) \\(b_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\sin nx\\mathrm{d}x\\enspace\\) (\\(n=1,2,3,\\dots)\\) \\(x\\) 为 \\(f(x)\\) 连续点时, 则 \\(\\frac{a_0}{2}+\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)=f(x)\\) \\(x\\) 为 \\(f(x)\\) 间断点时, 则 \\(\\frac{a_0}{2}+\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)=\\frac{f(x-0)+f(x+0)}{2}\\) 例: \\(f(x)\\) 以 \\(2\\pi\\) 为周期, \\(f(x)\\) 在 \\([-\\pi,\\pi]\\) 上表达式为 \\(f(x)=\\begin{cases} -1 &amp; -\\pi\\leqslant x&lt;0 \\\\ 1 &amp; 0\\leqslant x&lt;\\pi \\end{cases}\\) 请将 \\(f(x)\\) 展成 Fourier 级数, 并作其和函数图像. 解: 作 \\(y=f(x)\\) 图, \\(x=k\\pi\\enspace\\) (\\(k\\in Z\\) 为 \\(f(x)\\) 间断点 \\(a_0=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\mathrm{d}x=0\\) \\(a_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\cos nx\\mathrm{d}x=0\\enspace\\) (\\(n=1,2,3,\\dots)\\) \\(b_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\sin nx\\mathrm{d}x=\\frac{2}{\\pi}\\int_0^\\pi\\sin nx\\mathrm{d}x=-\\frac{2}{n\\pi}\\cos nx|_0^\\pi=\\frac{2[1-(-1)^n]}{n\\pi}=\\) \\(\\begin{cases} \\frac{4}{n\\pi} &amp; n=1,3,5,\\dots \\\\ 0 &amp; n=2,4,6,\\dots \\end{cases}\\) \\(f(x)=\\frac{4}{\\pi}(\\frac{1}{1}\\sin 1x+\\frac{1}{3}\\sin 3x+\\frac{1}{5}\\sin 5x+\\dots)=\\frac{4}{\\pi}\\displaystyle\\sum_{n=0}^\\infty\\frac{\\sin(2n+1)x}{2n+1}\\enspace\\) (\\(-\\infty&lt;x&lt;+\\infty\\) 且 \\(x\\neq k\\pi(k\\in Z)\\) (即 \\(x\\) 取不到间断点)) 当 \\(x=k\\pi(k\\in Z)\\) 时 \\(\\frac{4}{\\pi}\\displaystyle\\sum_{n=0}^\\infty\\frac{\\sin(2n+1)x}{2n+1}=\\frac{f(k\\pi-0)+f(k\\pi+0)}{2}=0\\) (结果是观察图像得出的) 令 \\(S(x)=\\frac{4}{\\pi}\\displaystyle\\sum_{n=0}^\\infty\\frac{\\sin(2n+1)x}{2n+1}\\) 作图: 定义于 \\([−\\pi,\\pi]\\) 上函数的傅里叶级数(非周期函数) 思想: 设 \\(f(x)\\) 定义于 \\([-\\pi,\\pi)\\) 1. \\(F(x)\\) 展成傅里叶级数 \\(a_0=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi F(x)\\mathrm{d}x=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\mathrm{d}x\\) \\(a_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\cos nx\\mathrm{d}x\\) \\(b_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\sin nx\\mathrm{d}x\\) \\(F(x)=\\frac{a_0}{2}+\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)\\enspace\\) (\\(-\\infty&lt;x&lt;+\\infty\\) , \\(x\\neq\\) 间断点) \\(f(x)=\\frac{a_0}{2}+\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)\\) \\(x\\) 延拓后有四种可能: \\(\\begin{pmatrix} -\\pi\\leqslant x\\leqslant\\pi , -\\pi\\leqslant x&lt;\\pi \\\\ -\\pi&lt;x\\leqslant\\pi , -\\pi&lt;x&lt;\\pi \\end{pmatrix}\\) , 选择哪个得看延拓后的点能否接上. 上图中延拓后两端依旧断开所以选择 (\\(-\\pi&lt;x\\leqslant\\pi\\)) 例: 求 \\(f(x)=|x|\\enspace\\) (\\(-\\pi\\leqslant x\\leqslant\\pi\\)) 的傅里叶级数 对 \\(f(x)\\) 进行周期延拓 \\(a_0=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\mathrm{d}x=\\frac{2}{\\pi}\\int_0^\\pi x\\mathrm{d}x=\\pi\\) \\(a_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\cos nx\\mathrm{d}x=\\frac{2}{\\pi}\\int_0^\\pi x\\cos nx\\mathrm{d}x=\\frac{2}{n\\pi}\\int_0^\\pi x\\mathrm{d}\\sin nx\\) \\(=\\frac{2}{n\\pi}[(x\\sin nx)|_0^\\pi-\\int_0^\\pi\\sin nx\\mathrm{d}x]\\) (分部积分法) \\(=\\frac{2}{n^2\\pi}\\cos nx|_0^\\pi=\\frac{2}{n^2\\pi}[(-1)^n-1]=\\begin{cases} -\\frac{4}{n^2\\pi} &amp; n=1,3,5,\\dots \\\\ 0 &amp; n=2,4,6,\\dots \\end{cases}\\) \\(b_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\sin nx\\mathrm{d}x=0\\enspace\\) (奇函数 \\(\\times\\) 偶函数 \\(=\\) 奇函数) \\(|x|=\\frac{\\pi}{2}-\\frac{4}{\\pi}(\\frac{1}{1^2}\\cos x+\\frac{1}{3^2}\\cos 3x+\\frac{1}{5^2}\\cos 5x+\\dots)\\enspace\\) (\\(-\\pi\\leqslant x\\leqslant\\pi\\)) 意外的收获: \\(x=0\\) 时有 \\(0=\\frac{\\pi}{2}-\\frac{4}{\\pi}(\\frac{1}{1^2}+\\frac{1}{3^2}+\\frac{1}{5^2}+\\dots)\\) \\(\\rArr\\frac{1}{1^2}+\\frac{1}{3^2}+\\frac{1}{5^2}+\\dots=\\frac{\\pi^2}{8}\\) 即 \\(\\displaystyle\\sum_{n=0}^\\infty\\frac{1}{(2n+1)^2}=\\frac{\\pi^2}{8}\\) \\(\\displaystyle\\sum_{n=1}^\\infty\\frac{1}{n^2}=S\\) $$ \\begin{aligned} S & =\\frac{1}{1^2}+\\frac{1}{2^2}+\\frac{1}{3^2}+\\dots \\\\ & =(\\frac{1}{1^2}+\\frac{1}{3^2}+\\frac{1}{5^2}+\\dots)+(\\frac{1}{2^2}+\\frac{1}{4^2}+\\frac{1}{6^2}+\\dots) \\\\ & =\\frac{\\pi^2}{8}+\\frac{1}{4}(\\frac{1}{1^2}+\\frac{1}{2^2}+\\frac{1}{3^2}+\\dots) \\\\ & =\\frac{\\pi^2}{8}+\\frac{1}{4}S\\rArr S=\\frac{\\pi^2}{6} \\end{aligned} $$ 即 \\(\\displaystyle\\sum_{n=1}^\\infty\\frac{1}{n^2}=\\frac{\\pi^2}{6}\\) 定义于 \\([0,π]\\) 上函数的傅里叶级数 思想: 先区间延拓, 再周期延拓. 区间延拓, 在 \\([-\\pi, 0]\\) 上补充定义: 奇延拓(补充后图像关于原点对称) 偶延拓(补充后图像关于\\(y\\) 轴对称) 周期延拓: 奇延拓, 周期延拓(正弦级数) \\(a_0=0\\) \\(a_n=0\\) \\(b_n=\\frac{2}{\\pi}\\int_0^\\pi f(x)\\sin nx\\mathrm{d}x\\enspace\\) (\\(n=1,2,3,\\dots\\)) \\(\\displaystyle f(x)=\\sum_{n=1}^\\infty b_n\\sin nx\\) (正弦级数) 区间 \\(\\begin{pmatrix} 0 \\leqslant x \\leqslant \\pi , 0 \\leqslant x &lt; \\pi \\\\ 0 &lt; x \\leqslant \\pi , 0 &lt; x &lt; \\pi \\end{pmatrix}\\) , 选择哪个得看延拓后的点能否接上 偶延拓, 周期延拓(余弦级数) \\(a_0=\\frac{2}{\\pi}\\int_0^\\pi f(x)\\mathrm{d}x\\) \\(a_n=\\frac{2}{\\pi}\\int_0^\\pi f(x)\\cos nx\\mathrm{d}x\\) \\(b_n=0\\) \\(\\displaystyle f(x)=\\frac{a_0}{2}+\\sum_{n=1}^\\infty a_n\\cos nx\\) (余弦级数) 区间 \\((0\\leqslant x\\leqslant\\pi)\\) 周期为 \\(2l\\) 的傅里叶级数 \\(f(x)\\) 以 \\(2l\\) 为周期 设 \\(x=\\frac{l}{\\pi}t\\) \\(f(x)=f(\\frac{l}{\\pi}t)=F(t)\\) \\(F(t+2\\pi)=f[\\frac{l}{\\pi}(t+2\\pi)]=f(\\frac{l}{\\pi}t+2l)=f(\\frac{l}{\\pi}t)=F(t)\\) 尝试将 \\(F(x)\\) 化为傅里叶级数: \\(a_0=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi F(t)\\mathrm{d}t\\xlongequal{t=\\frac{\\pi}{l}x}\\frac{1}{\\pi}\\int_{-l}^l f(x)\\cdot\\frac{\\pi}{l}\\mathrm{d}x=\\frac{1}{l}\\int_{-l}^l f(x)\\mathrm{d}x\\) (换元后积分上下界要变, 比如把下界的值代入: \\(-\\pi=\\frac{\\pi}{l}x\\rArr x=-l\\)) \\(a_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi F(t)\\cos nt\\mathrm{d}t\\xlongequal{t=\\frac{\\pi}{l}x}\\frac{1}{\\pi}\\int_{-l}^l f(x)\\cos(\\frac{n\\pi x}{l})\\cdot\\frac{\\pi}{l}\\mathrm{d}x=\\frac{1}{l}\\int_{-l}^l f(x)\\cos(\\frac{n\\pi x}{l})\\mathrm{d}x\\) \\(b_n=\\frac{1}{l}\\int_{-l}^l f(x)\\sin(\\frac{n\\pi x}{l})\\mathrm{d}x\\) \\(F(t)\\) 的傅里叶级数为 \\(\\displaystyle\\frac{a_0}{2}+\\sum_{n=1}^\\infty(a_n\\cos nt+b_n\\sin nt)=\\frac{a_0}{2}+\\sum_{n=1}^\\infty(a_n\\cos(\\frac{n\\pi x}{l})+b_n\\sin(\\frac{n\\pi x}{l}))\\) 定理: \\(f(x)\\) 以 \\(2l\\) 为周期, 在 \\([-l,l)\\) 上满足 Dirichlet 充分条件, 则: \\(f(x)\\) 可展成 \\(\\displaystyle\\frac{a_0}{2}+\\sum_{n=1}^\\infty(a_n\\cos(\\frac{n\\pi x}{l})+b_n\\sin(\\frac{n\\pi x}{l}))\\) \\(a_0=\\frac{1}{l}\\int_{-l}^l f(x)\\mathrm{d}x\\) \\(a_n=\\frac{1}{l}\\int_{-l}^l f(x)\\cos(\\frac{n\\pi x}{l})\\mathrm{d}x\\) \\(b_n=\\frac{1}{l}\\int_{-l}^l f(x)\\sin(\\frac{n\\pi x}{l})\\mathrm{d}x\\) 当 \\(x\\) 为 \\(f(x)\\) 连续点时 \\(\\displaystyle\\frac{a_0}{2}+\\sum_{n=1}^\\infty(a_n\\cos(\\frac{n\\pi x}{l})+b_n\\sin(\\frac{n\\pi x}{l}))=f(x)\\) 当 \\(x\\) 为 \\(f(x)\\) 间断点时 \\(\\displaystyle\\frac{a_0}{2}+\\sum_{n=1}^\\infty(a_n\\cos(\\frac{n\\pi x}{l})+b_n\\sin(\\frac{n\\pi x}{l}))=\\frac{f(\\text{?}-0)+f(\\text{?}+0)}{2}\\enspace\\) (\\(\\text{?}\\) 为间断点坐标) \\(f(x)\\) 定义于 \\([-l,l]\\) 解决思路: 周期延拓, 最后把 \\(x\\) 限制到 \\([-l,l]\\) , 左右端点是否存在看延拓后是否连续 \\(f(x)\\) 定义于 \\([0,l]\\) 先奇延拓或偶延拓, 然后周期延拓, 最后把 \\(x\\) 限制到 \\([-l,l]\\) , 左右端点是否存在看延拓后是否连续","link":"/zh-cn/learn/mathematics/2021/postgraduate-advanced-mathematics-2/"},{"title":"postgraduate-advanced-mathematics","text":"同济高等数学笔记整合(上) 考研用 基于 wmathor/Postgraduate-Advanced-Mathematics 不定积分是为定积分服务的, 它的目的是找原函数 函数与极限 函数 函数: 有集合 \\(D\\) 和 \\(x\\)、\\(y\\) 两个变量. 若对任意 \\(x\\in D\\), 总存在唯一确定的解 \\(y\\) 与 \\(x\\) 对应, 称 \\(y\\) 为 \\(x\\) 的函数, 记作 \\(y=f(x)\\), \\(D\\) 为 \\(x\\) 的定义域 反函数: \\(y=f(x)\\enspace(x\\in D)\\) 严格单调 (单调函数必有单调反函数) 若 \\(y=f(x) \\implies x=\\varphi(y)\\) 则 \\(\\varphi(y)\\) 就是 \\(f(x)\\) 的反函数 基本初等函数: 幂函数 \\(x^a\\) 指数函数 \\(a^x\\enspace(a&gt;0\\) 且 \\(a\\neq 1)\\) 对数函数 \\(\\log_a{x}\\enspace(a&gt;0\\) 且 \\(a\\neq 1)\\) 三角函数 \\(\\sin x,\\cos x,\\tan x,\\cot x,\\sec x,\\csc x\\) 初等函数: 由常数、基本初等函数经过四则运算、复合运算而成的式子 初等性质 奇偶性 设 \\(y=f(x)\\enspace\\) (\\(x\\in D\\), \\(D\\) 关于原点对称) 若对于 \\(\\forall x\\in D\\), 有 \\(f(-x)=-f(x)\\), 则为奇函数; \\(f(-x)=f(x)\\), 则为偶函数 单调性 设 \\(y=f(x)\\enspace(x\\in D)\\) 若 \\(\\exist x_1,x_2\\in D\\) 且 \\(x_1&lt;x_2\\) 时 , 有 \\(f(x_1)&lt;f(x_2)\\), 称 \\(f(x)\\) 在 \\(D\\) 上严格单调递增; 若 \\(\\exist x_1,x_2\\in D\\) 且 \\(x_1&lt;x_2\\) 时 , 有 \\(f(x_1)&gt;f(x_2)\\), 称 \\(f(x)\\) 在 \\(D\\) 上严格单独递减 有界性 设 \\(y=f(x)\\enspace(x\\in D)\\), 函数的界 \\(M\\) 若 \\(\\exist M&gt;0\\), 对于 \\(\\forall x\\in D\\), 有 \\(|f(x)|\\leqslant M\\), 称 \\(f(x)\\) 在 \\(D\\) 上有界 若 \\(\\forall x\\in D\\), \\(f(x)\\geqslant M_1\\), 有下界 若 \\(\\forall x\\in D\\), \\(f(x)\\leqslant M_2\\), 有上界 如: \\(|f(x)|\\leqslant 3\\hArr\\begin{cases} f(x)\\geqslant -3 \\\\ f(x)\\leqslant 3 \\end{cases}\\) 周期性 设 \\(y=f(x)\\enspace(x\\in D)\\) 若 \\(\\exist T&gt;0\\), 对于 \\(\\forall x\\in D\\enspace(x+T\\in D)\\), 有 \\(f(x+T)=f(x)\\), 称 \\(f(x)\\) 为周期函数 数列极限 数列收敛定义 (\\(\\epsilon−N\\)): 设数列 \\(\\{a_n\\}\\), \\(A\\) 为极限值, 最大误差 \\(\\varepsilon\\), 数列在元素 \\(a_N\\) 后极限有效(即之后数列元素与极限值的差值 \\(\\leqslant\\varepsilon\\)), 若 \\(\\forall\\varepsilon&gt;0\\), \\(\\exist N&gt;0\\), 当 \\(n&gt;N\\) 时 \\(|a_n-A|&lt;\\varepsilon\\) 称数列 \\(\\{a_n\\}\\) 收敛于极限 \\(A\\), 记作 \\(\\lim\\limits_{n\\to\\infty}=A\\) 或 \\(a_n\\to A\\enspace(n\\to\\infty)\\) 例: 设通项公式 \\(a_n=\\frac{n+1}{2n}\\), 具体值为 \\(\\frac{3}{4},\\frac{2}{3},\\frac{5}{8},\\frac{3}{5},\\dots\\), 观察得极限 \\(a_n\\to\\frac{1}{2}\\) 设 \\(\\varepsilon=\\frac{1}{10}&gt;0\\), 则 \\(|a_n-\\frac{1}{2}|=\\frac{1}{2n}&lt;\\frac{1}{10}\\rArr n&gt;5\\). 同理: 若 \\(\\varepsilon=\\frac{1}{100}&gt;0\\), 则 \\(\\frac{1}{2n}&lt;\\frac{1}{100}\\rArr n&gt;50\\) 若 \\(\\varepsilon=\\frac{1}{1000}&gt;0\\), 则 \\(\\frac{1}{2n}&lt;\\frac{1}{1000}\\rArr n&gt;500\\) 由此发现该数列有极限: \\(\\lim\\limits_{n\\to\\infty}a_n=\\frac{1}{2}\\) 性质 唯一性: 数列有极限必唯一 证明: (反证法) 设数列有两个极限 \\(\\lim\\limits_{n\\to\\infty}a_n=A\\), \\(\\lim\\limits_{n\\to\\infty}a_n=B\\), 且 \\(A\\neq B\\) 不妨设 \\(A&gt;B\\), \\(\\varepsilon=-\\frac{A+B}{2}\\) \\(\\because\\lim\\limits_{n\\to\\infty}a_n=A\\) \\(\\therefore\\exist N_1&gt;0\\), 当 \\(n&gt;N_1\\) 时, \\(\\mskip{1em}\\)➀ \\(|a_n-A|&lt;\\varepsilon\\Harr\\frac{3A+B}{2}&lt;a_n&lt;\\frac{A-B}{2}\\) \\(\\because\\lim\\limits_{n\\to\\infty}a_n=B\\) \\(\\therefore\\exist N_2&gt;0\\), 当 \\(n&gt;N_2\\) 时, \\(\\mskip{1em}\\)➁ \\(|a_n-B|&lt;\\varepsilon\\Harr\\frac{A-B}{2}&lt;a_n&lt;\\frac{-A+B}{2}\\) 取 \\(N=\\operatorname{max}\\{N_1,N_2\\}\\), 当 \\(n&lt;N_2\\) 时, ➀、➁ 都成立, 但这两个不等式没有交集, 矛盾, 所以 \\(A&gt;B\\) 不对, 同理 \\(B&gt;A\\) 也不对. \\(\\therefore A=B\\), 极限值只有一个. 有界性: 有极限一一定有界, 有界不一定有极限(必须得是单调有界) 若 \\(\\lim\\limits_{n\\to\\infty}a_n=A\\), 则 \\(\\exist M&gt;0\\), 使得 \\(|a_n|\\leqslant M\\), 反之不成立. 证明: \\(\\rArr\\) 取任意 \\(\\varepsilon&gt;0\\) \\(\\because\\lim\\limits_{n\\to\\infty}a_n=A\\) \\(\\therefore\\exist N&gt;0\\), 当 \\(n&gt;N\\) 时 , \\(|a_n-A|&lt;\\varepsilon\\) \\(\\because||a_n|-|A||\\leqslant|a_n-A|\\) (三角不等式) \\(\\therefore\\) 当 \\(n&gt;N\\) 时, \\(||a_n|-|A||&lt;\\varepsilon\\rArr|a_n|&lt;\\varepsilon+|A|\\) 取 \\(M=\\operatorname{max}\\{|a_1|,|a_2|,\\dots,|a_n|,\\varepsilon+|A|\\}\\), 对于 \\(\\forall n\\), 有 \\(|a_n|\\leqslant M\\) \\(\\nLeftarrow\\) 取 \\(a_n=1+(-1)^n\\), 有 \\(|a_n|\\leqslant 2\\), 但 \\(\\lim\\limits_{n\\to\\infty}a_n\\) 不存在 保号性: 若 \\(\\lim\\limits_{n\\to\\infty}a_n=A\\begin{cases} &gt;0 \\\\ &lt;0 \\end{cases}\\), 则 \\(\\exist N&gt;0\\), 当 \\(n&gt;N\\) 时, \\(a_n\\begin{cases} &gt;0 \\\\ &lt;0 \\end{cases}\\) 证明: 若 \\(A&gt;0\\), 取 \\(\\varepsilon=\\frac{A}{2}&gt;0\\) \\(\\because\\lim\\limits_{n\\to\\infty}a_n=A\\) \\(\\therefore\\exist N&gt;0\\), 当 \\(n&gt;N\\) 时, \\(\\mskip{1em}|a_n-A|&lt;\\frac{A}{2}\\hArr\\frac{A}{2}&lt;a_n&lt;\\frac{3A}{2}\\rArr a_n&gt;\\frac{A}{2}&gt;0\\) 若 \\(A&lt;0\\), 取 \\(\\varepsilon=-\\frac{A}{2}&gt;0\\) \\(\\because\\lim\\limits_{n\\to\\infty}a_n=A\\) \\(\\therefore\\exist N&gt;0\\), 当 \\(n&gt;N\\) 时, \\(\\mskip{1em}|a_n-A|&lt;-\\frac{A}{2}\\hArr\\frac{3A}{2}&lt;a_n&lt;\\frac{A}{2}\\rArr a_n&lt;\\frac{A}{2}&lt;0\\) 函数极限 定义 \\(\\varepsilon-\\delta\\) 语言定义法: (\\(\\varepsilon\\) 为值域的误差, \\(\\delta\\) 为定义域的误差) 若 \\(\\forall\\varepsilon&gt;0\\), \\(\\exist\\delta&gt;0\\), 当 \\(|x-a|&lt;\\delta\\) 时 \\(|f(x)-A|&lt;\\varepsilon\\), 称 \\(f(x)\\) 当 \\(x\\to 0\\) 时以 \\(A\\) 为极限 记作 \\(\\lim\\limits_{x\\to a}f(x)=A\\) 或 \\(f(x)\\to A\\enspace(x\\to a)\\) \\(\\varepsilon-X\\) 语言定义法: (\\(X\\) 为定义域极限存在临界点) 若 \\(\\forall\\varepsilon&gt;0\\), \\(\\exist X&gt;0\\) 当 \\(x&gt;X\\) 时, \\(|f(x)-A|&lt;\\varepsilon\\), \\(\\lim\\limits_{x\\to+\\infty}f(x)=A\\) 当 \\(x&lt;-X\\) 时, \\(|f(x)-A|&lt;\\varepsilon\\), \\(\\lim\\limits_{x\\to-\\infty}f(x)=A\\) 当 \\(|x|&gt;X\\) 时, \\(|f(x)-A|&lt;\\varepsilon\\), \\(\\lim\\limits_{x\\to\\infty}f(x)=A\\) 性质 唯一性(函数有极限必唯一) 证明: 设 \\(\\lim\\limits_{x\\to a}f(x)=A\\), \\(\\lim\\limits_{x\\to a}f(x)=B\\) 不妨设 \\(A&gt;B\\), 取 \\(\\varepsilon=\\frac{A-B}{2}&gt;0\\) \\(\\because\\lim\\limits_{x\\to a}f(x)=A\\) \\(\\therefore\\exist\\delta_1&gt;0\\), 当 \\(|x-a|&lt;\\delta_1\\) 时, \\(\\mskip{1em}\\)➀ \\(|f(x)-A|&lt;\\frac{A-B}{2}\\hArr\\frac{A+B}{2}&lt;f(x)&lt;\\frac{3A-B}{2}\\) 又 \\(\\because\\lim\\limits_{x\\to a}f(x)=B\\) \\(\\therefore\\exist\\delta_2&gt;0\\), 当 \\(|x-a|&lt;\\delta_2\\) 时, \\(\\mskip{1em}\\)➁ \\(|f(x)-B|&lt;\\frac{A-B}{2} \\hArr \\frac{3B-A}{2}&lt;f(x)&lt;\\frac{A+B}{2}\\) 取 \\(\\delta=\\operatorname{min}\\{\\delta_1,\\delta_2\\}\\), 当 \\(|x-a|&lt;\\delta\\) 时 ➀、➁ 皆成立, 矛盾. \\(\\therefore A&gt;B\\) 不对, 同理 \\(A&lt;B\\) 也不对. \\(\\therefore A=B\\), 极限值只有一个. 局部有界性: 设 \\(\\lim\\limits_{x\\to a}f(x)=A\\), \\(\\exist\\delta&gt;0\\)、\\(M&gt;0\\), 当 \\(|x-a|&lt;\\delta\\) 时, \\(|f(x)|\\leqslant M\\) 证明: 取任意 \\(\\varepsilon&gt;0\\) \\(\\because\\lim\\limits_{x\\to a}f(x)=A\\) \\(\\therefore\\exist\\delta&gt;0\\), 当 \\(|x-a|&lt;\\delta\\) 时, \\(|f(x)-A|&lt;\\varepsilon\\) 又 \\(\\because||f(x)|-|A||\\leqslant|f(x)-A|\\) (三角不等式) \\(\\therefore\\) 当 \\(|x-a|&lt;\\delta\\) 时, \\(\\mskip{1em}||f(x)|-|A||&lt;\\varepsilon\\rArr|f(x)|&lt;\\varepsilon+|A|(=M)\\) \\(\\therefore\\) 当 \\(|x-a|&lt;\\delta\\) 时, \\(|f(x)|\\leqslant M\\) 保号性: 设 \\(\\lim\\limits_{x\\to a}f(x)=A\\begin{cases} &gt;0 \\\\ &lt;0 \\end{cases}\\), 则 \\(\\exist\\delta&gt;0\\), 当 \\(|x-a|&lt;\\delta\\) 时, \\(f(x)\\begin{cases} &gt;0 \\\\ &lt;0 \\end{cases}\\) 证明: 若 \\(A&gt;0\\), 取 \\(\\varepsilon=\\frac{A}{2}&gt;0\\) \\(\\because\\lim\\limits_{x\\to a}f(x)=A\\) \\(\\therefore\\exist\\delta&gt;0\\), 当 \\(|x-a|&lt;\\delta\\) 时 \\(|f(x)-A|&lt;\\frac{A}{2}\\rArr f(x)&gt;\\frac{A}{2}&gt;0\\) 若 \\(A&lt;0\\), 取 \\(\\varepsilon=-\\frac{A}{2}&gt;0\\) \\(\\because\\lim\\limits_{x\\to a}f(x)=A\\) \\(\\therefore\\exist\\delta&gt;0\\), 当 \\(|x-a|&lt;\\delta\\) 时 \\(|f(x)-A|&lt;-\\frac{A}{2}\\rArr f(x)&lt;\\frac{A}{2}&lt;0\\) Notes: \\(\\{x|0&lt;|x-a|&lt;\\delta\\}\\) 可表示为 \\(\\mathring{\\bigcup}(a\\cdot\\delta)\\) (读作 \\(a\\) 的去心 \\(\\delta\\) 邻域) \\(x\\to a\\) 时 \\(\\begin{cases} x\\to a^- \\\\ x\\to a^+ \\end{cases}\\) 左极限与右极限 若 \\(\\forall\\varepsilon&gt;0\\), \\(\\exist\\delta&gt;0\\) 当 \\(x\\in(a-\\delta,a)\\) 时 \\(|f(x)-A|&lt;\\varepsilon\\), 此时 \\(A\\) 称为 \\(f(x)\\) 在 \\(x=a\\) 处左极限, 记为 \\(\\lim\\limits_{x\\to a^-}f(x)=A\\) 或 \\(f(a-0)=A\\) 当 \\(x\\in(a,a+\\delta)\\) 时 \\(|f(x)-B)|&lt;\\varepsilon\\), 此时 \\(B\\) 称为 \\(f(x)\\) 在 \\(x=a\\) 处右极限, 记为 \\(\\lim\\limits_{x\\to a^+}f(x)=B\\) 或 \\(f(a+0)=B\\) \\(\\lim\\limits_{x\\to a}f(x)\\) 意味着左右极限存在且相等 \\(\\lim\\limits_{x\\to a}f(x)\\) 与 \\(f(a)\\) 无关 (除非该点连续) 如: 分段函数 \\(f(x)=\\begin{cases} x-1 &amp; x&lt;0 \\\\ 0 &amp; x=0 \\\\ 2x-1 &amp; x&gt;0 \\end{cases}\\), 它的极限为 \\(\\begin{cases} \\lim\\limits_{x\\to 0^+}f(x)=-1 \\\\ \\lim\\limits_{x\\to 0^-}f(x)=-1 \\end{cases}\\rArr\\lim\\limits_{x\\to 0}f(x)=-1\\), 但 \\(f(0)=0\\) \\(\\lim\\limits_{x\\to 2}\\frac{x^2-4}{x-2}=\\lim\\limits_{x\\to 2}(x+2)=4\\), 但 \\(f(2)\\) 时分母为零 无穷小与无穷大 无穷小 \\(\\varepsilon-\\delta\\) 定义: 若 \\(\\forall\\varepsilon&gt;0\\), \\(\\exist\\delta&gt;0\\), 当 \\(|x-x_0|&lt;\\delta\\) 时 , \\(|\\alpha(x)-0| &lt;\\varepsilon\\), 称 \\(\\alpha(x)\\) 在 \\(x\\to x_0\\) 时无穷小, 记 \\(\\lim\\limits_{x\\to x_0}\\alpha(x)=0\\) 常规性质: 若 \\(\\alpha\\to 0\\), \\(\\beta\\to 0\\), 则 \\(\\begin{cases} \\alpha\\pm\\beta\\to 0 \\\\ k\\alpha\\to 0 \\\\ \\alpha\\beta\\to0 \\end{cases}\\) 无穷小乘有界函数还是无穷小: \\(\\alpha\\to 0\\), \\(|\\beta|\\leqslant M\\), 则 \\(\\alpha\\beta\\to 0\\) (重要)任意极限加无穷小还是原极限 \\(\\lim\\limits_{x\\to x_0}f(x)=A \\hArr \\lim\\limits_{x\\to x_0}f(x)=A+\\alpha\\enspace(\\alpha\\to 0)\\) 注意: 0 是无穷小, 但无穷小不一定为 0 无穷大 \\(\\varepsilon-\\delta\\) 定义: 若 \\(\\forall M&gt;0\\), \\(\\exist\\delta&gt;0\\), 当 \\(|x-x_0|&lt;\\delta\\) 时, \\(|f(x)|\\geqslant M\\), 称 \\(f(x)\\) 在 \\(x\\to x_0\\) 时无穷大, 记作 \\(\\lim\\limits_{x\\to x_0}f(x)=\\infty\\) \\(\\varepsilon-X\\) 定义: 若 \\(\\forall M&gt;0\\), \\(\\exist X&gt;0\\), 当 \\(x&gt;X\\) 时, \\(|f(x)|\\geqslant M\\), 称 \\(f(x)\\) 在 \\(x\\to +\\infty\\) 时无穷大, 记作 \\(\\lim\\limits_{x\\to+\\infty}f(x)=\\infty\\) 无穷小与无穷大的关系: \\(\\lim\\limits_{x\\to x_0}f(x)=0\\hArr\\lim\\limits_{x\\to x_0}\\frac{1}{f(x)}=\\infty\\) 极限的运算法则 四则极限法则 有 \\(\\lim\\limits_{x\\to x_0}f(x)=A\\), \\(\\lim\\limits_{x\\to x_0}g(x)=B\\) 加减: \\(\\lim\\limits_{x\\to x_0}[f(x)\\pm g(x)]=\\lim\\limits_{x\\to x_0}f(x)\\pm\\lim\\limits_{x\\to x_0}g(x)=A\\pm B\\) 数乘: \\(\\lim\\limits_{x\\to x_0}kf(x)=k\\lim\\limits_{x\\to x_0}f(x)=kA\\) 乘法: \\(\\lim\\limits_{x\\to x_0}[f(x)g(x)]=\\lim\\limits_{x\\to x_0}f(x)\\cdot\\lim\\limits_{x\\to x_0}g(x)=AB\\) 除法: \\(\\lim\\limits_{x\\to x_0}\\frac{f(x)}{g(x)}=\\frac{\\lim\\limits_{x\\to x_0}f(x)}{\\lim\\limits_{x\\to x_0}g(x)}=\\frac{A}{B}\\) 若最后是无穷大比无穷大, 极限除法的值以最高阶系数为准: 设 \\(P(x)=a_nx^n+\\dots+a_1x+a_0\\), \\(Q(x)=b_mx^m+\\dots+b_1x+b_0\\) 则 \\(\\lim\\limits_{x\\to\\infty}\\frac{P(x)}{Q(x)}=\\begin{cases} \\frac{a_n}{b_m} &amp; n=m \\\\ \\infty &amp; n&gt;m \\\\ 0 &amp; n&lt;m \\end{cases}\\) 复合函数极限法则: 设 \\(u=\\varphi(x)\\neq a\\), \\(\\lim\\limits_{u\\to a}f(u)=A\\), \\(\\lim\\limits_{x\\to x_0}\\varphi(x)=a\\), 则 \\(\\lim\\limits_{x\\to x_0}f[g(x)]=A\\) 极限存在法则和两个重要极限 极限存在准则 夹逼定理 数列型: 若 \\(\\begin{cases} a_n\\leqslant b_n\\leqslant c_n \\\\ \\lim\\limits_{n\\to\\infty}a_n=\\lim\\limits_{n\\to\\infty}c_n=A \\end{cases}\\) 则 \\(\\lim\\limits_{n\\to\\infty}b_n=A\\) 证明方法: 利用 \\(\\varepsilon−N\\) 定义推出 \\(A-\\varepsilon&lt;b_n&lt;A+\\varepsilon\\rArr|b_n-A|&lt;\\varepsilon\\) 函数型: 设 \\(\\begin{cases} f(x)\\leqslant g(x)\\leqslant h(x) \\\\ \\lim f(x)=\\lim h(x)=A \\end{cases}\\) 则 \\(\\lim g(x)=A\\) 单调有界数列必有极限 \\(\\{a_n\\}\\) 有界 \\(\\hArr\\{a_n\\}\\) 有上下界 若 \\(\\{a_n\\}\\) 单调递增: \\(\\begin{cases} \\text{有上界}\\rArr\\lim\\limits_{n\\to\\infty}a_n \\text{存在} \\\\ \\text{无上界}\\rArr\\lim\\limits_{n\\to\\infty}a_n\\text{不存在} \\end{cases}\\) 若 \\(\\{a_n\\}\\) 单调递减: \\(\\begin{cases} \\text{有下界}\\rArr\\lim\\limits_{n\\to\\infty}a_n \\text{存在} \\\\ \\text{无下界}\\rArr\\lim\\limits_{n\\to\\infty}a_n\\text{不存在} \\end{cases}\\) 两个重要极限 \\(\\lim\\limits_{x\\to 0}\\frac{\\sin x}{x}=1\\) 证明: 设 \\(0&lt;x&lt;\\frac{\\pi}{2}\\) \\(S_{\\triangle AOB}=\\frac{1}{2}\\sin x\\) \\(S_{扇形AOB}=\\frac{1}{2}x\\) \\(S_{RT\\triangle AOC}=\\frac{1}{2}\\tan x\\) \\(\\therefore\\) 结合图片和三者面积公式可得 \\(\\sin x&lt;x&lt;\\tan x \\rArr 1&lt;\\frac{x}{\\sin x}&lt;\\frac{1}{\\cos x}\\) \\(\\because\\lim\\limits_{x\\to0}\\cos x=1\\) \\(\\therefore\\lim\\limits_{x\\to0}\\frac{1}{\\cos x}=1\\), \\(\\lim\\limits_{x\\to0}1=1\\rArr\\lim\\limits_{x\\to 0}\\frac{x}{\\sin x}=1\\) (夹逼定理) \\(\\rArr\\lim\\limits_{x\\to 0}\\frac{\\sin x}{x}=1\\) 欧拉数 \\(e\\) 的定义: \\(\\lim\\limits_{n\\to\\infty}(1+\\frac{1}{n})^n=e\\) 无穷小的比较 无穷小的比较 \\(\\alpha\\to 0\\), \\(\\beta\\to 0\\) 若 \\(\\lim\\frac{\\beta}{\\alpha}=0\\), 称 \\(\\beta\\) 为 \\(\\alpha\\) 的高阶无穷小, 记 \\(\\beta=o(\\alpha)\\) 若 \\(\\lim\\frac{\\beta}{\\alpha}=\\infty\\), 称 \\(\\beta\\) 为 \\(\\alpha\\) 的低阶无穷小 若 \\(\\lim\\frac{\\beta}{\\alpha^k}=k\\enspace(k\\neq 0,\\infty)\\), 称 \\(\\beta\\) 为 \\(\\alpha\\) 的 \\(k\\) 阶无穷小 若 \\(\\lim\\frac{\\beta}{\\alpha}=k\\enspace(k\\neq 0,\\infty)\\), 称 \\(\\beta\\) 为 \\(\\alpha\\) 的同阶无穷小, 记 \\(\\beta=O(\\alpha)\\) 若 \\(\\lim\\frac{\\beta}{\\alpha}=1\\), 称 \\(\\beta\\) 为 \\(\\alpha\\) 的等价无穷小, 记 \\(\\beta\\sim\\alpha\\) 等价无穷小是同阶无穷小的充分不必要条件 等价无穷小的性质 \\(\\alpha\\to 0\\), \\(\\beta\\to 0\\) \\(\\alpha\\sim\\beta\\hArr\\beta=\\alpha+o(\\alpha)\\) 若 \\(\\alpha\\sim\\alpha_1\\), \\(\\beta\\sim\\beta_1\\), \\(\\lim\\frac{\\beta_1}{\\alpha_1}=A\\), 则 \\(\\lim\\frac{\\beta}{\\alpha}=A\\) 常用等价无穷小 (\\(x\\to 0\\)) \\(x\\sim\\sin x\\), \\(x\\sim\\tan x\\), \\(x\\sim\\arcsin x\\), \\(x\\sim\\arctan x\\), \\(x\\sim\\ln(1+x)\\), \\(x\\sim e^x-1\\) \\(1-\\cos x\\sim\\frac{x^2}{2}\\) \\((1+x)^a-1\\sim ax\\) 函数的连续性与间断点 函数连续是极限存在的充分不必要条件, 因为间断不代表极限不存在 连续 函数在一点连续: \\(\\lim\\limits_{x\\to a}f(x)=f(a)\\) 或 \\(f(a-0)=f(a+0)=f(a)\\) 若 \\(f(a-0)=f(a)\\), 称 \\(f(a)\\) 在 \\(x=a\\) 左连续 若 \\(f(a+0)=f(a)\\), 称 \\(f(a)\\) 在 \\(x=a\\) 右连续 函数在闭区间连续: \\(f(x)\\) 在 \\([a,b]\\) 上有定义, 若: \\(f(x)\\) 在 \\((a,b)\\) 内处处连续 \\(f(a)=f(a+0)\\), \\(f(b)=f(b-0)\\) 则称 \\(f(x)\\) 在 \\([a,b]\\) 上连续, 记 \\(f(x)\\in C[a,b]\\) 间断点及分类 间断: 若 \\(\\lim\\limits_{x\\to a}f(x)\\neq f(a)\\), 称 \\(f(x)\\) 在 \\(x=a\\) 间断 分类: 第一类间断点: \\(f(a-0)\\), \\(f(a+0)\\) 皆存在 可去间断点: \\(f(a-0)=f(a+0)\\neq f(a)\\) 跳跃间断点: \\(f(a-0)\\neq f(a+0)\\) 如 \\(\\lim\\limits_{x\\to 0^-}e^\\frac{1}{x}=0\\), \\(\\lim\\limits_{x\\to 0^+}e^\\frac{1}{x}=+\\infty\\) 第二类间断点: \\(f(a-0)\\), \\(f(a+0)\\) 至少一个不存在 连续函数运算及初等函数连续性 连续函数运算 四则运算 \\(f(x)\\), \\(g(x)\\) 在 \\(x=x_0\\) 处连续, 则 \\(f(x)\\pm g(x)\\) 在 \\(x=x_0\\) 处连续 \\(f(x)g(x)\\) 在 \\(x=x_0\\) 处连续 \\(\\frac{f(x)}{g(x)}\\) 在 \\(x=x_0\\) 处连续 \\((g(x)\\neq 0)\\) (证明思路是证明该点处极限与函数实际取该点值相等, 也就是上节讲到的函数连续定义) 复合运算 \\(f(u)\\), \\(u=\\varphi(x)\\neq a\\) 若 \\(\\lim\\limits_{u\\to a}f(u)=f(a)\\), \\(\\lim\\limits_{x\\to x_0}\\varphi(x)=a\\), 则 \\(\\lim\\limits_{x\\to x_0}f[\\varphi(x)]=f[\\lim\\limits_{x\\to x_0}\\varphi(x)]=f(a)\\) 初等函数连续性: 基本初等函数、初等函数在其定义域内连续 闭区间上连续函数的性质 最值定理 \\(f(x)\\in C[a,b]\\) \\(f(x)\\) 在 \\([a,b]\\) 上取到最小值 \\(m\\) 和最大值 \\(M\\) 即 \\(\\exist x_1,x_2\\in[a,b]\\), 使 \\(f(x_1)=m\\), \\(f(x_2)=M\\) 有界定理 \\(f(x)\\in C[a,b]\\) \\(\\exist k&gt;0\\), 使 \\(\\forall x\\in[a,b]\\) 有 \\(|f(x)|\\leqslant k\\) 零点定理 \\(f(x)\\in C[a,b]\\) 若 \\(f(a)f(b)&lt;0\\) \\(\\exist c\\in[a,b]\\) 使 \\(f(c)=0\\) 介值定理 \\(f(x)\\in C[a,b]\\) \\(\\forall\\eta\\in[m,M]\\), \\(\\exist\\xi\\in[a,b]\\) 使 \\(f(\\xi)=\\eta\\) 导数与微分 导数的概念 导数定义 设 \\(y=f(x)\\enspace(x\\in D)\\), \\(\\Delta y=f(x_0+\\Delta x)-f(x_0)\\enspace(x_0,(x_0+\\Delta x)\\in D)\\) 若 \\(\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta y}{\\Delta x}\\) 存在, 称 \\(f(x)\\) 在 \\(x=x_0\\) 处可导, 该极限称为 \\(f(x)\\) 在 \\(x=x_0\\) 处的导数, 记 \\(f^\\prime(x_0)\\) 或 \\(\\left.\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\right|_{x=x_0}\\) $$ f^\\prime(x_0)=\\lim\\limits_{\\Delta x\\to 0}\\frac{f(x_0+\\Delta x)-f(x_0)}{\\Delta x}=\\lim\\limits_{x\\to x_0}\\frac{f(x)-f(x_0)}{x-x_0} $$ (证明方法: 代入 \\(\\Delta x=x-x_0\\)) 导函数定义: \\(f^\\prime(x)=\\lim\\limits_{\\Delta x\\to0}\\frac{f(x+\\Delta x)-f(x)}{\\Delta x}=\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\) 注意: 可导时左右导数存在且相等 左导数: \\(\\left.\\begin{array}{c} \\lim\\limits_{\\Delta x\\to 0^-}\\frac{\\Delta y}{\\Delta x} \\\\ \\lim\\limits_{x\\to x_0^-}\\frac{f(x)-f(x_0)}{x-x_0} \\end{array}\\right\\} =f_-^\\prime(x_0)\\) 右导数: \\(\\left.\\begin{array}{c} \\lim\\limits_{\\Delta x\\to 0^+}\\frac{\\Delta y}{\\Delta x} \\\\ \\lim\\limits_{x\\to x_0^+}\\frac{f(x)-f(x_0)}{x-x_0} \\end{array}\\right\\} =f_+^\\prime(x_0)\\) 可导一定连续, 连续不一定可导. (因为连续函数在点 \\(f^\\prime(x)=0\\) 处不可导, 如正弦曲线的 \\(y=1\\) 处左右导数不同) 常见初等函数的导函数 \\(C^\\prime=0\\) \\((x^n)^\\prime=nx^{n-1}\\) \\((a^x)^\\prime=a^x\\ln a\\) 特别地 \\((e^x)^\\prime=e^x\\) \\((\\log_a x)^\\prime=\\frac{1}{x\\ln a}\\) \\((\\ln x)^\\prime=\\frac{1}{x}\\) \\((\\sin x)^\\prime=\\cos x\\) \\((\\cos x)^\\prime=-\\sin x\\) \\((\\tan x)^\\prime=\\sec^2x\\) \\((\\cot x)^\\prime=-\\csc^2x\\) \\((\\sec x)^\\prime=\\sec x\\tan x\\) \\((\\csc x)^\\prime=-\\csc x\\cot x\\) \\((\\arcsin x)^\\prime=\\frac{1}{\\sqrt{1-x^2}}\\) \\((\\arccos x)^\\prime=-\\frac{1}{\\sqrt{1-x^2}}\\) \\((\\arctan x)^\\prime=\\frac{1}{1+x^2}\\) \\((\\operatorname{arccot}x)^\\prime=-\\frac{1}{1+x^2}\\) \\((\\sin x)^{(n)}=\\sin(x+\\frac{nx}{2})\\) \\((\\cos x)^{(n)}=\\cos(x+\\frac{nx}{2})\\) \\((\\frac{1}{ax+b})^{(n)}=(-1)^n n!\\frac{a^n}{(ax+b)^{n+1}}\\) 证明: 第一步代入 \\(f^\\prime(x)=\\lim\\limits_{\\Delta x\\to0}\\frac{f(x+\\Delta x)-f(x)}{\\Delta x}\\) \\((x^n)^\\prime=nx^{n-1}\\) 会用到二项式展开式 \\((a^x)^\\prime=a^x\\ln a\\) 会用到 \\(x=e^{\\ln x}\\) 和 \\(x\\sim(e^x-1)\\) \\((\\log_a x)^\\prime=\\frac{1}{x\\ln a}\\) $$ f^\\prime(x)=\\dfrac{\\mathrm{d}y}{\\mathrm{d}x} =\\overbrace{\\dfrac{\\log_a(x+\\mathrm{d}x)-\\log_a x}{\\mathrm{d}x}=\\dfrac{\\log_a(\\frac{x+\\mathrm{d}x}{x})}{\\mathrm{d}x}}^{\\log_a \\frac{M}{N} =\\log_a M-\\log_a N}=\\dfrac{\\log_a(1+\\frac{\\mathrm{d}x}{x})}{\\mathrm{d}x} =\\overbrace{\\dfrac{\\frac{\\ln(1+\\frac{\\mathrm{d}x}{x})}{\\ln a}}{\\mathrm{d}x}}^{\\log_a N=\\frac{\\log_b N}{\\log_b a}} =\\overbrace{\\dfrac{\\frac{\\frac{\\mathrm{d}x}{x}}{\\ln a}}{\\mathrm{d}x}}^{x\\sim\\ln(1+x)}=\\dfrac{1}{x\\ln a} $$ $$ \\lim\\limits_{\\Delta x\\to 0}\\frac{\\sin(x+\\Delta x)-\\sin x}{\\Delta x} =\\underbrace{\\lim\\limits_{\\Delta x\\to 0}\\frac{\\sin x\\cos\\Delta x+\\cos x\\sin\\Delta x-\\sin x}{\\Delta x}}_{\\text{和差角公式}} =\\lim\\limits_{\\Delta x\\to 0}\\frac{\\sin x(\\cos\\Delta x-1)}{\\Delta x}+\\cos x\\lim\\limits_{\\Delta x\\to 0}\\underbrace{\\frac{\\sin\\Delta x}{\\Delta x}}_{x\\sim\\sin x}=\\cos x $$ \\((\\cos x)^\\prime\\) 的证明也同理 后面的都是将其化为 \\(\\sin x\\) 和 \\(\\cos x\\) 的形式然后利用求导的四则运算法则证明 (如 \\(\\sec x=\\frac{1}{\\cos x}\\)、\\(\\csc x=\\frac{1}{\\sin x}\\)) 使用反函数求导法则: 这里只证明 \\(\\arcsin x\\) \\(f(x):y=\\arcsin x\\), \\(\\varphi(y):x=\\sin y\\) \\(f^\\prime(x)=\\frac{1}{\\varphi^\\prime(y)}\\rArr(\\arcsin x)^\\prime=\\dfrac{1}{\\cos y}=\\underbrace{\\frac{1}{\\sqrt{1-\\sin^2 y}}}_{\\text{平方关系式}}=\\underbrace{\\frac{1}{\\sqrt{1-x^2}}}_{\\text{带入} x=\\sin y}\\) 使用高阶导数归纳法 \\(f(x)=\\sin x\\) \\(f^\\prime(x)=\\cos x=\\sin(x+\\frac{\\pi}{2})\\) \\(f^{\\prime\\prime}(x)=-\\sin x=\\sin(x+\\frac{2\\pi}{2})\\) \\(f^{\\prime\\prime\\prime}(x)=-\\cos x=\\sin(x+\\frac{3\\pi}{2})\\) \\(f^{(4)}(x)=\\sin x=\\sin(x+\\frac{4\\pi}{2})\\) \\(\\therefore f^{(n)}(x)=\\sin(x+\\frac{nx}{2})\\) 同理 \\((\\cos x)^{(n)}=\\cos(x+\\frac{nx}{2})\\) \\(f(x)=(2x+1)^{-1}\\) \\(f^\\prime(x)=(-1)(2x+1)^{-2}\\times 2\\) \\(f^{\\prime\\prime}(x)=(-1)(-2)(2x+1)^{-3}\\times 2^2\\) \\(\\therefore f^{(n)}(x)=(-1)^n\\times n! \\times 2^n \\times (2x+1)^{-(n+1)}\\) 求导法则 四则法则 设 \\(u(x)\\), \\(v(x)\\) 可导, 则 加减: \\([u(x)\\pm v(x)]^\\prime=u^\\prime(x)\\pm v^\\prime(x)\\) 数乘: \\((ku)^\\prime=ku^\\prime\\) 乘: \\([u(x)v(x)]^\\prime=u^\\prime(x)v(x)+u(x)v^\\prime(x)\\) 除: \\([\\frac{u(x)}{v(x)}]^\\prime=\\frac{u^\\prime(x)v(x)-u(x)v^\\prime(x)}{v^2(x)}\\enspace(v(x)\\neq 0)\\) 推论: \\((uvw)^\\prime=u^\\prime vw+uv^\\prime w+uvw^\\prime\\) 证明: 令 \\(\\varphi(x)=u(x)+v(x)\\) \\(\\begin{array}{rl} \\Delta\\varphi &amp; =\\varphi(x+\\Delta x)-\\varphi(x) \\\\ &amp; =u(x+\\Delta x)+v(x+\\Delta x)-u(x)-v(x) \\\\ &amp; =\\Delta u+\\Delta v \\end{array}\\) \\(\\lim\\limits_{\\Delta x\\to0}\\frac{\\Delta\\varphi}{\\Delta x}=\\lim\\limits_{\\Delta x\\to0}\\frac{\\Delta u}{\\Delta x}+\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta v}{\\Delta x}=u^\\prime(x)+v^\\prime(x)\\) 令 \\(\\varphi(x)=u(x)v(x)\\) $$ \\begin{array}{rl} \\footnotesize\\Delta\\varphi & \\footnotesize=\\varphi(x+\\Delta x)-\\varphi(x) \\\\ & \\footnotesize=u(x+\\Delta x)v(x+\\Delta x)-u(x)v(x) \\\\ & \\footnotesize=u(x+\\Delta x)v(x+\\Delta x)-u(x)v(x+\\Delta x)+u(x)v(x+\\Delta x)-u(x)v(x) \\\\ & \\footnotesize=\\Delta uv(x+\\Delta x)+u(x)\\Delta v \\end{array} $$ \\(\\begin{array}{rl} \\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta\\varphi}{\\Delta x} &amp; =\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta u}{\\Delta x}\\cdot\\lim\\limits_{\\Delta x\\to 0}v(x+\\Delta x)+u(x)\\lim\\limits_{\\Delta x\\to0}\\frac{\\Delta v}{\\Delta x} \\\\ &amp; =u^\\prime(x)v(x)+u(x)v^\\prime(x) \\end{array}\\) 提示: \\(\\lim\\limits_{\\Delta x\\to0}v(x+\\Delta x)=v(x)\\) 令 \\(\\varphi(x)=\\dfrac{u(x)}{v(x)}\\enspace(v(x)\\neq 0)\\) $$ \\begin{array}{rl} \\footnotesize\\Delta\\varphi=\\varphi(x+\\Delta x)-\\varphi(x) & =\\frac{u(x+\\Delta x)}{v(x+\\Delta x)}-\\frac{u(x)}{v(x)} \\\\ & =\\frac{u(x+\\Delta x)v(x)-v(x+\\Delta x)u(x)}{v(x+\\Delta x)v(x)} \\\\ & =\\frac{[u(x+\\Delta x)v(x)-u(x)v(x)]-[u(x)v(x+\\Delta x)-u(x)v(x)]}{v(x+\\Delta x)v(x)} \\\\ & =\\frac{\\Delta uv(x)-u(x)\\Delta v}{v(x+\\Delta x)v(x)} \\end{array} $$ \\(\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta\\varphi}{\\Delta x}=\\frac{\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta u}{\\Delta x}\\cdot v(x)-u(x)\\cdot\\lim\\limits_{\\Delta x\\to0}\\frac{\\Delta v}{\\Delta x}}{v(x)\\lim\\limits_{\\Delta x\\to0}v(x+\\Delta x)}=\\frac{u^\\prime(x)v(x)-u(x)v^\\prime(x)}{v^2(x)}\\) 提示: \\(\\lim\\limits_{\\Delta x\\to 0}v(x+\\Delta x)=v(x)\\) 反函数求导法则 \\(y=f(x)\\) 可导且 \\(f(x)^\\prime\\neq 0\\) (导数不为零意味着严格单调, 即反函数存在条件), 则反函数 \\(x=\\varphi(y)\\) 可导且 \\(\\varphi^\\prime(y)=\\frac{1}{f^\\prime(x)}\\) 证明: \\(\\varphi^\\prime(y)=\\lim\\limits_{\\Delta y\\to 0}\\frac{\\Delta x}{\\Delta y}=\\lim\\limits_{\\Delta y\\to 0}\\frac{1}{\\frac{\\Delta y}{\\Delta x}}=\\underbrace{\\lim\\limits_{\\Delta x\\to 0}}_{\\text{式➀}}\\frac{1}{\\frac{\\Delta y}{\\Delta x}}=\\frac{1}{f^\\prime(x)}\\) ➀ \\(\\lim\\limits_{\\Delta x\\to0}\\frac{\\Delta y}{\\Delta x}\\neq 0,\\infty\\rArr\\Delta y=O(\\Delta x)\\) 同阶无穷小 复合函数求导法则 (如何判断复合函数: 看其中一个函数的值域是否是另一个函数的定义域的子集) \\(y=f(u)\\) 可导, \\(u=\\varphi(x)\\) 可导且 \\(\\varphi^\\prime(x)\\neq 0\\), 则 \\(y=f(\\varphi(x))\\) 可导 有 \\(f[\\varphi(x)]^\\prime=f^\\prime[\\varphi(x)]\\varphi^\\prime(x)\\) 证明: 用极限: $$ \\begin{array}{rl} f[\\varphi(x)]^\\prime & =\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta y}{\\Delta x} \\\\ & =\\lim\\limits_{\\Delta x\\to 0}(\\frac{\\Delta y}{\\Delta u}\\cdot\\frac{\\Delta u}{\\Delta x}) \\\\ & =\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta y}{\\Delta u}\\cdot\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta u}{\\Delta x} \\\\ & =\\underbrace{\\lim\\limits_{\\Delta u\\to 0}}_{\\text{式➀}}\\frac{\\Delta y}{\\Delta u}\\cdot\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta u}{\\Delta x} \\\\ & =f^\\prime(u)\\cdot\\varphi^\\prime(x) \\end{array} $$ ➀ \\(\\varphi^\\prime(x)=\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta u}{\\Delta x}\\neq 0,\\infty\\rArr\\Delta u=O(\\Delta x)\\) 同阶无穷小 用微分: \\(f[\\varphi(x)]^\\prime=\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\frac{\\mathrm{d}y}{\\mathrm{d}u}\\cdot\\frac{\\mathrm{d}u}{\\mathrm{d}x}=f^\\prime(u)\\cdot\\varphi^\\prime(x)=f^\\prime[\\varphi(x)]\\varphi^\\prime(x)\\) 高阶导数 二阶及以上的导数称为高阶导数. 二阶导数: 对导数再求导一次就是二阶导数 \\(f^{\\prime\\prime}(x)=[f^\\prime(x)]^\\prime=\\frac{\\mathrm{d}(\\frac{\\mathrm{d}y}{\\mathrm{d}x})}{\\mathrm{d}x}=\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}\\) 同理三阶导数 \\(\\frac{\\mathrm{d}^3y}{\\mathrm{d}x^3}\\), \\(n\\) 阶导数 \\(f^{(n)}=\\frac{\\mathrm{d}^ny}{\\mathrm{d}x^n}\\) 高阶导数求导方法: 归纳法 公式法: \\((uv)^\\prime=u^\\prime v+uv^\\prime\\rArr(uv)^{\\prime\\prime}=(u^\\prime v)^\\prime+(uv^\\prime)^\\prime=u^{\\prime\\prime}v+2u^\\prime v^\\prime+uv^{\\prime\\prime}\\) (重要)莱布尼茨公式 \\((uv)^{(n)}=C_n^0 u^{(n)}v+C_n^1 u^{(n-1)}v^\\prime+C_n^2 u^{(n-2)}v^{\\prime\\prime}+\\dots+C_n^n uv^{(n)}\\) 隐函数及由参数方程确定的函数求导 隐函数求导 显函数: \\(y=f(x)\\) 隐函数: \\(F(x,y)=0\\enspace\\underrightarrow{\\text{显式化}}\\enspace y=f(x)\\) 方法: \\(F(x,y)=0\\), 将 \\(y\\) 视作关于 \\(x\\) 的函数 (\\(y=f(x)\\)), 两边对 \\(x\\) 求导. 求导时 \\(y^\\prime=f^\\prime(x)=\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\), 最终将一边化为 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\) 例: \\(e^{x+y}=x^2+y+1\\) 确定 \\(y\\) 为 \\(x\\) 的函数, 求 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\) 解: 两边对 \\(x\\) 求导得 $$ \\begin{array}{rl} & e^{x+y}(1+\\frac{\\mathrm{d}y}{\\mathrm{d}x})=2x+\\frac{\\mathrm{d}y}{\\mathrm{d}x} \\\\ \\hArr & (e^{x+y}-1)\\frac{\\mathrm{d}y}{\\mathrm{d}x}=2x-e^{x+y} \\\\ \\hArr & \\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\frac{2x-e^{x+y}}{e^{x+y}-1} \\end{array} $$ 参数方程确定的函数求导 \\(\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\end{cases}\\), 其中 \\(\\varphi(t) , \\psi(t)\\) 可导, 则 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\frac{\\psi^\\prime(t)}{\\varphi^\\prime(t)}\\enspace(\\varphi(t)\\neq 0)\\) 证明: \\(\\because\\varphi^\\prime(t)=\\frac{\\mathrm{d}x}{\\mathrm{d}t}\\), \\(\\psi^\\prime(t)=\\frac{\\mathrm{d}y}{\\mathrm{d}t}\\) \\(\\therefore\\frac{\\psi^\\prime(t)}{\\varphi^\\prime(t)}=\\frac{\\frac{\\mathrm{d}y}{\\mathrm{d}t}}{\\frac{\\mathrm{d}x}{\\mathrm{d}t}}=\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\) 微分 (一般情况下都是先有导数后求微分, 微分的主要应用是在知道导数的情况下求 \\(\\Delta y\\) 的近似值 \\(\\mathrm{d}y\\)) 微分定义 什么是微分 \\(y=f(x)\\enspace(x\\in D)\\), \\(\\Delta y=f(x_0+\\Delta x)-f(x_0)\\enspace(x_0,(x_0+\\Delta x)\\in D)\\) 若 \\(\\Delta x\\to 0\\) 时 , \\(\\Delta y\\) 和 \\(\\Delta x\\) 的关系能化为线性形式: \\(\\Delta y=A\\Delta x+o(\\Delta x)\\) 则称该函数在点 \\(x=x_0\\) 可微, 记作 \\(\\left.\\mathrm{d}y\\right|_{x=x_0}=A\\Delta x=A\\mathrm{d}x\\) 定理: 可导 \\(\\hArr\\) 可微 证明: 设函数 \\(f(x)\\) 在 \\(x=x_0\\) 处可微, 则有 \\(\\Delta y=A\\Delta x+o(\\Delta x)\\). 当 \\(\\Delta x\\neq 0\\) 时 $$ \\begin{array}{rl} \\frac{\\Delta y}{\\Delta x} & =A+\\frac{o(\\Delta x)}{\\Delta x} \\\\ \\hArr\\left.\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\right|_{x=x_0}=\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta y}{\\Delta x} & =\\lim\\limits_{\\Delta x\\to 0}[A+\\frac{o(\\Delta x)}{\\Delta x}]=A \\end{array} $$ 由上述证明可知, 若函数 \\(f(x)\\) 在 \\(x=x_0\\) 处可微, 其微分为 $$ \\left.\\mathrm{d}y\\right|_{x=x_0}=f^\\prime(x_0)\\Delta x $$ \\(\\Delta y\\) 可表示为该点的微分 \\(\\left.\\mathrm{d}y\\right|_{x=x_0}\\) 加上 \\(\\Delta y\\) 与 \\(\\left.\\mathrm{d}y\\right|_{x=x_0}\\) 的差值: $$ \\begin{array}{rl} & \\Delta y=\\left.\\mathrm{d}y\\right|_{x=x_0}+(\\Delta y-\\left.\\mathrm{d}y\\right|_{x=x_0}) \\\\ \\rArr & \\Delta y=f^\\prime(x_0)\\Delta x+\\underbrace{[\\Delta y-f^\\prime(x_0)\\Delta x]}_{\\text{式➀}} \\end{array} $$ 当 \\(\\Delta x\\to 0\\) 时 $$ \\begin{array}{rl} \\text{➀} & =\\lim\\limits_{\\Delta x\\to0}\\Delta y-f^\\prime(x_0)\\lim\\limits_{\\Delta x\\to 0}\\Delta x \\\\ & =\\lim\\limits_{\\Delta x\\to 0}\\Delta y-\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta y}{\\Delta x}\\cdot\\lim\\limits_{\\Delta x\\to 0}\\Delta x \\\\ & =\\lim\\limits_{\\Delta x\\to 0}(\\frac{\\Delta y\\Delta x}{\\Delta x}-\\frac{\\Delta y\\Delta x}{\\Delta x}) \\\\ & =\\lim\\limits_{\\Delta x\\to 0}(\\frac{0}{\\Delta x})=0 \\rArr o(\\Delta x) \\end{array} $$ 函数的微分: 结合导函数定义可得 \\(\\mathrm{d}y=f^\\prime(x)\\Delta x=f^\\prime(x)\\mathrm{d}x\\) (\\(\\mathrm{d}x=x^\\prime\\Delta x=\\Delta x\\)) 近似计算: 若要求 \\(f(x)\\) 的值, 可以找离 \\(x\\) 较近的点 \\(x_0\\), 它们的距离是 \\(\\Delta x\\), 且 \\(f(x_0)\\) 的值已知 则 \\(f(x)=f(x_0+\\Delta x)=f(x_0)+\\Delta y\\approx f(x_0)+f^\\prime(x_0)\\Delta x\\) 求近似值还可利用 0 的特殊性: \\(x\\to 0\\) 时, \\(f(x)=f(0+x)\\approx f(0)+f^\\prime(0)x\\) \\(\\sqrt[n]{1+x}\\approx 1+\\frac{x}{n}\\) \\(e^x\\approx 1+x\\) \\(\\ln(1+x)\\approx x\\) 微分公式 \\(\\mathrm{d}(c)=c^\\prime\\mathrm{d}x=0\\) \\(\\mathrm{d}(x^a)=ax^{a-1}\\mathrm{d}x\\) \\(\\mathrm{d}(a^x)=a^x\\ln a\\mathrm{d}x\\) \\(\\mathrm{d}(\\log_a x)=\\frac{1}{x\\ln a}\\mathrm{d}x\\) \\(\\mathrm{d}(\\sin x)=\\cos x\\mathrm{d}x\\) \\(\\mathrm{d}(\\cos x)=-\\sin x\\mathrm{d}x\\) \\(\\mathrm{d}(\\tan x)=\\sec^2 x\\mathrm{d}x\\) \\(\\mathrm{d}(\\cot x)=-csc^2 x\\mathrm{d}x\\) \\(\\mathrm{d}(\\sec x)=\\sec x\\tan x\\mathrm{d}x\\) \\(\\mathrm{d}(\\csc x)=-\\csc x\\cot x\\mathrm{d}x\\) \\(\\mathrm{d}(\\arcsin x)=\\frac{1}{\\sqrt{1-x^2}}\\mathrm{d}x\\) \\(\\mathrm{d}(\\arccos x)=-\\frac{1}{\\sqrt{1-x^2}}\\mathrm{d}x\\) \\(\\mathrm{d}(\\arctan x)=\\frac{1}{1+x^2}\\mathrm{d}x\\) \\(\\mathrm{d}(\\operatorname{arccot} x)=-\\frac{1}{1+x^2}\\mathrm{d}x\\) 微分四则运算 设函数 \\(u\\), \\(v\\) 加减: \\(\\mathrm{d}(u\\pm v)=\\mathrm{d}u\\pm\\mathrm{d}v\\) 乘: \\(\\mathrm{d}(uv)=\\mathrm{d}u\\cdot v+u\\cdot\\mathrm{d}v\\) 除: \\(\\mathrm{d}(\\frac{u}{v})=\\frac{\\mathrm{d}u\\cdot v-u\\cdot \\mathrm{d}v}{v^2}\\) 复合函数求微分 \\(y=f(u)\\), \\(u=\\varphi(x)\\) 则 \\(\\mathrm{d}y=f^\\prime[\\varphi(x)]\\varphi^\\prime(x)\\mathrm{d}x=f^\\prime[\\varphi(x)]\\mathrm{d}\\varphi(x)=f^\\prime(u)\\mathrm{d}u\\) 微分中值定理及导数应用 微分中值定理 罗尔中值定理 若: \\(f(x)\\in C[a,b]\\) \\(f(x)\\) 在 \\((a,b)\\) 内可导 \\(f(a)=f(b)\\) 则 \\(\\exist\\xi\\in(a,b)\\), 使 \\(f^\\prime(\\xi)=0\\) 拉格朗日中值定理 若: \\(f(x)\\in C[a,b]\\) \\(f(x)\\) 在 \\((a,b)\\) 内可导 则 \\(\\exist\\xi\\in(a,b)\\), 使 \\(f^\\prime(\\xi)=\\frac{f(b)-f(a)}{b-a}\\) (几何意义为 \\(a\\), \\(b\\) 间存在某个点的斜率等于 \\(a\\), \\(b\\) 两点所成直线的斜率. 某点导数就是该点切线的斜率) 证明: 作虚线 \\(L_{ab}\\) 连接点 \\(a\\)、\\(b\\), 带入直线点斜式方程可得: \\(L_{ab}:y-f(a)=\\frac{f(b)-f(a)}{b-a}(x-a)\\hArr y=f(a)+\\frac{f(b)-f(a)}{b-a}(x-a)\\) 令 \\(\\varphi(x)=\\text{曲}-\\text{直}=f(x)-y=f(x)-f(a)-\\frac{f(b)-f(a)}{b-a}(x-a)\\) \\(\\varphi(x)\\in C[a,b]\\), \\(\\varphi(x)\\) 在 \\((a,b)\\) 内可导且 \\(\\varphi(a)=\\varphi(b)=0\\) 根据罗尔中值定理, \\(\\exist\\xi\\in(a,b)\\), 使 \\(\\varphi^\\prime(\\xi)=0\\) \\(\\therefore\\varphi^\\prime(\\xi)=f^\\prime(\\xi)-\\frac{f(b)-f(a)}{b-a}=0\\rArr f^\\prime(\\xi)=\\frac{f(b)-f(a)}{b-a}\\) 柯西中值定理 若: \\(f(x),g(x)\\in C[a,b]\\) \\(f(x),g(x)\\) 在 \\((a,b)\\) 内可导 \\(g^\\prime(x)\\neq 0\\enspace(x\\in(a,b))\\) 则 \\(\\exist\\xi\\in(a,b)\\), 使 \\(\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}=\\frac{f(b)-f(a)}{g(b)-g(a)}\\) 证明: 构造辅助函数 \\(\\varphi(x)=f(x)-f(a)-\\frac{f(b)-f(a)}{g(b)-g(a)}[g(x)-g(a)]\\) \\(\\varphi(x)\\in C[a,b]\\), \\(\\varphi(x)\\) 在 \\((a,b)\\) 内可导且可知 \\(\\varphi(a)=\\varphi(b)=0\\) \\(\\therefore\\exist\\xi\\in(a,b)\\), 使 \\(\\varphi^\\prime(\\xi)=0\\) \\(\\therefore\\varphi^\\prime(\\xi)=f^\\prime(\\xi)-\\frac{f(b)-f(a)}{g(b)-g(a)}g^\\prime(\\xi)=0\\rArr\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}=\\frac{f(b)-f(a)}{g(b)-g(a)}\\) 洛必达法则 问题的起源: 求 \\(\\lim\\limits_{x\\to 0}\\frac{\\tan x-\\sin x}{x^3}\\) 解: 法1: 原式 \\(=\\lim\\limits_{x\\to 0}\\frac{\\tan x(1-\\overbrace{\\cos x)}^{\\tan x=\\frac{\\sin x}{\\cos x}}}{x^3}=\\lim\\limits_{x\\to 0}\\frac{x\\cdot\\frac{x^2}{2}}{x^3}=\\frac{1}{2}\\) 法2: 原式 \\(=\\lim\\limits_{x\\to 0}\\frac{x-x}{x^3}=0\\) (不行, 精确度不够) 同样使用等价无限小, 却得到了不同的结果. 说明对于存在 无穷小比无穷小(\\(\\frac{0}{0}\\)) 的极限 , 用等价无穷小解极限有局限性, 分子分母经等价无穷小转化后不同阶, 导数精确度不够 洛必达法则的目标: 解 \\(\\frac{0}{0}\\), \\(\\frac{\\infty}{\\infty}\\) 类极限新方法 洛必达法则: 若: \\(f(x)\\)、\\(g(x)\\) 在点 \\(x=a\\) 的去心邻域内可导且 \\(g^\\prime(x)\\neq 0\\) \\(\\frac{0}{0}\\) 型: \\(\\lim\\limits_{x\\to a}f(x)=0\\), \\(\\lim\\limits_{x\\to a}g(x)=0\\) \\(\\frac{\\infty}{\\infty}\\) 型: \\(\\lim\\limits_{x\\to a}f(x)=\\infty\\), \\(\\lim\\limits_{x\\to a}g(x)=\\infty\\) \\(\\lim\\limits_{x\\to a}\\frac{f^\\prime(x)}{g^\\prime(x)}=A\\) 则 \\(\\lim\\limits_{x\\to a}\\frac{f(x)}{g(x)}=A\\) 洛必达法则证明: (利用柯西中值定理) \\(\\lim\\limits_{x\\to a}f(x)=0\\), \\(\\lim\\limits_{x\\to a}g(x)=0\\) \\(\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}=\\frac{f(x)-f(a)}{g(x)-g(a)}\\enspace(\\xi\\in(a,x))\\) \\(\\therefore\\lim\\limits_{x\\to a}\\frac{f(x)-f(a)}{g(x)-g(a)}=\\lim\\limits_{x\\to a}\\frac{f(x)}{g(x)}=\\lim\\limits_{x\\to a}\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}=\\lim\\limits_{\\xi\\to a}\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}=A\\) (\\(x\\to a\\), \\(\\xi\\) 介于 \\(a\\) 与 \\(x\\) 之间 \\(\\rArr\\xi\\to a\\)) \\(\\lim\\limits_{x\\to a}f(x)=\\infty\\), \\(\\lim\\limits_{x\\to a}g(x)=\\infty\\) $$ \\begin{array}{rl} \\frac{f(x)}{g(x)} & =\\frac{f(x)-f(a)}{g(x)}+\\frac{f(a)}{g(x)} \\\\ & =\\frac{g(x)-g(a)}{g(x)}\\cdot\\frac{f(x)-f(a)}{g(x)-g(a)}+\\frac{f(a)}{g(x)} \\\\ & =[1-\\frac{g(a)}{g(x)}]\\cdot\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}+\\frac{f(a)}{g(x)}\\enspace(\\xi\\in(a,x)) \\end{array} $$ \\(\\hArr\\lim\\limits_{x\\to a}\\frac{f(x)}{g(x)}=\\lim\\limits_{x\\to a}[1-\\frac{g(a)}{g(x)}]\\cdot\\lim\\limits_{x\\to a}\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}+\\lim\\limits_{x\\to a}\\frac{f(a)}{g(x)}\\) \\(\\because f(a)\\)、\\(g(a)\\) 是定值 (因此远远小于 \\(\\infty\\)) \\(\\therefore\\lim\\limits_{x\\to a}\\frac{f(x)}{g(x)}=\\lim\\limits_{x\\to a}\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}=A\\) 注意 若 \\(\\lim\\limits_{x\\to a}\\frac{f^\\prime(x)}{g^\\prime(x)}\\) 不存在, 只表明洛必达法则不能使用, 不代表极限 \\(\\lim\\limits_{x\\to a}\\frac{f(x)}{g(x)}\\) 不存在 \\(\\lim\\limits_{x\\to+\\infty}\\frac{\\ln x}{x^a}=0\\enspace(a&gt;0)\\) \\(\\lim\\limits_{x\\to+\\infty}\\frac{x^a}{b^x}=0\\enspace(a&gt;0,b&gt;1)\\) 泰勒公式 泰勒公式 设 \\(f(x)\\) 在 \\(x=x_0\\) 邻域内 \\(n+1\\) 阶可导 则 \\(f(x)=P_n(x)+R_n(x)\\) 其中: \\(P_n(x)=f(x_0)+f^\\prime(x_0)(x-x_0)+\\frac{f^{\\prime\\prime}(x_0)}{2!}(x-x_0)^2+\\dots+\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\\) \\(R_n(x)=o((x-x_0)^n)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)^{n+1}\\enspace\\) (\\(\\xi\\) 介于 \\(x_0\\) 与 \\(x\\) 之间) 如果 \\(x_0=0\\), 这个式子被称为麦克劳林公式 泰勒公式证明: 设 \\(\\footnotesize f(x)=a_0+a_1(x-x_0)+a_2(x-x_0)^2+a_3(x-x_0)^3+\\dots+a_n(x-x_0)^n\\) 要使这个式子派用场, 得找到 \\(a_0,a_1,\\dots\\) 这些系数的值, 怎么做呢? 要得到 \\(a_0\\), 可以使 \\(x=x_0\\), 这样其他项就消除了 那其他的 \\(a_1,a_2,a_3\\) 呢? 我们可以不断对该式求它的一阶, 二阶, 三阶, … 导数: \\(f^\\prime(x)=a_1+2a_2(x-x_0)+3a_3(x-x_0)^2+\\dots+na_n(x-x_0)^{n-1}\\) \\(f^{\\prime\\prime}(x)=2a_2+3\\cdot 2a_3(x-x_0)^2+\\dots+n(n-1)(x-x_0)^{n-2}\\) \\(\\dots\\) 发现规律了吗, 将 \\(x=x_0\\) 带入, 可以轻松得到对应项的系数值: \\(a_1=\\frac{f^\\prime(x_0)}{1}\\), \\(a_2=\\frac{f^{\\prime\\prime}(x_0)}{1\\cdot 2}\\), \\(a_3=\\frac{f^{\\prime\\prime\\prime}(x_0)}{1\\cdot 2\\cdot 3}\\rArr a_n=\\frac{f^{(n)}(x_0)}{n!}\\) 然后式子就能写成 \\(\\footnotesize f(x)=f(x_0)+f^\\prime(x_0)(x-x_0)+\\frac{f^{\\prime\\prime}(x_0)}{2!}(x-x_0)^2+\\dots+\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\\) (常见泰勒展开式见章节: 无穷级数-&gt;函数展开成幂级数) 导数与函数单调性和曲线凹凸性的关系 导数与函数单调性 导数可以判别函数的单调性: \\(f(x)\\enspace(x\\in[a,b])\\) 在 \\((a,b)\\) 内可导 若 \\(f^\\prime(x)&gt;0\\enspace(a&lt;x&lt;b)\\), 则 \\(f(x)\\) 在 \\([a,b]\\) 上单调递增 若 \\(f^\\prime(x)&lt;0\\enspace(a&lt;x&lt;b)\\), 则 \\(f(x)\\) 在 \\([a,b]\\) 上单调递减 导数与曲线凹凸性 曲线凹凸性的定义: 若 \\(\\forall x_1,x_2\\in D\\) 且 \\(x_1\\neq x_2\\), 有 \\(f(\\frac{x_1+x_2}{2})&lt;\\frac{f(x_1)+f(x_2)}{2}\\) 则 \\(f(x)\\) 在 \\(D\\) 内为凹函数 若 \\(\\forall x_1,x_2\\in D\\) 且 \\(x_1\\neq x_2\\), 有 \\(f(\\frac{x_1+x_2}{2})&gt;\\frac{f(x_1)+f(x_2)}{2}\\) 则 \\(f(x)\\) 在 \\(D\\) 内为凸函数 二阶导数判别法: \\(f(x)\\enspace(x\\in[a,b])\\) 在 \\((a,b)\\) 内二阶可导 若 \\(f^{\\prime\\prime}(x)&gt;0\\enspace(a&lt;x&lt;b)\\), 则 \\(y=f(x)\\) 图像在 \\([a,b]\\) 上是凹的 若 \\(f^{\\prime\\prime}(x)&lt;0\\enspace(a&lt;x&lt;b)\\), 则 \\(y=f(x)\\) 图像在 \\([a,b]\\) 上是凸的 极值与最值 一个函数中, 极大值、极小值可以有很多, 但最大值、最小值只能有一个 极大值与极小值 定义: 设 \\(y=f(x)\\enspace(x,x_0\\in D)\\) 若 \\(\\exist\\delta&gt;0\\), 当 \\(0&lt;|x-x_0|&lt;\\delta\\) 时 有 \\(f(x)&gt;f(x_0)\\), 称 \\(x_0\\) 为极小点, \\(f(x_0)\\) 为极小值 有 \\(f(x)&lt;f(x_0)\\), 称 \\(x_0\\) 为极大点, \\(f(x_0)\\) 为极大值 求极值的步骤: 法一(利用目标点附近导数) 若同时满足 \\(\\begin{array}{cc} x&lt;x_0 &amp; f^\\prime(x)&lt;0 \\\\ x&gt;x_0 &amp; f^\\prime(x)&gt;0 \\end{array}\\) 则 \\(x=x_0\\) 为极小点 若同时满足 \\(\\begin{array}{cc} x&lt;x_0 &amp; f^\\prime(x)&gt;0 \\\\ x&gt;x_0 &amp; f^\\prime(x)&lt;0 \\end{array}\\) 则 \\(x=x_0\\) 为极大点 法二(利用二阶导数) 设 \\(f^\\prime(x_0)=0\\), \\(f^{\\prime\\prime}(x_0)\\begin{cases} &gt;0 &amp; x_0 \\text{为极小点} \\\\ &lt; 0 &amp; x_0 \\text{为极大点} \\end{cases}\\) 最大值与最小值 设 \\(f(x)\\in C[a,b]\\) 则极小值和极大值可在 \\(f(a)\\)、\\(f(b)\\) 和其他使 \\(f^\\prime(x)=0\\text{或不存在}\\) 的点之中找到 函数图像描绘 渐近线 设函数 \\(f(x)\\) 水平渐近线: 若 \\(\\lim\\limits_{x\\to\\infty}f(x)=A\\) 称 \\(f(x)\\) 有水平渐近线 \\(y=A\\) 垂直渐近线: 若 \\(\\lim\\limits_{x\\to a}f(x)=\\infty\\) 称 \\(f(x)\\) 有垂直渐近线 \\(x=a\\) 斜渐近线: 若 \\(\\lim\\limits_{x\\to\\infty}\\frac{f(x)}{x}=k \\quad\\) (可以理解为斜率) \\(\\lim\\limits_{x\\to\\infty}[f(x)-kx]=b\\) 称 \\(f(x)\\) 有斜渐近线 \\(y=kx+b\\) 作图 (根据一阶和二阶导数的值描绘函数曲线) 设函数 \\(f(x)\\enspace(x\\in D)\\) 在定义域内: 找出 \\(f^\\prime(x)=0\\text{或不存在}\\) 的所有点 找出 \\(f^{\\prime\\prime}(x)=0\\text{或不存在}\\) 的所有点 画渐近线 作表 \\(x\\) () ? () ? \\(\\dots\\) \\(f^\\prime(x)\\) \\(+\\) \\(-\\) \\(f^{\\prime\\prime}(x)\\) \\(+\\) \\(+\\) \\(f(x)\\) \\(\\nearrow\\) 极大 \\(\\searrow\\) 在坐标系上找到关键点, 描图 弧微分与曲率 弧微分 前面的微分能让我们求 \\(\\Delta y\\) 的近似值, 也就是从 \\(x\\) 到 \\(x_0\\) 后 \\(y\\) 轴的偏移量近似值 但如果我们想要求从 \\(x\\) 到 \\(x_0\\) 间这段函数曲线长度的近似值(即弧微分)呢? 两种弧微分形式: 普通函数 \\(L:f(x)\\) \\(\\mathrm{d}s=\\sqrt{(\\mathrm{d}x)^2+(\\frac{\\mathrm{d}y}{\\mathrm{d}x})^2(\\mathrm{d}x)^2}=\\sqrt{1+(\\frac{\\mathrm{d}y}{\\mathrm{d}x})^2}\\mathrm{d}x=\\sqrt{1+[f^\\prime(x)]^2}\\mathrm{d}x\\) 参数方程 \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\end{cases}\\) \\(\\footnotesize\\mathrm{d}s=\\sqrt{(\\mathrm{d}x)^2+(\\mathrm{d}y)^2}=\\sqrt{[\\varphi^\\prime(t)]^2(\\mathrm{d}t)^2+[\\psi^\\prime(t)]^2(\\mathrm{d}t)^2}=\\sqrt{[\\varphi^\\prime(t)]^2+[\\psi^\\prime(t)]^2}\\mathrm{d}t\\) 曲率与曲率半径 曲率大小的因素: 角度一定, 弯曲度与两点间的弧长成反比 \\(\\Delta\\alpha\\) 一定, \\(|\\stackrel\\frown{M_1N_1}|&lt;|\\stackrel\\frown{M_2N_2}|\\) 弧长一定, 弯曲度与切线夹角成正比 \\(|\\stackrel\\frown{MN}|\\) 一定, \\(\\Delta\\alpha_1&gt;\\Delta\\alpha_2\\) 曲率定义: 设 \\(L:f(x)\\), \\(|\\stackrel\\frown{MM^\\prime}|=\\Delta s\\) 平均曲率 \\(\\bar{k}=\\dfrac{|\\Delta\\alpha|}{|\\Delta s|}\\) 某点曲率 \\(k=\\lim\\limits_{\\Delta x\\to 0}|\\frac{\\Delta\\alpha}{\\Delta s}|=|\\frac{\\mathrm{d}\\alpha}{\\mathrm{d}s}|=\\frac{|f^{\\prime\\prime}(x)|}{(1+[f^\\prime(x)]^2)^\\frac{3}{2}}\\) 证明: 可知 \\(f^\\prime(x)=\\lim\\limits_{\\Delta x\\to 0}\\tan\\alpha\\), 两边对 \\(x\\) 求导得 \\(f^{\\prime\\prime}(x)=\\sec^2\\alpha\\cdot\\frac{\\mathrm{d}\\alpha}{\\mathrm{d}x}\\) \\(\\because\\sec^2\\alpha=1+\\tan^2\\alpha=1+[f^\\prime(x)]^2\\) \\(\\therefore\\frac{\\mathrm{d}\\alpha}{\\mathrm{d}x}=\\frac{f^{\\prime\\prime}(x)}{1+[f^\\prime(x)]^2}\\rArr\\mathrm{d}\\alpha=\\frac{f^{\\prime\\prime}(x)}{1+[f^\\prime(x)]^2}\\mathrm{d}x\\) 曲率半径: \\(R=\\frac{1}{k}\\) 不定积分 不定积分的概念与性质 原函数: 设 \\(f(x)\\), \\(F(x)\\enspace(x\\in I)\\) 若 \\(\\forall x\\in I\\), 有 \\(F^\\prime(x)=f(x)\\), 称 \\(F(x)\\) 为 \\(f(x)\\) 的其中一个原函数 注意: 一个函数若有原函数, 则一定有无数个原函数 设 \\(F^\\prime(x)=f(x)\\) 则 \\(F(x)+C\\) 为 \\(f(x)\\) 的一切原函数 一个函数的的任意两个原函数之差 \\(\\in C\\) 不定积分 \\(F(x)+C\\) 为 \\(f(x)\\) 的所有原函数 则称 \\(F(x)+C\\) 就是 \\(f(x)\\) 的不定积分, 记作 \\(\\int f(x)\\mathrm{d}x\\) 不定积分公式 \\(\\int k\\mathrm{d}x=kx+C\\) \\(\\int x^a\\mathrm{d}x=\\begin{cases} \\frac{1}{a+1}x^{a+1}+C &amp; (a\\neq -1) \\\\ \\ln|x|+C &amp; (a=-1) \\end{cases}\\) \\(\\int a^x\\mathrm{d}x=\\frac{a^x}{\\ln a}+C\\) \\(\\int\\sin x\\mathrm{d}x=-\\cos x+C\\) \\(\\int\\cos x\\mathrm{d}x=\\sin x+C\\) \\(\\int\\tan x\\mathrm{d}x=-\\ln|\\cos x|+C\\) \\(\\int\\cot x\\mathrm{d}x=\\ln|\\sin x|+C\\) \\(\\int\\csc x\\mathrm{d}x=\\ln|\\csc x-\\cot x|+C=\\ln|\\tan\\frac{x}{2}|+C\\) \\(\\int\\sec x\\mathrm{d}x=\\ln|\\sec x+\\tan x|+C\\) \\(\\int\\sec^2x\\mathrm{d}x=\\tan x+C\\) \\(\\int\\csc^2x\\mathrm{d}x=-\\cot x+C\\) \\(\\int\\sec x\\tan x\\mathrm{d}x=\\sec x+C\\) \\(\\int\\csc x\\cot x\\mathrm{d}x=-\\csc x+C\\) \\(\\int\\frac{1}{\\sqrt{1-x^2}}\\mathrm{d}x=\\arcsin x+C\\) \\(\\int\\frac{1}{\\sqrt{a^2-x^2}}\\mathrm{d}x=\\arcsin\\frac{x}{a}+C\\) \\(\\int\\frac{1}{1+x^2}\\mathrm{d}x=\\arctan x+C\\) \\(\\int\\frac{1}{a^2+x^2}\\mathrm{d}x=\\frac{1}{a}\\arctan\\frac{x}{a}+C\\) \\(\\int\\frac{1}{x^2-a^2}\\mathrm{d}x=\\frac{1}{2a}\\ln|\\frac{x-a}{x+a}|+C\\) \\(\\int\\frac{1}{\\sqrt{x^2+a^2}}\\mathrm{d}x=\\ln(x+\\sqrt{x^2+a^2})+C\\) \\(\\int\\frac{1}{\\sqrt{x^2-a^2}}\\mathrm{d}x=\\ln|x+\\sqrt{x^2-a^2}|+C\\) \\(\\int\\frac{1}{\\sqrt{a^2-x^2}}\\mathrm{d}x=\\frac{a^2}{2}\\arcsin\\frac{x}{a}+\\frac{1}{2}x\\sqrt{a^2-x^2}+C\\) 证明: \\(\\footnotesize\\int x^a\\mathrm{d}x\\enspace(a=-1)\\rArr\\begin{cases} \\int\\frac{1}{x}\\mathrm{d}x=\\ln(-x)+C &amp; (x&lt;0) \\\\ \\int\\frac{1}{x}\\mathrm{d}x=\\ln(x)+C &amp; (x&gt;0) \\end{cases}\\rArr\\ln|x|+C\\) \\(\\int\\tan x\\mathrm{d}x=\\int\\frac{\\sin x}{\\cos x}\\mathrm{d}x=-\\int\\frac{1}{\\cos x}\\mathrm{d}(\\cos x)=-\\ln|\\cos x|+C\\) \\(\\int\\cot x\\mathrm{d}x=\\int\\frac{\\cos x}{\\sin x}\\mathrm{d}x=\\int\\frac{1}{\\sin x}\\mathrm{d}(\\sin x)=\\ln|\\sin x|+C\\) 这里只证明 \\(\\int\\frac{1}{\\sqrt{x^2+a^2}}\\mathrm{d}x\\) 令 \\(x=a\\tan t\\) (第二类换元积分法) $$ \\begin{array}{rl} \\text{原式}=\\int\\frac{a\\sec^2t}{a\\sec t}\\mathrm{d}t & =\\int\\sec t\\mathrm{d}t \\\\ & =\\ln|\\sec t+\\tan t|+C \\\\ & =\\ln|\\frac{\\sqrt{x^2+a^2}}{a}+\\frac{x}{a}|+C \\\\ & =\\ln|x+\\sqrt{x^2+a^2}|\\cdot\\frac{1}{a}+C \\\\ & =\\ln|x+\\sqrt{x^2+a^2}|+\\ln\\frac{1}{a}+C \\\\ & =\\ln|x+\\sqrt{x^2+a^2}|+C\\enspace(\\ln\\frac{1}{a}\\text{并入}C) \\\\ & =\\ln|x+\\sqrt{x^2+a^2}|+C \\\\ & =\\ln(x+\\sqrt{x^2+a^2})+C \\end{array} $$ 不定积分性质 \\(\\int[f(x)\\pm g(x)]\\mathrm{d}x=\\int f(x)\\mathrm{d}x+\\int g(x)\\mathrm{d}x\\) \\(\\int af(x)\\mathrm{d}x=a\\int f(x)\\mathrm{d}x\\) 不定积分的换元积分法与分部积分法 换元积分法 第一类换元积分法 \\(f(u)\\) 存在原函数 \\(F(u)\\) 且 \\(\\varphi(x)\\) 可导, 则 \\(\\footnotesize\\int f[\\varphi(x)]\\underbrace{\\varphi^\\prime(x)\\mathrm{d}x}_{f^\\prime(x)\\mathrm{d}x=\\mathrm{d}f(x)}=\\int\\underbrace{f[\\varphi(x)]\\mathrm{d}\\varphi(x)}_{\\text{设}\\varphi(x)=t}=\\int f(t)\\mathrm{d}t=F(t)+C=F[\\varphi(x)]+C\\) 第二类换元积分法 \\(x=\\psi(t)\\) 可导且 \\(\\psi^\\prime(t)\\neq 0\\) \\(\\footnotesize\\int f(x)\\mathrm{d}x=\\int f[\\psi(t)]\\mathrm{d}\\psi(t)=\\int f[\\psi(t)]\\psi^\\prime(t)\\mathrm{d}t=\\int g(t)\\mathrm{d}t=G(t)+C=G[\\psi^{-1}(x)]+C\\) 例: \\(\\int\\frac{1}{\\sqrt{x}+\\sqrt[3]{x}}\\mathrm{d}x\\) 解: 令 \\(x=t^6\\) $$ \\begin{array}{rl} \\text{原式} & =6\\int\\frac{t^5}{t^3+t^2}\\mathrm{d}t \\\\ & =6\\int\\frac{(t^3+1)-1}{t+1}\\mathrm{d}t \\\\ & =6\\int\\frac{t^3+t^2+1-t^2}{t+1}-\\frac{1}{t+1}\\mathrm{d}t \\\\ & =6\\int\\frac{t^2(t+1)+(1+t)(1-t)}{t+1}-\\frac{1}{t+1}\\mathrm{d}t \\\\ & =6\\int(t^2-t+1)-\\frac{1}{t+1}\\mathrm{d}t \\\\ & =6[\\frac{1}{3}t^3-\\frac{1}{2}t^2+t-\\ln|t+1|]+C \\\\ & =2t^3-3t^2+6t-6\\ln|t+1|+C \\\\ & =2\\sqrt{x}-3\\sqrt[3]{x}+6\\sqrt[6]{x}-6\\ln|\\sqrt[6]{x}+1|+C \\end{array} $$ 分部积分法 先用换元积分法将积分式变成 \\(\\int u\\mathrm{d}v\\) 的形式 然后用分部积分公式: \\(\\int u\\mathrm{d}v=uv-\\int v\\mathrm{d}u\\) 证明: \\(uv=\\int(uv)^\\prime\\mathrm{d}x=\\int u^\\prime v\\mathrm{d}x+\\int uv^\\prime\\mathrm{d}x=\\int v\\mathrm{d}u+\\int u\\mathrm{d}v\\) 例: \\(\\int x^2\\ln x\\mathrm{d}x\\) 解: $$ \\begin{aligned} \\int x^2\\ln x\\mathrm{d}x & =\\int\\ln x\\mathrm{d}(\\frac{1}{3}x^3) \\\\ & =\\frac{1}{3}x^3\\ln x-\\int\\frac{1}{3}x^3\\mathrm{d}(\\ln x) \\\\ & =\\frac{1}{3}x^3\\ln x-\\frac{1}{3}\\int x^2\\mathrm{d}x \\\\ & =\\frac{1}{3}x^3\\ln x-\\frac{1}{9}x^3+C \\end{aligned} $$ 定积分 定积分的概念与性质 定积分定义 设 \\(f(x)\\) 在 \\([a,b]\\) 上有界, \\(x_1,x_2,\\dots,x_n\\) 为 \\([a,b]\\) 间的分段点 \\(a=x_0&lt;x_1&lt;x_2&lt;\\dots&lt;x_n=b\\), \\(\\Delta x_i=x_i-x_{i-1}\\enspace(1\\leqslant i\\leqslant n)\\) \\(\\exist s_i\\in[x_{i-1},x_i]\\), \\(\\displaystyle\\sum_{i=1}^n f(\\xi_i)\\Delta x_i\\) \\(\\lambda=\\operatorname{max}\\{\\Delta x_1,\\Delta x_2,\\dots,\\Delta x_n\\}\\) 若 \\(\\displaystyle\\lim\\limits_{\\lambda\\to 0}\\sum_{i=1}^n f(\\xi_i)\\Delta x_i\\) 存在, 称 \\(f(x)\\) 在 \\([a,b]\\) 上可积 称该极限为 \\(f(x)\\) 在 \\([a,b]\\) 上的定积分, 记作 \\(\\int_a^b f(x)\\mathrm{d}x\\) 即 \\(\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n\\textstyle f(\\xi_1)\\Delta x_i=\\int_a^b f(x)\\mathrm{d}x\\) 注: \\(L:y=f(x)\\geqslant 0\\enspace(x\\in[a,b])\\) 则 \\(A=\\int_a^b f(x)\\mathrm{d}x\\) 例: 物理中知道速度函数和时间求位移(\\(v\\) 为速度, \\(t\\) 为时间) 设 \\(v=V(t)\\enspace(t\\in[a,b])\\) 则 \\(S=\\int_a^b V(t)\\mathrm{d}t\\) \\(\\displaystyle\\lim\\limits_{\\lambda\\to 0}\\sum_{i=1}^n f(\\xi_1)\\Delta x_i\\) 与 \\([a,b]\\) 分法及 \\(\\xi_i\\) 取法无关 \\(f(x)\\) 在 \\([a,b]\\) 上有界不一定可积 如分段函数 \\(f(x)=\\begin{cases} 1 &amp; x\\in Q \\\\ 0 &amp; x\\in R-Q \\end{cases}\\) 若 \\(f(x)\\in C[a,b]\\), 则 \\(f(x)\\) 在 \\([a,b]\\) 上可积 若 \\(f(x)\\) 在 \\([a,b]\\) 上只有有限个第一类间断点, 则 \\(f(x)\\) 在 \\([a,b]\\) 上可积 定积分的一般性质 \\(\\int_a^a f(x)\\mathrm{d}x=0\\) \\(\\int_a^b f(x)\\mathrm{d}x=-\\int_b^a f(x)\\mathrm{d}x\\) \\(\\int_a^b[f(x)\\pm g(x)]\\mathrm{d}x=\\int_a^b f(x)\\mathrm{d}x\\pm\\int_a^b g(x)\\mathrm{d}x\\) \\(\\int_a^b kf(x)\\mathrm{d}x=k\\int_a^b f(x)\\mathrm{d}x\\) \\(\\int_a^b f(x)\\mathrm{d}x=\\int_a^c f(x)\\mathrm{d}x+\\int_c^b f(x)\\mathrm{d}x\\enspace(a&lt;b)\\) (即使 \\(c&lt;a&lt;b\\) 也成立, 因为 \\(\\int_a^c\\) 是负的, 正好减去了 \\(\\int_c^b\\) 多出来的, \\(a&lt;b&lt;c\\) 同理) \\(\\int_a^b 1\\mathrm{d}x=b-a\\) 定积分间的比较 \\(f(x)\\geqslant 0\\enspace(a\\leqslant x\\leqslant b)\\), 则 \\(\\int_a^b f(x)\\mathrm{d}x\\geqslant 0\\) \\(f(x)\\geqslant g(x)\\enspace(a\\leqslant x\\leqslant b)\\), 则 \\(\\int_a^b f(x)\\mathrm{d}x\\geqslant\\int_a^b g(x)\\mathrm{d}x\\) 若 \\(f(x)\\)、\\(|f(x)|\\) 在 \\([a,b]\\) 上可积, 则 \\(|\\int_a^b f(x)\\mathrm{d}x|\\leqslant\\int_a^b|f(x)|\\mathrm{d}x\\) 积分中值定理 设 \\(f(x)\\in C[a,b]\\), 则 \\(\\exist\\xi\\in[a,b]\\), 使 \\(\\underbrace{\\int_a^b f(x)\\mathrm{d}x}_{\\text{曲边梯形面积}}=\\underbrace{f(\\xi)(b-a)}_{\\text{矩形面积}}\\) 证明: \\(\\because f(x)\\in C[a,b]\\) \\(\\therefore\\exist m,M\\in[a,b]\\), 使 \\(m(b-a)\\leqslant\\int_a^b f(x)\\mathrm{d}x\\leqslant M(b-a)\\) \\(\\rArr m\\leqslant\\frac{1}{b-a}\\int_a^b f(x)\\mathrm{d}x\\leqslant M\\) \\(\\therefore\\exist\\xi\\in[a,b]\\), 使 \\(f(\\xi)=\\frac{1}{b-a}\\int_a^b f(x)\\mathrm{d}x\\rArr\\int_a^b f(x)\\mathrm{d}x=(b-a)f(\\xi)\\) (介值定理) 积分基本定理 积分上限函数及其与目标函数的关系: 设 \\(f(x)\\in C[a,b]\\), 令 \\(\\varPhi(x)=\\int_a^x f(t)\\mathrm{d}t\\), 则 \\(\\varPhi^\\prime(x)=\\frac{\\mathrm{d}}{\\mathrm{d}x}\\int_a^x f(t)\\mathrm{d}t=f(x)\\) 复合函数推论: \\(\\varPhi[\\varphi(x)]^\\prime=\\frac{\\mathrm{d}}{\\mathrm{d}x}\\int_a^{\\varphi(x)}f(t)\\mathrm{d}t=\\frac{\\mathrm{d}}{\\mathrm{d}\\varphi(x)}\\int_a^{\\varphi(x)}f(t)\\mathrm{d}t\\cdot\\frac{\\varphi(x)}{x}=f[\\varphi(x)]\\varphi^\\prime(x)\\) 证明: \\(\\footnotesize\\Delta\\varPhi=\\varPhi(x+\\Delta x)-\\varPhi(x)=\\int_a^{x+\\Delta x}f(t)\\mathrm{d}t-\\int_a^x f(t)\\mathrm{d}t=\\int_x^{x+\\Delta x}f(t)\\mathrm{d}t\\) \\(\\because f(x)\\in C[a,b]\\rArr f(x)\\in C[x,x+\\Delta x]\\) \\(\\therefore\\exist\\xi\\in[x,x+\\Delta x]\\), 使(积分中值定理) $$ \\begin{array}{rl} \\footnotesize f(\\xi)\\Delta x=\\int_x^{x+\\Delta x}f(t)\\mathrm{d}t=\\Delta\\varPhi & \\rArr\\frac{\\Delta\\varPhi}{\\Delta x}=f(\\xi) \\\\ & \\rArr\\footnotesize\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta\\varPhi}{\\Delta x}=\\lim\\limits_{\\Delta x\\to 0}f(\\xi)=\\lim\\limits_{\\xi\\to x}f(\\xi)=f(x) \\\\ & \\rArr\\varPhi^\\prime(x)=f(x) \\end{array} $$ 定积分与不定积分的比较: \\(\\int f(x)\\neq\\int f(t)\\enspace(x\\) 与 \\(t\\) 可能是不同的函数, 他们的值域不同, 导致积结果不同) \\(\\int_a^b f(x)\\mathrm{d}x=\\int_a^b f(t)\\mathrm{d}t\\enspace\\) (\\(x\\) 与 \\(t\\) 可能是不同的函数, 但积分范围被限制在 \\([a,b]\\), 即 \\(x,t\\in[a,b]\\), 所以相等) 因此: 定积分由上下限、函数关系确定, 与积分变量无关 即 \\(\\varPhi(x)=\\int_a^x f(x)\\mathrm{d}x=\\int_a^x f(t)\\mathrm{d}t\\enspace\\) (注意自变量的 \\(x\\) 与积分上限的 \\(x\\) 不同) 牛顿莱布尼茨公式 \\(f(x)\\in C[a,b]\\), \\(F(x)\\) 为 \\(f(x)\\) 的一个原函数, 则 \\(\\int_a^b f(x)\\mathrm{d}x=F(b)-F(a)=\\left.F(x)\\right|_a^b\\) 证明: \\(\\because F^\\prime(x)=f(x)\\), \\(\\varPhi^\\prime(x)=f(x)\\) (\\(F(x)\\) 与 \\(\\varPhi(x)\\) 皆为 \\(f(x)\\) 的原函数) \\(\\therefore \\begin{cases} F(a)-\\varPhi(a)=C_0 \\\\ F(b)-\\varPhi(b)=C_0 \\end{cases}\\rArr F(a)-\\varPhi(a)=F(b)-\\varPhi(b)\\) \\(\\because\\varPhi(a)=\\int_a^a f(t)\\mathrm{d}t=0\\) \\(\\therefore F(a)=F(b)-\\varPhi(b)\\hArr\\int_a^b f(x)\\mathrm{d}x=\\varPhi(b)=F(b)-F(a)\\) 积分中值定理的推广 \\(f(x)\\in C[a,b]\\), 则 \\(\\exist\\xi\\in(a,b)\\) (这里变成了闭区间), 使 \\(\\int_a^b f(x)\\mathrm{d}x=f(\\xi)(b-a)\\) 证明: 设 \\(F(x)=\\int_a^x f(t)\\mathrm{d}t\\), \\(F^\\prime(x)=f(x)\\) \\(\\exist\\xi\\in(a,b)\\) 使 \\(F^\\prime(\\xi)=\\frac{F(b)-F(a)}{b-a}\\) (拉格朗日中值定理) \\(\\footnotesize\\therefore\\int_a^b f(x)\\mathrm{d}x=F(b)-F(a)=F^\\prime(\\xi)(b-a)=f(\\xi)(b-a)\\enspace(\\xi\\in(a,b))\\) 定积分的换元积分法与分部积分法 换元积分法 若 \\(f(x)\\in C[a,b]\\), \\(x=\\varphi(t)\\) 满足: \\(\\varphi(t)\\) 为单调函数且 \\(\\varphi(\\alpha)=a\\), \\(\\varphi(\\beta)=b\\) \\(x=\\varphi(t)\\) 连续可导 则 \\(\\int_a^b f(x)\\mathrm{d}x=\\int_\\alpha^\\beta f[\\varphi(t)]\\varphi^\\prime(t)\\mathrm{d}t\\) 证明: 设 \\(F(x)\\) 为 \\(f(x)\\) 的原函数 $$ \\begin{array}{rl} \\int_\\alpha^\\beta f[\\varphi(t)]\\varphi^\\prime(t)\\mathrm{d}t & =\\int_\\alpha^\\beta f[\\varphi(t)]\\mathrm{d}\\varphi(t) \\\\ & =F[\\varphi(\\beta)]-F[\\varphi(\\alpha)] \\\\ & =F(b)-F(a) \\\\ & =\\int_a^b f(x)\\mathrm{d}x \\end{array} $$ 分部积分法 \\(\\int_a^b u\\mathrm{d}v=(uv)|_a^b-\\int_a^b v\\mathrm{d}u\\) 证明: \\(\\left.uv\\right|_a^b=\\int_a^b(uv)^\\prime\\mathrm{d}x=\\int_a^b u^\\prime v\\mathrm{d}x+\\int_a^b uv^\\prime\\mathrm{d}x=\\int_a^b v\\mathrm{d}u+\\int_a^b u\\mathrm{d}v\\) 例: 导出 \\(I_n=\\int_0^\\frac{\\pi}{2}\\sin^n x\\mathrm{d}x\\) (\\(n\\) 为非负整数)的递推公式 解: 易见 \\(I_0=\\int_0^\\frac{\\pi}{2}1\\mathrm{d}x=\\frac{\\pi}{2}\\), \\(I_1=\\int_0^\\frac{\\pi}{2}\\sin x\\mathrm{d}x=1\\). 当 \\(n\\geqslant 2\\) 时 $$ \\begin{array}{rl} I_n=\\int_0^\\frac{\\pi}{2}\\sin^n x\\mathrm{d}x & =\\int_0^\\frac{\\pi}{2}\\sin^{n-1}x\\cdot\\sin x\\mathrm{d}x \\\\ & =\\int_0^\\frac{\\pi}{2}\\sin^{n-1}x[-(\\cos x)^\\prime]\\mathrm{d}x \\\\ & =-\\int_0^\\frac{\\pi}{2}\\sin^{n-1}x\\mathrm{d}\\cos x \\\\ & =\\left.-(\\sin^{n-1}x\\cdot\\cos x)\\right|_0^\\frac{\\pi}{2}+\\int_0^\\frac{\\pi}{2}\\cos x\\mathrm{d}\\sin^{n-1}x \\\\ & =\\int_0^\\frac{\\pi}{2}\\cos x(\\sin^{n-1}x)^\\prime\\mathrm{d}x \\\\ & =\\int_0^\\frac{\\pi}{2}\\cos x\\cdot\\sin^{n-1\\prime}x(\\sin x)^\\prime\\mathrm{d}x \\\\ & =(n-1)\\int_0^\\frac{\\pi}{2}\\sin^{n-2}x\\cos^2 x\\mathrm{d}x \\\\ & =(n-1)\\int_0^\\frac{\\pi}{2}\\sin^{n-2}x(1-\\sin^2 x)\\mathrm{d}x \\\\ & =(n-1)[\\int_0^\\frac{\\pi}{2}\\sin^{n-2}\\mathrm{d}x-\\int_0^\\frac{\\pi}{2}\\sin^n x\\mathrm{d}x] \\\\ & =(n-1)(I_{n-2}-I_n) \\end{array} $$ 从而得到递推公式 \\(I_n=\\frac{n-1}{n}I_{n-2}\\) 反常积分 正常积分标准: 区间有限 \\(f(x)\\) 在区间上连续或有限个第一类间断点 积分区间无限 \\(f(x)\\in C[a,+\\infty)\\) 有 \\(\\int_a^{+\\infty} f(x)\\mathrm{d}x=\\lim\\limits_{b\\to+\\infty}[F(b)-F(a)]\\) 若 \\(\\lim\\limits_{b\\to+\\infty}[F(b)-F(a)]\\) 存在, 称 \\(\\int_a^{+\\infty} f(x)\\mathrm{d}x\\) 收敛 若 \\(\\lim\\limits_{b\\to+\\infty}[F(b)-F(a)]\\) 不存在, 称 \\(\\int_a^{+\\infty} f(x)\\mathrm{d}x\\) 发散 \\(f(x)\\in C(-\\infty,a]\\) 有 \\(\\lim\\limits_{b\\to-\\infty}[F(a)-F(b)]=\\int_{-\\infty}^a f(x)\\mathrm{d}x\\) 若 \\(\\lim\\limits_{b\\to-\\infty}[F(a)-F(b)]\\) 存在, 称 \\(\\int_{-\\infty}^a f(x)\\mathrm{d}x\\) 收敛 若 \\(\\lim\\limits_{b\\to-\\infty}[F(a)-F(b)]\\) 不存在, 称 \\(\\int_{-\\infty}^a f(x)\\mathrm{d}x\\) 发散 \\(f(x)\\in C(-\\infty,+\\infty)\\) 若 \\(\\int_{-\\infty}^{+\\infty}f(x)\\mathrm{d}x\\) 收敛 \\(\\hArr\\int_{-\\infty}^{a}f(x)\\mathrm{d}x\\) 与 \\(\\int_{a}^{+\\infty}f(x)\\mathrm{d}x\\) 收敛 且 \\(\\int_{-\\infty}^{+\\infty}f(x)\\mathrm{d}x=\\int_{-\\infty}^a f(x)\\mathrm{d}x+\\int_a^{+\\infty}f(x)\\mathrm{d}x\\) Gamma 函数 \\(\\Gamma\\) 定义: \\(\\Gamma(\\alpha)=\\int_0^{+\\infty}x^{\\alpha-1}\\cdot e^{-x}\\mathrm{d}x\\) 特性: \\(\\Gamma(\\alpha+1)=\\alpha\\Gamma(\\alpha)\\) \\(\\Gamma(n+1)=n!\\enspace(n\\in Z)\\) \\(\\Gamma(\\frac{1}{2})=\\sqrt{\\pi}\\) 无界函数反常积分 左无界: \\(f(x)\\in c(a,b]\\) 且 \\(f(a+0)=\\infty\\enspace\\) (\\(a\\) 称作瑕点) \\(\\forall\\varepsilon&gt;0\\), \\(\\lim\\limits_{\\varepsilon\\to 0^+}[F(b)-F(a+\\varepsilon)]=\\int_{a+\\varepsilon}^b f(x)\\mathrm{d}x\\) 若 \\(\\lim\\limits_{\\epsilon\\to 0^+}[F(b)-F(a+\\varepsilon)]\\) 存在, 称 \\(\\int_a^b f(x)\\mathrm{d}x\\) 收敛 若 \\(\\lim\\limits_{\\varepsilon\\to 0^+}[F(b)-F(a+\\varepsilon)]\\) 不存在, 称 \\(\\int_a^b f(x)\\mathrm{d}x\\) 发散 右无界: \\(f(x)\\in c[a,b)\\) 且 \\(f(b-0)=\\infty\\) \\(\\forall\\varepsilon&gt;0\\), \\(F(b-\\varepsilon)-F(a)=\\int_a^{b-\\varepsilon}f(x)\\mathrm{d}x\\) 若 \\(\\lim\\limits_{\\epsilon\\to 0^+}[F(b-\\varepsilon)-F(a)]\\) 存在, 称 \\(\\int_a^b f(x)\\mathrm{d}x\\) 收敛 若 \\(\\lim\\limits_{\\epsilon\\to 0^+}[F(b-\\varepsilon)-F(a)]\\) 不存在, 称 \\(\\int_a^b f(x)\\mathrm{d}x\\) 发散 中无界: \\(f(x)\\in c[a,c)\\cup(c,b]\\) 且 \\(\\lim\\limits_{x\\to c}f(x)=\\infty\\) 若 \\(\\int_a^b f(x)\\mathrm{d}x\\) 收敛 \\(\\hArr\\int_a^c f(x)\\mathrm{d}x\\) 与 \\(\\int_c^b f(x)\\mathrm{d}x\\) 收敛 且 \\(\\int_a^b f(x)\\mathrm{d}x=\\int_a^c f(x)\\mathrm{d}x+\\int_c^b f(x)\\mathrm{d}x\\) 定积分应用 元素法 经典积分思想: 分成无数细小的段然后加起来 元素法思想: 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}A=f(x)\\mathrm{d}x\\) \\(A=\\int_a^b\\mathrm{d}A=\\int_a^b f(x)\\mathrm{d}x\\) 例: 求 \\(L:x^2+y^2=R^2\\) 围成的面积 解: 取 \\([x,x+\\mathrm{d}x]\\subset[0,R]\\) \\(\\mathrm{d}A_1=\\sqrt{R^2-x^2}\\mathrm{d}x\\) \\(A_1=\\int_0^R\\sqrt{R^2-x^2}\\mathrm{d}x\\) 设 \\(x=R\\sin t\\), 则有 \\(\\int_0^\\frac{\\pi}{2}\\sqrt{R^2-R^2\\sin^2t}(R\\cos t)\\mathrm{d}t\\) \\(=\\int_0^\\frac{\\pi}{2}R^2\\sqrt{1-\\sin^2t}\\cos t\\mathrm{d}t\\) \\(=\\int_0^\\frac{\\pi}{2}R^2\\cos^2t\\mathrm{d}t\\) \\(=R^2\\int_0^\\frac{\\pi}{2}\\cos^2t\\mathrm{d}t\\) \\(=R^2\\times\\frac{1}{2}I_0=\\frac{\\pi}{4}R^2\\) \\(\\therefore A=4A_1=\\pi R^2\\) 几何应用(元素法的拓展) 面积 贴 \\(x\\) 轴曲面 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}A=f(x)\\mathrm{d}x\\) \\(A=\\int_a^b f(x)\\mathrm{d}x\\) 浮空曲边 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}A=[f(x)-g(x)]\\mathrm{d}x\\) \\(A=\\int_a^b[f(x)-g(x)]\\mathrm{d}x\\) 曲边扇形面积(以下内容为弧度制) \\(L:R=r(\\theta)\\enspace(\\theta\\in[\\alpha,\\beta])\\) 取 \\([\\theta,\\theta+\\mathrm{d}\\theta]\\subset[\\alpha,\\beta]\\) \\(\\mathrm{d}A=\\frac{1}{2}r^2(\\theta)\\mathrm{d}\\theta\\) (曲边扇形面积公式) \\(A=\\int_\\alpha^\\beta\\mathrm{d}A=\\int_\\alpha^\\beta\\frac{1}{2}r^2(\\theta)\\mathrm{d}\\theta\\) 体积 旋转体的体积 \\(V_x\\) (绕 \\(x\\) 轴旋转) 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}V_x=\\pi f^2(x)\\mathrm{d}x\\) \\(V_x=\\pi\\int_a^b f^2(x)\\mathrm{d}x\\) \\(V_y\\) (绕 \\(y\\) 轴旋转) 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}V_y=2\\pi|x|\\cdot|f(x)|\\cdot\\mathrm{d}x\\) \\(V_y=2\\pi\\int_a^b |x|\\cdot|f(x)|\\mathrm{d}x\\) 截口面积已知求几何体体积 有关于底面积的函数 \\(A(x)\\) 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}V=A(x)\\mathrm{d}x\\) \\(V=\\int_a^b A(x)\\mathrm{d}x\\) 弧长 \\(L:y=f(x)\\enspace(a\\leqslant x\\leqslant b)\\) 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}s=\\sqrt{(\\mathrm{d}x)^2+(\\mathrm{d}y)^2}=\\sqrt{1+(\\frac{\\mathrm{d}y}{\\mathrm{d}x})^2}\\mathrm{d}x=\\sqrt{1+[f^\\prime(x)]^2}\\mathrm{d}x\\) \\(l=\\int_a^b\\mathrm{d}s\\mathrm{d}x=\\int_a^b\\sqrt{1+[f^\\prime(x)]^2}\\mathrm{d}x\\) \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\end{cases}\\enspace(\\alpha\\leqslant t\\leqslant\\beta)\\) 取 \\([t,t+\\mathrm{d}t]\\subset[\\alpha,\\beta]\\) \\(\\mathrm{d}s=\\sqrt{(\\mathrm{d}x)^2+(\\mathrm{d}y)^2}=\\sqrt{[\\varphi^\\prime(t)]^2+[\\psi^\\prime(t)]^2}\\mathrm{d}t\\) \\(l=\\int_\\alpha^\\beta\\mathrm{d}s\\mathrm{d}t=\\int_\\alpha^\\beta\\sqrt{[\\varphi^\\prime(x)]^2+[\\psi^\\prime(x)]^2}\\mathrm{d}t\\) 微分方程 解微分方程的目的即根据已知微分条件求目标函数 微分方程的基本概念 微分方程: 含有导数或微分的方程 常微分方程: 只含一个自变量, 一个函数的微分方程, 如 \\(f^\\prime(x)+7f(x)=0\\) 这里探讨的范围仅限于常微分方程 微分方程的阶: 在微分方程中, 导数或微分的最高阶数 微分方程的解: 已知 \\(y\\) 关于 \\(x\\) 的微分方程 \\(F(y^{(n)},y^{(n-1)},\\dots,y^\\prime,y,x)=0\\) 若代入函数 \\(y=\\varphi(x)\\) 能够满足 \\(F(y^{(n)},y^{(n-1)},\\dots,y^\\prime,y,x)=0\\) 称 \\(y=\\varphi(x)\\) 为该微分方程的解 通解: 设 \\(n\\) 阶微分方程 \\(F(y^{(n)},y^{(n-1)},\\dots,y^\\prime,y,x)=0\\), 若该方程的解含 \\(n\\) 个相互独立的任意常数, 称该解为通解 如 \\(y=C_1e^x+C_2e^{2x}\\) 为 \\(y^{\\prime\\prime}-3y^\\prime+2y=0\\) 的通解 特解: 不含任意常数的解 可分离变量微分方程 定义: 形如 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\varphi_1(x)\\varphi_2(y)\\) 解法 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\varphi_1(x)\\varphi_2(y)\\rArr\\frac{\\mathrm{d}y}{\\varphi_2(y)}=\\varphi_1(x)\\mathrm{d}x\\) 两边积分: \\(\\int\\frac{\\mathrm{d}y}{\\varphi_2(y)}=\\int\\varphi_1(x)\\mathrm{d}x+C\\) (注意微分方程中自变量一端要加 \\(C\\)) 齐次微分方程 定义: 形如 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\varphi(\\frac{y}{x})\\) 解法 换元法, 设 \\(u=\\frac{y}{x}\\), 则 \\(y=ux\\rArr y^\\prime=u^\\prime x+ux^\\prime\\rArr\\frac{\\mathrm{d}y}{\\mathrm{d}x}=x\\frac{\\mathrm{d}u}{\\mathrm{d}x}+u\\) 将 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}=x\\frac{\\mathrm{d}u}{\\mathrm{d}x}+u\\) 和 \\(u=\\frac{y}{x}\\) 代入方程两边得到 \\(x\\frac{\\mathrm{d}u}{\\mathrm{d}x}+u=\\varphi(u)\\) 然后就可以分离变量, 最后两边积分: \\(\\frac{\\mathrm{d}x}{x}=\\frac{\\mathrm{d}u}{\\varphi(u)-u}\\rArr\\int\\frac{\\mathrm{d}x}{x}=\\int\\frac{\\mathrm{d}u}{\\varphi(u)-u}+C\\) 一阶线性微分方程 一阶齐次线性方程 定义: 形如 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}+P(x)y=0\\) 解法及通解公式 情况1 \\(y=0\\) 为方程的解 情况2 \\(y\\neq 0\\) 时, 先分离变量, 然后两边积分, 再套用积分公式求解: $$ \\begin{aligned} \\frac{1}{y}\\mathrm{d}y=-P(x)\\mathrm{d}x & \\rArr\\int\\frac{1}{y}\\mathrm{d}y=\\int-P(x)\\mathrm{d}x \\\\ & \\rArr\\ln|y|=-\\int P(x)\\mathrm{d}x+C_0 \\\\ & \\rArr|y|=e^{-\\int P(x)\\mathrm{d}x+C_0} \\\\ & \\rArr y=\\pm e^{C_0}\\cdot e^{-\\int P(x)\\mathrm{d}x}=Ce^{-\\int P(x)\\mathrm{d}x} \\end{aligned} $$ 通解 \\(y=Ce^{-\\int P(x)\\mathrm{d}x}\\) 一阶非齐线性微分方程 定义: 形如 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}+P(x)y=Q(x)\\) 解法 通过常数易变法, 将上面齐次方程通解中的常数项换成关于 \\(x\\) 的函数 \\(C=u(x)\\), 得到 ➀ \\(y=u(x)e^{-\\int P(x)\\mathrm{d}x}\\) 然后对 \\(y\\) 求导: (这里注意 \\(e^{-\\int P(x)\\mathrm{d}x}\\) 是复合函数) ➁ \\(y^\\prime=\\frac{\\mathrm{d}y}{\\mathrm{d}x}=u^\\prime(x)e^{-\\int P(x)\\mathrm{d}x}-u(x)P(x)e^{-\\int P(x)\\mathrm{d}x}\\) 将 ➀、➁ 代入一阶非齐线性微分方程: \\(u^\\prime(x)e^{-\\int P(x)\\mathrm{d}x}-u(x)P(x)e^{-\\int P(x)\\mathrm{d}x}+P(x)u(x)e^{-\\int P(x)\\mathrm{d}x}=Q(x)\\) \\(\\rArr u^\\prime(x)e^{-\\int P(x)\\mathrm{d}x}=Q(x)\\) \\(\\rArr u^\\prime(x)=Q(x)e^{\\int P(x)\\mathrm{d}x}\\) \\(\\rArr\\int u^\\prime(x)\\mathrm{d}x=\\int Q(x)e^{\\int P(x)\\mathrm{d}x}\\mathrm{d}x+C\\) \\(\\rArr u(x)=\\int Q(x)e^{\\int P(x)\\mathrm{d}x}\\mathrm{d}x+C\\) 求得的 \\(u(x)\\) 再次带入通解式得 \\(y=[\\int Q(x)e^{\\int P(x)\\mathrm{d}x}\\mathrm{d}x+C]e^{-\\int P(x)\\mathrm{d}x}\\) 可降阶的高阶微分方程 \\(y^{(n)}=f(x)\\enspace(n\\geqslant2)\\) 解法: 直接积分 \\(y^{(n-1)}=\\int f(x)\\mathrm{d}x=F(x)+C\\) \\(y^{(n-2)}=\\int(\\int(F(x)+C)\\mathrm{d}x\\) \\(\\dots\\) 例: \\(y^{\\prime\\prime}=x^3+e^{2x}\\) 解: \\(y^\\prime=\\frac{1}{4}x^4+\\frac{1}{2}e^{2x}+C_1\\) \\(y=\\frac{1}{20}x^5+\\frac{1}{4}e^{2x}+C_1x+C_2\\) (缺失 \\(y\\)) \\(f(x,y^\\prime,y^{\\prime\\prime})=0\\) 解法: 令 \\(y^\\prime=p\\), \\(y^{\\prime\\prime}=\\frac{\\mathrm{d}p}{\\mathrm{d}x}\\) 代入得 \\(f(x,p,\\frac{\\mathrm{d}p}{\\mathrm{d}x})=0\\rArr p=\\varphi(x,C_1)\\), 即 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\varphi(x,C_1)\\) \\(\\therefore y=\\int\\varphi(x, C_1)\\mathrm{d}x+C_2\\) 例: 求 \\(xy^{\\prime\\prime}+2y^\\prime=0\\) 通解 解: 令 \\(y^\\prime=p\\), \\(y^{\\prime\\prime}=\\frac{\\mathrm{d}p}{\\mathrm{d}x}\\), 代入得 \\(x\\frac{\\mathrm{d}p}{\\mathrm{d}x}+2p=0\\rArr\\frac{\\mathrm{d}p}{p}=-\\frac{2\\mathrm{d}x}{x}\\) \\(\\rArr\\int\\frac{1}{p}\\mathrm{d}p=-2\\int\\frac{1}{x}\\mathrm{d}x+C_0\\) \\(\\rArr\\ln|p|=-2\\ln|x|+C_0\\) \\(\\rArr|p|=e^{-2\\ln|x|+C_0}=\\frac{e^{C_0}}{x^2}\\) \\(\\rArr p=\\pm\\frac{e^{C_0}}{x^2}=\\frac{C_1}{x^2}\\), 即 \\(y^\\prime=\\frac{C_1}{x^2}\\) \\(\\therefore y=-\\frac{C_1}{x}+C_2\\) (缺失 \\(x\\)) \\(f(y,y^\\prime,y^{\\prime\\prime})=0\\) 解法: 令 \\(y^\\prime=p\\), \\(y^{\\prime\\prime}=\\frac{\\mathrm{d}p}{\\mathrm{d}x}\\rArr y^{\\prime\\prime}=\\frac{\\mathrm{d}p}{\\mathrm{d}y}\\cdot\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\frac{\\mathrm{d}p}{\\mathrm{d}y}\\cdot p\\), 代入得 $$ \\begin{array}{rl} f(y,p,\\frac{\\mathrm{d}p}{\\mathrm{d}y}\\cdot p)=0 & \\rArr p=\\varphi(y,C_1) \\\\ & \\hArr\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\varphi(y,C_1) \\\\ & \\hArr\\frac{\\mathrm{d}y}{\\varphi(y,C_1)}=\\mathrm{d}x \\\\ & \\rArr\\int\\frac{\\mathrm{d}y}{\\varphi(y,C_1)}=\\int\\mathrm{d}x+C_2 \\end{array} $$ 例: 求 \\(yy^{\\prime\\prime}-y^{\\prime 2}=0\\) 满足初始条件 \\(y(0)=1\\), \\(y^\\prime(0)=1\\) 的特解 解: 令 \\(y^\\prime=p\\), \\(y^{\\prime\\prime}=p\\frac{\\mathrm{d}p}{\\mathrm{d}y}\\), 代入得 \\(yp\\frac{\\mathrm{d}p}{\\mathrm{d}y}-p^2=0\\) $$ \\begin{array}{ll} \\because p\\neq 0 & \\\\ \\therefore y\\frac{\\mathrm{d}p}{\\mathrm{d}y}-p=0 & \\hArr\\frac{\\mathrm{d}p}{\\mathrm{d}y}-\\frac{1}{y}p=0 \\\\ & \\rArr p=C_0e^{-\\int-\\frac{1}{y}p\\mathrm{d}y} (\\text{\\footnotesize一阶齐次线性微分方程通解})\\\\ & \\hArr p=C_0e^{\\ln|y|} \\\\ & \\rArr p=C_1y \\\\ & \\hArr\\frac{\\mathrm{d}y}{\\mathrm{d}x}=C_1y \\\\ & \\hArr\\frac{\\mathrm{d}y}{C_1y}=\\mathrm{d}x \\\\ & \\rArr\\int\\frac{\\mathrm{d}y}{C_1y}=\\int\\mathrm{d}x+C_2 \\\\ & \\hArr\\ln|C_1y|=x+C_2 \\\\ & \\rArr y=\\frac{C_3e^x}{C_1} \\\\ & \\rArr y=C_4e^x \\end{array} $$ \\(\\because y(0)=1,y^\\prime(0)=1\\) \\(\\therefore C_4=1\\), 特解为 \\(y=e^x\\) 高阶线性微分方程 基本概念 二阶齐次线性微分方程: \\(y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=0\\) 二阶非齐线性微分方程: \\(y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=c(x)\\) \\(n\\) 阶齐次线性微分方程: \\(y^{(n)}+a_1(x)y^{(n-1)}+\\dots+a_{n-1}y^\\prime+a_n(x)y=0\\) \\(n\\) 阶非齐线性微分方程: \\(\\footnotesize y^{(n)}+a_1(x)y^{(n-1)}+\\dots+a_{n-1}y^\\prime+a_n(x)y=f(x)\\) 线性相关和线性无关: \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 为两个函数 若 \\(\\frac{\\varphi_1(x)}{\\varphi_2(x)}\\equiv k\\in R\\), 称 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 线性相关, 若 \\(\\frac{\\varphi_1(x)}{\\varphi_2(x)}=u(x)\\) (两函数的比例与 \\(x\\) 相关, 不恒为某个常数), 则称线性无关. 如 \\(x^2\\) 和 \\(\\sin x\\) 线性无关, \\(x^2\\) 和 \\(3x^2\\) 线性相关 性质 设 \\(\\begin{cases} \\text{➀ }y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=0 \\\\ \\text{➁ }y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=c(x) \\end{cases}\\) 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 为 ➀ 的解, 则 \\(y=C_1\\varphi_1(x)+C_2\\varphi_2(x)\\) 仍为 ➀ 的解(线性组合) 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 分别为 ➀, ➁ 的解, 则 \\(y=\\varphi_1(x)+\\varphi_2(x)\\) 为 ➁ 的解 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 为 ➁ 的解, 则 \\(y=\\varphi_2(x)-\\varphi_1(x)\\) 为 ➀ 的解 证明: 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 为 ➁ 的解 则有 \\(\\begin{cases} \\varphi_1^{\\prime\\prime}+a(x)\\varphi_1^\\prime+b(x)\\varphi_1=c(x) \\\\ \\varphi_2^{\\prime\\prime}+a(x)\\varphi_2^\\prime+b(x)\\varphi_2=c(x) \\end{cases}\\) 将 \\(y=\\varphi_2(x)-\\varphi_1(x)\\) 代入 ➁: \\((\\varphi_2-\\varphi_1)^{\\prime\\prime}+a(x)(\\varphi_2-\\varphi_1)^\\prime+b(x)(\\varphi_2-\\varphi_1)\\) \\(=(\\varphi_2^{\\prime\\prime}+a(x)\\varphi_2^\\prime+b(x)\\varphi_2)-(\\varphi_1^{\\prime\\prime}+a(x)\\varphi_1^\\prime+b(x)\\varphi_1)\\) \\(=c(x)-c(x)=0\\) \\(\\therefore y=\\varphi_2(x)-\\varphi_1(x)\\) 为 ➀ 的解 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 为 ➀ 的两个线性无关的特解, \\(\\varphi_0(x)\\) 为 ➁ 的一个特解 则 ➀ 通解为 \\(y=C_1\\varphi_1(x)+C_2\\varphi_2(x)\\); ➁ 的通解为 \\(y=C_1\\varphi_1(x)+C_2\\varphi_2(x)+\\varphi_0(x)\\) ➂ \\(y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=f_1(x)+f_2(x)\\) ➂’ \\(\\enspace y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=f_1(x)\\) ➂’’ \\(\\enspace y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=f_2(x)\\) 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 分别为 ➂’, ➂’’ 的特解, 则 \\(y=\\varphi_1(x)+\\varphi_2(x)\\) 为 ➂ 的特解 证明: 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 为 ➂’, ➂’’ 的解 则有 \\(\\begin{cases} \\varphi_1^{\\prime\\prime}+a(x)\\varphi_1^\\prime+b(x)\\varphi_1=f_1(x) \\\\ \\varphi_2^{\\prime\\prime}+a(x)\\varphi_2^\\prime+b(x)\\varphi_2=f_2(x) \\end{cases}\\) 将 \\(y=\\varphi_1(x)+\\varphi_2(x)\\) 代入 ➂: \\((\\varphi_1+\\varphi_2)^{\\prime\\prime}+a(x)(\\varphi_1+\\varphi_2)^\\prime+b(x)(\\varphi_1+\\varphi_2)=f(x)\\) \\(\\hArr(\\varphi_1^{\\prime\\prime}+a(x)\\varphi_1^\\prime+b(x)\\varphi_1)+(\\varphi_1^{\\prime\\prime}+a(x)\\varphi_2^\\prime+b(x)\\varphi_2)=f(x)\\) \\(\\hArr f_1(x)+f_2(x)=f(x)\\) \\(\\therefore y=\\varphi_1(x)+\\varphi_2(x)\\) 为 ➂ 的解 常系数齐次线性微分方程 二阶常系数齐次线性微分方程: \\(y^{\\prime\\prime}+py^\\prime+qy=0\\) 它的特征方程: \\(\\lambda^2+p\\lambda+q=0\\) , \\(\\Delta=b^2-4q\\) \\(\\Delta&gt;0\\), \\(y=C_1e^{\\lambda_1x}+C_2e^{\\lambda_2x}\\) \\(\\Delta=0\\), \\(y=(C_1+C_2x)e^{\\lambda_1x}\\) \\(\\Delta&lt;0\\), \\(y=e^{\\alpha x}[C_1\\cos(\\beta x)+C_2\\sin(\\beta x)]\\) 这种根据二阶常系数齐次线性方程的特征方程的根直接确定其通解的方法称为特征方程法 特征方程法解释: 二阶常系数齐次线性微分方程 \\(y^{\\prime\\prime}+py^\\prime+qy=0\\enspace\\) (\\(p\\)、\\(q\\) 为常数) (⁕) 猜测: (⁕) 解的形式? \\(\\begin{cases} e^{\\lambda x} \\\\ \\sin(\\beta x)\\cdot\\cos(\\beta x) \\end{cases}\\) 令 \\(y=e^{\\lambda x}\\) 为 (⁕) 的解, 有 \\(\\lambda^2e^{\\lambda x}+p\\lambda e^{\\lambda x}+qe^{\\lambda x}=0\\rArr\\lambda^2+p\\lambda+q=0\\), 称其为 (⁕) 的特征方程 情况1 \\(\\Delta=p^2-4q&gt;0\\) 则 \\(\\lambda^2+p\\lambda+q=0\\) 有两个不同实根 \\(\\lambda_1\\)、\\(\\lambda_2\\) 因此 \\(y_1=e^{\\lambda_1x}\\), \\(y_2=e^{\\lambda_2x}\\) 为 (⁕) 的特解 \\(\\because\\lambda_1\\neq\\lambda_2\\) \\(\\therefore\\frac{y_1}{y_2}=e^{(\\lambda_1-\\lambda_2)x}\\) 不恒为某个常数, \\(y_1\\) 与 \\(y_2\\) 线性无关 \\(\\therefore\\) (⁕) 的通解为 \\(y=C_1e^{\\lambda_1x}+C_2e^{\\lambda_2x}\\) (高阶线性线性微分方程性质 4) 情况2 \\(\\Delta=p^2-4q=0\\) 则 \\(\\lambda^2+p\\lambda+q=0\\) 有两个相等的实根 \\(\\lambda_1=\\lambda_2\\) \\(y_1=e^{\\lambda_1x}\\) 为 (⁕) 的一个特解, 还要找出与 \\(y_1\\) 线性无关的另一个特解 \\(y_2\\) (满足 \\(\\frac{y_2}{y_1}\\) 不是恒常数的 \\(y_2\\)) 令 \\(\\frac{y_2}{y_1}=u(x)(\\neq C)\\) 且 \\(y_2\\) 为 (⁕) 的解, 得到 \\(\\begin{cases} y_2=ue^{\\lambda_1x} \\\\ y_2^\\prime=u^\\prime e^{\\lambda_1x}+\\lambda_1ue^{\\lambda_1x} \\\\ y_2^{\\prime\\prime}=u^{\\prime\\prime}e^{\\lambda_1x}+2\\lambda_1u^\\prime e^{\\lambda_1x}+\\lambda_1^2ue^{\\lambda_1x} \\end{cases}\\) 将以上三式代入 (⁕) 得 \\(u^{\\prime\\prime}e^{\\lambda_1x}+2\\lambda_1u^\\prime e^{\\lambda_1x}+\\lambda_1^2ue^{\\lambda_1x}+pu^\\prime e^{\\lambda_1x}+p\\lambda_1ue^{\\lambda_1x}+que^{\\lambda_1x}=0\\) \\(\\rArr u^{\\prime\\prime}+2\\lambda_1u^\\prime+\\lambda_1^2u+pu^\\prime+p\\lambda_1u+qu=0\\) \\(\\rArr u^{\\prime\\prime}+(2\\lambda_1+p)u^\\prime+(\\lambda_1^2+p\\lambda_1+q)u=0\\) \\(\\because \\begin{cases} \\lambda_1^2+p\\lambda_1+q=0 \\\\ \\lambda_1+\\lambda_2=-p \\rArr 2\\lambda_1+p=0\\enspace\\footnotesize(\\text{韦达定理} x_1+x_2=-\\frac{b}{a}) \\end{cases}\\) \\(\\therefore u^{\\prime\\prime}=0\\), 取 \\(u(x)=C_1x+C_2\\) \\(\\therefore y_2=(C_1x+C_2)e^{\\lambda_1x}=C_1xe^{\\lambda_1x}+C_2e^{\\lambda_1x}\\) 则通解 \\(\\footnotesize y=C_0e^{\\lambda_1x}+C_1xe^{\\lambda_1x}+C_2e^{\\lambda_1x}=(C_0+C_1x+C_2)e^{\\lambda_1x}=(C_3+C_1x)e^{\\lambda_1x}\\) 情况3 \\(\\Delta=p^2-4q&lt;0\\) 则 \\(\\lambda^2+p\\lambda+q=0\\) 有一对共轭复根 \\(\\footnotesize\\lambda_{1,2}=-\\frac{1}{2}p\\pm\\frac{1}{2}\\sqrt{4q-p^2}i=\\alpha\\pm\\beta i\\) \\(y_1=e^{(\\alpha+\\beta i)x}\\) 与 \\(y_2=e^{(\\alpha-\\beta i)x}\\) 为 (⁕) 的复值函数形式特解 为了求出实值函数形式的特解, 将 \\(y_1\\) 与 \\(y_2\\) 改写为: \\(y_1=e^{\\alpha x+\\beta xi}=e^{\\alpha x}\\cdot e^{\\beta xi}=e^{\\alpha x}\\cdot\\underbrace{[\\cos(\\beta x)+i\\sin(\\beta x)]}_{\\text{欧拉公式 }e^{i\\theta}=\\cos\\theta+i\\sin\\theta}\\) \\(y_2=e^{\\alpha x-\\beta xi}=e^{\\alpha x}\\cdot e^{-\\beta xi}=e^{\\alpha x}\\cdot[\\cos(\\beta x)-i\\sin(\\beta x)]\\) 取方程的两个特解: (高阶线性线性微分方程性质 1) \\(Y_1=\\frac{1}{2}(y_1+y_2)=e^{\\alpha x}\\cos(\\beta x)\\) \\(Y_2=\\frac{1}{2i}(y_1-y_2)=e^{\\alpha x}\\sin(\\beta x)\\) \\(\\because\\frac{Y_2}{Y_1}=\\tan(\\beta x)\\) \\(\\therefore\\) \\(Y_1\\) 与 \\(Y_2\\) 线性无关, (⁕) 的通解为 \\(\\footnotesize y=C_1e^{\\alpha x}\\cos(\\beta x)+C_2e^{\\alpha x}\\sin(\\beta x)=e^{\\alpha x}[C_1\\cos(\\beta x)+C_2\\sin(\\beta x)]\\) \\(n\\) 阶常系数齐次线性微分方程 \\(y^{(n)}+p_1y^{(n-1)}+\\cdots+p_{n-1}y^\\prime+p_ny=0\\) 其特征方程: \\(\\lambda^n+p_1\\lambda^{n-1}+\\cdots+p_{n-1}\\lambda+p_n=0\\) 特征方程的根 通解中的对应项 \\(k\\) 重根 \\(\\lambda_1=\\lambda_2=\\cdots=\\lambda_k\\) \\(y=C_1+C_2x+\\cdots+C_kx^{k-1})e^{\\lambda_1x}\\) \\(k\\) 重共轭复根 \\(\\lambda_{1,\\cdots,n}=\\alpha\\pm\\beta i\\) \\(e^{\\alpha x}[(C_1+C_2x+\\cdots+C_kx^{n-1})\\cos(\\beta x) \\\\ +(D_0+D_1x+\\cdots+D_kx^{k-1})\\sin(\\beta x)]\\) 例: \\(y^{\\prime\\prime\\prime}+py^{\\prime\\prime}+qy^\\prime+ry=0\\), 它的特征方程 \\(\\lambda^3+p\\lambda^2+q\\lambda+r=0\\) \\(\\lambda_1\\)、\\(\\lambda_2\\)、\\(\\lambda_3\\) 为实数且各不相等 \\(y=C_1e^{\\lambda_1x}+C_2e^{\\lambda_2x}+C_3e^{\\lambda_3x}\\) \\(\\lambda_1\\)、\\(\\lambda_2\\)、\\(\\lambda_3\\) 为实数且 \\(\\lambda_1=\\lambda_2\\neq\\lambda_3\\) \\(y=(C_1+C_2x)e^{\\lambda_1x}+C_3e^{\\lambda_3x}\\) \\(\\lambda_1\\)、\\(\\lambda_2\\)、\\(\\lambda_3\\) 为实数且相等 \\(y=(C_1+C_2x+C_3x^2)e^{\\lambda_1x}\\) \\(\\lambda_1\\in R\\), \\(\\lambda_{2,3}=\\alpha\\pm i\\beta\\) \\(y=C_1e^{\\lambda_1x}+e^{\\alpha x}[C_2\\cos(\\beta x)+C_3\\sin(\\beta x)]\\) 常系数非齐次线性微分方程 形如 \\(y^{\\prime\\prime}+py^\\prime+qy=f(x)\\enspace\\) (\\(p\\)、\\(q\\) 为常数, \\(f(x)\\) 称为自由项) 通解思路: (高阶线性微分方程性质 5) 先求 \\(y^{\\prime\\prime}+py^\\prime+qy=0\\) 通解 找 \\(y^{\\prime\\prime}+py^\\prime+qy=f(x)\\) 的一个特解 \\(y_0(x)\\) (很困难, 接下来只谈两种使用待定系数法的情况) 有通解 \\(y=C_1e^{-x}+C_2e^{2x}+y_0(x)\\) 自由项 \\(f(x)=P_n(x)e^{kx}\\) 其中 \\(P_n(x)=a_0x^n+a_1x^{n-1}+\\cdots+a_{n-1}x+a_n\\) 令特解为 \\(y_0=x^l(ax+b)e^{kx}\\) , 其中 \\(l\\) 为与 \\(k\\) 的值相等的特征值个数 例1: 求 \\(y^{\\prime\\prime}-3y^\\prime+2y=(2x+3)e^x\\) 通解 解: 特征方程: \\(\\lambda^2-3\\lambda+2=0\\rArr\\lambda_1=1\\), \\(\\lambda_2=2\\) \\(y^{\\prime\\prime}-3y^\\prime+2y=0\\) 通解为 \\(y=C_1e^{x}+C_2e^{2x}\\) \\(k=1=\\lambda_1\\), 因此令特解 \\(y_0(x)=x(ax+b)e^x=(ax^2+bx)e^x\\), 有 \\(\\begin{array}{rl} y_0^\\prime(x) &amp; =(2ax+b)e^x+(ax^2+bx)e^x=(ax^2+2ax+bx+b)e^x \\\\ y_0^{\\prime\\prime}(x) &amp; =(2ax+2a+b)e^x+(ax^2+2ax+bx+b)e^x \\\\ &amp; =(ax^2+4ax+bx+2a+2b)e^x \\end{array}\\) 代入原式, 得到: $$ \\begin{array}{l} \\footnotesize(ax^2+4ax+bx+2a+2b)e^x-3(ax^2+2ax+bx+b)e^x+2(ax^2+bx)e^x=(2x+3)e^x \\\\ \\footnotesize\\hArr(ax^2+4ax+bx+2a+2b)-3(ax^2+2ax+bx+b)+2(ax^2+bx)=2x+3 \\\\ \\footnotesize\\hArr -2ax+2a-b=2x+3 \\\\ \\footnotesize\\rArr\\begin{cases} -2ax=2x & \\hArr a=-1\\\\ 2a-b=3 & \\hArr b=-5 \\end{cases} \\end{array} $$ 即 \\(y_0(x)=-(x^2+5x)e^x\\) \\(\\therefore\\) 原方程通解为 \\(y=C_1e^x+C_2e^{2x}-(x^2+5x)e^x\\) 例2: 求 \\(y^{\\prime\\prime}-2y^\\prime+y=(3x+2)e^x\\) 通解 解: 特征方程 \\(\\lambda^2-2\\lambda+1=0\\rArr\\lambda_1=\\lambda_2=1\\) \\(y^{\\prime\\prime}-2y^\\prime+y=0\\) 通解 \\(y=(C_1+C_2x)e^x\\) \\(k=1=\\lambda_1=\\lambda_2\\), 因此令特解 \\(\\footnotesize y_0(x)=x^2(ax+b)e^x=(ax^3+bx^2)e^x\\) \\(y_0^\\prime(x)=\\cdots\\), \\(y_0^{\\prime\\prime}(x)=\\cdots\\) 代入原方程解得 \\(a=\\frac{1}{2}\\), \\(b=1\\) 即 \\(y_0(x)=(\\frac{1}{2}x^3+x^2)e^x\\) \\(\\therefore\\) 原方程通解为 \\(y=(C_1+C_2x)e^x+(\\frac{1}{2}x^3+x^2)e^x\\) 例3: 求 \\(y^{\\prime\\prime}-2y^\\prime-3y=6x-1\\) 通解 解: \\(\\lambda^2-2\\lambda-3=0\\rArr\\lambda_1=-1\\), \\(\\lambda_2=3\\) \\(y^{\\prime\\prime}-2y^\\prime-3y=0\\) 通解为 \\(y=C_1e^{-x}+C_2e^3\\) 自由项 \\(6x-1\\) 可视为 \\((6x-1)e^0x\\), 即 \\(k=0\\). 注意此题中 \\(\\lambda\\) 的值没有与 \\(k=0\\) 相同的 因此令特解 \\(y_0(x)=ax+b\\) (余下略) \\(\\dots\\) \\(\\dots\\) \\(f(x)=e^{\\alpha x}\\) [\\(\\text{多项式}\\cdot\\cos(\\beta x)+\\text{多项式}\\cdot\\sin(\\beta x)\\)] 令特解为 \\(\\footnotesize y_0(x)=x^le^{\\alpha x}[a\\cdot\\cos(\\beta x)+b\\cdot\\sin(\\beta x)]\\enspace\\) (\\(a\\)、\\(b\\) 根据多项式内容决定, \\(l\\) 的值为与 \\(\\alpha+i\\beta\\) 的值相等的特征值个数) 注: \\(\\alpha\\)、\\(\\beta\\) 的值已经在方程中给出, 因此解对应非齐次方程通解可以直接用 例1: 求 \\(y^{\\prime\\prime}+4y=3\\cos 2x\\) 通解 解: \\(\\lambda^2+4=0\\rArr\\lambda_{1,2}=\\pm 2i\\) \\(y^{\\prime\\prime}+4y=0\\) 通解为 \\(y=C_1\\cos 2x+C_2\\sin 2x\\) \\(\\alpha=0\\), \\(\\beta=2\\rArr\\alpha+i\\beta=2i=\\lambda_1\\) 因此令特解 \\(y_0(x)=x(a\\cos 2x+b\\sin 2x)\\enspace\\) (\\(\\cos\\) 和 \\(\\sin\\) 都不能少哦) (余下略) \\(\\dots\\) \\(\\dots\\) 例2: \\(y^{\\prime\\prime}-2y^\\prime+2y=(x+1)e^x\\cos x\\) 解: \\(\\lambda^2-2\\lambda+2=0\\rArr\\lambda_{1,2}=1\\pm i\\) \\(y^{\\prime\\prime}-2y^\\prime+2y=0\\) 通解为 \\(y=e^x(\\cos x+\\sin x)\\) \\(\\alpha=1\\), \\(\\beta=1\\rArr\\alpha+i\\beta=1+i=\\lambda_1\\) 因此令特解 \\(y_0(x)=xe^x[(ax+b)\\cos x+(cx+d)\\sin x]\\) (余下略, 解出 \\(a,b,c,d\\), 最后得出通解) \\(\\dots\\) \\(\\dots\\)","link":"/zh-cn/learn/mathematics/2021/postgraduate-advanced-mathematics/"},{"title":"english-grammar","text":"英语的语法是一系列的规则, 只要理清和遵循这些规则, 就能写出正确的句子 本文的作用旨在脑中形成一个能够检查英语语法正确性的模型. article.article .content { font-family: KaTeX_Main, 'FZYaSongS-R-GB'; font-size: 1.0rem; } .nospace { font-size: 0; /* For sub elements use rem (only relative to root font-size) since font-size is set to zero */ } .def { font-size: 1.0rem } .red { color: #ff0000; font-size: 1.0rem; } .green { color: #00ff00; font-size: 1.0rem; } .blue { color: #0000ff; font-size: 1.0rem; } .yellow { color: #d7af00; font-size: 1.0rem; } .pink { color: #ef00ff; font-size: 1.0rem; } .cyan { color: #008080; font-size: 1.0rem; } 词法 连词 Conjunction 连词属于虚词, 无实义. 并列连词: and, or, but, for, not only…but also, neither…nor. 从属连词: that, if, whether, when, although, because, so that 介词 Preposition Prepositions are a class of words used to express spatial or temporal relations or mark various semantic roles. A preposition typically combines with a noun phrases, this being called its complement, or sometimes object. A preposition establishes a grammical/sematic relationship that links its complement to another word or phrase in the context. 介词分类 spatial: towards, in, on, under, against, near. temporal: after, during. sematic roles: of, for, without, than, via, per. 介词按结构分为 简单介词 Simple preposition 是由一个单词组成的介词. 例如 on, above, among. 复合介词 Compound preposition 是由两个词合成的介词. 例如 into, outside, within, throughout. 二重介词 Double preposition 是有两个介词构成的词组. 例如 from under, from behind, until after. 短语介词 Phrasal preposition 是由一或多个其他此类与一或两个介词构成的词组. 其作用相当于一个介词. 如 according to, apart from, due to, because of, by means of, for the purpose of, in addition to, in comparison with, in front of, instead of, with reference to, with regard to. 分词介词 Participle preposition 是有某些现在分词转换成的介词. 如 considering, including, regarding, concerning, given. given 与后边的并词构成短语在句中作条件状语. Given good health, I hope to finish the work this year. 介词在动词、名词和形容词后 与某些动词搭配: consist of, belong to, rely on/upon, add…to…, compare…with, differ from, insist on, persist in, depend on/upon. 与某些名词搭配: advantage over, search for, arrival at, similarity to, confidence in, struggle against, contribution to, satisfaction with, key to. 与某些形容词搭配: afraid of, responsible for, familiar with, fond of (喜欢), full of, faithful to, similar to, different from, free from. 介词与宾语的搭配 介词短语是由介词与其后宾语构成. 介词+名词 along the road, as an engineer, before lunch, in front of the house, according to the passage, due to the failure. 介词+代词 besides us, for them, except him, instead of her, on behalf of us all. 介词+数词 on 21st, May; at six; plus 16; from 10 to 20. 介词+动名词 without paying any taxes, upon hearing the news, instead of staying at home. 介词+疑问代词/疑问副词 引出的从句或不定式短语. about how he worked at the company. from what she has said. on how to improve the efficiency. 介词短语的用法 介词短语在句中主要担任定语和状语, 也可作表语和补足语. 定语 介词短语通常作后置定语. You must know the meaning of every word you learn. Most of the products on display are new ones. 状语 介词短语作状语修饰动词、形容词、副词或整个句子. Ships are built for sea transport. (修饰谓语 are built) Soon flying in the air became a fact. (修饰动名词 flying) The book is very popular among young people. (修饰形容词 popular) I haven’t been away from home. (修饰副词 away) In spite of his shortcomings, he is a responsible man. (修饰整句) 表语 These goods are of perfect quality. Mary seems in high spirits today. His story sounds like science fiction. The agreement will remain in force for another five years. 宾/主语补语 Once a cold kept her in bed for three days (宾语补语) When she entered the room she found everything in good order. (宾语补语) Pure iron is considered of little use. (主语补语) The price you offered is found on the high side. (主语补足语) 介词副词 介词副词是小品词 (particle), 它在形式上语介词相同, 但是句法功能不同. 它们在句中有时是介词, 有时是副词, 要注意区分. A truck drove past the gold mine. (介词) A truck drove past (副词) The moon circles round the earch. (介词) She will come round to see me. (副词) Our boat sailed up the river. (介词) The train stopped to pick up passenger. (副词) 副词 Adverb not, even, where, how, thus 代词 Pronoun 疑问代词: who[m], whose, which, what 关系代词: who[m], whose, which, that, as 不定代词: any, some, nothing, none 感叹词 Interjection oh 形容词与副词比较级 原级 (positive degree) 即形容词和副词原形. 比较级 (comparative degree) 和最高级 (superlative degree) 是在形容词和副词的原级基础上构成. 对于单音节和少数双音节形容词和副词, 其变化规则为: 比较级: 原级+er 最高级: 原级+est 对于多音节和多数双音节的形容词和副词, 其变化规则为: 比较级: more+原级 最高级: most+原级 少数形容词与副词的比较级和最高级是不规则的: 原级 比较级 最高级 good, well better best bad, badly, ill (坏) worse worst many, much more most little less least far farther (距离), further (进一步) farthest, furthest old older, elder (兄弟姐妹) oldest, eldest 用法 原级 表示双方程度相等用 as 原级 as. He is as busy as before. 表示双方程度不相等用 not so/as 原级 as. It is not so/as cold today as yesterday. He didn’t make as much progress as he had expected. She did’nt sing so well last night as she usually does. 比较级 两事物比较, 用 ‘比较级 than’. She has better memories than I. She arrived earlier than the others. 比较级可用 much, far, a lot, a great deal, a little, a bit 等修饰. The new method is much more efficient than the old one. We have had {a lot,great deal} more rainfall this year than we had last year. 用 ‘the 比较级, the 比较级’ 结构表示 '越…, 越…&quot;. In fact, the busier he is, the happier he feels. The soon you leave there, the better. 最高级 三个或三个以上事物比较用 ‘the 最高级’ 结构. Autumn is the best season in Beijing. 如果最高级前有物主代词, 则不需要定冠词 the. Please send us the goods at your earliest convenience. 如果不与他者相比, 最高级也可不加定冠词 the. Vegetables are best when they are fresh. 有时最高级表示 “非常”、“很” 的以上, 可加不定冠词 a/an 或不加冠词. This film is most interesting. This is a most touching story. 句法 句子成分 词类-句子成分对应关系 主语 宾语 表语 Predicative 定语 状语 主/宾语补语 (complement) 名词[短语] ✓ ✓ ✓ ✓ ✓ ✓ 代词 ✓ ✓ ✓ ✓ ✓ 数词 ✓ ✓ ✓ ✓ ✓ 形容词 ✓ ✓ ✓ 副词 ✓ ✓ 不定式[短语] ✓ ✓ ✓ ✓ ✓ ✓ {现在,过去}分词[短语] ✓ ✓ ✓ ✓ 动名词[短语] ✓ ✓ ✓ ✓ 介词短语 ✓ ✓ ✓ ✓ [状语][前置定语]主语[后置定语] [状语]谓语[状语] [前置定语]宾语[后置定语][宾语补语][状语] [前置定语]主语[后置定语] 系动词 表语[主语补语] 例子: 主语 数词做主语: Three plus four equals seven. 表语 介词短语作表语: The story of my life may be of help to others 不定式短语作表语: His plan is to seek work in the city. 其中 work 是 seek 的宾语, in the city 是 seek 的状语. 宾语 动名词短语作宾语: Do you mind opening the window? 定语 (Attribute): 广义的形容词. 限定主语或宾语的范围. 修饰名词性的单词、短语、从句. 单词作定语时通常放在修饰名词前 (前置定语); 短语和从句作定语时通常放在所修饰名词后 (后置定语). 名词作定语: They are woman workers. 所有格名词作定语: Tom’s father didn’t write home until yesterday. 形容词作定语: Equal pay for equal work shoud be introduced. 其中 for equal work 是 pay 的后置定语. 代词、数词和介词短语作定语: This is her first trip to Europe. 状语: 广义的副词. 修饰动词、形容词、副词. 表示地点、时间、原因、目的、结果、条件、让步、程度、方式、伴随情况等. 副词作状语: These products are selling quickly. 这里 are 是助动词和 selling 组成复合谓语. 名词作状语: He is in keen deep snow. 介词短语作状语: The best fish swim near the bottom. 比较状语从句 as…as: It is just as foolish to say that one should never eat meat and potatoes together as it is to say that one should never eat bread or drink milk. 这里 say 后面的都是同位语从句. 让步状语从句 as 引出: The ants, hard-working as they are, have their times for play. hard-working 为表语成分, 放在从句句首构成倒装. 宾语补语和主语: 有些及物动词作谓语, 除了要有宾语, 还需要宾语补语才能使句子意义完整. 宾语和宾语补语一起构成复合宾语. 如果是被动态语句, 宾语是实际主语, 宾语补语变为实际主语补语. 分辨: 修饰主语/宾语的不是表示限定作用的定语, 那么就是补语. 名词短语作宾语补语: They elected me caption of the team. 形容词短语作宾语补语: He made me ashamed of myself. 形容词短语: 形容词+补语(介词短语, 不定式[短语). 介词短语作宾语补语: We found everything there in good order. 不定式短语作宾语补语: I should advise you not to miss the chance. 分词短语作宾语补语: I could feel my heart beating fast. 不定式短语作主语补语: The price is expected to rise the near future. 形容词作主语补语: Some goods are left unsold. 名词短语作主语补语: She was elected director of public relations. 五大句型 (SV) 主语 谓语(不及物动词) e.g. He cried. (SVC) 主语 系动词 表语 [主语补语] e.g. The dinner smells good. e.g. This is an English-Chinese dictionary. (SVO) 主语 谓语 宾语 e.g. He enjoys reading (SVOO) 主语 谓语 间接宾语(通常指人) 直接宾语(通常指物) e.g. He brought you a dictionary. (SVOC) 主语 谓语 宾语 宾语补语 宾语与宾语补语构成复合宾语, 存在意义上的主谓关系. e.g. I often find him at work. e.g. They painted the door green. 句子用途 英语句子按用途可分为陈述句、疑问句、祈使句、感叹句. 疑问句 Interrogative sentence 有四类: 一般, 特殊, 选择, 反意 一般疑问句 General question: 用 yes/no 来回答. 句中助动词 (包括情态动词) 要放在主语前, 形成到装. 特别情况下, 如表示猜测、惊异、怀疑时, 可以自然语序. 如: You think the boy is impossible? 特殊疑问句 Special question: 就句中具体内容提出问题. 常用疑问词有 who[m], whose, which, what, where, when, why, how 等. 如: Who are responsible for the company’s advertising? What does macaroni look like? 选择疑问句 Alternative question: 提供两种或两种以上情况, 问对方选择哪一种. 通常有两个一般疑问句加 or 构成, 后一句常用省略结构. 如: Does your sister work in the wholesale department or in the retail store? Is the action necessary or unnecessary? 反意疑问句 Disjunctive question: 附在陈述句后, 对陈述句叙述的事实提出相反疑问. 通常表示说话怀疑或没有把我, 要求 yes/no 回答. 但有时也用于加强语气, 并不要求回答. 通常结构: {do,have,be,情态动词} + 主语; 若陈述句为否定结构, 反意疑问句用肯定结构. She doesn’t often wash her hair, does she? Tom washed his car yesterday, didn’t he? Everything is arranged in a good order, isn’t it? 祈使句 Imperative sentence 祈使句的主语 (听话者, 即 you) 通常被省略. 否定结构为在肯定结构前加 do not. 用 let 引起的是第一人称祈使句, let us 表示说话者和听话者都包括在内; let me 则只指说话者一方. Let’s start work at once. 感叹句 Exclamatory sentence 由 how, what 感叹词加被强调部分及陈述句其他部分组成. 如: How hard he works! How lucky I am to be invited to the party! What an interesting role she played! What a pity it is to lose the game again! 三大从句 定语从句 Attributive Clause 被定语从句修饰的词叫先行词, 定语从句必须放在先行词后面 something 为先行词, 定语从句不能用 which 定语从句三要素: 先行词、关系词、关系词在从句中充当的成分. 关系代词 that, who/whom, which, whose 引导的定语从句 先行词在从句中作主语时不可省略, 作宾语时可省略. 先行词是人, 用 who/whom, that The man {who,that} is standing there is my English teacher. (先行词在从句作主语, 不可省略) The man [{whom,that}] I am talking to is from the US. (先行词在从句中作宾语, 可省略) 先行词是物, 用 which, that The book {which,that} is on my desk is the best saller of 2018. (先行词在从句作主语, 不可省略) The book [{which/that}] I am reading is the best seller of 2018. (先行词在从句中作宾语, 可省略) 从句是人或物具备的特质, 用 whose (在从句中作定语) The man whose hair is brown is the chairman of the meeting. I am looking for the book whose cover is red. that 与 which 的比较 that 不可作介词的宾语, 这种时候只能用 “prep. which”. 只用 that 不用 which 的情况 先行词为不定代词 (some-, -thing, any-, all, every-, none, no-, little, few, much, neither…) Is there anything [that] I can do for you? That’s all [that] I know. 唯一 (the only, the one) 恰好 (the {very,right} that) 人和物 (先行词既有人又有物) They talk about | the thing and people that were unforgetable |. 先行词为序数词或形容词最高级 The first thing [that] we should do is work out a plan. This is one of the most exciting foolball games [that] I have ever seen. 关系副词 when, where, why 引导的定语从句 (在从句中作状语) 先行词是事件, 用 when. I still remember the day when we had the first class in this hall. 先行词是地点, 用 where. I still remember the city where we visited ten years ago. 先行词为原因, 用 why. I don’t know the reason why you are absent from the meeting. “prep. {which,whom}” 引导的定语从句 如果 which 或 whom 在定语中原为介词的宾语, 那么该介词可提到从句前. The house in which Lu Xun used the live is now a museum. The girl to whom you spoke is my sister. 限制性/非限制性定语从句 定语从句根据先行词的密切程度可分为限制性定语从句和非限制性定语从句. 限制性定语从句 从句与先行词关系密切, 从句为整个句子不可缺少的部分. The distance that light travels in one second is 300 thousand kilometers. 非限制性定语从句 从句与先行词关系松散, 起补充说明的作用. 去掉从句后主句的意思仍然清楚, 且从句往往有逗号隔开. 不能用 that 引导 Jim passed the driving test, which surprised everybody in the office. Steel, which has many useful properties, is widely in the machine-building industry. as 引导的定语从句 As is known to all, the earth is round. John, as you know, is a famous writer. He is from the south, as we can see from his accent. as 常在 such…as 和 same…as 的结构中作关系代词, 引出定语从句. Such people as you describe are rare nowadays. I feel just the same as you do. 定语从句表示状语关系 有时定语还可与主句有状语关系, 表示原因、条件、目的、结果等. The computer, which seems to play the role of a human brain, is often called an electronic brain. (原因) Computers, which have many advantages, cannot replace man. (让步) 状语从句 Adverbial Clause 由从属连词引导, 与主语连接, 常用逗号与主句分开. 如果位于句末, 其前一般不用逗号. 根据其用途可以分为时间、地点、原因、目的、结果、条件、比较、方式、让步状语从句. 时间状语从句, 通常由下列连词引导: when, whenever, while, as, before, after, until/till, since, as soon as, once. when 的用法 表示主句和从句动作同时或先后发生, 动词可以是延续性动词也可以是非延续性动词 I worked for a foreign company when I was in Shanghai. whenever Come and see me whenever you want to. while 的用法 往往表示主句和从句中的动作同时发生, 且常用延续性或表示状态的动词. They rushed in while we were discussing problems. as 的用法 as 引导时间状语从句表示一边…一边…, 随着, 或者正当… Helen heared the story as she washed clothes. before 和 after 的用法 before 表示在…之前, after 表示在…之后. I will always work hard before I enter Peking University. She cooked several delicious dishes for me after I got to her home. until/till 的用法 意思相同, 可以互换, 但 till 不能用于句首 主句谓语是延续性动词时. 主句用肯定形式, 表示这个动作或状态一直持续到 until/till 引导的从句的动作发生为止. I will wait for you untill/till you come to see me. 主句谓语是非延续性动词时, 主句用否定形式, 表示主句的动作直到 until 引导的从句动作发生才发生(构成 not…until 结构), 此时不能用 till. (有时不用 not, 而用其它表示否定的词, 如 never, nothing) I didn’t go to bed until I finished my homework. since 的用法 since 引导的时间状语从句, 一般主句用现在完成时, 从句用一般过去时. I have worked in this company since I graduated from Peking University. as soon as 的用法 as soon as 引导的时间状语从句, 表示从句的动作一发生, 主句的动作也随之发生. 该从句一般用现在时表示将来时. I will tell him the truth as soon as he comes here. 时间状语从句还可由一些名词 (the moment, the instant, every time 等) 和副词 (instantly, directly 等) 连接. I’ll telephone you the instant I know. Every time I catch a cold, my nose runs. when, while, as 的区别 when, while, as 引导的从句都可使用持续性动词. when 和 as 都可以与非持续性动词连用, 而 while 不能. when 可表示瞬间, 也可表示时间段, 与主句所陈述的动作、事情可同时发生, 也可有先后. while 常用于连接同时进行的两个持续性动词相伴随而发生的动作. as 不指先后, 尤指两个动作或事件同时发生. The film has been on when we arrived. My mother was cooking while I was doing my homework. As I left the house, I forgot the key. 条件状语从句 通常有连词 if, unless, suppose/supposing (假设), provided/providing [that] (假若), on condition [that] (如果), as [so] long as (只要), in case (如果). 主句为祈使句、一般将来或含有情态动词时, 条件状语从句通常用一般现在时. 关于条件从句中连接词的省略, 详见非真实条件句中的虚拟语气. 为了强调动作完成, 从句中也能用完成时 You can go out if you have finished your homework. if 引导 I will visit the Great Wall if it doesn’t rain tomorrow. If you want something done in a hurry, don’t go to the man who has clearly not much to do. unless 引导 We’ll go for an outing tomorrow unless it rains (=if it doesn’t rain). I shall return on Thursday unless something unexpected happens. suppose/supposing, provided/providing 引导 Suppose/Supposing we can’t get the necessary data, what shall we do? We’ll let you use the room provided/providing you keep it clean and tidy. 我们可以让你用这个房间, 但你要保持房间整洁. on condition [that] 引导 I’ll lend you my computer on condition [that] you keep it in good shape. 如果你能保持我的计算机的良好状态, 我就可以借你用. as [so] long as 引导 You can go out *as long as you promise to be back before 11 o’clock. in case Send me a message in case you have any difficulty. should 引导 should 与主语倒装, 置于句首. 这种句式多用于表示虚拟语气的结构中, 但其主句也可以是陈述语气. Should the observations or predictions turn out to be as expected, the scientist has added confidence in the probable truth of his hypothesis. Should I be free tomorrow, I will come. 原因状语从句 原因状语从句通常由 because, since, as 或 now [that] (既然), not that…but that (不是…而是) 引导. 前三个词表示的语气由 because 到 as 逐渐递减. because 的用法 表示因果关系的语气最强, 用来回答 why 的问题, 所引出的原因往往是听话人所不知道或者感兴趣的, because 引导的原因状语从句往往显得比主句更重要. I’m leaving because I am fed up with the lecture. My friends admire me because I can speak English as fluently as the native speakers. since 的用法 表示已知事实, 不需要强调的原因, 因此经常译成既然…, 通常放在句首. since 引导的从句是次要的, 重点强调主句的内容. Since every one is here, let’s get started. as 的用法 as 与 since 用法相似, 所引出的理由在说话人看来已经很明显, 或已为听话人所熟悉而不需要用 because 加以强调. as 引导的从句与主句具有同等的重要性. She didn’t hear us come in as she was asleep. now [that] 的用法 主要用于口语, 表示微弱的原因, 主、从句因果关系不明显, 意为既然. Now [that] you have come, you may as well stay. not that…but that 的用法 He felt a bit worried, not that his students were not working hard, but that they cared little for their health. 目的状语从句 目的状语从句通常由 {,so,in order} that (为了, 以便), lest (以免, 以防) 等引导. 从句谓语中常含 may, might, can, could, will, would 等情态动词. They set out early that they might arrive at the station in good time. He must get up early so that he can go to work on time. We sent the letter by air mail in order that it might reach them in time. We must hurry off lest we should miss the bus. (从句谓语虚拟语气, 即 should V1) 当从句主语与主句主语一致时, 可用 so as to 和 in order to. He worked day and night in order that he could succeed. = He worked day and night in order to succeed. 结果状语从句 结果状语从句通常由 [so] that (结果, 以致), so…that (如此…以致), such…that (这样的…以致). 在非正式文本中, so…that, such…that 中的 that 有时可省略. [so] that 引导 The weather was bad for some weeks, so that progress with the building of the power station slowed down. 由 so…that, such…that 引导 so adj./adv. that The problem is so complicated that it will take us much time to work it out. His father gave him so many toys he couldn’t play with them all. (非正式文本可省略 that) such a/an adj. noun. that The aircraft was flying at such a high altitude that we could hardly see it. She is so lovely a girl that we love her very much. She is such a lovely girl that we love her very much. so adj. a/an 单数名词 that such adj. 复数/不可数名词 that 当名词前有 many, much, little, few 修饰时, 用 so 不用 such. We have so much time that we can finish the work very well. so…that 句型否定形式可用简单句 too…to… 或 not…enough to 代替. He is so young that he can’t go to school. He is too young to go to school. He is not old enough to go to school. 让步状语从句 让步状语从句通常由 although/though, as (尽管, 虽然), even if/though (即使), however, whatever, no matter [{how,what,where,when}], whether…or 等引导. although/though 的用法 同义, 一般情况下可互换, 但 although 语气较重, 大多置于句首. 可与 yet 连用, 不可与 but 连用. They are generous though they are poor. Although he was Japanese, he spent most of his life in China. though 有时有 “但是, 不过” 的意思. 此时主句后面的让步状语从句接近并列的分句. I haven’t checked the information, though I think it is correct. even though/if 的用法 同义, 表示语气更强的让步. Even though he is 24 new, he’s still like a little child. We’ll make a trip even if/though the weather is bad. wh-ever 类引导词的用法 在英语中 wh-ever 既可引导名词性从句, 还可引导让步状语从句且可换成 “no matter + 相应 wh- 词”, 而在引导名词性从句时只能用 wh-ever. Whenever I am unhappy, it is my friend who cheers me up. = No matter when I am unhappy, it is my friend who cheers me up. as Try as I might, I couldn’t lift the stone. (从句语序倒装) no matter how He keeps on with his physical training in the winter no matter how cold it is. however However hard he tries, he never seeoms able to do the work satisfactoroily. 地点状语从句 引导地点状语从句的从属连词有 where 和 wherever. 指具体地点时, 从句可位于主句之前或之后; 表抽象含义时, 从句需放主句前. He lives where the climate is cool. Where there is a will, there is a way. Whereever you go you will see great changes that have taken place in that city. 注意区分 where 引导的状语从句和定语从句. You’d better make a mark where you have questions. (状语从句) You’d better make a mark | at the place where you have questions |. (有先行词, 定语从句) 比较状语从句 比较状语从句通常由 as…as, than, not as/so…as, the…the…, as…so… 引导. He worked as fast as a skilled worker. The project was completed earlier than we had expected. She didn’t work as/so hard as her sister. The sooner, the better. As one is to two, so is five to ten. 另请参阅形容词与副词的比较级. 方式状语从句 方式状语从句通常由连词 as, as if/though. 从句中谓语动词哦可用陈述语气, 也可用虚拟语气. 虚拟语气用来表示比较地 “非真实性”. Please state the facts as they are. It looks as if/though it’s going to rain. 注意: 不能同时出现在一个句子中的连词 because (因为) 引导原因状语从句. so (所以) 连接并列句. 不能同时出现在一个句子里, 只能用其一. Because he was tired, he couldn’t walk here. = He was tired, so he couldn’t walk here. although/though (虽然) 引导让步状语从句. but (但是) 连接并列句. 不能同时出现在一个句子里, 只能用其一. 但 although/though 和 yet 可以出现在一个句子里 (这里 yet 不是连词, 而是副词). 名词性从句 引导名词性从句的关联词 (connective) 主要有三类: 连接代词: who/whom, whose, what, which. 有词义, 在从句中充当句子成分, 如主语、表语、宾语等. 连接副词: when, where, why, how. 有词义, 在从句中充当句子成分, 作状语. 主从连词: that, whether, if, as if. that 无词义, 在从句中不充当句子成分, 有时可省略; 而 whether, if, as if 虽有词义, 但在从句中不充当句子成分. 主语从句 主语从句在复合句中作主语. Who will go is not important. 用 it 作形式主语放句首, 主语从句放句末, It doesn’t matter so much whether you will come or not. 但 what 引导的主句从句表示 “…的东西” 时, 不用 it 做形式主语, whatever, whichever, whoever 一般也不用 it 做形式主语. What he needs is more experience. that 引导主语从句时不能省略 That he suddenly fell ill made us surprised. 表语从句 若主句的主语是 advice, suggestion, order, request, requirement 等名词, 则表语从句的谓语用虚拟语气, 即 “should V1”. His suggestion is that we (should) change our course. 主语为 reason 时, 表语从句关联词要用 that, 而不用 why 或 because. The reason for such a serious accident is that the driver was too careless and drunk. because, why, as if/as though, as, like 等也可作表语从句关联词. He has lung cancer. That is because he has been smoking too much. (根据句子结构判断是表语从句还是结果状语从句) 宾语从句 宾语从句分三类: 动词的宾语从句、介词的宾语从句和形容词的宾语从句. 根据不同作用, 宾语从句的关联词通常分以下几类: that 本身无意义, 只起连接作用, 口语中可以省略. He said (that) Kate was good at swimming. what, which, who/whom, whose 等连接词, 在从句中作一定的成分, 如主语、宾语、表语、定语. I don’t know what they are going to do. (what 作宾语) He asked me whose book it was. (双宾; whose 作定语) when, where, why, how 等连接副词, 在从句中充当状语. Could you tell me where you live? (地点状语) Do you know how they found the place? (方式状语) If, whether 意为是否, 不作句子成分, 但不能省略. (条件状语区分: 宾语从句事情已做, 而条件状语事还没做) He asked me if Miss Zhao was a teacher. 同位语从句 起补充说明主语/宾语的作用. 识别同位语从句: 同位语从句是名词性从句; 因为名词性所以同位语能替换主语或宾语, 而定语和补语不能. 主句中有些词义比较抽象的主语/宾语, 如 belief, doubt, evidence, idea, fact, hope, possibility, thought 等, 通常用 that 引出的同位语从句修饰. There is no doubt that a large number of people benefit from heart surgery. Is there any proof that the food of the plant differs from that of animals? 如果修饰主语的同位语较长, 可置于句末: A plan was made last year that several roads would be built in this part of the city. 特殊句式 虚拟语气 Subjunctive Mood 虚拟语气是谓语动词的一种形式, 用来表示非真是的假设, 或用来表示命令、建议或说话人的主管愿望. 非真实条件中的虚拟语气 非真实条件就是违背 (现在, 过去, 将来) 事实的假设. 条件从句 主句 违背现在 一般过去时 should/would V1 (过去将来时) 违背过去 过去完成时 should/would have V3 (过去将来完成时) 违背将来 1) should V12) were 动词不定式 should/would V1 (过去将来时) 虚拟语气中主句第一人称用 should, 第二、三人称用 would. 但在美式英语中第一人称用 would. 此外, 主句可用情态动词 could 或 might 代替 should 或 would. 违背现在事实的假设. 在违背现在事实时, 如果条件从句谓语是 be, 各个人称均用 were. 但在非正式文体中, 特别是在口语中, 第一、三人称单数用 was 的也不少. If I were/was you. I would reconsider their proposal. What would you do if you were in his position. If the manager were/was here, he might/would make a decision. (might 可代替 would) 违背过去事实的假设 If I had left a little earlier, I would have caught the train. I could have done it better if I had been more careful. 可能违背将来事实的假设 指将来不太可能发生或说话人主观上不希望发生的假设. If he should fail, we would encourage him to try again. If I were to do it, I would do it in a different way. We would wipe them out if they should attack us. If it should rain tomorror, what could we do? 介词短语表示假设条件. 有时不用 if 引导条件从句, 而用介词短语表示违背事实的假设条件, 这时句中谓语动词仍用虚拟语气形式. Without air, there would be no wind or clouds. In that case we could have done the work better. But for the storm, we should have arrived earlier. if 的省略 如果条件从句谓语包含 had, should, were, 有时 if 可省略. 这时 had, should, were 要移到从句主语前面形成倒装. 这种句型主要见于书面形式. Had he not been ill, he might have come. Were I to do it, I would do it in a different way. Should it rain tomorror, what could we do? Were it not for his help, we chouldn’t have got over the difficulties. 名词性从句中的虚拟语气 在表示建议、命令、要求以及表示 “重要性” 和 “紧迫性” 等含义的主语、宾语、表语、同位语从句中, 谓语动词常用虚拟语气, 由 “[should] V1” 构成. 主语从句 在下列结构的主语从句中, 谓语动词用虚拟语气. It is {necessary,imperative,important,essential,advisable,better,ordered,proposed,desired,requested,suggested,recommended,demanded,decided,arranged} that 例如: It is desired that we [should] get everything ready before Friday. It is necessary that he [should] be sent there at once. 宾语从句 在下列动词后面的宾语从句中, 谓语动词用虚拟语气: suggest, insist, recommend, order, propose, require, request, command, demand. He commanded that we [should] attack the enemy at once. They demanded that the right to vote be given to every adult man. 同位语从句和表语从句 关联/修饰下列名词的同位语从句和表语从句中, 谓语动词用虚拟语气: suggestion, proposal, order, instruction, advice, motion (提议). He gave the order that the results of the experiment [should] be rechecked. My suggestion is that we [should] send a trade delegation to Malaysia. wish, would rather/sooner 后的虚拟语气 动词 wish 后的宾语从句表示未实现的主观愿望. 这类宾语从句的谓语动词用虚拟语气. 其形式及对应用法如下表: 用法 宾语谓语动词形式 当时未实现的愿望 一般过去时 过去未实现的愿望 过去完成时 将来不太可能实现的愿望 过去将来时 I wish I knew both English and French. We wish he hadn’t gone. 宾语从句谓语动词为 be 时, 用 were, 单数第一、第三人称也可用 was. I wish I were/was as young as you. I would rather/sooner the football match would take place tomorrow. wish 如果是过去时, 后面的宾语从句虚拟语气形式不变. She wished she knew how to drive the car. I wished I hadn’t made that mistake. 虚拟条件句 在含有虚拟条件句的复合语句中, 主句和从句的谓语都要用虚拟语气 违反现在事实 (从句) V2, (主句) {would/should/could/might} V1 If my brother were here, everything would be all right. 违反过去事实 (从句) had V3, (主句) {would/should/could/might} have V3 If you had taken my device, you wouldn’t/couldn’t) have failed in the exam. 违反将来事实 (从句) {V3/should V1/were to V1}, (主句) {would/should/could/might} V1 If it were Sunday tomorrow, I would/should/could/might/ go to see my grandma. If it were to snow this evening, they would not go out. 错综时间 有时条件从句中动词和主语中的动作发生时间不一致, 这时动词形式要根据它所表示的时间加以调整 If you had listened to doctor, you would be all right now. (从句过去动作, 主句现在动作) 注意: 主句中 should 只用于第一人称(但在美语中 should 常被 would 代替); 从句中 should 可用于各种人称. 虚拟条件句可以转换成下列形式 省略连词 if 在书面中, 如果虚拟条件从句中有 were, had 或 should, 可以把 if 省略, 把这几个词放到主语之前, 构成主谓倒装. Should he come (If he should come), tell him to ring me up. Were I you (If I were you), I would not do it. 用介词短语代替条件状语从句 有时假设的情况并不用条件从句表示出来, 而是通过介词短语来表示. Without air (If there were not air), there would be no living things. But for your help (If it hadn’t been for your help), I couldn’t have done it. 假设的情况有时可以通过上下文或其他方式表达出来. I was busy that day. Otherwise I would have gone with them. (If I hadn’t been busy that day, I would have gone there with them). I would have finished the work, but I have been ill. (If I hadn’t been ill, I would have finished the work.) 省去条件状语从句 表示虚拟从句的主句或从句有时可以省略, 但其含义仍可以推知. 省去条件从句 (If you had wanted to,) You could have washed your clothes yourself. 省去主句(常用于表示愿望) If my grandma were with me! If only she had not left. 虚拟语气的其他用法 虚拟语气在主语从句的用法 在 It is important(strange, natural, necessary)/suggested/desired/proposed…that… 句型中, that 所引导的主语从句的谓语动词常用 should + 动词原形的结构. It is important that every member (should) inform himself of these rules. 虚拟语气在宾语从句的用法 在动词 wish 后的宾语从句中表示与现在或过去的事实相反或对将来的主观愿望, 从句通常省略连词 that 表示对现在情况的虚拟: 从句动词用过去式或过去进行时(be + were) I wish I knew the answer to the question. 表示对过去情况的虚拟: 从句动词常用 had+过去分词. I wish(wished) I hadn’t spent so much money. 表示对将来的主观愿望: 谓语动词为 would+动词原形. 此时要注意, 主句主语与从句主语不能相同, 因为主句主语所期望的从句动作能否实现取决于从句主语的态度和意愿(非动物名称除外). I wish it would stop. I wish you would come soon. 在 suggest, demand, order, propose, insist, command, request, desire 等动词后面的宾语从句中, 谓语动词用 should + 动词原形. I demand that he (should) answer me immediately. 注意: 当 suggest 表示暗示, 表明之意, insist 表示坚持认为之意时, 其后宾语从句不适用虚拟语气形式, 应使用陈述语气形式. The smile on his face suggested that he was satisfied with our work. The man insisted that he had never stolen the money. 在 would rather 后的宾语从句中, 也用虚拟语气, 其谓语为动词过去式(表示现在或将来动作)或过去完成时(表示过去动作) I would rather she came tomorrow. He would rather I had done the work for him. 虚拟语气在状语从句中的用法 在带有 even if/even though 引导的让步状语从句的主从复合句中, 主句和从句都用虚拟语气, 动词形式与含有非真实条件的虚拟语气相同. Even if he had been ill, he would have gone to his office. 由 as if 或 as though 引导的状语从句表示比较或方式时. 从句谓语形式为动词的过去式(be + were)或 had + 过去分词. He treated me as if I were a stranger. She talked about the film as if she had really seen it. 在 in order to 或 so that 引导的目的状语从句中, 谓语动词多用 could 或 might (有时也用 should) + 动词原形. Mr. Green spoke slowly so that His students could(might) hear clearly. 虚拟语气在定语从句中的用法 在 it is time (that)… 句型中, 定语从句的谓语常用虚拟语气表示将来时, 动词原形一般换成过去式, 意思是该做某事的时候了. It’s (high) time we did our homework. 虚拟语气在简单句中的用法 情态动词过去式用于现在时态, 表示说话人的谦虚、客气、有礼貌, 或委婉的语气, 常见于日常会话中. I would be better for you not to stay up too late. 在一些习惯表达中. I would rather not tell you. 用 may + 动词原形, 表示祝愿, 此时 may 必须置于句首(多用于正式文体中). May you be happy! May good luck be yours! 强调句 Emphatic Sentence 把强调的成分放到单独的分句中, 这样处理的句子成为强调句或分裂句 (cleft sentence). 强调句构成有两种形式. (that/who/which 不能省略) 强调主语、宾语、状语: It is/was 强调部分 that/who/which 剩余部分 Anne had a severe heart attack last night. (强调主语) It was Anne that/who had a severe heart attack last night. (强调宾语) It was a severe heart attack that Anne had last night. (强调状语) It was last night that Anne had a severe heart attack. 如果被强调的是人称代词, 该人称代词可用主格也可用宾格. 非正式问题中多用宾格. It was she/her who told the police. 判断强调句的简便方法是将 It, is/was, that 三者去掉，句子结构仍然完整. 另一种是用名词从句 What…is/was…, 用来强调主语或宾语. What impressed us most was his image. What I like is her writing style. 强调动词: 人称代词 + do/did + 强调部分 + that 剩余部分 祈使句 动词在句首=祈使句 复合谓语 复合谓语的形式: 情态动词 + 动词原形 助动词 + 实意动词或短语动词 助动词 + 动名词/过去分词 The machine is drilling a hole. 系动词 + 表语(主系表可看作主谓) 独立主格 独立主格是没有谓语的特殊句子, 后面需要跟上主句, 不能独立存在. 比如: Her eyes moist and red there be 开头的句子也是独立主格 并列句 Compound sentence 使用并列连词连接起来的两个以上的句子 结构: 简单句 + 并列连词 + 简单句 常见的并列连词 分号 ;、冒号 :、逗号 , Every day the newspapers carry a few pages of classified ads; in the large Sunday editions there may be several sections of them. I’ve just had some good news: I’ve been offered a job in a law firm. Sometimes I laugh, sometimes I am down. 表示转折、并列、递进关系的并列连词 and, both…, and…, as well as, not only…but also…, neither…nor… My father bought me a present and I like it very much He is not only a good basketball player but also can play the plano very skillfully. 表示转折、对比关系的并列连词 but, yet, while, however, whereas Lucy likes playing the plano while Lily likes playing basketball. 表示选择关系的并列连词 either…or… 连接主语时, 动词和靠近它的主语在人称、数上保持一致, 即就近原则. or 或者, 还可以表示否则; otherwise Either you or your mother has been invited. Study hard, or you will fail the exam. 表示因果关系的并列连词 so 后面接结果, for 经常用于引出推断性的原因, 不能位于句首. Kate was ill, so she didn’t go to school. It must have rained last night, for the ground is wet. 注意: and 和 for 用于否定句中的用法 当列举成分是主语且在否定词之前时, 用 and 连接; 当列举成分在否定词之后, 用 or 构成全否定(指 or 连接的两个都否定) Lucy and Lily can’t speak Chinese. I can’t sing or dance. 在否定句中, 如果所连接的两部分都有否定词. 那么用 and, 不用 or There is no water and no air on the moon. 在否定句中, without 之后若有列举成分, 则用 and 连接, 构成完全否定; 在肯定句中, without 之后的列举成分要有 or 连接才能构成完全否定. Man can’t live without air and water. = Man will die without air or water. 当连结词 and 连接的并列句前半部分是祈使句, 后半部分是一般将来时的陈述句时, 前半部分相当于(指可转换成) if 引导的条件状语从句. 这种句型还可以用 or 连接, 但转换成的 if 引导的条件状语从句需是否定形式 Think it over, and you will find the answer. = If you think it over, you will find the answer. Hurry up, or you will be late. = If you don’t hurry up, you will be late. 复合句 复合句 (Complex sentence): 由一个主句和一个或一个以上从句构成的句子叫复合句, 也称主从复合句. 从句由关联词 (Connective) 引导, 可分为主语从句、宾语从句、表语从句、同位语从句、定语从句和状语从句. 复合句的特征是至少包含两个谓语 (主句一个从句一个)的句子. 词法 代词 用作形式主语或宾语, 或起从句连接作用 人称/物主代词, 反身代词, 指示代词(单this/that, 复these/those) 不定代词(some-, -thing, any-, all, every-, none, no-, neither…), 相互代词, 疑问代词, 关系代词(用于从句) for 反身代词: 由 (反身代词) 自己, 自己亲自; 为 (代词) 自己 by 反身代词: 不依靠别人, 独立地 in 反身代词: 就 (代词) 自己本身来说 连词 whereas 然而; 鉴于 wh-ever 任何… 冠词 Article 冠词放在名词前. 冠词语两种: 不定冠词 (indefinite article) a/an 和定冠词 (definite article) the. a/an 表示泛指, a 用在辅音前, an 用在元音前. the 表示特指. 单复数: a/an 只能用于单数名词. the 可用于单/复数名词和不可数名词. 不定冠词 表示人或事物的某一种类, 以区别其他类 She is a language teacher. What you saw in sky last night was a man-made satelite. 表示 “一” 这一数量概念, 但不强调. The special apparatus had a cage for the rat and three doors. Some people think of a family as a mother, a father, and their children. 表示 “某个”、任何一个&quot; 或 “每一个” 的意思. By eating an animal, you could get some of the good qualities of that animal for yourself. A library could hardly be used if the books were kepe in random order. 定冠词 表示某个或某些特定的人或事物. This is the house where my father once lived. Let’s see how the rat will open the door for itself. 表示前面已提过的人或事物. There is a girl and an old man standing at the bus stop. I think the man must be the girl’s father. I got a letter yesterday. The letter was sent from Russia by my uncle. 表示说话人和听话人都知道的人或事物. Close the door, please. Let’s meet at the railway station. 表示独一无二的食物. The moon is about 239,000 miles away from the earth. The whole world is waiting for the result of their talks. 和可数名词单数连用, 表示一类人或事物. Anyone who is willing to quarrel with the dictionary is regarded as either eccentric or mad. The family is important to people all over the world. 可数名词的类属可用 ‘the 单数名词’、‘a/an 单数名词’ 或 ‘复数名词’ 表示. The hammer is a useful tool. A hammer is a useful tool. Hammers are useful tools. 某些河流、海洋、山脉、群岛、海峡、海湾常加定冠词. the Yangtze, the Red Sea, the Alps, the Philippines, the English Channel, the Persian Guff. 某些由普通名词和其他词构成的专有名词前多要加定冠词. the People’s Republic of China, the United Nations, the State Council, the Great Hall of the People, the Daily Mail, the Capital Theatre. 在某些形容词前加定冠词, 是形容词名词化, 代表某类人. the poor, the rich, the sick, the wounded, the oppressed. 在序数词、形容词最高级和表示方位的名词前要加定冠词. The second tax is for the state government. The simplest kind of advertising is the classified ad. The sun rises in the east. 在某些习惯用语的名词前加定冠词. in the {morning,afternoon,evening}, in the city, by the way, for the time being (暂时), on the whole, out of the question (毫无可能的). 不加冠词 泛指的不可数名词或表示一般概念的复数名词不加冠词. Meaningfulness affects memory at all levels. Air is necessary in many ways. Social scientists study families. 人名、地名不加冠词. Deng Xiaoping, George Washington, India, Los Angeles, Paris, Hong Kong. 名词前已有 this, that, our, your, some, any, no, every 等代词作定语时, 不加冠词. Some birds are very lively in their sports. They could occasionally see part of our earth in full sunlight. 在某些固定词组或习惯用法中的名词不加冠词. go to bed, by air, at home, in fact, after school, in town, from morning till night. 介词 放在宾语/主语前, 视主语/谓语动词而定 TODO: 方位介词 用 for 还是 to 还是 of? 后接动作对象时, to 和 for 差不多 表示事物性质特点或原因或目标或一段时间用 for 形容人性格或品质用 of 常见介词短语(介词+名词, 介词后跟宾语) be relevant to change in // 强调改变的内容 change of // 强调改变本身 change to/into // 强调改变后的状态 confident of have effect on = affect be bound to 一定要 impact on carry out mastery over cross out 删去 matter to 对…很重要 so as to 以便于 be up to 取决于 an integral part of …不可或缺的一部分 multitude of 众多的 through thick and thin 风雨同舟 动词 及物动词和不及物动词 及物动词需后跟宾语 助动词 助动词: do, have, be, 情态动词 助动词后跟动词原形组成复合谓语 助动词作用: 构成时态、语态, 表达情感 情态动词 Modal Verb 情态动词属于助动词 情态动词: 主要有 can/could, may/might, must, need, ought, dare, 词为 shall/should, will/would 在一定场合也可用作情态动词. 情态动词的特点是它有一定的词义, 但通常需同另一个动词一起构成复合谓语. 除 ought 不定式外, 其他情态动词都跟动词原形. can 表示能力. Two eyes can see more than one. The theatre can seat 1,500 people. 表示可能性. You can’t expect others to pay for your food, your clothes and your room. You can sometimes meet him at the college. 表示允许. 该用法和 may 意思相近. You can/may go now. We can’t smoke near the gas station. 后接动词完成时, 表示可能已做某事. Where can he have gone? They can’t have gone out because the light’s on! 他们不可能已经出门了, 因为灯还亮着呢? 后接动词进行时, 表示可能正在做某事. What can he be doing at this time of the day? He can’t be swimming all day. could 表示能力、允许和可能性 (作为 can 的过去式). When he was young, he could speak both English and French very well. She asked whether she could take the books out of the reading-room. 用于委婉地提出请求、疑问或看法. 在时态上与 can 没有差别. Could you lend me some money? Could that be true? 后接动词完成时, 表示可能已做某事或本可以做某事. How could she have forgotten her own name? 她怎么可能连自己名字都忘了呢? We could have started a little earlier. 我们本可以早点动身. may 表示允许. May I trouble you with a question? You may do exactly as you like. 表示可能性 You may walk ten miles without seeing a house. It may be a new model of engine. 后接动词完成时, 表示可能已做某事. He may have seen the movie. 后接动词进行时, 表示可能正在做某事. They may be waiting for you. She may be leaving tomorrow. might 表示允许、可能性. (作为 may 的过去式) I asked her if I might see her. I thought it might be difficult for her to study psychology. may 的委婉形式. 在时态上与 may 没有差别. Mr. White might want to contact you. Might I ask for another cup of tea? 后接动词完成时, 表示可能已做某事或本可以做某事. He might have read the book. 后接动词进行时, 表示可能正在做某事. She might still be thinking about the questions you raised. He might be planning to buy a car instead of a motorcycle. must 表示必须要做某事. We must leave at 5. You must come earlier tomorrow. must 的否定是表示 “必须不能”. You mustn’t talk like that. We mustn’t stay here any longer. must 也可表示过去的情况, 主要用在间接引语或宾语从句中. She said that she must finish her homework at once. I felt I must call and see her. 表示推测. This must be your room. There must be a mistake. 后接动词完成时, 表示想必已经做某事. They must have arrived by now. She must have made a big mistake. 后接动词进行时, 表示想必正在做某事. Let’s hurry up. She must be waiting for us. You must be joking. ought ought 与不定式构成谓语动词. 主要用法如下: 表示应该做某事. You ought to take his advice. You oughtn’t to smoke so much. 你不应该抽太多烟. Oughtn’t we to give him a change to try? 后接不定时完成时, 表示本应该做某事. He ought to have done the exercise more carefully. You oughtn’t to have spoken to her in that way. need need 做情态动词时, 主要用于否定句和疑问句. Need he go soon? 他需要马上走吗? You needn’t tell him. need 后接动词完成时, 主要用于否定句, 表示本可不必做某事. You needn’t have told her that. You need not have gone there yestereday. need 也可用作及物动词, 后接名词、不定式、动名词等做宾语. She needs your help. They did not need to arrive so early. dare dare 作情态动词时, 主要用于否定句、疑问句和条件句. He daren’t even look at you. No one dared live there any longer. 但是 dare 多用做及物动词, 后接不定时作宾语. We must dare to think, to speak and to act. I wondor how he dared to say such a thing. She stopped at the door, not daring to enter. 但有时作 dare 宾语的不定式符号 to 也可省略. I didn’t dare (to) look up. They do not dare (to) speak. shall shall 通常作助动词, 它和其它动词一起构成将来时态, 主要用于第一人称. 但 shall 也可作情态动词, 用于第二和第三人称. The seller shall make shipment before October and the buyer shall make payment within 10 days after receipt of the goods. The law shall come into effect on May 1st. should should 除作为助动词 shall 的过去式用于第一人称外, 还可作情态动词. 表示劝告或建议. He should learn how to drive the car. You should listen to the doctor’s advice. 表示预测或可能. They should be home by now, I think. This kind of reference book should be in the reading-room. 表示惊奇、愤怒、失望等感情. Why should I go? I can’t think why you should tell her about it. It’s strange that it should be so hot tody. 很怪, 今天这么热. 后接动词完成时, 表示应该已经做某事. You are right, I should have thought of that. They shouldn’t have left so soon. 后接动词进行时, 表示应该正在做某事. Why should we be sitting here doing nothing? You shouldn’t be working like that. will will 通常作助动词构成将来时态. 但 will 有时也可作情态动词, 可用于各个人称, 表示意志、意愿和习惯等. I will do my best. I will pay you at a rete you ask. will 在疑问句中用于第二人称时, 表示说话人向对方提出请求或询问. Will you explain the sentence once again? Won’t you come in and have a cold drink? would would 除作为助动词 will 的过去式构成过去将来时态外, 还可作为情态动词. 作为情态动词 will 的过去式, 可用于各个人称, 表示意志、意愿和习惯等. He said that he would do everything to help us. I told her that I would go with her. would 在疑问句中用于第二人称时, 也表示说话如向对方提出请求或询问, 但语气更为委婉. Would you tell me something about yourself? Would you like to have a cup of milk? 使役动词 使役动词: have, make, let, help, use 使役动词后跟动词原形组成复合谓语 have作使役动词不能直接跟动词 系动词(也称连系动词) 系动词: 后面不接宾语, 而接表语. 非实义系动词: be 实义系动词:be, ramain appear, keep, 感官动词(look, sound, feel, smell, taste, seem, …), 趋势动词(get, go, become, turn, grow, remain, come, fall, hold, keep, stand, stay…) 不完全不及物动词: 需跟表语意思才完整, become, 如 The match | become | very exciting. 系动词否定形式: don’t+系动词 及物和不及物 不及物动词后不能直接跟名词 await (vt.) = wait (vi.) for 短语动词 Phrasal Verb 四种结构: 动词 介词 I look after my young brother. 动词 副词 Cats are taking over the planet. 动词 副词 介词 He is moving forward to it. 动词 名词 介词 Not all nursery schools make use of the opportunities open to them. take into set apart // set us apart as beings compare to // point out resemblances between objects regarded as essentially of a different order compare with // point out different between objects regarded as essentially of the sane order give up 的两种形式 give up sth. 名词 give it up 代词 非谓语动词 不可单独作谓语. 非谓语动词有三种: 不定式、分词和动名词. 不定式 Infinitive 构成 to V1 (to 是不定式的符号, 无意义, 有时可省略). 不定式保有动词特征, 可以有自己的状语和宾语 (及物动词), 组成不定式短语, 但没有三单和复数形式. 如 to read the text slowly. 不定式前可加某些疑问代词, 如 who, what, which; 或疑问副词如 when, where, how, why 等. 构成特殊的不定式短语. 如 what to do next, how to get there. 不定式还可有逻辑主语, 构成另一种特殊的不定式短语. 它由 “for 名词 不定式” 组成. 如 for the children to watch TV, for us to look for a job. 当不定式[短语]修饰的名词需通过介词才能联系时, 该不定式末尾需附有此介词: The light is | too weak to read by. (too weak to read by the light) The house is | good enough for us to live in. (good enough for us to live in the house. She’d like to have someone to speak English to. (to speak English to Her) 用法 不定式可作主语、主语补语、表语、宾语、宾语补语、定语、状语. 作主语 To learn English is not easy for me. 不定式短语作主语时, 往往放在最后面, 而用 it 作为形式主语. 其结构为 It be adj. [for/of sb.] 动词不定式 如上句可改为 It is not easy for me to learn English. 作主语补语 复合宾语中不定式作宾补时, 若变为被动语态, 原宾语变为主语, 原宾语补语变为主语补语. 不定式作主语补语时, 不能省略 to. He was asked to maek a speech at the meeting. They were made to work day and night. 作表语 My work is to clean the room everyday. 作宾语 What sport does he like to play? He likes to play football. 不定式常作某些及物动词的宾语, 不能作介词的宾语 (but, expect 除外). 这些动词常常表示命令、打算或希望. 这些及物动词有: afford, aim, claim, decline, demand, resolve, threaten, determine, endeavor, would like, want, like, wish, hate, hope, continue, manage, try, offer, start, begin, forget, promise, mean (打算), pretend, intend (想要), decide, learn, desire, agree, care, choose (愿意), refuse, fail, plan, expect 等. Would you like to see a film this evening? 如果谓语为 find/think 后跟不定式作宾语时, 常用 it 作形式宾语, 而将真正的宾语放在最后面. I find it hard to write English articles. 注意: 不定式常和疑问代词/副词 what, which, when, where, how 作不定式短语的宾语, 在句法中作宾语从句. The kid doesn’t know how to do it himself. (= how he should do it himself.) 作宾语补语 不定式作宾补时与宾语有逻辑上的主动关系. Lucy asked him to turn down the radio. 有些及物动词的宾语后常有不定式作宾语补语, 构成复合宾语, 这样意义才能完整. 这些及物动词有 tell, ask, invite, force, get (让), allow, wish, want, hate, help, leave, expect, prefer, advise, presuade, permit, remind, request, order, warn, mean (打算), cause, allow, would like, encourage 等. Would you like us to go with you. He asked you to call him back at 11. 还有一些使役动词和感官动词也用不定式作宾补. 这时要省略 to. 这些动词有: 一感 (feel, notice), 二听 (hear, listen to), 三让 (let, make, have), 四看 (look at, see, watch, notice), 但是这些动词变被动语态时, 作动词的不定式必须加上 to The boss made them work the whole night. They were made to work the whole night by the boss. 作定语 不定式作定语应放在被修饰名词之后 (只作后置定语), 它与被修饰名词之间有逻辑上的被动关系. We don’t have enough food to eat. 如果不定式是不及物动词, 且与所修饰词间有被动关系, 需在不定式后加上适当介词. There is nothing to worry about. Do you have any ink to write with? It is a very good school to study in. 作状语 不定式作状语, 用来修饰动词、形容词、副词或整个句子. 通常表示目的、结果、原因、程度等. 作目的状语 To save the time, we took the plane to Beijing. 注意: 如果强调此目的, 可在不定式前加 in order/so as. 但 so as to 不能用于句首. I will take notes in order not to/so as not to forget these important points. 作结果状语, 往往表示出乎意料的结果, 常与 only 连用 He hurried to the station only to find that the train had left. 著名的 too…to…句式 It is too late to do anything now. 作原因状语 To hear him talk to me in that manner, you would think that the is my boss. 接在某些形容词后面常表示喜怒哀乐的原因. We are pround to be the citizens of China. 作程度状语 He is old enough to go to school. Mary wouldn’t be so careless as to forget her key. 时态与语态 一般现在时 表示不定式的与主要谓语动词的动作或状态几乎同时或在其后发生. She was seen to enter the hall. (seen 与 to enter 两个动作同时发生) I have some news to tell you. (to tell 动作发生在 have 之后) 现在进行时 表示不定式动作正在进行且与谓语表示的动作同时发生. They seem to be getting along quite well. They are said to be building another bridge across the river. 据说他们正在这条河上修建另一座大桥. 现在完成时 表示不定式动作发生在谓语动作之前. I am sorry to have hept you waiting. (to have kept 发生在 am 表示的时间之前) She seems to have read the book before. 被动语态 不定式中, 及物动词的简单时和完成时有被动语态, 但不及物动词则都没有被动语态. 及物动词 不及物动词 一般时 to V1 to V1 to be V3 完成时 to have V3 to have V3 to have been V3 进行时 to be V(+ing) to be V(+ing) 完成进行时 to have been V(+ing) to have been V(+ing) 当不定式的逻辑主语是该不定式动作的承受者时, 不定式一般要用被动形式. Is is an honour for me *to be asked to speak here*. He wanted the letter *to be mailed at once*. 但在某些句子中, 虽然不定式与最近的名词与动宾关系, 但与句中另一个名词却可能有主谓关系. 这时不定式常用主动式. He has no one to take care of. (He 与 to take care of 有主谓关系) We still have many difficulties to overcome. Give him some books *to read, please. They found the lecture hard to understand. 动名词 Gerund 动名词兼有名词特性, 可作主语, 及物动词的动名词可带宾语, 比如: Thus forming an integrated image with all the information placed in a single mental picture can help us to preserve a memory. 独立结构 with + n. (all the information) + V3 (placed [in a single mental picture]) 作方式状语修饰动名词短语 forming an integrated image. 构成: V+ing 用法 作主语 谓语动词用单数. Eating too much is bad for your health. Talking mends no holes. 空谈无济于事. 在某些结构中, 可用引导词 it 作形式主语放句首, 而将世纪主语放句尾. It is no use asking her advice. It is a waster of time discussing such matters. 做表语 The real problem is getting to know the needs of the customers. Her job is nursing the disabled. 动名词和不定式都可做主语或表语. 一般来说, 在表示比较抽象的一般行为时多用动名词; 在表示具体某次动作或将来发生的动作时, 多用不定式. Smoking is not allowed here. To smoke so much is not good for you. Their job is building houses. Their work is to build another bridge across the river. 作宾语 表示一般的习惯或抽象行为或经常性的动作. 作动词宾语 以下及物动词及短语动词常用动名词做宾语: acknowledge, admit, advocate, avoid, contemplate, dislike, evade, fancy, grudge, recollect, response, resist, include, finish, suggest, stop, mind, enjoy, require, postpone, delay, practise, excuse, risk, consider, miss, imagine, deny, escape, put off, give up, keep on, can’t help (禁不住), be worth, have trouble/problems/difficulty (in), spend some time/money (in), feel like, be/get used to. She suggested spending another day in the mountain area. I enjoy seeing you and talking about old times. There’s no way to escape doing the work. require 后的动名词有被动含义. Does you care require servicing? 在 love, like, hate, prefer, begin, start, continue, intend, attempt, propose, deserve, need, want, can’t bear, can’t afford 等动词后可用动名词也可用不定式作宾语, 两种结构在意义上差别不大. I like {playing,to play} basketball very much. need, want 后面的动名词具有被动含义. Your suit needs {ironing,to be ironed}. 你的西服需要烫平. The plants want {watering,to be watered}. 在 like, hate, prefer 等动词后, 如果表示一般倾向, 多用动名词作宾语; 如指具体某次动作, 多用不定式. I like reading books of this kind, but I don’t like to read that book. I prefer to stay at home today. 在 begin, start 和 cease 后, 如果表示有意识地开始或停止某动作, 多用动名词; 如果动作自动或惕然开始或停止则多用不定式. He began talking about his plan for summer hoildays. Suddenly it began to rain. 在 remember, regret 等动词后, 动名词做宾语和不定式作宾语的意义差距明显. 动名词表示已经做了, 不定时表示将要去做. I remember seeing her once somewhere. I must remember to write to you often. I regret not haveing taken your advice. I regret to say that we can’t accept your price. 作介词宾语 动名词也和作介词的宾语, 并和介词一起构成介词短语. 在句中作定语、状语或表语. Stamps are used for sending letters. The simplest kind of advertising is the classified ad. 做定语 单个动名词可作前置定语. 如 drinking water 饮用水, drawing paper 绘图纸. 动名词做定语与现在分词做定语有所不同: 动名词和他所修饰的名词在逻辑上没有主谓关系, 即前者不是后者发出的动作. working method 工作方法 (working 是动名词, working 不是 method 发出的动作, 等价于 method for working) working people 劳动人民 (working 是现在分词, working 是 people 发出的动作, 等价于 people who work) 时态与语态 动名词的时态语态与现在分词 主动 被动 一般时 V+ing being V3 完成时 having V3 having been V3 一般时 表示动名词的动作与谓语动作同时发生, 或在谓语动作之后发生. Children enjoy reading picture-story books. He only took interest in buying a second-hand computer. (buying 在 took interest 之后) 完成时 表示动名词的动作通常发生在谓语动作之后. He was praised for having made such a contribution to his community. I regret having told her the news. 但在某些动词后或在某种情况下, 也可用动名词的一般时代替完成时, 尽管动名词的动作发生在谓语动词之前. I don’t remember ever seeing the car anywhere. Thank you for giving us so much help. On returning home, she found her father had been sent to hospital. 被动式 当动名词的逻辑主语是动名词动作的对象时, 动名词一般要用被动形式. He did all this without being asked by anyone. After having been interviewed, he was offered the job. 动名词的逻辑主语 动名词可用物主代词或所有格来修饰, 表示动名词的逻辑主语. Do you mind my making a suggestion? I’m pleased with John’s paying his income tax in time. 但在非正式英语中, 尤其是当动名词在句中做宾语时, 更常见的是用人称代词和普通格修饰动名词. Do you mind me making a suggestion? I’m pleased with Join paying his income tax in time. 动名词和现在分词作定语区别 现在分词通常表示修饰词的动作或状态, 可扩展为定语从句; 动名词通常表示所修饰的食物的用途或目的, 不可扩展为定语从句, 但可扩展为介词短语. swimming mammals = mammals that swim (现在分词作定语) swimming pool = pool for swimming (动名词作定语) 分词 Participle 分词的作用相当于形容词, 在句中可以担当定语、表语、状语、补语. 现在分词 (present participle) 与过去分词 (past participle) 现在分词 V+ing; 过去分词 V+ed, 但有不规则形式. 现在分词有主动、进行之意; 过去分词有被动、完成之意. 用法 作定语 单个分词常放在修饰名词前, 分词短语常放在被修饰名词后. 但有时过去分词也可放在被修饰名词之后. 现在分词作定语修饰其逻辑主语; 过去分词作定语修饰其逻辑宾语. Do you know the girl standing under the tree? Please hand in your written exercises. They decided to change the material used. (单个过去分词作后置定语) 作状语 表示时间、原因、方式、结果、条件、让步和伴随情况等. 作状语的分词通常放在句首或句尾, 有时也可插在主谓直接. 分词作状语其逻辑主语为句子的主语. Relying on our own efforts, we overcame all the difficulties. (原因) Hearing the news, they all jumped with joy. (时间) The teacher walked about the classroom, using his hands to help him in his explanation. (方式) The child fell, striking his head against the door and cutting it. (结果) The students went out of the school, laughing and talking (方式或伴随情况) Given better attention, the trees could grow better. (条件) 为了表示明确时间或条件, 有时可在分词前加 when, while, if 等连词. When leaving the airport, she waved again and again to us. While waiting for the train, I had a long talk with Jane. If translated word by word, the sentence will be meaning less. 当主句和从句主语不一致且要用分词作状语时 (称为独立结构 absolute construction), 要在分词前面加上动作的逻辑主语. 在很多情况下表示时间、原因、条件或伴随情况. The hoildays being over, they began to get down to do their work again. (时间) So many people being absent, we decided to put the meeting off. (原因) Weather permitting, the football match will be played on Wednesday. (条件) We went far into the forest, her father acting as guide. (伴随) 有时这样的独立结构还可用介词 with 引导. He stood there with his hands crossed before him. With tears rolling down her cheeks, she carefully covered her mother’s body with sand. 作表语 分词常在系词后作表语. 现在分词表示主语的性质、特征; 过去分词表示某种状态. The book is so interesting that I will read it again. The boy is too frightened to move. 作补语 现在分词作补语, 被补足的宾语/主语是它的逻辑主语 过去分词作补语, 被补足的宾语/主语是它的逻辑宾语 (因为过去分词有被动含义) 分词可在 see, hear, notice, watch, keep, find, get, have, feel 等动词后与一个名词构成复合宾语. Don’t keep us waiting for a long time. I heard him singing in the classroom. He’ll have his hair cut after school. 当谓语变为被动语态时, 原宾语变为主语, 原宾语补语变为主语补语. The hall was found thoroughly cleaned and everything arranged in good order. The children were heard singing the song. 在 see, hear, notice, watch, feel 等动词后既可用现在分词也可用不带 to 的不定式作宾语补语. 现在分词强调动作正在进行和发展中, 而不定时表示动作的全过程已经结束. She saw the man getting on the truck. 她看见那个人在往卡车上爬. She saw the man get on the truck and drive off. 她看见那个人爬上卡车并把车开走了. —Do you hear someone knocking at the door? —Yes, I heared him knock three times. 现在分词的时态和语态 主动 被动 一般时 V+ing being V3 完成时 having V3 having been V3 完成时 现在分词的完成时主要用在状语中, 表示该动作在谓语动作之前发生. Having done his homework, the boy began to watch TV. Having watered the vegetables, the farmer took a short rest. 被动式 现在分词的被动式不仅表示被动, 而且表示这个动作正在发生, 或与谓语动作同时发生. 现在分词被动式主要用于定语、状语和宾语补语. The bridge being built there will be one of the longest in China. (正在进行, 定语) Being surrounded, the enemy were forced to put down their guns. (正在进行, 状语) He found the topic being discussed everywhere. (being discussed 与 found 同时发生, 宾语补语) 完成时被动式 现在分词的完成时被动式不仅表示被动, 而且表示这个动作在谓语动作之前发生. 这种形式常用作状语. Having been given such a good chance, how could she give it up? Having been told that some guests were coming, she shopped all morning in that supermarket. 易混淆点 动词不定式复合结构用 of 或 for 的区别 在 kind, good, nice, clever 等表示人的品质、特征的形容词后, 不用 for 而用 of; 在表示事物性质特点的形容词后用 for. It’s very clever of you to do it like this. It’s very difficult for me to finish the task in an hour. 不定式符号 to 和介词 to 的区别 to 既可以是不定式的符号, 也可以是介词, 后面跟名词、代词或动名词作宾语. 常用的含有介词 to 的短语: make a contribution to devote…to… prefer…to… get/be used/accustomed to… apply to 动词不定式作宾补和现在分词作宾补的区别 see, watch, hear, feel 等感官动词 后接省略 to 的不定式作宾补时, 表示动作的全过程已经结束; 后接现在分词作宾补, 表示动作正在进行. I saw him cross the street. I saw him crossing the street 某些动词后面接不定式和动名词有区别 stop, forget, remember, try, regret, mean, go on, can’t help need, require, want 后面跟不定式和动名词作宾语的区别 后面接动名词主动式表示被动含义, 也可跟不定式的被动式. The window needs cleaning. The window needs to be cleaned. 用动词不定式还是动名词 TODO: 整理特点 工作内容用不定式 兴趣爱好用动名词 伴随动作用动名词 如 We walked as fast as we could, hoping to catch the 9:30 train like to do 想去做某事 like doing 习惯于 go on/continue to do 停下手上的活做其他的事请 go on/continue doing 一直在做没有停止 remember/forget to do 记得/忘记将要去做 remember/forget doing 记得/忘记做过 try to do 尽力,努力 try doing 尝试 mean to do 打算去做 mean doing 意味着 regret to do 抱歉(为将要发生的事请) regret doing 抱歉(已经发生的事请) begin/start to do 下意识的 begin/start doing 自然发生的 need doing=need to be do: need 为情态动词; need to do: need 为实意 hear sb doing 和 hear sb do: 前者进行时, 后置强调结果 be worthy of being done = worthwhile to do first 和 last 用不定式 the first to do the last to do no good/use 用动名词 please/happy/enough 用不定式 cannot but 用动名词 let alone 用动名词 spend两种形式 spend on sth. spend in doing plan 用不定式 permit 用动名词 miss 用动名词 practice 用动名词 have no … but 用动名词 worth 用动名词 spend (in) doing it takes sb. some time to do sth. 动词形态 时态和语态 英语动词从时间 (time) 上看有现在、过去、将来机过去将来; 从体 (aspect) 上看有一般、进行、完成及完成进行. 动词的时间与体的结合即动词时态 (verb tense). 在十六种时态中, 将来完成进行时 (future perfect continusus tense)、过去将来进行时 (past future continuous tense)、过去将来完成时 (past future perfect tense)、过去将来完成进行时 (past future perfect continuous tense) 很少使用. 分清句子时态: 过去的过去用过去完成时; 见到一段时间用完成时 谓语动词有主动和被动两种语态. 主动语态 (active voice) 表示主语是动作执行者, 被动语态 (passive voice) 表示主语是动作的承受者, 宾语是动作的执行者. 被动语态一共有十二种, 但实际常用的只有八种. 不定式的主动式时态有一般现在时, 现在进行时和现在完成时三种. 被动式时态有一般现在时和现在完成时两种. aspect\\time Present Past Future Past Future Simple V1-s/es V2 will/shall V1 would/should V1 am/is/are V3 was / were &nbsp; V3 will/shall &nbsp; be V3 would/should &nbsp; be V3 to V1 to be V3 Continuous am/is/are V+ing was / were &nbsp; V+ing will/shall &nbsp; be V+ing would/should &nbsp; be V+ing &nbsp;(Rare) am/is/are &nbsp; being &nbsp; V3 was / were &nbsp; being &nbsp; V3 will/shall &nbsp; be &nbsp; being &nbsp; V3 &nbsp;(Rare) would/should &nbsp; be &nbsp; being &nbsp; V3 &nbsp;(Rare) to be V+ing Perfect has/have V3 had &nbsp; V3 will/shall &nbsp; have V3 would/should &nbsp; have V3 &nbsp;(Rare) has/have &nbsp; been &nbsp; V3 had &nbsp; been &nbsp; V3 will/shall &nbsp; have &nbsp; been &nbsp; V3 &nbsp;(Rare) would/should &nbsp; have &nbsp; been &nbsp; V3 &nbsp;(Rare) to have V3 to &nbsp; have &nbsp; been &nbsp; V3 Perfect &nbsp; Continuous has/have &nbsp; been &nbsp; V+ing had &nbsp; been &nbsp; V+ing will/shall &nbsp; have &nbsp; been &nbsp; V+ing &nbsp;(Rare) would/should &nbsp; have &nbsp; been &nbsp; V+ing &nbsp;(Rare) 一般现在时 Simple Present Tense 经常或反复发生的动作或存在的状态. 常和表示频率的时间状语 (如 often, always, usually, sometimes, every day, once a week) 连用. He takes a walk after supper every day. How often do you wash your hair? 表示主语的特征、性格、能力等. Mr. Smith hates fish and never eats any. She has great concern for others. 客观事实或普遍真理. The sun rises in the east and sets in the west. Light travels faster than sound. 表示安排或计划好的将来发生的动作. The plane takes off at 10 a.m. When does the train leave for Shanghai? 在时间或条件状语从句中表示将来的动作. Please wait till Jane arrives. When you see her, just tell her that I am all right. 代替过去时表示某些文学作品中的情节描写, 或用于引述书看材料. The little boy goes up to the policeman and says, “There’s a car accident over there.” The author says that the soldiers fight for freedom not for money. 一般过去时 Simple Past Tense 表示过去某时发生的动作或状态, 常和表示过去的时间状语 (如 yesterday, last week, three years age, in 1984) 连用. She bought a Sabtabb kast week. He lived in London when he was young. 一般将来时 Simple Future Tense 表示将来发生的动作或情况. They will leave for Hong Kong tomorrow. We won’t be free tonight. 在时间或条件状语从句中, 一般不用将来时, 而用现在时代替. I’ll let you know when I*'m* through with the work. If you put the baby down, he will scream. 将来时还有以下形式: am/is/are goint to V1 表示最近打算去做或可能要发生的事情. We are going to visit the Museum of Chinese History tomorrow. How long are you going to stay here? am/is/are about to V1 表示即将发生的动作. We are about to leave, so there is no time to visit her now. Please get everything ready. The experiment is about to start. am/is/are to V1 表示必须或计划进行的动作. The girl are to go to school next week. There is to be a sport meet on Saturday. 过去将来时 Past Future Tense 主要用来表示过去某一时间内将要发生的动作或存在的状态. He told me that he would see mee off at the station. I rang up to tell my father that I should go home next Monday. 和一般将来时类似, 过去将来时也有特殊形式: was/were going to V1 There were going to have a meeting to discuss the matter. was/were about to V1 I was about to go out when a friend of mine dropped in. was/were to V1 They were to visit the White House that afternoon 现在进行时 Present Continuous Tense 表示现在正在进行的动作. What are you doing? I*'m doing* some washing. 有些动词 (如 go, come, stay, leave, start) 的现在进行时形式也可表示将来即将发生的动作. He is coming to see you tomorrow. The plane is leaving for London. 有些表示状态和感觉的动词不用于或在某个词义上不用于进行时. 如 hate, like, love, believe, think (以为), look (看起来), mind (在意), have (有), seem, sound (听起来), remain. 过去进行时 Past Continuous Tense 表示过去某一时刻或某段时间内正在进行的动作. I was practicing my oral English at eight o’clock yesterday evening. When I saw her, she was working at the computer. 与现在进行时类相似, go, come, stay, leave 等动词的过去进行时形式可以表示过去将要发生的动作. She asked my whether I was starting the next day. Mr. White told me that he was leaving for Singapore in a few days. 将来进行时 Future Continuous Tense 表示在将来的某段时间正在发生的动作或按计划在奖将来将要进行的动作. “What will you be doing at there tomorrow afternoon?” “I*'ll be flying* to Hong Kong.” We shall be having a business talk with Mr. Brown in a minute. 现在完成时 Present Perfect Tense 表示过去开始, 但持续到现在的动作; 或表示过去发生的动作, 但对现在仍留下某种影响. My mother has been ill for three days. I have not seen her since 1991. 过去完成时 Past Perfect Tense 表示过去某个时间或某个动作前已经完成的动作; 或表示过去某个时间开始一直延续到过去另一个时间的动作. When I came to her room, she had alrady left. I waited until he had finished his work. 将来完成时 Future Perfect Tense 表示在将来某一时间以前已经完成的动作. We hope it will have stopped raining before we set of for the picnic. I*'ll have dont* all the work by the time you are back this eveing. 现在完成进行时 Present Perfect Continuous Tense 表示从过去某一时间开始一直持续到现在的动作. 这个动作可能刚刚结束, 也有可能继续进行下去. She has been working in Shenzhen since 1985. Where have you been? I have been looking for you everywhere. 过去完成进行时 Past Perfect Continuous Tense 表示过去某个时间以前已经开始而又延续到过去这个时间的动作. 这个动作可能刚刚结束, 也可能还在继续. He told me that he had been teaching physics for more thant twenty years. Dick had been smocking for ten years before he decided to give it up last year. 时态呼应 The Sequence of Tenses 名词从句, 尤其是宾语从句中的动词时态, 常受主句中时态的影响. 例如 She told John that she liked his tie 中, 从句的谓语 like 用了过去时, 这并不是说她现在已经不喜欢 John 的领带了. 而是因为主句的谓语是过去时. 规则: 从句谓语由一般现在时变成一般过去时, 一般过去时变为过去完成时, 一般将来时变成过去将来时. 即 主句现在时态, 从句该用什么时态用什么. 主句过去时态, 分情况讨论: 从句动作若在主句动作发生之前, 从句用过去完成时态. 从句的动作与主句动作同时发生, 用一般过去时或过去完成时. I thought the experiment was going on now. 从句动作发生在主句动作之后, 从句用过去将来时 She siad the apparatus would be available next week. 以下情况可不遵守时态呼应的规则: 客观真理, 自然现象, 格言谚语. The boys learned yesterday that the planets are circling about the sun. (不用 were circling) 从句中有表示绝对过去时间的状语. The old man said he joined the Red Army in 1933. (不用 have joined) 说话者强调动作现在正在进行或将要发生. He told me the train leaves at three. (不用 left) 被动语态的用法 被动是针对于主语而言的, 无生命的一般为被动 在被动语态的句子中, 动作的执行者一般由介词 by 引起的短语来表示. We often help them. (主动) They are often helped by us. (被动) 被动语态常用于一下情况 当不知道动作执行者是谁或没有必要提到动作执行者. Paper was first made in China. No decision has been made so far. 当强调或突出动作承受者的作用时. 此时动作执行者用介词 by 加代表动作执行者的名词或代词表示. The new machine was invented by a 20-year-old young worker. 被动语态的几种特殊结构 不及物动词、表状态动词一般用主动语态(即不能作被动) come true, consist of, take place, happen, become, rise, occur, belong, break out, appear, arrive, die, fall, last, exist, fail, succeed 含情态动词的被动语态结构: 情态动词 + be + 及物动词的过去分词. The goods must be shipped before the end of September. In this sense, bad things can be turned into good things. 短语动词的被动语态结构. 短语动词应作为一个整体看待, 变为被动语态不能丢弃构成短语动词的介词、副词或名词等成分. We have sent for the doctor. The doctor has been sent for. We shall put off the meeting till Friday. The meeting will be put off till Friday. People looked down upon women in the past Women were looked down upon in the past. The nurse takes good care of the children. The children are taken good care of by the nurse. 含有双宾的主动结构变为被动结构. 主动结构中若有两个宾语, 变为被动结构时, 只将其中一个宾语变为主语, 另一个宾语不变, 通常称为保留宾语 (retained object). We allowed him an hour to get to the airport. 变为被动: He was allowed an hour to get to the airport. 或者: An hour was allowd him to get to the airport. 含有复合宾语的主动结构变为被动结构. 主动结构中如有复合宾语 (宾语+宾语补语), 变为被动结构时只将元复合宾语中的宾语变为主语, 宾语补语部分不变, 但语法上变为主语补语 (subject complement). We advised him to practice speaking English. He was advised to practice speaking English. 下列动词的主动形态表被动含义 lock, wash, sell, read, wear, blame, ride, drive, write (且常与 well, easily, badly 等副词连用) Glass breaks easily. The car rides/drives smoothly. The case locks easily. The book sells well. 系动词(look, sound, feel, smell, taste, appear, seem, turn, keep, …): The steel feels cold. I don’t want to sound like anyone else, but I’ve had a hard life. 表示开始、结束、运动的动词: begin, finish, start, open, move 等 The shop closes at 6 p.m. every day. 表示事物(或人)客观上&quot;需要&quot;: want, need, require 作谓语 用动名词作宾语一般主动形式表示被动含义. (等价于动词不定式的被动形式) 若动名词是不及物动词, 后面还需跟上相应的介词. 某些作表语的形容词(easy, difficult, light, heavy, fit, good, safe, comfortable, dangerous, pleasant, …)后面(作状语)的动词不定式主动表被动 如 She is easy to approach have sb. do sth. 和 have sb./sth. doing 和 have sth. done 的区别 have sb. do sth. 让某人做某事, have 可用 let, make 代替. 不定式往往表示一次性的动作, 且强调动作已经完成或尚未发生. The police had the boy stand with back to his father. have sb./sth. doing 让某人或某物一直做某事, have 可用 keep 代替, 现在分词往往具有持续、进行、主动的含义. The teacher had the students reading aloud the text for a quarter. The two men had their lights burning all night long. have sth. done 有两层含义: 托某人做(=ask sb. to do sth.) The driver had hist car washed once a week. 遭受某人做. 过去分词的动作由他人完成, 被动含义且强调动作已完成. He had his wallet stolen when he was shopping. 杂项 Misc Equivalent pursue sth. = in pursuit of sth. be + adj. = be + of + n. e.g. He is an able man = He is a man of ability Mass Noun, Uncountable Noun advice furniture information news Append Gerund only practice V(+ing) hardly Verb(v3) when no sooner Verb(v2) than do well to 最好做… 一个名词放在另一个名词前作定语时, 通常用单数, 但 “销售税” 却是 sales tax. 又如: sports meeting 运动会. part of 某物的一部分; a part of 某物的一小部分. no more than = only He is no more than a beginner = He is only a beginner. nothing but 仅仅, 不过是 have [nothing,much] to do with 与…{有,无,有很大}关系. 倒装 主语和表语: Very busy must be their thoughts = Their thoughts must be very busy. 宾语道装: Many of the things that animals know how to do they seem to know either without learning, or in some way which we cannot understand. They | seem to know | many of the things that animals know how to do | either without learning, or in some way which we cannot understand. only + 状语 引出一个句子时, 该句必须倒装. Nor 引出的否定句用倒装: Nor is this all. be made from…, be made of… 前者看不到原材料, 后者可以看出原材料. if…only 表示尚欠缺的条件. In cases where the explanation is unknown the scientific point of view is that there is a reason if it can only be discovered. 在对一些现象的解释还不为人们所知的情况下, 科学的观点是, 其中必有原因, 只是尚未被发现罢了. too/so + adj. + a/an + noun. It’s too difficult a task for me. I’ve never before met so intelligent a person as he is. had + noun. + V3 We’ll have this house built in 5 months. He had his hair cut yesterday. be to 相当于一个情态助动词. 可表示 “将”, “要”, “应”, 会&quot; 等意思. I am to see him today at six o’clock. You are not to smoke in this room. not so much…as 与其说…不如… He is not so much as scientist as a writer. 与其说他是个科学家, 不如说他是个作家. 即可接动名词也可接不定式的及物动词 attempt begin commence continue deserve disdain dread endure forget hate help intend like love mean need neglect omit propose regret remember scorn try want stop 跟动名词时时及物动词; 后跟不定式时时不及物动词, 不定式时目的状语 When did you stop working? We stopped to rest. try 跟不定式作宾语, 意为 “设法”, “试图” (需费力或有困难). 后跟动名词作宾语, 意为 “试一试”. You must try to be more careful. Let’s try knocking at the back door. 倒装句 在英语句子中, 通常主语放在谓语动词的前面, 这样的语序称为自然语序 (natural word-order). 反之, 如果谓语动词的一部分或全部放在主语前面, 则称为倒装语序 (inverted word-order) there be 句型和多数疑问句都是倒装句. 表示否定或基本否定的词与词组放在句首作状语时 这些词与词组主要有: never, scarcely, hardly, rarely, little, nowhere, no sooner…than, not only, in no case, in no way, on no account, at no time, under/in no circumstances. 这些词/词组引出的倒装句中, 倒装到主语前的那部分谓语动词通常是助动词、情态动词或 be 动词. Never before has anyone applied such principles to practice. Hardly had he said anything before he left. Scarcely had she fallen asleep when a knock at the door awakened her. No sooner had Anne arrived there than she fell ill. Rarely did Tom leave his lab those days. Little did I think a year ago that I could work for your company. only 引出的状语放在句首时 这种情况下的倒装一般是部分倒装. Only then did the doctor realize that his patient needed surgery. Only after class was he allowed to raise the question. Only when you adjust down your price to some extent can we conclude the business. Only once did his father call his full name. here, there, then, thus 等副词放在句首, 且谓语为 come, go, be, exist, follow 等不及物动词时 这种情况下的倒装一般为全部倒装. Here is a book for you. Here comes the bus. There goes the bell. There exist two types of flying machines. Then follows the fashion show. Thus arose the division between the developed and developing countries. 句首为 so, nor, neither 等副词, 表明前句说明的情况也适用于本句时 Richard can speack Japanese. So can his sister. Copper is a good conductor, So are many other metals. He didn’t say anything. Nor/Neither did his assistant. The first one wasn’t good enough and neither was the second. 在虚拟语气中, 非真是条件从句中的连词省略时 这种情况下倒装到主语前的是助动词 had, should 和动词 were. Had I left a little earlier, I would have caught the train. Should it rain tomorrow, what could we do? Were there no air, there would be no sound. 句子主语部分过长或上下文之间需要紧凑衔接时 有的句子因为主语较长而谓语较短, 为使句子保持平衡需要倒装. 有的倒装是为了上下文之间衔接得更紧凑. 这类倒装并非语法上的要求, 而是一种修辞性倒装. Sitting in front of the counter is the young father who wishes to purchase a life insurance policy and agrees to pay a sum of $200 per year for 40 years. (此句主语因有一个定语从句而变得很长, 故倒装到谓语之后) More important is the question of how to face the possibilities of illness, injury, death and financial loss. The writing of a dictionary involves a number of tasks. Among them are the reading of literature, the copying of words on cards, the sorting of the cards and the writing of definitions. (后句倒装可与前句衔接更紧密) 构词法 派生法 Derivation 在词根 (root) 前面或后面加上词缀来产生新词. 构成名词的后缀 人或物 -er, -or, -ist, -ee, -ian, -ese, -ant 如: thiner; translator, conductor; physicist; employee, trainee; Italian; Japanese; assistant. 行为、性质、状态 -ance, -ence, -[a]tion, -sion, -ics, -ing, -ity, -ment, -ness, -th, -ty, -ure, -ship 如: acceptance; confidence; reptition, preparation; discussion; physics, fabrics; wedding; reality; settlement; hardness; length; safety; failure, pressure; leadership. 构成形容词的后缀 -able, -ible, -al, ful, -less, -ish, -ive, -ous, -an, -ic, -ly, -y, -ant, -ent, -ary, -en available; permissible; national; powerful; useless; selfish; decisive; famous; American; scientific; friendly; noisy; significant; dependent; imaginary; golden. 构成副词的后缀 -ly, -ward, -wise. regularly; eastward; otherwise. 动词后缀 -ise (美国 -ize), -en, -ify realize; widen; verify. 前缀 相反意义 un-, dis-, in-, im-, ir-, il-, de- unhappy; dislike; informal; impossible; irregular; illegal; devalue. 重新 re- retell 错误 mis- misunderstand 反、防 anti- anti-social 前 ex- ex-president 预先 pre- preheat 后 post- postgraduate 先 fore- forecast 自我、自动 self- self-control 自动 auto- automobile 超级、上层 super- supermarket 下级 sub- subdivide 之间、互相 inter- interact 跨越、移 trans- transport 外、极 ultra- ultraviolet 半 semi- semiconductor 副 vice- vice-premier 单 uni- uniform 双 bi- bicycle 多 multi- multistage 常用前后缀 prefix12345678910111213141516171819202122232425262728anti- : &quot;opposite&quot; antisocialauto- : &quot;by oneself or itself&quot; autobiographybi- : &quot;two&quot; bicyclebio- : &quot;biological&quot; biologyco- : &quot;together&quot; cooperatecounter- : &quot;against&quot; counteraccackde- : &quot;negative, remove&quot; defrostdis- : &quot;negative, opposite&quot; dishonesten- : &quot;make it in...state&quot; enlargeil- : &quot;not, used before the letter 'l'&quot; illegalim- : &quot;not, used before the letter 'm', 'b', 'p'&quot; impossiblein- : &quot;not&quot; inactiveir- : &quot;not, used before the letter 'r'&quot; irregularinter- : &quot;between&quot; internationalmid- : &quot;middle&quot; middaymini- : &quot;small&quot; miniskirtmis- : &quot;wrong&quot; misunderstandnon- : &quot;not&quot; nonstoppost- : &quot;after&quot; postwarpre- : &quot;before&quot; prewarre- : &quot;again&quot; rewritesub- : &quot;below&quot; subwaysuper- : &quot;great&quot; superherotele- : &quot;large distance&quot; telescopetrans- : &quot;across&quot; transpacifictri- : &quot;three&quot; triangleun- : &quot;not&quot; unimportantunder- : &quot;beneath&quot;, &quot;not enough&quot; underestimate suffix 名词后缀12345678910111213-age-ance, -ence-ancy, -ency-er, -or-hood childhood-ion, -tion, -ation-ian-ist-ment-ness-ology biology, psychology-ship friendship, membership-ty, -ity 动词后缀123-en fasten. shorten-fy, -ify satisfy, simplify-ize, -ise modernize 形容词后缀1234567891011-able, -ible, -ble-al environmental-ful-ic, -ical atomic, economical-ish bluish-ive-less-ly-ous-some troublesome-y 副词后缀12-ly-ward(s) backward(s), afterward(s) 合成法 Compounding 由两个以上的词合成一个新词 名词: hardware, network, well-being. 形容词: duty-free, far-reaching, face-to-face. 动词: overthrow, heat-treat, counteroffer. 转换法 Conversion 词形不变, 词性转变. 通常词义与转换前有密切联系, 但有时差异很大. look v. 看 → n. 相貌 back n. 后背 → v. 支持 second num. 第二; → v. 赞成 有些双音节词转换后, 重音发生变化. 通常名词重音在前, 动词重音在后, 有时读音也有不同. TODO: 补充注音 名词 动词 conduct 行为 传导 digest 文摘 消化 export 出口 出口 increase 增加 增加 produce 农产品 生产 refuse 垃圾 拒绝","link":"/zh-cn/learn/2021/english-grammar/"},{"title":"suspicious-stew","text":"可疑的炖菜: 就是一些来路不明的未整合笔记 二次元萌萌人语录 (u1s1, 看着这些内容我都不自觉地脸红…) 呐呐呐，服务员欧内酱~~（超级肉麻） 诶多捏诶多捏，瓦塔西就是那个，二次元得斯~~（超级得意） 二次元の美好，米娜桑都知道的吧！（转身超级大声跟店里的顾客说了这句话） 哒嘎啦，人家厚洗一对，那个二次元的徽章呐~偶捏该，瓦塔西斯够固sikisiki呆！！siki那个徽章呐~ 纳尼?一定要那个口号吗….呜呜呜，哈子卡西….得莫，为了超级想要的二次元徽章….瓦塔西会干巴爹的！！！ 异世相遇！！！！（华丽转圈圈）尽享美味！！！！！（转圈停下来然后跳起来对着服务员左手叉腰右手比着 ） 阿里嘎多欧内酱！！！呆siki了！ 米~娜~桑！新春佳节又来了desu哇~阿喏呐阿喏呐(｡&gt;∀&lt;｡)，首先呢新的一年呀，要-给-米-娜-桑拜个年desu！(^ω^)（姆Q）米娜桑新年おめでとうそしてそして在新的一年里，米~娜~桑的生活要摩多摩~~~多の西亚☆哇塞♡desu呦✧٩(ˊωˋ*)و✧，和往年一样呢，米~娜~桑的祝福呐！/ 3B1B 向量是什么 https://www.bilibili.com/video/av5987715 导数的本质 https://www.bilibili.com/video/av24325548 构图 可应用于绘画, 摄影 常用画面 1:1, 3:2, 4:3, 6:4, 按需裁剪 中心构图法: 画面尽量对称; 将视觉主体和周围环境紧密结合, 但不能色彩撞衫导致主次不清 对角线构图法 第一眼让观众知道你拍的视觉主体是什么 景物内容尽量完整 人物视觉对象不能是显得堵的东西 虚化对象要保留起码的特征 尽量使主题出现在黄金分割线 需要避免的 非刻意情况下画面要有层次感, 避免引起视觉错觉 人物在视觉上不能在顶房梁 脚不能被卡出画面外 附加 飞向镜头的物品能增加视觉冲击力 街头纪实摄影, 比如巷道口那样的一线天画内搭画框 字体 明日方舟标题英文字体是: NOVECENTOWIDE 明日方舟基建英文字体是 Bender TNO字体: 主标题字体 Tannenberg, 旧版GUI字体 VT323, 新版GUI字体Aldrich Mechanism 一些零件规格, PCB 打样可以找嘉立创 DIY 准备工作: 防割板 电阻电容样品本(Pingcon 样品本 0603 封装, 0402 封装, 常用 IC 元件) 示波器推荐 DS213 开源示波器 Screws M3x10 3mm直径, 10mm螺纹端长度 M4x10r 4mm直径, 10mm螺纹端长度, 圆顶 螺母 M3nS 方形 Pulley GT2-16 Motor 42步进电机 无刷伺服电机 同步带 聚氨酯 PU 同步带 软件 multisim 模拟电路仿真 Altium Designer 有开源替代 kicad Autodesk Fusion 或 Rhino 6 Visual Studio Extension: Visual Micro Grandle 设置代理: gradle.properties12345678910...systemProp.http.proxyHost=hostnamesystemProp.http.proxyPort=8080systemProp.http.proxyUser=usernamesystemProp.http.proxyPassword=xxxsystemProp.https.proxyHost=hostnamesystemProp.https.proxyPort=8080systemProp.https.proxyUser=usernamesystemProp.https.proxyPassword=xxx 椭圆参数方程 \\(\\begin{cases} x=a\\cos t \\\\ y=b\\sin t \\end{cases}(0\\leqslant t\\leqslant 2\\pi)\\) 变形后可得椭圆方程: \\(\\begin{array}{l}\\frac{x}{a}=\\cos t \\\\ \\frac{y}{b}=\\sin t\\end{array}\\rArr\\begin{array}{l}\\frac{x^2}{y^2}=\\cos^2 t \\\\ \\frac{y^2}{b^2}=\\sin^2 t\\end{array}\\rArr\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=\\cos^2 t+\\sin^2 t=1\\) 因式分解 整式乘法与整式除法 整式乘法: 以 \\((x+1)(2x^2+3x-2)=2x^3+5x^2+x-2\\) 为例 $$ \\begin{array}{rrrrrrrr} & & & 2x^2 & + & 3x & - & 2 \\\\ \\times & & & & & x & + & 1 \\\\ \\hline & & & 2x^2 & + & 3x & - & 2 \\\\ & 2x^3 & + & 3x^2 & - & 2x & & \\\\ \\hline & 2x^3 & + & 5x^2 & + & x & - & 2 \\end{array} $$ 整式除法: 以 \\((2x^3+5x^2+x-2)\\div(x+1)=(2x^2+3x-2)\\) 为例 因式定理与余数定理: 因式定理: 如果多项式 \\(f(a)=0\\) , 则多项式必含因式 \\((x-a)\\) ; 反之, 若多项式含有因式 \\((x-a)\\) , 则 \\(f(a)=0\\) 余数定理: 用 \\((x-a)\\) 去除多项式 \\(f(x)\\) , 所得余式(相当于除法中的余数)是一个值为 \\(f(a)\\) 的常数 试根法: 分解高次多项式时, 用常数项因数与最高次项系数之因数的比值(记为 \\(a\\))去试根, 若验证 \\(f(a)=0\\) 则 \\((x-a)\\) 可整除原多项式, 即 \\((x-a)\\) 为 \\(f(x)\\) 因式 (试根法的本质是因式定理) 如: \\(2x^3+5x^2+x-2=(x+1)(2x^2+3x-2)=(x+1)(2x-1)(x+2)\\) 它的常数项因数(\\(\\pm1\\)、\\(\\pm2\\))和最高次项系数之因数(\\(\\pm1\\)、\\(\\pm2\\))的比值有 \\(\\pm1\\)、\\(\\pm2\\)、\\(\\pm\\frac{1}{2}\\) , 代入得其中 \\(-1\\)、\\(-2\\)、\\(\\frac{1}{2}\\) 可整除原多项式 IUPAC Organic 123456789101112131415161718192021222324252627282930313233343536373839(1S,3R,4R,5R)-3-{[(2E)-3-(3,4-dihydroxyphenyl)prop-2-enoyl]oxy}-1,4,5-trihydroxycyclohexanecarboxylic acidtri hydroxy cyclo hexane carboxylic三羟基环己烷羧酸Latinate series Ordinal numeralprimarysecondarytertiaryquaternary, quartaryquinarysenaryseptenaryoctonarynonarydecenaryundenaryduodenarytri- 三meth- 甲eth- 乙prop- 丙but- 丁pent- 戊hex- 己hept- 庚oct- 辛non- 壬dec- 癸methylp 甲基hydroxy 羟基phenyl 苯基cyclo- 环-ane 烷(Alkanes)carboxylic 羧酸 利用 Zerotier 白嫖校园网 “Zerotier 打洞, 永远滴神” 首先确定你的校园网有IPv6, 一个简单的方法是看看号称支持IPv6的手机支付宝, 能不能在只连接校园网且未登录Wifi的状态下正常使用. 网关机配置转发和NAT:123sudo iptables -t filter -A FORWARD -i zt+ -s &lt;你的Zerotier网络地址段&gt; -d 0.0.0.0/0 -j ACCEPTsudo iptables -t filter -A FORWARD -i eth0 -s 0.0.0.0/0 -d &lt;你的Zerotier网络地址段&gt; -j ACCEPTsudo iptables -t nat -A POSTROUTING -o eth0 -s &lt;你的Zerotier网络地址段&gt; -j SNAT --to-source &lt;你的网关机公网地址&gt; 在 ZeroTier Central 中添加路由: 0.0.0.0/0 via &lt;你的网关机在Zerotier网络中的地址&gt; 在想要白嫖的电脑上, 启用 Zerotier 的 Allow Default Route 最小二乘法求回归直线方程的公式推导 回归直线方程: \\(\\hat{y}=a+bx\\) 其中: \\(\\hat{b}=\\frac{\\sum_{i=1}^n x_iy_i-n\\bar{x}\\bar{y}}{\\sum_{i=1}^n x_i^2-n\\bar{x}^2}\\) , \\(\\hat{a}=\\bar{y}-\\hat{b}\\bar{x}\\) (\\(\\bar{x}\\) 和 \\(\\bar{y}\\) 为 \\(x_i\\) 和 \\(y_i\\) 的均值) 证明: 用所有离差(近似值 \\(\\hat{y}_i\\) 和观察值 \\(y_i\\) 的差)的平方和来表示总离差: \\(\\displaystyle Q=\\sum_{i=1}^n(y_i-\\hat{y}_i)^2=\\sum_{i=1}^n(y_i-a-bx_i)^2\\) (因为离差有正有负, 直接加可能相互抵消) 由于平方又叫二乘方, 所以这种使&quot;离差平方和为最小的方法&quot;称为最小二乘法 开始变形: $$ \\scriptsize \\begin{array}{l} Q=\\displaystyle\\sum_{i=1}^n(y_i-a-bx_i)^2=(y_1-a-bx_1)^2+\\dots+(y_n-a-bx_n)^2 \\\\ =(y_1^2+a^2+b^2x_1^2+2abx_1-2ay_1-2bx_1y_1)+\\dots+(y_n^2+a^2+b^2x_n^2+2abx_n-2ay_n-2bx_ny_n) \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2+na^2+b^2\\sum_{i=1}^n x_i^2+2ab\\sum_{i=1}^n x_i-2a\\sum_{i=1}^n y_i-2b\\sum_{i=1}^n x_iy_i \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2+na^2+b^2\\sum_{i=1}^n x_i^2+2ab\\cdot n\\bar{x}-2a\\cdot n\\bar{y}-2b\\sum_{i=1}^n x_iy_i \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2-2b\\sum_{i=1}^n x_iy_i+b^2\\sum_{i=1}^n x_i^2+na^2-2na(\\bar{y}-b\\bar{x}) \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2-2b\\sum_{i=1}^n x_iy_i+b^2\\sum_{i=1}^n x_i^2+n(a^2-2a(\\bar{y}-b\\bar{x})) \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2-2b\\sum_{i=1}^n x_iy_i+b^2\\sum_{i=1}^n x_i^2+n(a^2-2a(\\bar{y}-b\\bar{x})+(\\bar{y}-b\\bar{x})^2-(\\bar{y}-b\\bar{x})^2) \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2-2b\\sum_{i=1}^n x_iy_i+b^2\\sum_{i=1}^n x_i^2+n(a-(\\bar{y}-b\\bar{x}))^2-n(\\bar{y}-b\\bar{x})^2 \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2-2b\\sum_{i=1}^n x_iy_i+b^2\\sum_{i=1}^n x_i^2+n(a-(\\bar{y}-b\\bar{x}))^2-n\\bar{y}^2+2nb\\bar{x}\\bar{y}-nb^2\\bar{x}^2 \\\\ =\\displaystyle(\\sum_{i=1}^n y_i^2-n\\bar{y}^2)-2b(\\sum_{i=1}^n x_iy_i+n\\bar{x}\\bar{y})+b^2(\\sum_{i=1}^n x_i^2-n\\bar{x}^2)+n(a-(\\bar{y}-b\\bar{x}))^2 \\end{array} $$ 到此, 需要两个关键变形公式以继续变形: \\(\\displaystyle\\sum_{i=1}^n(x_i-\\bar{x})^2=\\sum_{i=1}^nx_i^2-n\\bar{x}^2\\) 证明: $$ \\scriptsize \\begin{array}{ll} \\displaystyle\\sum_{i=1}^n(x_i-\\bar{x})^2 & =(x_1-\\bar{x})^2+\\dots+(x_n-\\bar{x})^2 \\\\ & =(x_1^2-2x_1\\bar{x}+\\bar{x}^2)+\\dots+(x_n^2-2x_n\\bar{x}+\\bar{x}^2) \\\\ & =(x_1^2+\\dots+x_n^2)+n\\bar{x}^2-2\\bar{x}(x_1+\\dots+x_n) \\\\ & \\displaystyle=\\sum_{i=1}^n x_i^2+n\\bar{x}^2-2n\\bar{x}\\frac{(x_1+\\dots+x_n)}{n} \\\\ & \\displaystyle=\\sum_{i=1}^n x_i^2+n\\bar{x}^2-2n\\bar{x}^2 \\\\ & \\displaystyle=\\sum_{i=1}^n x_i^2-n\\bar{x}^2 \\end{array} $$ \\(\\displaystyle\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})=\\sum_{i=1}^n x_iy_i-n\\bar{x}\\bar{y}\\) 证明: $$ \\scriptsize \\begin{array}{ll} \\displaystyle\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y}) & =(x_1-\\bar{x})(y_1-\\bar{y})+\\dots+(x_n-\\bar{x})(y_n-\\bar{y}) \\\\ & =(x_1y_1+\\bar{x}\\bar{y}-x_1\\bar{y}-y_1\\bar{x})+\\dots+(x_ny_n+\\bar{x}\\bar{y}-x_n\\bar{y}-y_n\\bar{x}) \\\\ & =(x_1y_1+\\dots+x_ny_n)+n\\bar{x}\\bar{y}-\\bar{y}(x_1+\\dots+x_n)-\\bar{x}(y_1+\\dots+y_n) \\\\ & \\displaystyle=\\sum_{i=1}^n x_iy_i+n\\bar{x}\\bar{y}-n\\bar{y}\\frac{x_1+\\dots+x_n}{n}-n\\bar{x}\\frac{y_1+\\dots+y_n}{n} \\\\ & \\displaystyle=\\sum_{i=1}^n x_iy_i+n\\bar{x}\\bar{y}-n\\bar{y}\\bar{x}-n\\bar{x}\\bar{y} \\\\ & \\displaystyle=\\sum_{i=1}^n x_iy_i-n\\bar{x}\\bar{y} \\end{array} $$ 接上面: $$ \\scriptsize \\begin{array}{rl} Q= & \\displaystyle(\\sum_{i=1}^n y_i^2-n\\bar{y}^2)-2b(\\sum_{i=1}^n x_iy_i+n\\bar{x}\\bar{y})+b^2(\\sum_{i=1}^n x_i^2-n\\bar{x}^2)+n(a-(\\bar{y}-b\\bar{x}))^2 \\\\ = & \\displaystyle\\sum_{i=1}^n(y_i-\\bar{y})^2-2b\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})+b^2\\sum_{i=1}^n(x_i-\\bar{x})^2+n(a-(\\bar{y}-b\\bar{x}))^2 \\\\ = & \\displaystyle\\sum_{i=1}^n(y_i-\\bar{y})^2+\\sum_{i=1}^n(x_i-\\bar{x})^2(b^2-2b\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2})+n(a-(\\bar{y}-b\\bar{x}))^2 \\\\ = & \\displaystyle\\sum_{i=1}^n(y_i-\\bar{y})^2+\\sum_{i=1}^n(x_i-\\bar{x})^2(b^2-2b\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2}+(\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2})^2 \\\\ & \\displaystyle-(\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2})^2)+n(a-(\\bar{y}-b\\bar{x}))^2 \\\\ = & \\displaystyle\\sum_{i=1}^n(y_i-\\bar{y})^2+\\sum_{i=1}^n(x_i-\\bar{x})^2(b-\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2})^2 \\\\ & \\displaystyle-\\sum_{i=1}^n(x_i-\\bar{x})^2(\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2})^2+n(a-(\\bar{y}-b\\bar{x}))^2 \\\\ = & \\displaystyle\\sum_{i=1}^n(y_i-\\bar{y})^2+\\sum_{i=1}^n(x_i-\\bar{x})^2(b-\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2})^2 \\\\ & \\displaystyle-\\frac{[\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})]^2}{\\sum_{i=1}^n(x_i-\\bar{x})^2}+n(a-(\\bar{y}-b\\bar{x}))^2 \\\\ \\end{array} $$ 至此, 公式变形结束. 观察公式, 其中 \\(\\scriptsize-\\frac{[\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})]^2}{\\sum_{i=1}^n(x_i-\\bar{x})^2}\\) , \\(\\scriptsize\\sum_{i=1}^n(y_i-\\bar{y})^2\\) 为常数项与 \\(a\\) , \\(b\\) 无关. 因此只需使 \\(b=\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2}\\) , \\(a=\\bar{y}-b\\bar{x}\\) 即可得到最小 \\(Q\\) 值 咖啡的种植 种子培育 用洗净的中细河沙做催芽基质 种子剥去羊皮纸外壳, 以60度以内温水泡种催芽2-7天[根据地方气候决定催芽时间长短], 夏季2-4天即可. 每日换水一次, 直到白色胚芽凸起. 可以正式育苗. 种子均匀铺在苗床上, 种子不可重叠, 点种是种子裂口处朝上覆盖一层稻草或其他保湿物. 或以珍珠棉和泡沫箱盖住, 留有部分空间不可盖严. 2-3日浇一次水, 如气温高水分蒸发过快需每日浇水. (用喷雾) 可在上面搭建塑料透明薄膜棚子, 但待苗出土后幺注意遮阴. 20-40天出苗, 但各地气温不同, 出苗会有前后. 催芽床可用600倍多菌灵喷雾喷催芽床四周, 催芽过程中, 适时喷药. 预防小苗猝倒病, 如有猝倒及时隔离. 预防蚂蚁蟋蟀地老虎等害虫. 育苗期 搭建遮阴棚遮阴, 咖啡喜阴不可在太阳下直晒. 将20公分左右的咖啡幼苗移植到装有营养土的营养袋. 适度浇水, 保持土壤抓起来可成团, 搓, 可散开. 移植幼苗成活后, 30天左右可少量施水肥. 咖啡盆栽管理 咖啡习性: 咖啡喜阴怕晒, 耐热怕冷, 怕旱怕涝, 喜肥怕贫瘠. 咖啡苗移盆时尽量不要弄散原培养土, 所换花盆盆地加碎石子提高沥水性. 土表见干即可浇水, 如出现短暂脱水叶片会蔫掉浇水后6小时即可回转. 施肥: 咖啡施肥每个月一次调水浇灌, 最好使用专用肥. 用量少效果好, 没有也可用普通氮磷钾肥代替效果可能稍差. 施肥量专用肥一年苗不超过20粒每次[调水浇]. 三年苗不超过80粒每次[调水浇]. 施肥后一个星期不可出现脱水现象. 防虫: 咖啡主要有蚜虫, 钻心虫, 蚧壳虫, 毛毛虫. 使用石灰水刷咖啡主干可有效防止. 如出现害虫用吡虫啉喷雾可有效杀死害虫. 病害: 炭疽病, 锈病. 本人也只是听说从未见过. 我地多年来从未出现过咖啡病害, 本人也无计可施. 咖啡品种分辨 铁皮卡即蓝山咖啡, 铁皮卡是阿拉比卡系列里血统最纯品质最高的品种. 树系高大枝叶稀疏形似野生, 新叶呈古铜色, 叶质轻薄柳长. 籽粒椭圆略长于其他品种, 颜色略微泛黄. 卡蒂姆(Catimor): 1959年, 葡萄牙人将巴西卡杜拉与提摩混血, 培育出抗病能力强的卡蒂姆/卡提摩, 目前是商用豆的重要品种. 波邦分黄波邦和波邦, 黄波邦果实呈黄色. 树形与卡蒂姆难于区分…卡蒂姆产量高于波邦. 唯有挂果期好分辨… 尺码对照表 上衣(女) 标准 国际 中国 胸围(cm) 腰围(cm) 肩宽(cm) 适合身高(cm) 尺码明细 XXXS 145/73A 74~76 58~60 34 147~150 XXS 150/76A 76~78 60~62 35 150~153 XS 155/80A 78~81 62~66 36 153~157 S 160/84A 82~85 67~70 38 158~162 M 165/88A 86~89 71~74 40 163~167 L 170/92A 90~93 75~79 42 168~172 XL 175/96A 94~97 80~84 44 173~177 XXL 180/100A 98~102 85~89 46 177~180 裤子(女) 标准 国际 中国 腰围(cm) 臀围(cm) 尺码明细 XXXS 23 55~57 77~80 XXS 24 57~60 80~83 XS 25 60 83 S 26 63 87 M 27 67 90 L 28 70 93 XL 29 73 97 XXL 30 77 100 XXXL 31 80 103 上衣(男) 标准 国际 中国 胸围(cm) 腰围(cm) 肩宽(cm) 适合身高(cm) 尺码明细 S 165/80A 82~85 72~75 42 163~167 M 170/84A 86~89 76~79 44 168~172 L 175/88A 90~93 80~84 46 173~177 XL 180/92A 94~97 85~88 48 178~182 XXL 185/96A 98~102 89~92 50 182~187 XXXL 190/100A 103~107 93~96 52 187~190 裤子(男) 标准 国际 中国 身高 腰围(cm) 臀围(cm) 尺码明细 XXXS 28 70 93 XXS 29 160/66A 73 97 XS 30 165/70A 77 100 S 31 170/74A 80 103 M 32 175/78A 83 107 L 33 180/82A 87 110 XL 34 185/86A 90 113 XXL 36 185/86A 93 117 XXXL 38 190/90A 97 123~127 上述腰围指实际腰围, 并不是裤子的尺码 维修 BGA推荐风枪温度: 拆卸(原厂高温锡) 424°C 植锡/焊盘清理 334°C 烙铁推荐温度: 原厂高温锡 300-350°C 其他 280-320°C 读书摘录 “I tell you I must go!” I retorted, roused to something like passion. “Do you think I can stay to become nothing to you? Do you think I am an automaton? — a machine without feelings? and can bear to have my morsel of bread snatched from my lips, and my drop of living water dashed from my cup? Do you think, because I am poor, obscure, plain, and little, I am soulless and heartless? You think wrong! — I have as much soul as you, — and full as much heart! And if God had gifted me with some beauty and much wealth, I should have made it as hard for you to leave me, as it is now for me to leave you. I am not talking to you now through the medium of custom, conventionalities, nor even of mortal flesh; — it is my spirit that addresses your spirit; just as if both had passed through the grave, and we stood at God’s feet, equal, — as we are!” — Jane Eyre “I am no bird; and no net ensuares me: I am a free human being with an independent will, which I now exert to leave you.” — Jane Eyre “在写作当中运用别人的语句并不就意味着模仿或抄袭, 写出来的东西并非毫无价值可言, 因为它至少 能够说明我已经能够灵活地驾驭这些优美的文字, 能够表达我对那些优美的、富有诗意的思想的欣赏” ⸺《儒林外史》 “但在绝大部分的明清通俗小说中, 尽管对于科举制度的不平、愤激、斥责俯首皆是, 但叙述时字里行间却仍然包含了对于科举的依赖和眷念, 这尤其体现为男主人公获得进士科名往往是小说团圆大结局结局不可或缺的元素.” ⸺《儒林外史》-导读 叶楚炎 “而与之相比, 吴敬梓对于科举社会的种种情状却有着更深的洞察力和表现力: 无论是对于科举社会中士人生存困境的呈现, 还是对于诸多弊端的反思, 以及对于儒林中人出路的探寻,《儒林外史》都远远地超过了同题材的这些作品.” ⸺《儒林外史》-导读 叶楚炎 &quot;消除胆怯为当务之急, 对此, 英国大作家汤玛士·卡莱尔曾说: “要想成为一个真正的人, 第一就要征服恐惧不安.” 为了达到征服的目的, 第一步骤就是 “行动”. 也就是说要积极向前迈进. 如此, 恐惧不安必能被消除. 勇敢采取行动向前迈进吧. 希尔多·罗斯福就是因这种积极的行动, 结果很成功地消除了恐惧不安. 他说: &quot;我经常被 ‘不安’ 所困扰, 可是我从不向他低头, 也从不担心未来的任何事, 所以, ‘不安’ 就逐渐消失了. “” ⸺《如何消除胆怯》 (ISBN7-5048-2005-9/Z·290) “如果碰到你不懂的事又不敢或不肯问, 那么你就真的注定要笨到底了. 因为怕显得笨而更笨的人是无可救药的.” ⸺《如何消除胆怯》 (ISBN7-5048-2005-9/Z·290) “我们随别人喜而喜, 随别人忧而忧. 如是说来, 你我果真成了一张扑克牌, 一张任人揉捏、任别人摆弄的扑克牌? 没有自己的主张, 没有自己的愿望, 更没有自己的自尊. 就这样一生都摆脱不了别人的支配与选择? 果真是这样吗? 不! 我们绝不是一张扑克牌! 扑克牌毕竟没有思维, 而我们, 却是一群有着高级思维能力的活生生的人啊! 我们本该拥有与扑克牌截然不同的人生! 自己的历史靠自己书写, 自己的青春靠自己去创造, 自己的世界靠自己去闯! 而不是像牌那样在冥冥中失去自我!” ⸺《如何消除胆怯》 (ISBN7-5048-2005-9/Z·290) “感到畏惧的时候, 你就去做你畏惧的事, 不久你就不用再畏惧它了. 如果你害怕某一件事, 你试着不要让自己沉溺于这事的想象中, 首要的责任是征服恐惧, 为此需要积极的、勇往直前的行动, 去攻击恐惧, 攻击的力量越大. 畏惧消失得也就越快.” ⸺《如何消除胆怯》 (ISBN7-5048-2005-9/Z·290) &quot;罪恶之源无关紧要, 人们关心的是对抗它和战胜它, 既不要乐观, 也不要悲观, 要把不懈努力使事情变得更美好作为唯一指南. &quot; ⸺ (西) 伊巴涅斯 &quot;每天务必要做一点你所不愿意做的事情. 这是一条最宝贵的准则, 它可以使你养成认真尽责而不以为善的习惯. &quot; ⸺ (美) 马克·吐温 “理想的 (绝大多数是内在的) 学习动机着重于战略和战术, 而并不那么强调立竿见影的效果, 因此, 需有极强的忍受挫折的耐力才行, 因为解决问题的方法只有在重重困难中方可产生. 因此可以判断, 程序教学的学习计划和形式把任何微不足道的思维活动都当作成功的做法, 是与创造力敌对的” ⸺《创造力》 (德) 海纳特 &quot; 许多人提到的另一问题是关于 “智力” 这个术语的实际定义和含义. 他们对于智力的解释含糊不清感到不满意. 而事实上, 尽管心理学家们使用的智力测验大多雷同, 但他们的理论解释也不尽一致. 这里有必要弄明白正在测量的是什么和如何测量它. 我想就关于由智力测验来量度的智力的本性说几句话. 在此之前, 我要说明, 根据文献知识和在此领域多年来的实际工作经验, 我所说的只是自己对此问题的看法. 对于我的观点, 其他心理学家未必会赞同, 当然它也可能是十分错误的. 不过真理或许正在我这方面. 当我们详细地分析智力测验的执行情况时, 我们发现有一个显著的特征, 它比其它因素在决定成败上更为重要, 这就是思维速度. 如果你出了大量十分简单的题目 (全是同一类型), 比如说一个字母序列 A, C, E, G? 你会发现, 很少有人会打错, 或者会发现题目太难. 然而, 某些人能在几秒钟内解答二十题或三十题, 而另一些人做这些题几乎要花几分钟. 速度上的差异在原来越难的题目中同样有所表现; 换句话说, 那些对容易题目做得快的人, 对难题也做得快; 而那些对容易题目做得慢的人, 对难题也做得慢. 我认为这种普遍存在的思维速度的不同是由造成人们智力差异的、基本的遗传因素所决定的. 然而, 思维速度又不能与智商等同, 这是因为在任何智商测量中, 各种非智力的个性因素也同样起作用. 首先我们要明白, 在典型的智商测验中速度的确是一个重要的变量. 你还可能会发现, 尽管你在规定的半小时内只能答出几道题, 但如果你愿意坚持做下去, 实际上, 每道题你都会做. 因此, 测验的时间限制是最基本的, 否则几乎每个人都会得到优异的成绩. 因此在典型的智力测验中不可能出很复杂和很难的试题. 如果注意一下 “考考智力巨人” 那部分测验题, 你将看到, 我们如果要给出时间限制的话, 则必须规定为几小时, 甚至几天, 这在管理上实际是难以执行的. 即使不限制时间, 人们也得不到满分. 这是由于某些个性因素造成的. 测验时间一长这些个性因素就会影响成绩. 即使时间短也常有影响. 在这方面试验研究确定了与此有关的两种主要个性, 它们通常被称为粗心和缺乏坚韧性. 如果你的思维速度慢, 那么, 对于某一测验, 思维速度快的人在半小时内就可答完, 而你可能要花上 20 个小时. 这样在测验时间结束之前, 你的积极性可能已经大大衰减, 因此可能放弃掉某些认为答不上来的问题. 其实, 只要能再坚持一会儿是可以答上来的. 当然, 如果缺乏坚韧性, 即使时间短也会影响成绩的. 有些人只愿意在一个题目上花费半分钟而不愿花费两分钟. 实际上, 题目的难易程度和解答它所需的时间之间似乎有一种对数关系, 这就要求思维速度相当慢的人的坚韧性比其他人强得多才行. 在日常生活及不限时间的测验中是有这种可能性的, 即可以用坚韧性来换取思维速度; 这就是所谓 “失之东隅, 收之桑榆”, 反之亦然. 即使你的思维速度快而且有坚韧性, 但你可能粗心大意, 就是说只要想出一种答案也不考虑一下它实际上是否正确就将它答上. “验错机构” 失灵, 如同思维速度慢和没有坚韧性一样都会使得分降低. 性格外向的人在这方面就更差. 他们比性格内向的人会出更多的错误. 有足够的证据证明, 有创造性的人 (他们擅长于开放题测试) 在闭式题测验中常常粗心. 这是我们重提用 “11+ 考试” 来评价某些有才智的人是否公平的另一个理由. &quot; ⸺《了解自己的智力 2》 (英) H. J. 艾森克 “心理战, 是运用心理学的原理, 通过宣传等方式从精神上瓦解敌方军民的斗志, 或消除敌方宣传所造成影响的对抗活动. 其手段包括: 宣传、威慑、谋略等. 在信息化条件下, 敌方对我实施心理战的主要目的是: ①动摇人民群众的防空信心; ② 制造人们对高科技武器的心理; ③ 扰乱人们的正常思维和行为; ④ 造成人的生理机能紊乱, 形成战争综合征.” ⸺《民防知识》 江苏省民防局&amp;江苏省教育厅 ISBN 978-7-305-11263-8 《创造力》笔记 作者: (德)海纳特, Gottfried Heinelt 译者: 陈钢林 原版出版商: Verlag Herder KG Freiburg im Breisgau 译文出版商: 工人出版社 原版版次: 1974 译文版次: 1986年2月第1版 书号: 7007·173 创造力的概念: 创造力的各式各样的定义(针对创造力的本性、“本质”): 米德 (M·Mead) 在解释创造力是强调主观创新: &quot;当一个人自己想出、做出或发明了一样新东西, 就可以说他完成了一次创造性行动. 这样看来, 一个二十世纪的儿童自己发现, 在直角三角形里, 勾、股边的平方之和等于弦边的平方, 那么他也就完成了一次跟毕达哥拉斯一样的创造性行动, 尽管这个发现的结果对于文化传统来说等于零, 因为这句话早已是几何学的组成部分了. &quot; (P16, P17) 德雷夫达尔 (J·E·Drevdahl) 着重指出 “目的性” 和 “目标明确性”, 以及在各个领域里的实现: “创造力是人产生任何一种形式的思维结果的能力, 而这些思维结果在本质上是新颖的, 是产生它们的人事先所不知的. 他有可能是想象力或者是一种不只限于概括的思想综合. 创造力本身包括根据已知信息重新组合新系统的能力. 创造的产品尽管不一定能直接利用, 也无须尽善尽美, 但是, 创造性活动必须是有目的和目标明确的, 而不是无益的、幻想般的. 可以设想它是一种艺术的、文学的或科学的形式, 或者是可以实施的技术设计或方式方法.” (P17) 申克-丹齐格 (L·Schenk-danzinger) 强调信息量和创造积极性之间的关系. 原则上来说, 创造力可以在最小信息量的前提下产生, 亦能在信息完备和充分的条件下产生. 正是在信息不够的情况下, 才产生了解决问题的战略和可能性, 这些战略和可能性都可以看作是富于想象力和富有独创性的: “分散思维过程并不是在定好的轨道中产生的, 而是依据所获得的最低限度的信息 ⸺ 因此是有创造性的.” (P17) 施拉姆尔提醒人们创造力与燥狂性精神病之间的亲缘关系: “观念敏捷性(吉尔福德)和’病态的观念奔逸’, (后者在燥狂性精神病理学`中十分典型) 这两个词的亲缘关系使人不难看出, 创造力和精神病理学领域挨得多么近.” (P19, P20) 托伦斯: “因为创造力的本质是’寻求真理’, 所以重要的是, 让一系列大学研究室去探讨寻求真理的范畴和方法. 没有这些能力, 创造性思维便缺乏深度.” 与托伦斯的看法相似的是韦特墨的观点, 他在试图阐明创造性思维时指出, 创造性思维最终关系到把握 “结构的真理”: “…(创造性)思维需要的是注意和详察结构的特性和要求; …是寻求有结构的而非零碎的真理…就人看来, 在他后面隐藏着一种要求和渴望, 即想注意事物的突出点、结构的核心与情景的根源; (想彻底地研究这件事); 想由事物模糊的和不适当的关系获得清晰的、透明的和直接的对比, 直接地从思维者的内心到达思维对象和问题的核心…这种类型的思维过程以对现实充分肯定的态度为前提.” (P20, P21) 沃尔施勒格将创造性活动提到更大范围的内在联系中去看, 并且宣称, 创造力是理智地改变社会现行规范的发动机: “创造力是揭示新的内在联系的能力, 是理智地改变现行规范的能力, 使用创造力, 可使问题在社会现实中得以普遍的解决.” (P21) 沃尔施勒格认为, 可以把 “社会创造力” 或者 “集体创造力” 看成目标. 这样一来, 立时突破了个人创造力的设计, 引人注目地提出了在有组织的集体里产生创造性活动的可能性. (P21, P22) 创造性活动的模式 (P23~P25) 把析出各种思维模式作为出发点, 给创造力下定义: ⸺ 以具备一些不同的、归属智力范畴的个性特征 (特性) 为前提 (静态模式); ⸺ 是一种在意识区和无意识区流动的创造性过程 (动态模式); ⸺ 是一个有创造力的人的表现形式和 “表达” (个人模式) 类创造力、假性创造力 (P14~P16) 类创造力 (亦被看作前创造力) 是以创造力为目标的创造力雏形, 亦称作创造力的准备阶段: 如缺乏现实性的儿童幻想、内倾型的空想和青年人的想入非非. 假性创造力是一种伪装的创造力. 如某人 “无论如何” 都要具有独到见解, 靠 “权势和权力”, 必要时在社会的压力下, “必须” 出名. 创造型教师: 倘若把创造力作为教育的目标, 那么实现的前提就是创造型教师. (P105) 幽默感与创造力: (P123) 至今仍有一些教师把取笑、挖苦和讽刺归为幽默感的表现, 这是完全错误的看法. 拿别人取乐不属于幽默感, 因为攻击、伤害或者恶语伤人都不是真正的幽默感. 同创造力一样, 强迫和命令都不能产生幽默感. 幽默感并不是每时每刻都能出现的, 而是高兴的一瞬间的果实, 是友好气氛的结晶, 是创造性自由的馈赠; 它是表露, 同时也是作用: 它能消除紧张, 解决争端, 消除不和谐因素. 毫无幽默感的人不会有创造力. 创造型集体 非创造型集体: (P99, P100) 破坏型集体多是权威或反权威教育的结果. 其集体成员多维持着彼此否定、拒绝甚至敌视的关系 情绪和情感上强烈的紧张状态以及流露出来的利己思想将正在形成的集体感扼杀于萌芽状态. 精神和力量耗尽在冲突和各种社会障碍中, 集体气氛和实际的劳动态度更无从谈起. (P99) 持批判态度的成绩型集体的特征是, 其成员的社会差距大, 批判意识强, 无论是同学还是教师都成为他们的批判对象. 他们常用 “合理的客观动机” 作为批判理由. 各种批判性的判断培养了利己主义和不承认同学的唯成绩态度. 每个学生都想方设法击败另一名学生, 因为他感到那人成为他的竞争对象. 我们的教育体系至今还在继续促发这种唯成绩集体. 因此也就有人教育学生要依赖和顺从集体的其他成员和仅有批判眼光的教师. 后进学生的动机和背景无人过问, 跟不上的则要受到严厉的批评. 由于社会关系居于次要的地位, 所以无法与他人建立伙伴式的合作关系. 这种集体根本谈不上创造性活动, 他重视的唯有在成绩单上和获得威望时表现出来的成功. 创造型集体的特征: (P100) 创造型集体以高度团结作为标志. 在这里要区分集体内的团结, 即内部团结, 和与外界的团结, 即外部团结. 外部团结是由家长、学校校长、其他教师和学校管理人员的关系决定的. 创造型集体的目标在于: (P101) ⸺ 消除破坏性的社会紧张; ⸺ 挖掘集体内在的潜力; ⸺ 培养创造型人物. 创造型集体人数限制. 有关文献把理想人数定在八至十人之间. 一般认为超过三十名学生的班级便失去了发挥集体创造力的有利先决条件. 当然, 不应把它作为绝对的标准, 已经结构化的集体人数可以多一些, 但结构差的集体人数须控制在较少的范围. (P102) 创造型学生: 大专院校的实践: 我们今天所面临的相当困难的任务, 无疑是在极端的墨守陈规和彻底的放任自流之间寻找一条中间道路, 这条道路应该是现实的和有建设性的, 换句话说: 创造力意味着从再现反应式的狭隘行为和思想中解放出来, 向灵活性、自发性和独创性的方向发展, 而不走到绝对自由的新极端上去. (P73) 《人生活动的艺术》节选 作者: 顾晓鸣 出版商: 浙江人民出版社 书号: 统一书号 7103·1339, ISBN 7-213-00091-8/G·14 版次: 1987 年 1 月第 1 版 用行动创造 “自己的故事” (P28) 在姑娘生日的早餐, 邮递员送来了一个小小的包裹, 包裹里是一条姑娘最喜欢的围巾, 款式、质地、色泽样样中她心意. 此时, 姑娘的感受难以用 “激动”、“甜蜜” 之类普通的形容词来描述, 小伙子寄来的生日礼物, 大大震动了姑娘的心… 到商店里去买一条围巾, 只需要花上几块钱, 这邮费, 也不过是几毛钱, 谁去买来寄都是这个价, 为什么在姑娘收到的时候, 却觉得贵似金, 重千钧了呢? 这是因为那小伙子创造了一个情境, 区区的围巾在这情境中升值. 升值了的围巾凝聚着旁人所看不见摸不着的 “情” 和 “意”, 成了姑娘人生中的一个纪念品, 一个记忆中永不会被遗忘的闪光点; 而这整个情境和过程, 构成了姑娘一个终身值得回味的故事 ⸺ 他俩的故事! 小伙子用自己的思维和行动写下了一个故事, 一段个人生活史中有声有色的事件… 朋友, 当你用文字在创造, 用工具在创造的时候, 有没有想到用自己那似转瞬即逝的一举一动、一言一笑来创造自己的 “故事” 呢? 我们用自己的行动创造了一个具有美好意境的故事, 它将永远被心灵的眼睛看见, 再看见…它同时成为我们今后人生的一部分, 这个永不消逝的故事把我们导向新的故事, 我的故事引起你的故事, 最后又共同创造了 “我们的” 故事. 当年老力衰, 生命将尽之时, 自己创造的无数悲壮的、动人的、滑稽的…故事会连成一片, 组成个人美好的人生史, 这是我们生命存在过的见证和痕迹, 这是我们的业绩! 还有比这更能宽慰晚年的心灵吗? 正在追求着的朋友们啊, 让我们共同创造一种情境, 创造自己的人生阶段, 用言语行动在心灵的稿子上抒写一个个隽永不朽的故事! 这, 就是我们的故事. 爱情、友谊, 还有生活中的一切活动, 都是创造故事, 抒写自己历史的好题材. 譬如说, 明天是星期天, 你怎样度过这一天? ⸺ 星期天, 这是自己人生历程中一页新的稿纸, 我能在它上面抒写一个怎样的故事, 从而使它成为与以往星期天不一般的日子载入人生的史册? 一旦我们有了这样的战略思考, 那么, 我们不是度过一个星期天, 而是在创造一个星期天! 现在让我们把目光移向整个人生: 学习、工作、研究…在这些事情中, 我们是 “被动地度过” 还是 “主动地创造”? 是追求文凭、金钱、地位之类的东西呢, 还是追求一种伟大美好的人生历程, 用自己的行动写出自己的人生故事. 故事是需要事先有个粗粗的提纲的. 开始步入人生的朋友啊, 自问自己有没有充分的思想准备, 有没有充分的知识准备, 有没有眼界和魄力. 或者象 “走自己的路” 的伟人们那样目标始终如一; 或者象在十五岁时制定了总数达一百二十七个愿望的计划, 到今天已实现了一百零六项愿望的美国人科达尔那样, 自觉地创造生活, 自觉地让生命的画布发挥其最大的价值, 在它上面绘出最宏伟美好的场景, 写下最令人们感动而又最令自己回味的故事. 这些故事, 在每个人的生命航程中, 都会掀起洁白的浪花. 撑竹篙的启示 (P77) 当船离岸的时候, 我们用竹篙轻轻地一点, 沉沉的船就被撑动了. 如果我们心急, 想一下子离岸, 因而使尽力气把竹篙抵向岸边, 船却不动. 其中的道理, 学过力学的同志都是知道的. 但是, 当我们处理生活问题的时候, 却常常忘了这一点. 有的人, 听到人家说学习外语重要, 买了词典买了书, 劲头十足, 一连几天甚至几星期日日夜夜地学, 可是一段时间过去, 感到似乎收获甚微, 从此便心灰意冷, 书积蛛网. 又过了一段时间, 心血来潮, 取出旧书, 又拚命读了一阵, 不久觉得效果不大, 又偃旗息鼓, 不再问津. 多少人如此热热冷冷, 不但花了好些时间, 而且每重复一次, 学习的信心就减退一些. 最后, 只能望 “书” 兴叹, 自以为不是学外文的料. 其实, 这些同志有决心, 舍得花时间, 只是不懂 “撑竹篙” 的道理. 学习的原理和力学的原理有点相像. 公式是: 学习的效果 = 学习的力气 × 时间长度. 可以说, 没有持之以恒的努力, 是不可能学会一门学问的. 如此说来, 是不是要花很多很多的时间去读书呢? 不. 假如你念课文, 在兴头上一连念了十遍, 以后灰心而不念了; 而另一个人, 同样念十遍, 先每天念两遍, 念了三天, 然后, 每天念一遍, 又念了四天, 你说哪一个效果好? 其实, 不只是读书, 学艺、科研, 甚至养病吃药都有这个小原理吧. 你不妨观察体会一下. 那么这里的道理在哪里呢? 原来, 我们每一项活动不但与时间的长短有关, 而且与我们心智、身体和事物发展的节律有关. 药片吃下去, 药性同体内生化反应的过程相作用, 才能影响体质, 抵御疾病; 阅读时眼睛吸收的信息, 需要有一个复杂的记忆、理解、应用的过程相匹配, 才能 “消化”; 至于种田、养猪, 还牵扯到植物和动物的生长节律. 因此, 在诸如此类的场合, 绝对的时间长度的增加, 并不一定有效地促进这些活动的进行, 有时反而成了 “拔苗助长”、“消化不良”, 或者白白做了无用功. 因此, 切合自己心理、体力, 切合所做的事情的自身规律来使用时间、分配时间, 不但能够收到良好的效果, 而且还能 “事半功倍”, 节约大量的时间. 譬如马克思读书, 就喜欢用特别的 “间隔法” 加以复习 ⸺ 他读完一本有价值的书, 就夹张纸做标记, 以后先隔几个月复读一遍, 再隔半年、一年进行浏览, 依靠这种时间安排, 他费时不多, 却牢牢地记住了这些读物内容, 不断加深着理解, 达到 “博闻强记” 的目的. 登山的启示 (P93) 你可知道? 现代登山运动员同早期登山运动员的区别在哪里? 早期的人们登山是乐在目标, 现代登山运动员所追求的则不但在于登上顶峰, 而且乐在途中 ⸺ 他们选择最难攀登的道路, 在一个个危险的关口, 体验自己生命 ⸺ 体力、意志、智力、技巧的力量. 奇妙不奇妙? 由于有了这个动机, 难得、苦的、险的竟成了登山运动员们追求的对象, 苦转化为乐, 而不难、不苦、不险反而使登山者索然无味了! 作为生活的攀登者, 当你向着一个目标挺进的时候, 不也需要现代登山者的这种精神吗? 艰难的学习条件, 不平静的生活环境等等, 正是登山途中的一道道关口. 如果你不是消极地、满腹怨言地去对待它们, 并且征服它们; 那么, 你就不但充满着自信和愉快的情绪, 而且为你潜在生命力的发挥创造了条件. 乐在途中, 不仅乐而已, 而且, 在乐的中间攀登, 会使人更容易走完艰难的路程. 好比你读一本难读的厚厚的书, 你不是让 “真难”、“看不进”、“怕看不到底” 这些消极的念头占据心灵, 而是象登山者那样迎着难点上, 那么, 每翻过一页, 每想通一段疑难的段落, 你心中就有一种胜利的喜悦 ⸺ 乐在途中, 这本书很快就会读完的! 这里所包含的道理, 牵扯到动机的方向问题. 我们做任何一件事情, 心中总会关注于两个方面: 这件事的最终目的和这件事的过程, 事实上常常是 “一心两用” 的. 因此, 做一件事的动机常常包含着两个方向 ⸺ 一是针对目标和目的地, 一是针对过程本身. 在通常的情况下, 崇高的目标、美好的前景会激发我们强烈的动机, 有时会使我们无视过程中的艰难困苦, 但是, 在一般情况下, 由于我们主要地只把动机针对于目标, 因此过程中的困难都被看成是达到目标的障碍, 不免从消极方面去看待过程. 这样就可能成为减弱动机的负因素, 针对过程的动机成为负动机. 而在现代登山运动员看来, 他们的动机明确地分为两个方向, 既关注于目的地, 又把登山过程看作锻炼和检验自己意志和体力的机会, 看成享受生命的机会. 这时, 他们的登山动机受到两方面的激励, 互相补充, 互相促进: 每克服一个险阻, 既尝到自身的快乐, 又因为离目的地进了一步, 而得到双倍的快慰. 因此, 在生活中有意识地分配自己的活动动机, 发掘活动过程中可能带来的意义和乐趣, 克服对过程中困难的消极心理. 就能乐中有乐, 苦中有乐, 处处充满快乐, 而这种心境的出现, 又成为一种良好的活动激情, 又会激起我们前进的动机. 乐在途中, 虽说途中有乐, 但最大的乐毕竟在于登上那巍峨的高峰啊! 消费和&quot;时间的消费&quot; (P116) 在古代社会, 对于一个青年来说: “消费” 究竟意味着什么呢? 当然, 你会说, “消费” 就是指 “花钱” 嘛. 然而, 在社会生活中, “消费” 却并不单单是花钱的问题. 从社会学的角度看, 还有一种与消费金钱相随的消费. 只有了解了这一点, 你才能用一种新颖的眼光去对待经济性的花钱行为, 从而能自觉地设计自己的 “最佳消费方案”. 你花掉好些钱, 百里迢迢来到一个旅游点, 可你连一分钱的土特产也没有买, 讲得更绝对一点, 连吃的东西也是自己带去的, 这时你在 “消费” 着什么呢? 或者, 你为了 “充分地消费掉” 你的收录机, 一边看书一边听录音, 甚至没日没夜地放音乐, 而这却使你心不在焉, 使别的活动效率降低. 这时, 你会明显地感到, 自己虽然充分使用着收录机, 然而却在浪费着时间! 是的, 正是时间, 这是伴随着我们消费行为的另一种 “消费品”. 有些消费行为, 本质上正是在 “消费” 着时间, 如度假、旅游、收听消遣性的流行音乐; 有些消费者是消费物品, 其实也同有没有相应的时间有关 ⸺ 买了一架没有时间去玩的乐器, 等于没有消费这个 “物品”! 反过来, 在 “时间就是金钱” 的现代社会, 不问时间消费是否适当的消费, 实际上是最不合算的消费. 你一定有过这样的体验: 花了钱同朋友或家人出去游玩, 但由于时间局促, 心中老记挂着要做的事, 结果心不在焉, 很不痛快. 为什么我们的消费行为总要同时间 “消费” 紧密相连呢? 因为从社会学来看, 人的时间 “消费” 模式是人的生活方式的指标, 是人的社会活动的表现. 而任何一种被消费的物品, 只有同如何 “消费” 自己的时间结合起来, 才能最大限度地&quot;物尽其用&quot;, 得到充分的消费. 从这个挂念出发, 我们就能体会到, 即使我们钱很少, 无法购买昂贵的消费品, 但是用它买来的一架简陋的半导体, 如果它正是自己人生活动最需要的东西, 我们从中所获得的消费享受也许比一千元价值的收录机还大! 树立消费的 “时间眼光” ⸺ 在添置一件大型消费品或进行一项消费性活动时, 问一问自己, 有没有相应的时间可供 “消费”? 只有同自己的时间分配结构最吻合的消费品, 才能充分使用, 从而使有限的金钱消费到最多的东西. 从另一方面说, 在消费品中要努力寻找那些可以 “生产” 时间的消费品, 例如洗衣机, 常用备查的工具书, 甚至早日买一辆自行车, 虽说不靠它作为上下班的交通工具, 但每天零星的买油买醋之类, 都可以借助它来 “生产” 时间, 而这些时间又可供我们 “消费” 家中其他的消费品! 从而提高自己整个的 “消费水平”! 但这还只讲了一半, 每个人可供自己消费的时间又是受什么制约的呢? 每个人的时间分配和使用方式, 与他所处于的人生周期紧密相连. 什么叫人生周期? 通俗地说: 就是我们的人生阶段 ⸺ 少年, 青年、壮年…由于人的社会角色 (工作、职务、家庭负担) 和心理都与人生周期密切相关, 因此, 可以用于 “消费” 的时间和一般消费的心理都与一定的人生阶段有关. 人生的特定阶段意味着这一时期主要从事的活动. 因为人生的需要和时间的使用情况是处于不断变动之中的, 只有最密切配合当时当地的人生活动的消费, 才是利用率最高的消费, 好比小孩买玩具, 在他智力刚萌芽时恰到好处地买给他一种智力玩具, 才能使他能玩得来, 玩得最起劲, 因此每天玩的时间也最长 ⸺ 最后完全地把玩具 “消费” 掉! 青年期人生活动的变化也很多, 只要你仔细观察一下, 就会发现, 比如上学或业余学习第一年所需要的和所能 “用得来” 的书籍或用具, 二、三年之后的效用就大不相同了. 早买还是晚买, 其消费效果是大不相同的. 再举个小例子, 有的姑娘喜欢买衣料藏起来, 这种消费看似 “节约”, 似乎衣料在家, 什么时候做都一样, 但由于它离开了当时当地的特定活动, 往往反而造成了浪费, 衣料未能及时好好地加以消费 ⸺ 自己岁数大了几岁后, 衣料的颜色也许不合适了. 什么叫合适? 不就是有符合人生特定阶段的活动和需要吗? 顺着这条思路想下去, 我们有时买了一件用具, 却 “保管” 得太好, 舍不得常常使用它, 怕弄坏了弄脏了, 结果在最需要的人生阶段, 该用而不用, 时过境迁, 反而用不着了. 这时尽管它很新, 但对自己来说, 消费价值近乎零. 讲得过头点, 买来的东西, 该用时就要尽量地用, 那怕没几年就用旧用坏了, 但由于它尽了自己的效用, 那才是充分的消费! 然而, 人并不单是为现在而活着的, 人有总体的生活目标, 因此 ⸺ 消费, 还应该按 “人生目标” 来作通盘考虑. 由于人生目标是自己全力贯注的, 会影响到自己往后的岁月, 维系着一生的幸福, 因此, 属于人生目标的活动是我们要费大半生的时间去进行的. 这样, 符合人生目标的消费品是我们最有时间或最舍得花时间去使用的东西, 显然买来后的使用率最高. 而且它们往往跨越 “人生阶段”, 成为长久甚至终身使用和爱好的东西. 譬如说, 酷爱摄影的同志, 不妨下定决心, 早一点买一架较好的照相机, 这看似把一般青年都有的消费品 “挤” 掉了, 但它的利用率最高, 并会长久地为你产生新的经济能力, 从而使你有更大的财力去消费到更多的消费品. 根据人生目标来消费, 我们就有一种战略安排, 先买什么, 后买什么, 先花钱去 “玩”, 还是先花钱去买东西, 等等, 都要有一种内在的次序和结构. 有的青年在毕业后三年中, 不考虑添置大家伙, 而以充足的财力上业余大学或进行业余研究工作, 结果三年之后, 他们学历提高, 为终身的生活目标打好了基础, 同时也由于作出了成绩而晋升了工资, 这样又为进一步消费准备了财力. 随着水平的提高和结婚问题提上议事日程, 再逐步添置大件用品…这只不过是一种例子, 每个青年可以想想自己的人生计划, 然后排一个轻重缓急. 这样该消费时, 消费得痛快, 不该消费的地方, 也不会过分犹豫不决. 可以说, 消费形式是否最佳, 效果是否最好, 主要还是看这种消费是否促进了自己的人生活动, 是不是最大限度地利用了生命的时间, 使我们有限的人生发出最大限度的光, 为 “人类的幸福和自身的完美” (马克思语) 作出了最大的贡献! 这里再提一段 “开发你家庭的空间” (P142) 的内容: 我们的家庭居住面积有限: 因为没有安排好一个可以随时阅读写作的 “角落”, 许多时间就随便放掉 ⸺ 一天疲劳之后, 我们懒得再清理出一块地方进行读书写作, 于是空间限制了家庭活动; 因为没有给孩子留出一块可以搭起房子、大桥的 “场地”, 许多很有趣的玩具常常束之高阁; 如此等等, 由于空间的筹划不够妥当和精明, 我们浪费着时间, 损失着活动的时机, 限制着生活的范围, 收缩着创新的触角! 利用信息, 防止失真与噪声 (P133) 当我们在小橱里找什么药的时候, 一个瓶子一个瓶子看过去, 拧开盖子又盖上, 要花多少时间? 当我们找笔记本时也会发生同样的情况, 一本本地翻阅. 如果每次放药, 每次新开用一本本子, 都在外面写上字, 那么, 这样可以节省好多时间. 这就是信息的功能. 我们用这样的眼光打量一下生活, 就会发现, 每天因为信息不明而浪费了好多人力物力和时间. 如家里钟不准, 造成上班迟到; 朋友的地址不好好记在笔记本上, 临到上路, 还要花好些时间询问. 买衣服买鞋或替别人买衣服, 讲不清尺码, 就容易买得不合适, 如此等等. 发生这些小事, 其实都是因为我们不重视信息在生活中的巨大作用而造成的. 不相信你去试试看, 每天对一次钟, 你的时间信息就准了, 时间观念就会强了; 地址、电话号码等必要的数据随手记在备忘本子上, 查起来就随手可得; 给容易搞混的瓶子做上标记, 不仅随手可得, 而且不易搞错. 这就能起到信息的有效作用. 还有, 如果你今天要迟回来或离家办什么事, 写一张便条给家里人, 这个信息可以省掉他们许多不必要的耽心和等待. 这里的关键是什么呢? 是在于随时把模糊的信息变成确切的信息, 但是, 同一条信息, 例如瓶子上的一个标签、留给家人的一张便条, 由于时间的间隔或过多的转手, 本来清晰的意义也有可能变得不清了. 所以, 我们不仅要利用信息, 而且要防止信息的&quot;失真&quot;. 对于发送信息的人来说, 要尽量精确, 而对接收信息的人说, 则要设法把失真的地方复原. 传播学的研究证明, 信息在传播过程中总要发生或大或小的 “失真”, 因此, 我们利用信息的人在接收到信息时, 一定要清醒地看到这一点. 在广开致富门路的今天, 各方面传来的消息很多, 有的同志一听到别人说起某某地方有什么货源, 某某行当可以发展之类, 急急去办, 结果吃了大亏. 毛病就出在其幼稚的信息观, 他们认为有了某种消息就是信息了, 不知道他所接收到的信息, 由于传播中的种种原因, 已经失真了, 其中有效信息很少, 甚至完全不真实了. 按照不可靠的信息去办事, 哪能成功呢? 因此, 当我们看到和听到某个消息时, 应立即分析 “传播者” 的情况, 分析 “传播者” 的信息和来源, 分析一下这个信息传到自己经过了几个环节 (例如, 朋友听朋友的父亲说的, 朋友的父亲又是听他的同事说的), 然后大致就会衡量出可能的失真度. 如果是重要的信息, 则等待其他渠道传过来的信息加以验证. 这些道理写出来似乎很简单, 但只要想想我们多少人上过 “小道消息” 的当, 就可以知道, 真要在最有吸引力的 “信息” 面前保持冷静的头脑, 该有一点科学眼光才行. 信息在传播过程中, 不但可能失真变音, 还可能伴随 “噪声”, 从而影响其可信度和有效度 ⸺ 正当你听着收音机, 欣赏那美妙动人的音乐的时候, 突然喇叭里发出吱吱叽叽的怪音, 你一定感到讨厌极了, 因为它无法使你欣赏优美的乐曲. 我们知道, 这就是噪声, 在信息 (乐曲) 传播的过程中, 噪声模糊了信息, 信息的利用率就降低了. 不用说, 噪声越小, 信息就清晰, 被人们利用的效果就越好. 其实, 我们交谈、写文章、作报告也都是信息传播的过程. 如果我们有信息的观念, 就会着力把多余的客套话、“话搭头”、不必要的重复减少到最低限度, 因为这些都是信息传播过程中的 “噪声”. 冗长的报告, 哪怕是要传给听众的信息很重要, 但淹没在大量的 “噪声” 中, 听众只想早点摆脱这个报告, 其中的信息听而无闻, 这样的信息传播效果是很低的. 所以, 我们要向别人表达意思的时候, 一定要再三躬身自问: “噪声” 减到最小了吗? 但是, 我们又看到, 社会生活中有时不免会有必要的 “噪声”, 例如, 为了礼貌, 在讲一番话时, 得客气几句; 对长辈或陌生人, 说话要适当拐一个弯, 等等. 确实, 这是社会生活中不同于单纯自然科学信息传播过程的地方. 不过, 尽管这些 “噪声” 有时是必要的, 但它们往往也会模糊真正的意思. 譬如说, 我们做了一件错事, 同志们为了照顾我们的面子, 在批评的实质性话中, 加了很多委婉的语句. 这时, 如果我们一不在意, 就听不出同志们的批评意思, 不能引起对问题的重视. 反过来, 如果我们有一点 “信息和噪声” 的概念, 就会自觉地在客气话的 “噪声” 中接收到十分有价值的 “信息” ⸺ 同志们批评的真正意思. 回到我们一开始举的例子, 如何用最精确、最小失真、最小噪声的信息来显示周围一切, 来与人们进行沟通, 成为现代人突出的基本能力. 你能顺着这一思路, 而举一反三吗? 《创造性与潜意识》笔记 作者: (日) 马场谦一等编著 译者: 李守田、姜在录 译本出版商: 延边教育出版社 书号: 统一书号 2092·1, ISBN 7-80509-259-1/B·1 版次: 1987 年 9 月第 1 版 特殊名词: 情结 (complex): 精神分析学用语. 指被压抑而未上升为意识的, 被强烈情绪歪曲的观念群和记忆群. (P47) 如奥狄普斯情结 (Oedlipuscomplex), 奥狄普斯是希腊神话中的底比斯王子, 曾解过金字塔前斯芬克斯的迷. 后来误杀父亲并娶母亲为妻, 发觉后自刺双目, 流浪而死. 泛指男孩对父亲不怀好意而亲近作为异性的母亲这种潜意识的情结. (P56) 异化: 心理学用语. 使差异显著的两个对象相接近, 以求差异更加突出. (P89) 净化 (katharsis): 精神分析学用语. 把被压抑而停留在潜意识状态的情结导出, 究明其原因并使症状消失的治疗技术. (P89) 虐待淫乱症 (sadism)、受虐待淫乱症 (massochlsm): 给异性以痛苦来满足性欲的异常性欲和接受异性给予的肉体或精神上的痛苦来得到满足的异常性欲. (P53) 口唇期: 根据精神分析学理论划分的性本能发展阶段之一, 人的性本能的第一个阶段 (出生后一年左右), 认为这个时期人的性快感的中心部位在口唇. (P112) 肛门期: 根据精神分析学理论划分的性本能发展阶段之一, 是处在口唇期之后的第二阶段 (约一至三、四岁), 是靠刺激肛门性感带有感觉性快感的时期. (P53) 里比多 (libido): 精神分析学上指从潜意识的深层发出的欲求. (P90) 相貌性体验: 自我与周围世界未分化的一种体验. (P18) 超我 (superego): 弗洛伊德的用语. 由罪恶感、良心的责备表示的处罚性机能 (潜意识的良心) 和用确定理想、价值观, 来维护自己, 褒奖自己的自我理想构成. (P9) 亚尼莫斯象 (animus): 在女性中被压抑而具有潜在的男性特征. (P6) 亚尼玛象 (anima): 在男性中被压抑而具有潜在的女性特征. (P5) 反动: 指潜意识中的强烈愿望, 在行动上却表现为相反的倾向的现象, 如对性的强烈关心, 在行动上表现为对性的藐视等现象. 判断中止 (epokhe): 在古代哲学中指中止判断. 摘录: 精神病和创造性::精神医学与文化价值::精神病 (津本一郎): 病迹学取得作为一门学问的资格, 的确经历了一段长期艰难的历史行程. 创造者个人的人格价值, 理所当然地是从那个社会的文化价值的本身打下的基础. 社会的文化价值与创造这个价值的创造者个人的人格价值, 有着密不可分的关系. “两者的关系并不是两种类别的不同价值, 而是对同一价值从两个侧面进行解释这样一种关系”. 这样, 作为人格倾向的关于创造性的本质的学问, 就是从把实现文化价值看成个性的发现的角度, 遵照这个个性所属的文化价值的规范, 来全面描述一个人的人格倾向, 即个人的经验的事实. 这里所说的创造性, 就是根据文化科学的方法论规定的价值的肯定性概念. 但是, 精神病与创造性完全不同, 它是从另一个角度出发来研究对象的. 从广义上讲, 精神病有心因性精神病、外因性精神病和内因性精神病的区别. 其中心因性精神病一般被认为是特异性质的, 因此, 在我们的讨论中暂把后两种当作精神病来研究. 同精神病打交道的精神医学, 乃是一般医学中的一个特殊部门. 一般医学是把各个异质的个体看做反复多次的、独立的媒体, 从中发现统一这些个体的一般规律的科学, 即发现疾病的学问. 因而它理所当然地属于自然科学范畴. 所以一般医学上的疾病, 本来就是非个性的, 没有普遍价值的概念. 精神医学是一般医学的一个特殊部门, 属于自然科学. 它的方法论也是把各个异质的个体, 看作能够反复多次的同质的对象, 从中发现这些个体的一般规律. 精神病也和其他一般医学的疾病一样, 本来是非个性的、没有普遍价值的概念. 不过, 一个麻烦的问题是, 一般医学上疾病的概念并不完全适用于精神病. 矛盾律 就是说, 谁都可以看得出某个人精神有异常表现, 但是, 如果不能确认其相应的身体变化, 便不能立即断定是一种疾病. 因为单凭精神变化, 确认作为一般性的疾病是非常困难的. 遇到这种情况, 就需以各个时代文化的、精神科学的特殊领域的价值规范为基准, 来确定是不是疾病; 而且要以有没有对社会的非协调性和文化的劣等性为判定的依据. 因此, 某个人格的同一个精神病理学变化, 在某一个社会可能被看作精神病; 某一个被认为是疾病, 而另一个不是. 诸如此类的情况有很多. 正因为如此, 不管人们意识到还是没有意识到, 现在我们这个社会的精神医学的疾病观, 确实是在生物学上的劣等者就是文化上的劣等者这样一个价值观的基础上形成的. 我认为这样说并不过分. 既然如此, 如果遵循现在的精神医学的理念, 对精神病与创造性的内在联系进行探讨, 无论我们付出多大的精力, 我们所能得出的只能是文化价值的创造者是没有资格创造价值的, 从而否定价值的存在这样一个似是而非的结论. 病迹学的历史, 事实上就是为回避在其中内在的价值肯定性和否定性的自相矛盾而奋斗的历史. 精神病和创造性::精神医学与文化价值::新的视野: 今天, 几乎所有精神医学家都否认精神上患病这件事本身就等于创造文化价值这样一个观点. 实际上, 他们很早就放弃了病迹学本来的课题, 把研究的方向转移到精神病怎样使创造物的表现变形的问题上. 这是不是说精神病绝不可能创造什么东西呢? 那也不一定. 正如我们已经讨论过的, 从前古典的病迹学最大的错误在于: 它从来就未敢越出依据精神病者就是文化价值劣等的也是生物学上的劣等者这样一个基本理念形成的体系的范畴一步. 作为病迹学研究对象的精神病者, 尽管在生物学上处于劣等状态, 但是这种人终究非成为文化价值上的优等者不可. 现在对我们来讲, 有必要放弃把精神病理学的现象只看成变态这一偏见, 而要把这些现象看成人的自然的精神现象, 即要采取某种现象学上的判断中止态度. 要放弃向来的精神医学的理念, 同时确立其本身包含客观上合理的价值的精神病理念, 从而早日从矛盾的价值观解脱出来, 以开扩精神病理学的视野, 这就是赋予病迹学极为迫切的研究任务. 等价变换创造理论的全貌 (市川龟久弥) 开头: 等价变换理论同长期以来文学表现手法上的关于隐喻 (metaphor) 的构成技巧这一难题也有直接关系. 使晚年的歌德垂泪的一首诗: 一八三一年八月二十七日正是歌德刚写完诗剧《浮士德》, 迎接他八十二寿辰的前一天. 这一天, 他在年轻时曾经都留过的科齐尔汉的山道上驾着马车, 到了他要专程来看的那幢房子. 他不等陪同前来的人的搀扶, 自己就爬上了楼梯, 急忙走向窗边, 聚精会神地看着一个墙角. 那里居然有用铅笔写下来的他仍然记得的那一首诗. 他认出了写那一首诗的日期 ⸺ 一七六〇年九月十七日, 和自己年轻时的署名. 这是一首题为《游人的夜晚之歌》的八行诗. 然而, 如今的歌德重读自己这首诗时, 再也不能抑制盈眶的泪水. 据传. 当时他把视线调转到附近的森林, 手里拿着手帕, 沉默不语. “群峰, 已有睡意. 树梢上, 微风一丝不起. 静悄悄, 林中鸟儿不啼. 等一会儿, 你也该休息.” 这个插曲的出处虽然不很清楚, 但以上所引却是原同志社大学校长住谷悦治的小册子介绍的要点. 根据他的解释, 此时此刻的歌德可能正处于一种即将来临的 “不在乎自己死亡的心境”. 以 “等一会儿, 你也该休息” 为结语的这一首诗, 是如何包含了容忍他自己的心理过程这一点, 还是要进一步讨论的. 简单地看《旅人的夜晚之歌》, 只不过是一个年轻的文学青年, 在一个夏天夜里的山上, 以随笔的形式轻松挥笔写下来的自然景物. 但是从另一个角度看, 这一首诗仿佛表现了这样的情景: 在阳光灿烂的仲夏, 林中鸟儿叽叽喳喳, 远处雷电闪现的充满着生气的一天已经过去, 寂静的夜晚已经来临, 而在暗淡的灯光下只有他一个人独自徘徊. 这一首诗如实地表现了是该入睡了这样一个旅人的心境. 回首过去, 从几十岁开始进入创作活动以来, 历经炽热的恋爱, 无数的慕名者和不断应付杂事的歌德, 写完《浮士德》以后, 忽然醒悟自己作为人间的游人. 在这个尘世间已经度过了八十二个春秋. 结束了仲夏充满喧嚣和生气的一天, 游人自然想在山上的住处安静地进入梦乡, 游人的这种心情与上面说的歌德的心境之间, 当然没有事先的沟通, 但却存在着本质上的同一性, 也就是下边还要讨论的等价性. 这是完全可以用 “终末观” 一词来概括的一种现象: 虽然人类处在不断流动的历史长河之中, 担任何人都不能逃避对普遍原理的再确认. 正是在这个普遍原理里面隐藏着以接受信息的人的心理的、生活的条件, 从而在意义信息世界里再发现与之对应的世界. 这就是下面所说的隐喻的基本原理. 《方丈记》和《徒然草》里的隐喻 在日本中世纪的文学史上有两位伟大的散文家, 他们是写《方丈记》的鸭长明和写《徒然草》的卜部兼好. 由于作者本人出身属于上层社会, 这些作品的内容都是以作者很高的文化教养作为基础的, 再由于作者本人都是站在出家的和尚和遁世文人的立场, 能把本身的利害得失置之度外, 因而他们心底透明, 思想敏锐, 见识高超, 终于写出了这样不朽的作品. 他们不愧是中世纪的伟大思想家. 然而, 在文学表现的世界里, 作者的某一种见地并不等于是作品的深度. 如果卓越的见地不同适当的题材相结合, 不与传递意义信息的技巧世界恰当地再构成 (表现), 也就不会有什么深刻意义. 正因为如此, 在这个富有意义信息的世界里, 作家负有用隐喻作为表达技巧的使命. 以下根据笔者一九七九年在福井大学召开的日本英文学总会上所作的 “特别讲演” 所提出的论点进行研究. “河水长流不息, 流水不再返回. 漩涡里的泡沫边结聚边消失, 无法留住. 人生世上亦如此.” 人们都会明白, 这是《方丈记》的一节. 虽然只是这么几句话, 如果仔细一想就会明白, 这个概括了中世纪日本社会哲人的人生观, 即带有冷酷意味的 “万物流转” 思想, 毫无疑问对任何一个人都会留下深刻印象. 河水确实是在那里, 可是在那流着的水, 一刻也不再停在同一个地方; 在漩涡上漂浮着的泡沫, 也不会长久留在原处.《方丈记》的作者就是这样断言的. 根据笔者给予定义的等价变换理论, 这是相当于意义信息传达过程的第一阶段中单纯明确的 “思维模型” 的提出一环.《方丈记》的作者, 从这个人人皆知的思维模型里抽出必要而又充分的本质, 提出这个本质与贯串于人生的那个道理是完全同一的 (等价的) 这一新的命题. 从信息接受者的角度看, 这个事实确实要使人从内心涌现出 “蛮有理呀” 这样一种共鸣感. “镜子没有颜色, 也没有影子, 但它可以映出世间万物. 如果它有颜色和影子, 就定然不会映出任何一种东西” 这是《徒然草》第二百三十五段中的一节. 按照前一个例子的方法进行分析, 这一段所涉及的单纯明确的思维模型是不言自明的, 因为它是映照人们脸面的常见的用品之一. 作者先对镜子的功能做了简短说明, 然后告诉人们这样一个道理: 如果一个人有一定的框框、私欲和偏见就不会对人生的意义有深刻的理解和认识. 特别是这段文章最后的结论完全是依靠对对方的主观判断. 这是一个在传达意义的技巧上很好地达到了等价变换理论所说的 “再发现性对应的模型” 的典型例子, 它可以使读者引起强烈感受, 达到较高的认识水准. 以上意义上的等价变换理论的展开, 当然是以弗洛伊德和荣格式的深层心理的世界为出发点的, 是使人预感也可能有深层心理世界的促动因素浮在意识的世界而才生产出作品这样一种情况. 汤川秀树在与笔者合著的《天才的世界》一书里引用过石田六郎的文章, 其中指出的石田对石川琢木的 “在东海小岛的白沙滩上, 我悲叹与螃蟹为伍” 一句的分析, 可以说是一个有代表性的例子. 可以肯定的说, 思维模型的提示, 不管是否在显在意识的世界, 而对对方来讲, 非要具有单纯明确的内容和相当熟悉的对象不可. 我们在前面提到过《游人的夜晚之歌》这一插曲, 其中思维模式就是歌德年轻时自作的那一首诗. 歌德以蕴含在那首八行诗里的等价性为线索, 成功地再发现如同自己过去一夜之眠那样, 轻松地迎接今天到来的人生的终了的心境. 悟到这一点之后, 老歌德绝望的轻松感, 恐怕就要表现在用眼泪把洁白的手帕沾湿这一细微的动作上. 我们这样讲并不算过分. 作为创造理论的等价变换理论: 在本章开头我们已经提到, 笔者在过去四十年来一直在寻找创造理论体系化的途径, 结果感觉到, 从较低的发展阶段再向下一个发展阶段完成次元交换, 就是创造性逻辑的根基. 用一句话概括: 历史发展的逻辑不外乎是等价变换再构成的理论. 再具体一点说, 就是 “以特定的事物和现象为前提, 从中抽出对下一个发展阶段可以成为遗产的东西 (本质), 再在此基础上导入成为新的发展阶段的要素的东西, 并为使两者具有整体性构造而进行再构成作业”. 黑格尔哲学定义中的扬弃这一概念, 也许可以说是摸索到这样一点轮廓的一个概念. 无论如何, 在上述 “抽出作业” 中, 应该成为遗产的本质要素的当然是前后发展阶段都共同具有的有存在价值的东西. 换句话说, 以一定的观点规定的同一性作为思维媒介的等价变换理论, 可以把它用 “等价次元” 一词来概括. 把从不同的对象中寻找这个等价次元的作业, 称之为 “发现等价关系”, 而把使这个作业可能成功的前提条件, 叫做 “等价性” 的存在. 这不仅仅是意义信息的创造性传达作业, 而且是发明、发现等创造性活动的核心部分. 如果以上述的等价性和等价次元的抽出为线索, 把现阶段的事物向下一阶段变换再构成, 那么一定就会出现良好的结果. 概括以上所叙述的历史发展的基本逻辑, 并以符号来概括表现出的, 就是图 1 所列的等价方程式的实质. \\[ \\textbf{\\small 图 1. 等价方程式} \\\\ \\boxed{ \\begin{array}{c} \\begin{array}{ccc} \\underset{\\bm{\\uparrow}}{\\varSigma S_{ca-i}} & & \\\\ A\\omicron & \\stackrel{c\\varepsilon}{=} & B\\tau \\\\ vi\\bm{\\rarr} & & \\stackrel{\\bm{\\uparrow}}{\\varSigma S_{cb-i}} \\end{array} \\\\ \\footnotesize \\begin{array}{l} \\text{$o$: 占 $A$ 事实、现象的座的系 (原系或出发点) \\char\"2E3A $o$ 系} \\\\ \\text{$\\tau$: 占 $B$ 事实、现象的座的系 (变换系或到达系) \\char\"2E3A $\\tau$ 系} \\\\ \\text{$A$: 在原系 $o$ 上出现的事实、现象} \\\\ \\text{$B$: 在变换系 $\\tau$ 上出现的事实、现象或靠 $c\\varepsilon$ 的媒介在 $\\tau$ 系上再构成的事实、现象} \\\\ \\text{$\\varepsilon$: 使方程式的两边可能用等号结合的等价次元} \\\\ \\text{$c$: 具体地定义上述等价次元的限定条件 (但原则上是复数 ($\\varSigma\\leqslant i$))} \\\\ \\text{$\\varSigma S_{ca-i}$: $o$ 系的特殊化了的条件群, 简略写 $\\varSigma a$} \\\\ \\text{$\\varSigma S_{cb-i}$: $\\tau$ 系的特殊化了的条件群, 简略写 $\\varSigma b$} \\\\ \\text{$vi$: 任意观点之一} \\\\ \\text{$\\bm{\\rarr}$: 指示展开方向} \\end{array} \\end{array}} \\] 对于研究人文系统学科的诸位来讲, 这个方程式也许是一个令人看不惯的异次元世界的闯入物. 然而把以上分析的创造理论的核心部分, 最大限度地加以压缩而成为 “逻辑公式” 的就是这个方程式. 方程式左边的符号, 就隐喻的情况而言, 相当于单纯明确的思维模型 (以 \\(Ao\\) 表示). 当然, 这是靠作者的深思熟虑选定的, 是表现意义的核心部分, 在前面引用的《方丈记》里的 “河水长流不息” 和《徒然草》第二百三十五段所讲的 “镜子” 都相当于这一点. 这两部书中写的 “流水不再返回”, “如果它有颜色和影子” 等有关人生的变迁的内容, 是相当于去掉各种夹杂物, 巧妙地抽出与表现目的相一致的事物的本质 (再方程式中 \\(c\\varepsilon\\)) 的思维过程. 然后拿出表现得最终目的, 也就是把作者想主张的关于人生问题的个别信息 (在方程式中 \\(\\varSigma b\\)), 同前者相结合即可 (在方程式中, 再构成 \\(B\\tau\\)) 那么, 这个作业第一阶段的 “思维模型” 是怎样找到的呢? 这与向接收信息的对方传达什么样的意义信息有关, 也就是与作品的内容有关. 假如表现的最终目的如象上面《方丈记》引文那样, 是 “万物流转的厌世主义”, 那么只要找出含有与这个本质等价的内容 (有等价性的)的、单纯明确的人生中的实际事情即可. 这就是使作者采用 “河水长流” 这个题材的原因. 上面提到的日本中世纪文学史中的两个人, 绝不是在贫困潦倒的生活中随心所欲地拾起河流或镜子当作作品的题材的, 相反, 他们有强烈的表达愿望, 而且根据这个愿望从身边的一般生活题材中, 发现并洞察了与作品主题的本质等价的东西. 如果不理解这个原理, 那么, 从内容上来区别单纯记述身边风物的杂文或是真正的随笔文学, 是根本不可能的. 根据以上议论, 可见隐喻的世界的创造性活动的本质就是: (1) 按照表现目的, 发现对社会有价值的主题; (2) 选择含有与这个主题内容相符合的等价性的单纯明确的思维模型 (题材); (3) 以这个思维模型为出发点, 根据表现目的, 再以文字形式进行等价变换再构成. 在以上的分析当中, 为了说明的方便起见, 我举出了谁都可以理解的象征诗体思维模型的实例, 其实写实诗体的表现方法跟它也没有什么不同. 在前一种情况下, 可以从作品的主题所统摄的材料的外部寻找含有等价性的模型; 而在后一种情况下, 就要从主题所统摄的材料的内部寻找含有等价性的模型. 在隐喻和等价变换理论方面, 和笔者持有同样观点的有福井大学文学院芝原宏治. 这可参看他的《修辞学》一书. 等价变换理论概观 等价变换理论作为历史发展的逻辑, 既然具有它的理论体系, 当然也适用于其他一切创造性活动的领域. 同样的创造性活动的原则, 也应当适用于科学上的发明与发现. 例如一九四八年肖克利 (W·Shockley) 等人的晶体管的发明和一九〇五年爱因斯坦特殊相对论的发现. 如果让笔者简单给以说明, 那么, 前一个发明的思维模型是矿石检波器的作用, 而后一个发现的思维模型则是马克斯韦尔电磁力学的整体像. 它们的变换再构成, 在前者的情况下是达成不必放出热电子的、新的电增幅素子; 而在后者的情况下, 是达成不需要作为光的弹性媒体的以太 (ether) 假说的统一的电磁力学. 与生物学上的进化有关的创造性课题, 从等价变换理论的观点看, 也具有绝不比上述例证逊色的戏剧性内容. 关于这一点, 可以用达尔文学派的形态学家赫克尔 (E·H·H·aeckl) 提出的那个著名的 “反复论” 为前提予以概括说明, 这样就更便于理解. 赫克尔认为 “生物个体在一代生长过程中的形态变迁史, 总是极大地反复着伴随该物种进化过程的形态变迁史”. 例如完全变态的昆虫的形态 (即幼虫 \\(\\rarr\\) 蛹 \\(\\rarr\\) 成虫), 大体上反映了该昆虫在进化历程上的形态变迁史. 如图2(a)表示, 发育至终点的成虫, 作为幼虫体的等价变换再构成, 是创造性地出现的东西. 它是经过调节荷尔蒙的过程而实现的, 其大体经过, 看图2(b)就会更加明白. 以上举出的是完全变态这一特殊的个体发展的例子, 如果把上述的逻辑再加细分, 那么对于那些不完全变态的生物的个体的发展 (其中包括着哺乳类), 上述原则也基本上是适用的. 如果进一步把以上原则的适用范围加以扩大, 那么, 在前面提过的社会体系史自不必说, 连我们人的人格形成史即教育的本质论和方法论问题也都可以提到眼前来. 这个领域当然与直观的逻辑构造等也有联系. 我们还是把讨论集中到精神疗法的领域. 自弗洛伊德以来的所谓深层心理方法, 一般来说就是使过去没有自觉到的心理因素在显在意识的世界得到呈现, 并在此基础上重新形成患者的人格. 这个方法论是值得重视的. 这个方法从等价变换理论的角度看, 是相当于把属于一个人格的精神史的统一构造追溯到某一个历史阶段, 并把它加以分解, 再把这个精神史引向将来进行变换再构成的作业. 只少可以讲, 这是靠溶解自闭的、假性的 “蛹期状况”, 实行人格蜕变的作业的过程. 一九四二年罗杰斯 (C·R·Rogers) 采用过所谓 “非直接法” (non-directism), 它的基本内容是 “人格的形成过程本身就是治疗”. 很明显, 这一想法与等价变换创造理论的想法有很多一致之处. 这种治疗活动的实质, 就是要帮助患者提高人的自我洞察能力和感受能力, 而这种方法论的根据, 当然是要追溯到患者前一阶段心理上的某一点, 从中找出可继承的东西. 这正是等价变换创造理论所说的, 创造性地继承一个人物人格中的等价性. 《人体生物钟自测》摘录 什么是人体生物钟? 大量的研究调查发现, 人的情绪、智力、体力都各自存在一种周期性的变化, 并有一定的规律可循. 后来有人把这三种节律组合成体力 ⸺ 情绪 ⸺ 智力三节律, 用正弦波绘出了它们的图像. 人们把这三种节律简称为人体生物钟. 生物钟的种类: 恒生物钟与似稳生物钟 恒生物钟是指节律周期恒定不变的生物钟. 例如, 我国东海滩, 有一种小蟹, 雄的有一只大螯的出现, 意味着要涨潮, 渔民叫它们 “招潮”. 在不同的时间里, 招潮蟹身体颜色亮暗的程度不同, 正好与潮落潮涨相反. 它的体色最暗的时间也是每天后移 50 分钟. 因此, 人们把与潮汐相应的生物钟, 叫做 “潮汐钟”. 它的周期是 24 小时又 50 分钟. 而似稳生物钟则是指周期围绕某时间值变化的生物钟. 如人的情绪为 28 天, 智力为 33 天, 体力为 23 天. 这种生物钟节律, 最明显的要算妇女的月经周期了. 多数妇女的月经周期是 28 天, 但有些妇女则可能为 28 天左右, 总围绕着 28 天这一时间值. 跟自然变化相关的生物钟 本书所说的自然变化, 指地球的自转、月亮的望朔, 地球绕太阳的公转而出现的昼夜、月和年的周期变化. (1) 超日钟 它是指节律比昼夜短的生物钟. 如人的心跳周期、呼吸周期等, 可用分或秒做描述单位. (2) 太阳日钟 指跟地球自转周期相等的生物钟, 它的周期是 24 小时. 国外科学家曾把人体 24 小时里的各种变化做过分析: 凌晨 1 时, 大多数人已睡了三小时, 进入易醒的浅睡阶段, 对疼痛特别敏感. 2 时, 除肝外, 体内的大部分器官工作节律极慢. 3 时, 全身各部分几乎都在休息, 肌肉完全放松. 此时, 血压较低, 脉搏次数相当少. 4 时, 血压最低, 脑部供血量最少. 不少心血管病人在这个钟点死亡, 全身器官工作节律极慢, 但听觉却很灵, 稍有响动就会醒. 5 时, 肾不分泌. 6 时, 血压回升, 心跳加快. 7 时, 人体的免疫功能特别强. 8 时, 肝内的有害物质全部排尽, 对酒精的敏感性特别高. 9 时, 精神活性提高, 痛感降低, 心脏开足马力工作. 10 时, 精力充沛, 处于最佳工作状态. 11 时, 心脏的工作仍在高潮期, 其他各种器官也处于高潮期, 人体不易感觉疲劳. 12 时, 全身各器官仍处在较好的工作状态. 13 时, 肝脏休息, 部分糖分进入血液, 身体各器官的工作能力渐趋疲倦, 需要休息. 14 时, 身体各器官功能达到低潮, 大脑迟钝, 反应很慢. 15 时, 人体各种器官功能好转, 尤以嗅觉和味觉最是灵敏. 16 时, 人血液中的糖分增加. 17 时, 大脑灵活, 机体灵敏. 18 时, 痛感下降, 机体 “希望” 增加活动量. 神经活动降低. 19 时, 血压增至一天中的最高值, 精神最不稳定. 20 时, 集体反应异常迅速, 体重最大. 21 时, 神经活动正常, 大脑记忆细胞最兴奋. 22 时, 血液中白细胞达一日中的密度最大值, 每立方厘米由 5000 到 8000 增加到 12000. 体温下降. 23 时, 人体准备休息, 继续做恢复细胞工作. 24 时, 机体达昼夜中的低潮期. 从以上的分析可以得知, 人在一天时间里的生理机能的变化: 7 时到 10 时机能上升, 达一天中第一个峰值后缓慢下降, 16 时左右较平坦, 但是白天里最低的, 17 时后机能再度上升, 23 时后又急剧下降, 凌晨 3、4 时人体机能达到一昼夜中的最低潮. (3) 自激钟与近昼夜钟 科学家们在研究生物节律中发现: 如果把许多种动物从正常的昼夜环境中放到相同的温度和连续光照下生活几周, 它们的睡眠时间和活动时间仍然同实验外的正常昼夜变化的节律几乎完全一样, 动物在实验室内的连续光照和恒温条件下所保持的节律, 称之为 “自激” 节律, 他们体内的这种钟叫 “自激钟”. 而近昼夜节律则是会随条件的变化使间隔逐渐缩短, 最短只有 18 小时, 最长可达 28 小时. 通过实验证明, 人体也同样存在近昼夜节律. (4) 朔望月节律 它是指周期等于一个朔望月 (29.5 天) 的生物钟. 许多生物都按照此节律活动. 例如, 下弦月时鳗鱼在挪威北海大量出现; 夏季月圆时, 西洋萤火虫大量聚集在百慕大群岛附近. 对人来说, 人的眼睛在朔日对红光和橙光最敏感. (5) 近月钟 它是指周期接近一个朔望月的生物钟. 这种生物钟对人类的行为影响较大. 由于恒星月周期是 27.33 天, 朔望月周期是 29.5 天, 太阳黑子的周期是 27 天, 宇宙电磁对地球的作用也是 27 天. 这些引力和电磁力对人类长期的作用, 人体内各种因子的与之协同, 加上人类独有的高度智能和丰富的情感, 形成了人体的有智力、情绪、体力的近月周期变化. 人的近月生物性, 包括体力钟、情绪钟和智力钟, 组合在一起叫 &quot;人体三节律. 人体三节律还具有这样的特点: 人类独有, 出生起算, 用途很广. 生物钟给人们带来什么 处于高潮期的生理效应 当一个人的体力处于高潮期时, 其体力充沛、朝气十足, 且意志坚强并富于耐力. 当人的情绪处于高潮期时, 感情丰富、精神愉快, 心情舒畅, 觉得诸事如意, 有丰富的创造力和很强的艺术感染力. 当智力处于高潮期时, 人的头脑思维敏捷、记忆力强、信息传递快, 有较好的思维推理和逻辑判断能力. 处于低潮期的生理效应 当体力处于低潮期时, 体乏力虚、身体怠动. 当情绪处于低潮期时, 会感到烦躁或烦闷, 精神恍惚. 当智力处于低潮期时, 会感到反应迟钝, 记忆力差, 没有灵感. 处于临界期的生理效应 在临界期内, 人体细胞的各种机能变化较复杂, 起伏也较大. 当体力处于临界期时, 体内的抵抗力不佳, 容易患病. 当情绪处于临界期时, 精神不易集中, 易出差错. 当智力处于临界期是, 人的判断力差. 对人来说, 最不安全的时刻是临界日和低谷日. 怎样计算人体三节律 求出生日至计算日的总天数 周年天数的计算 例如, 求某人 1970 年 5 月 25 日 (出生日) 至 1971 年 5 月 25 日 (计算日) 的天数. \\(\\begin{aligned} \\text{\\footnotesize 计算的天数} &amp; =(\\text{\\footnotesize 计算年号$-$出生年月})\\times\\text{\\footnotesize 平年天数} \\\\ &amp; =(1971-1970)\\times 365=365 \\text{\\footnotesize(天)}\\end{aligned}\\) 超出周年天数的计算 例如: 求某人 1970 年 5 月 25 日 (出生日) 至 1971 年 7 月 25 日 (计算日) 的天数. 周年部分同上. \\(\\begin{aligned} \\text{\\footnotesize 超出周年的天数} &amp; =\\text{\\footnotesize 计算月、日$-$出生月、日} \\\\ &amp; = \\text{\\footnotesize 7 月 25 日$-$5 月 25 日$=61$ (天)}\\end{aligned} \\\\ \\text{\\footnotesize 实际计算日的天数$=365+61=426$ (天)}\\) 不足周年天数的计算 例如: 求某人 1970 年 5 月 25 日 (出生日) 至 1971 年 5 月 20 日 (计算日) 的天数. \\(\\begin{aligned} \\text{\\footnotesize 不足的天数} &amp;=\\text{\\footnotesize 出生月、日$-$计算月、日} \\\\ &amp;= \\text{\\footnotesize 5 月 25 日$-$5 月 20 日$=5$ (天)}\\end{aligned} \\\\ \\text{\\footnotesize 实际计算日的天数$=365-5=360$ (天)}\\) 闰年有效天数的计算 为了求闰年有效天数, 可分三步: 第一, 先粗略判断闰年年号; 第二, 核实; 第三, 查找对比计算对象是否渡过. 另外也可通过查表 (见表 5) 的方法来确认. 如计算者已渡过此日, 可在计算的天数上增加所跨过的闰年的天数. 例如: 求某人 1970 年 5 月 25 日 (出生日) 至 1990 年 5 月 25 日中所经过的闰年天数. 通过查表得此天经过的闰年天数 5 天. ※: 当年号的十位数及个位数均为零时, 该年是否为闰年, 凡年号能被 400 整除时为闰年, 不能被 400 整除则不是闰年. 由于人从出生起他的生命节律就开始运行, 体力钟以 23 天 为一个周期, 中间为临界, 横轴以上为高潮, 以下为低潮期. 同理, 情绪为 28 天, 智力钟为 33 天. 由于三节律的运行轨迹也不同. 人们为了了解所需日子的三节律情况, 可以通过各种计算方法获取. 这里给出三个节律的简单函数 (可以用 GeoGebra 查看): 体力: \\(f(x)=3\\sin(\\frac{2\\pi}{23}x)\\) 情绪: \\(g(x)=2\\sin(\\frac{2\\pi}{28}x)\\) 智力: \\(h(x)=\\sin(\\frac{2\\pi}{33}x)\\) 这里放一张本人第 8155 天 (22 岁 119 天) 时的三节律情况: The World of English 我所知道的康桥 徐志摩 康桥的灵性全在一条河上; 康河, 我敢说, 是全世界最秀丽的一条水. 河的名字是葛兰大 (Granta), 也有叫康河 (River Cam) 的, 许有上下流的区别, 我不甚清楚. 河身多的是曲折, 上游是有名的拜伦谭 (“Byron’s pool”), 当年拜伦常在那里玩的; 有一个老村子叫格兰骞斯德, 有一个果园, 你可以躺在累累的桃李树荫下吃茶, 花果会掉入你的茶杯, 小雀子会到你桌上来啄食, 那真是别有一番天地. 这是上游; 下游是从骞斯德顿下去, 河面展开, 那是春夏间竟舟的场所. 上下河分界处有一个坝筑, 水流急的很, 在星光下听水声, 听近村晚钟声, 听河畔倦牛刍草声, 是我康桥经验中最神秘的一种: 大自然的优美, 宁静, 调谐在这星光与波光的默契中不期然的淹入了你的性灵. 但康河的精华是在它的中杈著名的 “Backs”, 这两岸是几个最蜚声的学院的建筑. 从上面下来是 Pembroke, St. Katherine’s, King’s, Clare, Trinity, St. John’s, 最令人留连的一节是克莱亚与王家学院的毗连处, 克莱亚的秀丽紧邻着王家教堂 (King’s Chapel) 的闳伟. 别的地方尽有更美更庄严的建筑, 例如巴黎赛因河的罗浮宫一带, 威尼斯的利阿尔多大桥的两岸, 翡冷翠维基鸟大桥的周遭; 但康桥的 “Backs” 自有它的特长, 这不容易用一二个状词来概括, 它那脱尽尘埃气的一种清激秀逸的意境可以说是超出了画图而化生了音乐的神味. 再没有比这一群建筑更调谐更匀称的了! 论画, 可比的许只有柯罗 (Corot) 的田野; 论音乐, 可比的许只有萧班 (Chopin) 的夜曲. 就这也不能给你依稀的印象, 它给你的美感简直是神灵性的一种. 假如你站在王家学院桥边的那颗大椈树荫下眺望, 右侧面, 隔着一大方浅草坪, 是我们的校友居 (Fellows Building), 那年代并不早, 但它的妩媚也是不可掩的, 它那苍白的石壁上春夏间满缀着艳色的蔷薇在和风中摇头. 更移左是那教堂, 森林似的尖阁不可浼的永远直指着天空; 更左是克莱亚, 阿! 那不可信的玲珑的方庭, 谁说这不是圣克莱亚 (St. Clare) 的化身, 哪一块石上不闪耀着她当年圣洁的精神? 在克莱亚后背隐约可辨的是康桥最华贵最骄纵的三清学院 (Trinity), 它那临河的图书楼上坐镇着拜伦神采惊人的雕像. 但这时你的主意早已叫克莱亚的三环洞桥魔术似的摄住. 你见过西湖白堤上的西冷断桥不是 (可怜它们早已叫代表近代丑恶精神的汽车公司给踩平了, 现在它们跟着苍凉的雷峰永远辞别了人间)? 你忘不了那桥上斑驳的苍苔, 木栅的古色, 与那桥拱下泄露的湖光与山色不是? 克莱亚并没有那样体面的衬托, 它也不比庐山栖贤寺旁的观音桥, 上瞰五老奇峰, 下临深潭与飞瀑; 它只是祛怜怜的一座三环洞的小桥,它那桥洞间也只掩映着细纹的波鳞与婆娑的树影, 它那桥上栉比的小穿阑与阑节顶上双双的白石球, 也只是春姑子头上不夸张的香草与野花一类的装饰; 但你凝神的看着, 更凝神的看着, 你再反省你的心境. 看还有一丝屑的俗念沾滞不? 只要你审美的本能不曾汨灭时, 这是你的机会实现纯粹美感的神奇! 但你还得选你赏鉴的时辰. 英国的天时与气候是走极端的. 冬天是荒谬的坏. 逢着连绵的雾盲天你一定不迟疑的甘愿进地狱本身去试试; 春天 (英国是几乎没有夏天的) 是更荒谬的可爱, 尤其是它那四五月间最渐暖最艳丽的黄昏, 那才真是寸寸黄金. 在康河边上过一个黄昏是一服灵魂的补剂. 阿! 我那时蜜甜的单独, 那时蜜甜的闲暇. 一晚又一晚的, 只见我出神似的倚在桥阑上向西天凝望: ⸺ 看一回凝静的桥影, 数一数螺细的波纹: 我倚暖了石阑的青苔, 青苔凉透了我的心坎; ⋯⋯ 还有几句更笨重的怎能仿佛那游丝似轻妙的情景: 难忘七月的黄昏, 远树凝寂, 像墨泼的山形, 衬出轻柔暝色, 密稠稠, 七分鹅黄, 三分橘绿, 那妙意只可去梦边缘捕捉; ⋯⋯ Cambridge As I Knew It1 [An Excerpt] Translated from the Chinese by Wang Jiao-sheng The very soul of Cambridge is in a river. The River Cam, I dare say, is the most beautiful stream in the world. Its name is Granta, but some call it the River Cam, maybe to indicate, I am not quite clear, the difference between the upper and lower reaches. The river meanders with many bends. The upper reach boasts the famous Byron’s Pool, where the poet used to roam for pleasure. Here lies an ancient village called Glancester, which has an orchard where you can recline sipping tea in the shade of peach and plum trees laden with fruit. You let some of the fruit drop into your cup, and little sparrows would come down to your table to peck something to eat, so that you have the sensation of being in quite another world. This is the upper reach. The lower reach runs from Chesterton down to where the river broadens to afford an ideal spot for boat-racing between spring and summer. A dam separates the two reaches at a point where the current becomes very swift. To listen under starlight to the sound of the water, the chimes of evening bells wafted from a neighbouring village, and worn-out cows grazing at the river’s edge: these are some of my most mysterious experiences at Cambridge. Here the beauty of Nature, its tranquility, its harmony, flood your soul in spite of yourself, with the starlight and the shimmering waves looking on, as it were, in acquiescence. But the essence of the River Cam is in its center, the famous Backs, where the river is lined on either bank with buildings of some of the best-known collages. Going from the upper to the lower end, you pass in succession Pembroke, St. Katherine’s, King’s, Clare, Trinkty, St. John’s. The juncture of Clare and King’s is where you are most tempted to linger: the enchanting gracefulness of Clare being in close vicinity to the grandeur of King’s Chapel. There may be constructions more beautiful and dignified elsewhere, such as the precincts of the Louvre on the river Seine in Paris, the banks of the great Rialto Bridge in Venice, the environs of the ancient Pont Vecchio in Florence. But the Backs of Cambridge has characteristics all its own that defy summing up with a few epithets. Its lucid, delicate artistic conception, free from all mundane polution, may be said to be beyond the bounds of painting, and transformed into the magic flavour of music. There is nothing more harmonious, more symmetrical, than this group of structures. Comparable to it, perhaps, is only Corot’s “Farmland” in painting, and Chopin’s “Nocturne” in music. Yet even these cannot give you an impression quite so ethreal. The sense of beauty in inspires is *nothing short of2 divine. Imageine yourself standing in the shade of that big cedar tree by King’s College bridge and looking into the distance. To your right, beyond a spacious square of new-mown lawn, is our Fellows Building, which, though of no very ancient date, yet possesses a charm that cannot be concealed. Between spring and summer, on its pallid stone walls, roses sway in the soft breeze in a riot of colour. To the left is the Chapel, with its forest of pinnacles perpetually pointing skyward, not to be sullied. Still further left is St. Clare. Ah, that square court of incredibly exquisite workmanship — who can dispute its being the personification of St. Clare herself? And which of its stones but is glittering with her spirit of holy purity in bygone years? Faintly discernible behind Clare is Cambridge’s most magnificent, most prestigious Trinity College, on top of whose library building, overlooking the river, sits on guard the Sculpture of Byron, his features brimming over with astonishing vitality. However, at the moment your attention has been arrested, as by magic, by Clare’s Three-Arched Bridge. You have seen the Breakoff Bridge at Xi Ling on West Lake’s Bai Causeway, (unfortunately it and its like have long since been trampled down by the Bus Companym, representative of the sordidness of all modernity; they have gone the way of the melancholy Lei Feng Pagoda, and taken leave *for good3 of the world of mortals) haven’t you? Surely you cannot forget the mottled green moss on the bridge, the ancient look of its wooden paling, the beautiful tints of lake and hill stealing from under its arches. St. Clare’s bridge is not so daintily set off as all that. Nor is it comparable to the bridge of the Goddess of Mercy nestling against the Temple of the Virtuous on Mount Lushan, commanding a view of the miraculus Five-Old-Men Peak overhead and the deep pools and cascading waterfalls below. It is no more than a diffidant-looking little bridge with its three arches set of by rippled waves and the whirling shadows of trees. The rows of small railing on the bridge and pairs of white stone balls on top of them are but like the unpretentious herbs and wild flowers country girls deck their hair with. But gaze intently, gaze intently again. Then look in retrospect at the mood you are in and see if it is still tainted with a streak of vulgar thought. This is a wonderful occasion for you to capture a sense of sheer beauty if only your instinctive capacity for the appreciation of beauty has not entirely left you. Still you have to choose a moment opportune for such enjoyment. In England the climate and weather go to extremes. In winter it is beastly even to absurdity. After days of blinding mist, surely you would rather wish to have a taste of Hell itself *without further ado4. On the other hand, spring (in England there is almost no summer) is absurdly lovable, especially between the months of April and May when the evenings are at their loveliest as they get warmer and warmer, and every moment becomes golden. It is a veritable tonic for the soul to pass an evening on the bank of the River Cam. Ah! The days I enjoyed being all by myself and having long hours of leisure, sweet with all the sweetness of honey. How evening after evening found me leaning against the balustrade of the bridge, losing myself in reverie as I gazed toward the western sky. Glance at the bridge’s tranquil shadow, Count fine mother-of-pearl on rippling waves; I nestle up to the stone railing to warm the green moss, Warm the green moss till it cools me To the depth of my heart. Other scenes too cumbersome to merit comparison With the airiness of gossamer; A July evening unforgettable, Trees buried in far-off stillness; Shape of hills ink-spalashed Silhouetted5 against the tenderness of dust — Close-woven, seven-tenths goose-yellow, three-tenths orange-green; A subtle charm there’s no recapturing Save at the edge of an autumn dream… ^ 此题有二种译法: (1) Cambridge As I Knew It 一般写作者对过去在剑桥时的回忆. (2) The Cambridge I knew 侧重于写回忆过去, 对比现在的剑桥. 例如可以说: The Cambridge I know was quite difference from the Cambridge of today. 本文写于 1926 年 1 月, 时作者已阔别康桥二年, 康桥即英国的剑桥大学 (Cambridge University). ^ 简直可以说 (nothing 也可用 little). You use nothing short of or little short of to emphasize how great or extreme something is. ^ 永久地. If something changes or disappears for good, it never changes back or comes back as it was before. ^ 干脆. If you do something without further ado or without more ado, you do it at once and do not discuss or delay it any longer. ^ 轮廓. 可做动词或名词. (1) A silhouette is the solid dark shape that you see when someone or something has a bright light or pale background behind them. (2) The silhouette of something is the outline that it has, which often helps you to recognize it. Doing Chores August Heckscher I have been doing chores, being for a brief spell alone in a house that recently was astir with bustle and echoed with the voices of a gathered family. For those, who may be in some doubt as to the nature of chores, their variety, their pleasures and their drudgery, I am prepared to deliver a short disquisition. The first point about chores is that they are repetitive. They come every day or thereabouts, and once done they require after a certain time to be done again. In this regard a chore is the very opposite of a ‘happening’–that strange sort of event which a few years back was so much in fashion. For a happening was in essence unrepeatable; it came about in ways no one could predict, taking form from vaporous imaginings or sudden impulse. chores, by contrast, can be foreseen in advance; for better or worse, I know that tomorrow I must be re-enacting the same small round of ritualistic deeds; and they arise, moreover, from practical necessities, not from poetic flights. A second point about chores is that they leave no visible mark of improvement or progress behind them. When I am finished, things will be precisely as they were before–except that the fires will have been set, the garbage disposed of, and the garden weeded. In this, they are different from the works which optimistically I undertake. Ozymandias may have been presumptuous, but he was essentially right when he looked about him and said: “See how my works endure!” A work, once achieved, leaves a mark upon the world; nothing is ever quite the same again. The page of a book may have been printed or a page of manuscript written; a sketch, a poem, a song composed; or perhaps some happy achievement reached in one of the more evanescent art forms like the dance or cooking. All these have an existence of their own, outside of time, and at least for a little while live on in the mind of their creator and perhaps a few of his friends. The well-meaning wife, seeing her husband about his chores, will miss the character of his performance. “Henry loves to cut wood,” she will say; “he positively dotes on controlling the flow of waste from dinner-table to compost heap.” The wife is perhaps trying to appease an unnecessary sense of guilt at seeing her spouse engaged in mundane efforts. The fact is, he doesn’t love doing chores. But neither does he feel humiliated or out of sorts for having to do them. The nature of a chore is that it is neither pleasant nor unpleasant in itself; it is entirely neutral–but it is obligatory. neutral–and yet I must confess that with their repetition, and perhaps because of their very inconsequence, chores can in the end evoke a mild sort of satisfaction. Here, as in more heroic fields of endeavor, a certain basic craft asserts itself. To do what must be done neatly, efficiently, expeditiously–“without rest and without haste”–lights a small fire deep in the interior being and puts a man in good humor with the world. Santayana described leisure as “being at home among manageable things”; and if he was right we who are the chore-doers of the world are the true leisure classes. At least one can be sure that no chore will defeat us; none will raise insuperable obstacles, or leave us deflated as when the divine muse abandons her devotee. A man I know became seduced by the minor pleasure of doing chores–or at any rate by the absence of pain which they involve–and could be seen from morning till nightfall trotting about his small domain, putting everything in order, setting everything to rights that the slow process of time had disturbed. He was perhaps going too far. To season chores with work and to intersperse them with a few happenings, is the secret of a contented existence. Fortunate the man or woman who achieves a just balance between these three types of activity–as I have been able to do by good chance, and for a little space of time. 文章取自吉拉德·列文所编《短篇范文》 (Short Essays–Models for Composition by Gerald Levin, Third Edition, NY 1983). 本文作者奥古斯特·赫克斯切 1913 年生于纽约市亨廷顿区， 曾多年担任《纽约论坛报》 (New York Tribune) 编辑和社论撰稿人. 他的著作主要是关于城市生活的文章和论述公共事务的书籍. Chore 本是日常要做的家庭琐事. 但本文作者把它与正式工作和偶发事件并列, 认为是人的三种主要活动, 写法自然不同于一般, 这样的散文从内容到文字格调都比较高. 文章前后呼应结构严谨, 论述清晰, 列文认为可作美国大学生作文的范例而编入他的书. Prof.Lin Xu As a new ‘SISTor’ in ShanghaiTech, I feel very exciting, proud, and really lucky. Just the same as my dear colleagues who have shared their experiences, I would like to tell you my own story. But my story will be a little different, I believe. I was born in a small village in the south of Sichuan privince, where people were poor, struggling just for food and clothes. I had to stay at home for one year doing nothing before meeting the age requirement of a primary school, just for saving 5 RMB. Although the financial situation was not good, my childhood was very happy, because, as a child, I did not have any awareness about finance, Instead, what I had were plenty of play time, plenty of little fellows, and plenty of game places, e.g., wild fields, small hills, and rivers. Moreover, we did not have any extra course. In this sense, we were much luckier than today’s kids, particularly the Shanghai kids. I stood out soon after I went to the village’s primary school, especially in math. Like most of my dear colleagues, I also had a dream to become a scientist or an engineer, even though I did not know what a scientist and an engineer really did. It turned out in my later life, this dream was too luxury. Anyway, gradually, I became the so called ‘neighbor’s kid’ and also the hope of my family since it seemed possible for me to change my life by education, which was the only way to leave the countryside for kid like me. Fortunately, I made it. In 1996, I graduated from the middle school with top ranking, meeting the entrance requirements of the best high school in my home county as well as the technical secondary school. As Prof.Pingqiang Zhou mentioned in the first issue of the SIS newsletter, in 1980s and early 1990s, graduation from a technical secondary school guaranteed a job from the government or the state-owned enterprises, and it took only 3 or 4 years after middle school. Therefore, a technical secondary school was cost-effective and usually the first choice for most of the best students from the countryside. But, actually, I preferred to go to the high school and then a university to pursue my dream. Unfortunately, I had to give it up and picked a technical secondary school due to family’s financial situation. This was the first time that I was aware of the impact of finance on my life. Four years later, I graduated from the technical secondary school with honors and was offered to be recommended for admission to a university without exams. Once again, I rejected this offer due to the same goddam financial reason, and then accepted the assigned job in a state-owned enterprise. I still remember my first salary, i.e., 304 RMB, with which I started to live on myself and partially shouldered the burden of my family, e.g., supporting my younger sister for her high school expenses. I was just 19 years old at that moment. Kids with this age should have sat in a spacious and bright classroom absorbing all kinds of invaluable knowledge rather than struggling for living. I was just like half-grouted rice which should have enjoyed the warm sunshine and sweet water and grown rapidly, but were harvested too early. Back to my job. It was an ordinary worker rather than a cadre. An ordinary worker and a cadre were the two fundamental markers for employees in a state-owned enterprise. You may have no idea how huge the gap between them was, but just keep in mind, most of the ordinary workers were not able to cross this gap even exhausting the whole efforts of their entire career. Coming from the countryside without any social resource, I did not think God would shed special light on me such that I could cross the gap, although I was almost there six years later. Furthermore, I did not like the tasks of this job. I worked in a heat-treatment workshop. What I did was to put (manually) the metal material, sometimes very large and heavy, into an electric resistance furnace and take them out after a certain period and then chill them with water or special liquid, in order to alter their physical properties. Today, some software engineers describe their work as ‘moving bricks’ with self-deprecating humor. But my work was really ‘moving metal’, seriously. For me, it was just physical labor requiring no professional knowledge nor skills. Every health adult could do that after a couple of month training. The only good thing was that, after work, I ate well, slept well, and never had hair-loss problem. But what was the value of my four-year study in the techniical secondary school? And what about my childhood dream? Although I had to give up the opportunity to a university twice, I had never given up my dream, ever. So what should I do? Again, education became the straw which might be able to save my drowning life. I took the self-study higher education examination, choosing mechatronics as my major, which was quite different from heat treatment and therefore really challenging. I did the fulltime job and studied the machatronics in the late evening, during what time people around me were having all kinds of fun. As indicated by the name ‘self-study’, I was totally on myself without any external help, any teacher, nor any classmate. What I had were a textbook, a syllabus, and several copies of previous exams for each course. Unlike today, it was not easy to get information through the internet since I could not even afford for a computer at that moment. So basically I had to understand the textbook and figure out every single problem by my self. One example, for the course ‘Microcomputer principle and interface technology’, there were lots of concepts I had never heard before. The first time I just read it as a novel and tried to understand its structure. Then I repeated reading, thinking, reading, thinking, …, and finally passed the exam with a score of 91. But this was only one course, and I had to pass more than 30 courses in order to obtain a bachelor degree. The whole process took me six years, which were the most difficult but also the most valuable years in my life. It was a treasure from the God, I guess, because as Mengzi said, if the God wanted you to do something really big, he would first blablabla… So, thank you, my God, but what was the thing really big? Oh perhaps it was ShanghaiTech, I did not get it until recently. After finishing the bachelor, I made a big decision: to take the National Graduate Entrance Examination (NGEE) with target at University of Electronic Science and Technology of China (UESTC). I believed it was this decision that led me to an academic career, and finally to ShanghaiTech. Just like throwing a little into the quiet water, this news spread soon all over the factory and resulted in quite some surprise, doubt, laugh, …, but no trust. I have seen all kinds of eyes and faces; from which I could hear sounds like ‘are you kidding?’, ‘it is impossible’, et al. Well, nothing is impossible. So just let it be. I ignored all sounds outside and was preparing for the exam following my own pace. An even bigger news came two months later (three months before the NGEE): I rejected a promotion to a cadre (the League secretary) because it was accompanied by the condition of giving up the NGEE. As I said before, in a state-owned enterprise, the gap between a worker and a cadre was so huge that most workers could not cross it during their entire career. So in all people’s minds, I should grab this opportunity. However, they were not me, the ‘stupid’ guy who chose the NGEE which was labeled as impossible. To be honest, I alse cloud not predict the NGEE result at that moment. But what I knew was the this was my last chance to a university pursuing my dream, and if I missed this one I would miss it completely and would definitely regret it in the rest of my life. I alse knew that I cloud live with the worst NGEE reult. So why not? People did not understand me except for my family. My parents and two sisters always trusted me, encouraged me, and supported me. Other people felt like ‘are you crazy’? Yes, I was crazy. I was crazy because this time I could follow the inside of my heart without considering the goddam finance. I was crazy alse because I felt so colse to my dream, only missing the final shot. I felt full of energy in every single nerve and every single cell of my body. As a man, I was fighting against the fate, which, I believe, should only be ontrolled in my own hands. The biggest news came along with the warm sunshine and plaeasant spring breeze: I made it. Again, I saw all kinds of interesting eyes and faces. But this time, the underlying sounds were different. The rest of my life was much easier. I finished my master study at UESTC and then went to boroad for a Ph.D. at the Eindhoven University of Technology, where I also did my postdoc training. When I started looking for a faculty position, ShanghaiTech came into my mind immediately since I knew it quite a few years ago, from my middle school classmate and friend, Prof. Ji Hu, assistant professor at SLST in ShanghaiTech. It was interesting that, different from me choosing the techinical secondary school, Ji went to the high school and then a university. But this was not the point. The thing was that he was that he was a full professor at Xi’an Jiaotong University before joining in ShanghaiTech as assistant professor in 2014. And he was not the only case. I noticed, almost during the same period, another full professor at Nanjing University joined in ShanghaiTech as associate professor, although he was promoted soon. I was so surprised, just like people hearing that I rejected the cadre position. I was curious about what kind of university ShanghaiTech was. After extensive learning about her tenure-track system, founding and education philosophy, high academic freedom, as well as the competitive salary and benefits, I understood their choices. Since then, ShanghaiTech had become my dream insitute to develop an academic career. Again I made it. I received the offer a couple of days after the on-site interview, and accepted it without hesitation. I joined in ShanghaiTech in Sep.2019, with education and research interests focused on biomedical signal processing and its application in neuromuscular rehabilitation and ambulatory health monitoring. To me, like was miraculous. As you see, me and Ji started from the same village school, then followd two totally different trajectories, but finally met again in ShanghaiTech, which confirmed, once again, the very old saying: ‘All roads lead to Rome’. To make it more specific, perhaps I cloud say: ‘All roads lead to ShanghaiTech, sooner or later’. So, just be prepared and patient. And, to make it even further, I would say ‘All roads lead to the same destination - end of the life’. So, just cherish and enjoy every single minute and every single scene in our lives. 激素 2022-06-10 11:26:55 雌二醇(SNSE2) 97 pg/ml 促软泡激素(FSH) &lt;0.20 mlU/mL 睾酮(T) 0.30 ng/mL 催乳素(PRL) 12.96 ng/mL 促黄体生成素(LH) &lt;0.20 mlU/ml 谷草转氨酶 17 U/L 谷丙转氨酶 12 U/L 尿素 3.21 mmol/L 肌酐 68.0 umol/L 尿酸 272.7 umol/L OD 可选药物 引用自 @Spr1ngW1nd 右美沙芬 推荐12-48片, 起始剂量 6-8 片. 6-8片效果: 欣快感, 身体轻盈, 头晕 普瑞巴林 推荐 600mg (8片), 最大 1200mg (16片) 效果: 神经异常放电 (手抖), 性欲提升, 欣快感, 幸福感. 同理心增强, 语言能力增强, 犯困, 幻觉. 安非他酮 推荐 500mg 一下 效果: 欣快感, 空间感知能力下降, 提神, 癫痫. 苯海拉明 + 右美沙芬 2-6 片苯海拉明 + 12-24 片右美沙芬 效果: 欣快感 普瑞巴林 + 巴氯芬 + 褪黑素 普瑞巴林 600-1200mg, 巴氯芬 25-50mg, 褪黑素 2-4mg 效果: 话多, 吐真, 失忆 金刚烷胺 10-12 片, 最高 18 片 效果: 欣快感, 时间感知能力抑制, 幻 SSRI (NMDA) AXS-05 (Auvelity): 氢溴酸右美沙芬 45mg, 盐酸安非他酮缓释片 105mg Hydroalcoholic 凝胶吸收率 Forearm (Ventral) 1.0x Forearm (Dorsal) 1.1x Foot Arch (Plantar) 0.14x Ankle (Lateral) 0.42x Palm 0.83x Back 1.7x Scalp 3.5x Axilla 3.6x Forehead 6.0x Jaw Angle 13.0x Scrotum 42x 常用等价无穷小 $$ x\\to 0 \\begin{array}{ll} \\sin x\\sim x & \\tan x\\sim x \\\\ \\ln(1+x)\\sim x & e^x-1\\sim x \\\\ \\arcsin x\\sim x & \\arctan x\\sim x \\\\ \\log_a (1+x)\\sim\\frac{x}{\\ln a} & x-\\ln(1+x)\\sim\\frac{1}{2}x^2 \\\\ 1-\\cos x\\sim\\frac{1}{2}x^2 & \\ln(x+\\sqrt{1+x^2})\\sim x \\\\ x-\\sin x\\sim\\frac{1}{6}x^3 & \\tan x-x\\sim\\frac{1}{3}x^3 \\\\ (1+x)^\\alpha-1\\sim\\alpha x & \\arcsin x-x\\sim\\frac{1}{6}x^3 \\\\ x-\\arctan x\\sim\\frac{1}{3}x^3 & \\tan x-\\sin x\\sim\\frac{1}{2}x^3 \\end{array} $$ 示波器用法 原理: 示波器分时段截取波形, 需告诉示波器如何截取波形 (波形捕捉). 否则示波器自动截取的波形可能会 “走动”. 旋转 Trigger 旋钮可调节波形中心点的捕捉电压. 默认是动态捕捉, 如果需捕捉瞬时的波形 (如开关闭合时的上电异常), 按下 Single 键. 测量波形: 按下 Cursor 键, 出现测量卡尺. 按菜单键可更改模式. 幅值模式下旋转 Cursor 旋钮能测最大电压; 时间模式下旋转 Cursor 旋钮能测持续时间. 采样率: 1 GSa/s 代表 1 Giga Sample/second 一般示波器标注的是最高采样率, 实际采样率受存储深度的限制. 存储深度, 示波器将分段采集的波形存储并用于展示的内存空间. 如 2.5k 的存储深度代表能同时存储 2500 个采样. 则 \\(\\frac{\\pu{2.5e3 Sa}}{\\pu{1e9 Sa/s}}=\\pu{2.5e-6 s}=\\pu{2.5 us}\\) 即在满采样率下只能采集长度 2.5 微秒的波形. 如要采集长度 1 毫秒的波形, 通过变化上面的公式, 得到此时的采样率: \\(\\frac{\\pu{2.5e3 Sa}}{\\pu{1 ms}}=\\pu{2.5e3 Sa/ms}=\\pu{2.5e6 Sa/s}\\) 示波器带宽: 示波器探头到采用芯片的电路课简单理解为一个 RC 电路, 低频信号可以通过, 高频信号会被衰减. 频率和衰减幅值的关系如图: 衰减到原来的 0.707x 时的信号频率便是示波器的带宽. 五倍原则: \\(\\text{待测信号频率}\\times 5\\leqslant\\text{示波器带宽}\\). 即 100M 带宽的示波器的待测信号频率不应超过 20M. 对照衰减曲线. 频率为 \\(\\frac{\\text{示波器带宽}}{5}\\) 的信号只衰减到 0.98x, 误差只有 2%. 社会 签协议时注意违约部分的不对等惩罚 性别是身份认同的政治，通过创造出身份的道德从而利用固死的身份认同和身份认同的规训侵占个体的独特性。它是现代社会集体侵略个体的一种典型手段 什么是引战 引战的诀窍: 让人们&quot;意识到&quot;他们属于不同的群体, 再提供一下具有地图炮属性的&quot;帽子&quot;和极端又激烈的&quot;弹药&quot; 渴望证明存在感的人们就会自觉自愿地拿起这些帽子, 抄起弹药向其他人发动攻击 引战的本质是人人都为了虚假的&quot;身份认同&quot;而战 举报维权电话 纪委12388, 组织12380, 环保12369, 检察12309, 社保12333, 物价12358, 食药12331, 商务12335, 税务12366, 司法12348, 外交12308, 文化12318, 文物12359, 互联网12321, 运输12328, 知识产权12330, 质检12365, 海关12369, 国土12336, 公积金12329, 烟草12313, 保监会12378, 快递12305, 铁路12306, 农业信息12316, 国家扶贫办12317, 城市服务12319, 防震减灾12322, 妇联12338, 间谍举报12339, 城管12342, 民政12349, 安全生产12350, 工会12351, 残联12385, 证监会12386 医保异地需要转院证明 整容的结果都是未知的，找到一个靠谱的医生，然后尽可能只去整一些后遗症小的部位，这样成功率可以大大提升。切记，不要去私立医院，绝大多数都是广告、医托、莆田系。普通的三甲医院也不要去，很多整形科都外包给莆田系了。推荐北京八大处，和上海九院，医生方面可以自己多了解，选一个靠谱的、适合自己的。 网络骚扰 如果你觉得微博上有人肆无忌惮地伤害您, 您又不知道 Ta 是谁、不知怎么告 Ta, 一步一步这样做: 找你居住地的公证处, 要求公证这些令你觉得受到伤害的帖子. 通常大约1000元左右. 注意, 您要亲自去一下公证处. 可以电话预约. 保留好发票!有人最后会报销的. 居住地的含义是你现在居住的地方而不是户籍地只需要有暂住证或居住证. 在你居住地的法院, 提交诉讼. 诉讼费约 50 元. 如果觉得写诉状头疼, 可以延请你信任的任何人, 甚至不一定是执业律师. 诉讼制度改革后, 法院目前对此类诉状基本去了就受理. 律师费高低不等, 不过不会白花钱的, 把发票放好, 最后也会有人报销. 所以强烈建议找个律师并给予全面授权, Ta 会为您办很多事情, 包括并不限于全权代理您出庭, 您自己都可以不去. 我实践的时候, 根本不想看见那些人, 所以我一次都没出庭. (说结果: 赢了) 重点来了. 你要告的第一个人(法人)是新浪微博(微梦创想公司). 你要求他提供侵权人的信息. 依据两高的司法解释(具有法律效力, 附后), 你的诉求会被法院支持. 这时候, 已经非常娴熟的微博律师会提出和解. 你答应就好: 给出涉嫌侵权人的信息, 我就撤销对你的诉讼. 这是庭前和解, 具有法律强制效力. 新浪微博的律师很快会给出你希望找到的那个人的一大堆信息, 包括他最近几年每一个帖子的 IP 地址、发微博的手机号, 如果他带 V, 还有所有认证信息, 包括身份证号码. 你如约撤销对微博的诉讼, 追加那个你终于得到个人信息的、你真正想告的人, 开始进入正常的诉讼环节. 胜诉, 申请强制执行. 细节处理. 如果您请了律师, 律师也会知道这些: 拿到了微博提供的信息, 比如一些 IP 地址、电话号码等等, 你还是无法查出他的身份信息, 导致法院无法进入正常的诉讼程序, 怎么办? 律师可以填写附图的表, 请法庭协助调查. 很快, 你就能知道 Ta 叫什么、身份证号码、身份证上的地址(很重要)了. 不知道他当前的地址怎么送达传票? 要求法院按照身份证上的地址邮递. 如果因为未被签收、拒收等等原因退回, 就更好了. 你这时可以要求进行&quot;公告送达&quot;, 手续费大约几十元到 200 元不等. 发票也存好. 公告会出现在某个法院指定的报纸上: xxx, 某人已向你提起诉讼, 请于什么时间之前与谁联系… Ta 还不理? 最好了. 公告刊登60天后视同送达, 法庭将在公告后择日开庭. Ta 不出现? 最好, 法庭将缺席审理, 并视同对方放弃质证和答辩权. 这时候你只要回答审判员或合议庭的问题就好了. 对方拒不执行怎么办? 你的诉讼请求要包括要求对方公开赔礼道歉(很重要)、删除帖子、负担诉讼费、律师费、公证费、公告费及精神赔偿. 判决生效后, 你可以去执行庭请求强制执行. 删除帖子好办, 法庭出个文, 微博会照办的. 赔偿也好办, 你有他的名字和身份证号码, 执行庭会查出他的银行卡并强制扣除, 不够扣的, 他就是老赖, 上黑名单. 赔礼道歉的部分, 你一定要求: 在微博置顶道歉 N 天(多少天你和律师商量, 一般是 7-15 天)或(很重要!)在微博首页或你所在城市的报纸刊登判决书摘要 N 天. 这样, 如果他拒绝在他的微博道歉, 你可以申请强制执行刊登判决书摘要. 其成本由被告承担, 通常需要几十万到上百万元. 如果不给钱, 当然也是强制执行, 他卡上钱如果不够, 可以列入老赖, 直到给付为止. 在此期间你可以公开征求对方财产线索, 如房产、汽车、股票等, 如果获得, 可报告执行庭实施查封、拍卖. 如果对方是体制内的人士或者党员团员, 不要忘记将此诉讼和执行情况, 整理成文件, 发给 Ta 的主管纪检监察部门. 依据新党规 100 条, 有 Ta 好看的. 附带说一下, 还有被我诉讼、判决生效后的人迄今没有履行. 别忘记, 我在一定的时效内可以随时申请强制执行. 去执行庭填个申请表, 10 分钟的事儿. 我什么时候想起来去填报, 看我高兴. 对方只是转发我可以告 Ta 吗? 可以, 而转发的阅读量越大, 责任越大. 详见附录的第十条. 附录 最高人民法院关于审理利用信息网络侵害人身权益民事纠纷案件适用法律若干问题的规定摘要(最高人民法院审判委员会第 1621 次会议通过). 众所周知, 最高法院的法律解释具有法律效力. 第一条 本规定所称的利用信息网络侵害人身权益民事纠纷案件, 是指利用信息网络侵害他人姓名权、名称权、名誉权、荣誉权、肖像权、隐私权等人身权益引起的纠纷案件. 第二条 利用信息网络侵害人身权益提起的诉讼, 由侵权行为地或者被告住所地人民法院管辖. 侵权行为实施地包括实施被诉侵权行为的计算机等终端设备所在地, 侵权结果发生地包括被侵权人住所地. 第三条 原告依据侵权责任法第三十六条第二款、第三款的规定起诉网络用户或者网络服务提供者的, 人民法院应予受理. 原告仅起诉网络用户, 网络用户请求追加涉嫌侵权的网络服务提供者为共同被告或者第三人的, 人民法院应予准许 原告仅起诉网络服务提供者, 网络服务提供者请求追加可以确定的网络用户为共同被告或者第三人的, 人民法院应予准许. 第四条 原告起诉网络服务提供者, 网络服务提供者以涉嫌侵权的信息系网络用户发布为由抗辩的, 人民法院可以根据原告的请求及案件的具体情况, 责令网络服务提供者向人民法院提供能够确定涉嫌侵权的网络用户的姓名(名称)、联系方式、网络地址等信息. 网络服务提供者无正当理由拒不提供的, 人民法院可以依据民事诉讼法第一百一十四条的规定对网络服务提供者采取处罚等措施. 原告根据网络服务提供者提供的信息请求追加网络用户为被告的, 人民法院应予准许. 第十条 人民法院认定网络用户或者网络服务提供者转载网络信息行为的过错及其程度, 应当综合以下因素: (一) 转载主体所承担的与其性质、影响范围相适应的注意义务; (二)所转载信息侵害他人人身权益的明显程度. 第十五条 雇佣、组织、教唆或者帮助他人发布、转发网络信息侵害他人人身权益, 被侵权人请求行为人承担连带责任的, 人民法院应予支持. 第十六条 人民法院判决侵权人承担赔礼道歉、消除影响或者恢复名誉等责任形式的, 应当与侵权的具体方式和所造成的影响范围相当. 侵权人拒不履行的, 人民法院可以采取在网络上发布公告或者公布裁判文书等合理的方式执行, 由此产生的费用由侵权人承担. 第十八条 被侵权人为制止侵权行为所支付的合理开支, 可以认定为侵权责任法第二十条规定的财产损失. 合理开支包括被侵权人或者委托代理人对侵权行为进行调查、取证的合理费用. 人民法院根据当事人的请求和具体案情, 可以将符合国家有关部门规定的律师费用计算在赔偿范围内. 被侵权人因人身权益受侵害造成的财产损失或者侵权人因此获得的利益无法确定的, 人民法院可以根据具体案情在 50 万元以下的范围内确定赔偿数额. 睡眠 先说说睡眠的过程, 睡眠的过程大概是以一个半小时为一个睡眠周期 每个睡眠周期分为四个阶段(每个周期间还会穿插快速眼动时期, 此时人会做梦), 每个阶段人的脑袋脑电波所处的波频不一样. 通常建议每个人的睡眠最好是以周期进行, 常常说人要睡足八个小时的原因, 往往是 5 个周期 + 眼动时期的误差时间. 有些人七个半小时很有可能就已经足够了. 在工作比较紧张的时候, 一周最起码要保证 30 个睡眠周期(这也是经常提给高三高考生的睡眠建议), 以及平日里如果有空，需要保证 35 个睡眠周期的优质睡眠. 蓝光对人的睡眠节律有着毁灭性的破坏, 但即使是在睡眠前半个小时不玩手机, 蓝光对我们的影响还在持续, 最理想的是应该在睡眠的前一个半小时停止接触蓝光设备, 期间整理整理衣服, 看一看书(不建议看情节性太强的小说, 建议看虚幻/科幻类的小说). 人的黄金睡眠时间是 22：00 到 2：00, 最好能够在这期间进入睡眠, 而且尽量固定起床时间, 按照睡眠周期往前推算, 比如果定好 6：00 起床, 那么假设现在已经 23：15, 不妨推到 12：00 左右再入眠 假若你的起床时间能够调整到 6：00 到 8：00 之间的话, 建议在这段时间里在户外的自然光环境下呆上半个小时. 假若你有在户外吃早餐的习惯, 那再好不过了. 人的眼睛和皮肤对自然光极其敏感, 平日里的自然光是室内光的100倍, 即使是在阴天, 也有 10 倍左右, 人就是靠光线来调整自身的昼夜节律的, 这一点非常重要. 其他时间当然也行, 不过所需的时间可能需要更长一点, 你当然可以选择在晚饭后的傍晚沐浴在夕阳温柔的余晖里散步. 以及不要在卧室床上做睡眠以外的任何事情, 人对空间有功能分区, 会潜意识里对每个物件或是空间进行功能归因, 我们在课上经常睡成习惯, 往往是我们对课堂进行了睡眠归因. 大脑其实非常聪明, 比如我们平日里不用英语, 而只是用英语进行应试, 大脑对信息的接受和提取要慢的很多. 如果床的功能被一段时间的行为紊乱了之后(比如玩手机), 那么我们在床上入睡的愿望可能就完全没有那么强烈, 所以请把你的床当成一个神圣的地方. 药物不良反应 盐酸曲咗酮片 (美时玉) 眼部疲劳 恶心/呕吐 震颤 全身乏力 身体数据 2021-05-11 领围 40, 连肩袖长 72-74, 颈围 37, 腰围 73, 胸围 85, 臀围 88, 大腿 48, 小腿 36, 肩宽 40 2022-06-07 领围 36.5, 连肩袖长 65 颈围 35.5, 腰围 72, 上胸围 84.5, 下胸围 76 臀围 92, 大腿 52, 小腿 37 肩宽 37.5","link":"/zh-cn/daily-life/2021/suspicious-stew/"},{"title":"data_structure","text":"从 0 开始 需要对C语言的指针和数组有一定的了解 全部代码示例皆为C语言 函数中所有用到的变量都声明在开头 函数名使用帕斯卡命名法 变量使用驼峰命名(我平时用匈牙利命名法) 数据结构概论 了解一下就好 抽象数据类型(Abstruct Data Type, ADT): 数据对象(Int, String, List等)的逻辑描述方法123456789101112131415ADT 线性表(List)Data 创建一个存储 DataType 类型元素的线性表, 线性表的数据对象集合为{a_1, a_2, ..., a_n}, 每个元素的类型均为DataType. 其中除第一个元素 a_1 外, 每一个元素有且只有一个前驱元素; 除了最后一个元素 a_n 外, 每一个元素有且只有一个直接后继元素. 数据元素之间的关系是一对一(链式)的关系.Operation InitList(*L) : 初始化操作, 建立一个空的线性表 L . ListEmpty(L) : 判断线性表是否为空表, 若线性表为空, 返回 true , 否则返回 false . ClearList(*L) : 将线性表清空. GetElem(L, i, *e) : 将线性表 L 中的第 i 个位置元素值返回给 e . LocateElem(L, e) : 在线性表 L 中查找与给定值 e 相等的元素, 如果查找成功, 返回该元素在表中序号表示成功; 否则返回 -1 表示失败 ListInsert(*L, i, e) : 在线性表 L 中第 i 个位置插入新元素 e . ListDelete(*L, i, *e) : 删除线性表 L 中第 i 给位置元素, 并用 e 返回其值. ListLength(L) : 返回线性表 L 的元素个数.endADT 数据的逻辑结构: 有 集合, 线性, 树形, 图形 四类 算法 特性(仅了解): 输入输出: ≥0个输入, ≥1个输出 有穷性: 不会死循环 确定性: 相同的输入, 一样的结果 可行性: 不会消耗过长的时间 要求(仅了解): 正确性 可读性 健壮性: 即使是奇怪的输入也不会导致奇怪的后果 时间效率高 存储量低 时间复杂度 表示随着输入规模增大导致耗时增加的程度 记作: \\(T(n) = O(f(n))\\) , 其中 \\(n\\) 代表问题规模, \\(f(n)\\) 是渐进时间复杂度 (高数中的同阶无穷大) 通常我们用 \\(O(f(n))\\) 来表示算法的时间复杂度, 叫作大O阶 推导大O阶: 只保留 \\(T(n)\\) 中的最高阶项 去除最高阶项的常数(除非最高阶是常数 1) 常见的时间复杂度 函数阶 非正式用语 常见于 \\(O(1)\\) 常数阶 略 \\(O(n)\\) 线性阶 循环结构 \\(O(n^2)\\) 平方阶 嵌套双循环 \\(O(n^3)\\) 立方阶 嵌套3循环 \\(O(2^n)\\) 指数阶 嵌套n个循环(嵌套多了, 就变成指数阶了) \\(O(\\log n)\\) 对数阶 循环子的增长呈指数的循环 \\(O(n\\log n)\\) \\(n\\log n\\) 阶 对数阶+套个循环 耗费的时间从小到大依次是: \\(O(1)&lt;O(\\log n)&lt;O(n)&lt;O(n\\log n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)\\) 最坏情况与平均情况 算法的时间复杂度不是固定的, 依据输入的数据而决定 通常算法给出的时间复杂度都是指最坏情况 空间复杂度 算法所需占用的内存 记作 \\(S(n)=O(f(n))\\) 空间复杂度为 \\(O(1)\\) 时称为原地工作 实际情况下通常不考虑空间复杂度 线性表(List) 定义和抽象数据类型 定义: 线性表的结构长这样: 记作: \\((a_1, a_2, \\dots, a_{i-1}, a_i, a_{i+1}, \\dots, a_n)\\) 若元素个数 n=0 时, 称为空表, i 称作位序 每一个元素有1个前驱和后继, 第一个和最后一个元素除外. 如图中 \\(a_i\\) 有前驱 \\(a_{i-1}\\) 和 后继 \\(a_{i+1}\\) ADT 定义:1234567891011121314151617ADT 线性表(List)Data 线性表的数据对象集合为{a1, a2, ......, an}, 每个元素的类型均为DataType. 其中, 除第一个元素a1外, 每一个元素有且只有一个直接前驱元素, 除了最后一个元素an外, 每一个元素有且 只有一个直接后继元素. 数据元素之间的关系是一对一的关系.Operation InitList(*L): 初始化操作, 建立一个空的线性表L. ListEmpty(L): 若线性表为空, 返回true, 否则返回false. ClearList(*L): 将线性表清空. GetElem(L, i, *e): 将线性表L中的第i个位置元素值返回给e. LocateElem(L, e): 在线性表L中查找与给定值e相等的元素, 如果查找成功, 返回该元素在表中序号表示成功；否则, 返回-1表示失败 ListInsert(*L,i,e): 在线性表L中的第i个位置插入新元素e ListDelete(*L,i,*e): 删除线性表L中的第i个位置元素, 并用e返回其值 ListLength(L): 返回线性表L的元素个数EndADT 线性表的顺序存储结构 结构特点: 用一段地址连续的存储单元依次存储线性表的数据元素 顺序存储结构需要三个属性: 存储空间地址 data 线性表的最大存储容量 MaxSize 线性表的当前有效长度 length 线性表的顺序存储结构代码:12345678typedef int ElemType; // ElemType类型根据实际情况而定, 这里假设为inttypedef struct{ ElemType data[MAXSIZE]; // 数组存储数据元素, 最大值为MAXSIZE int length; // 线性表当前长度} SequenceList; 地址的计算: 要取得 \\(a_i\\) 的地址: ElemType a_i = data + (i-1) * sizeof(ElemType); 线性表顺序存储结果的优缺点 优点 缺点 * 无须为表示表中元素之间的逻辑关系而增加额外的存储空间* 可以快速地存取表中任一位置的数据 * 插入和删除操作需要移动大量元素* 当线性表长度变化较大时, 难以确定存储空间的容量* 造成存储空间的\"碎片\" 顺序存储结构的插入与删除 GetElem(L, i, *e) 的实现 返回 0 代表 OK, -1 代表 ERROR 1234567891011#define OK 0#define ERROR -1int GetElem(SequenceList list, int i, ElemType *e){ if (list.length == 0 || i &lt; 1 || i &gt; L.length) return ERROR; *e = list.data[i - 1]; return OK;} 插入操作 思路: 为了给插入元素腾出空间, 遍历从 i 开始至最后一个元素, 将它们向后移动一个位置(除非插入到表尾). 将元素插入位置 i 处 表长+1 若插入位置不合理, 抛出异常 若线性表已满, 抛出异常或动态增加容量 实现代码如下: 123456789101112131415161718192021#define OK 0#define ERROR -1int ListInsert(SequenceList *list, int i, ElemType e){ if (list-&gt;length == MAXSIZE) /* 顺序线性表已满 */ return ERROR; if (i &lt; 1 || i &gt; list-&gt;length + 1) /* 当i不在范围内时 */ return ERROR; if (i &lt;= list-&gt;length) /* 若插入数据位置不在表尾 */ { for (int k = list-&gt;length - 1; k &gt;= i - 1; k--) /*将要插入位置后数据元素向后移动一位 */ list-&gt;data[k + 1] = list-&gt;data[k]; } list-&gt;data[i - 1] = e; /* 将新元素插入 */ list-&gt;length++; return OK;} 删除操作 思路: 为了缩回空出的地方, 遍历从 i 开始至最后一个元素, 将它们向前移动一个位置(除非删除的是表尾的元素). 表长-1 如果删除位置不合理, 抛出异常 实现代码如下: 12345678910111213141516171819202122#define OK 0#define ERROR -1int ListDelete(SequenceList *list, int i, ElemType *e){ if (list-&gt;length == 0) /* 线性表为空 */ return ERROR; if (i &lt; 1 || i &gt; list-&gt;length) /* 删除位置不正确 */ return ERROR; *e = list-&gt;data[i - 1]; if (i &lt; list-&gt;length) /* 如果删除不是最后位置 */ { for (int k = i; k &lt; list-&gt;length; k++) /* 将删除位置后继元素前移 */ list-&gt;data[k - 1] = list-&gt;data[k]; } list-&gt;length--; return OK;} 插入与删除的时间复杂度分析 如果元素要插入到最后一个位置, 或者删除最后一个元素, 时间复杂度为 \\(O(1)\\), 通常把具有这一特点的存储结构称为随机存取结构. 如果元素要插入到第一个位置或者删除第一个元素, 意味着要移动所有的元素向后或者向前, 时间复杂度为 \\(O(n)\\) 平均情况: 由于元素插入到第 i 个位置, 或删除第 i 个元素, 需要移动 n-i 个元素. 平均执行次数是 \\(\\frac{(n-1)+(n-2)+\\dots+(n-n)}{n}=\\frac{n^2-\\frac{(1+n)n}{2}}{n}=n-\\frac{1+n}{2}=\\frac{n-1}{2}\\) (运用等差数列的知识进行化简) 化为大O阶后平均时间复杂度还是 \\(O(n)\\) 线性表的链式存储结构 顺序线性表的缺点就是插入和删除时需要移动大量元素, 显然很耗费时间 因此有了存储形式非线性的链式线性表 结构特点: 用一组任意的存储单元存储线性表的数据, 这组存储单元可以是连续的, 也可以是不连续的. 这些数据可以存在内存未被占用的任意位置 存储元素的区域称为数据域, 存储后继位置的域称为指针域 这样的一个单元称为结点 因为此链表的每个结点只包含一个指针域, 所以叫作单链表 注意: 为了方便记录链表信息, 可在链表在第一个结点前附设一个头结点, 头结点的数据域可以存储如线性表长度等信息. 指向链表起始位置的指针称为头指针, 若链表有头结点, 则是指向头结点 链表最后一个结点(称为终端结点)的尾指针为空(用 “NULL” 或 “^” 表示) 线性表的单链表存储结构代码12345typedef struct Node{ ElemType data; struct Node *next;} Node, *LinkList; 单链表的读取 获得链表第 i 结点上数据的算法思路: 声明一个指针 p 用于存储遍历的地址, 初始值为第一个结点地址 初始化循环子 j=1, 当 j &lt; 1 时, 就遍历链表, 让 p 指针向后移动, 不断指向下一结点, j 累加 1 若循环到 p 为 NULL (还没到 i 结点就到单链表结尾了), 说明第 i 结点不存在, 抛出异常 若非法输入 i &lt; 1, 抛出异常 实现代码如下:1234567891011121314int GetElem(LinkList list, int i, ElemType *e){ LinkList p = list-&gt;next; /* 声明一指针p, 让p指向链表list的第一个结点 */ int j = 1 /* j为计数器 */ for(; j &lt; i &amp;&amp; p; j++) /* p不为空且计数器j还没有等于i时, 循环继续 */ p = p-&gt;next; /* 让p指向下一个结点 */ if(!p || i &lt; 1) return ERROR /* 第i个结点不存在 */ *e = p-&gt;data; /* 取第i个结点的数据 */ return OK;} 最坏情况时间复杂度为 \\(O(n)\\) (对比顺序线性表读取始终为 \\(O(1)\\)) 单链表的插入与删除 单链表的插入 先把结点 \\(s\\) 的后继指向 \\(p\\to next\\) , 再把结点 \\(p\\) 的后继改为指向结点 \\(s\\) 12s-&gt;next = p-&gt;next;p-&gt;next = s; 执行后: 对于单链表的表头和表尾的情况, 因为只要动前一个元素的后继指向, 所以操作是相同的 单链表插入为第 i 个结点 首先需要获得链表第 i-1 结点的地址(参考上一章, 但不同的是 p 初始没有指向第一个结点) 若查找成功, 生成空结点 s, 将数据 e 赋给 s-&gt;data 进行上面讲的插入操作 实现代码如下: 12345678910111213141516171819int ListInsert(LinkList *list, int i, ElemType e){ LinkList p, s; int j = 1; p = *list; for(; j &lt; i &amp;&amp; p; j++) /* 遍历寻找第i-1个结点 */ p = p-&gt;next; if(!p || i &lt; 1) return ERROR /* 第i个结点不存在 */ s = (LinkList) malloc(sizeof(Node)); /* 分配内存空间(C标准函数) */ s-&gt;data = e; s-&gt;next = p-&gt;next; /* 将p的后继结点赋给s的后继 */ p-&gt;next = s; /* 将s赋值给p的后继 */} 单链表第 i 个结点删除 思路: 首先需要获得链表第 i-1 结点的地址(参考上一章) 将结点 i-1 的后继指向结点 i+1 : p-&gt;next = q-&gt;next 实现代码如下: 123456789101112131415161718192021int ListDelete(LinkList *list, int i, ElemType *e){ LinkList p, q; int j = 1; p = *list; for(; j &lt; i &amp;&amp; p-&gt;next; j++) /* 遍历寻找第i-1个结点 */ p = p-&gt;next; if(!(p-&gt;next) || i &lt; 1) return ERROR; q = p-&gt;next; p-&gt;next = q-&gt;next; /* 将q的后继赋值给p的后继 */ *e = q-&gt;data; /* 将q结点中的数据给e */ free(q); /* 释放内存 */ return OK;} 插入与删除的时间复杂度分析 单链表的插入和删除算法, 都是由遍历查找第 i 结点和插入和删除结点这两部分构成, 时间复杂度都是 \\(O(n)\\) 如果不知道第 i 个结点的指针位置, 单链表结构在插入和删除操作上与顺序线性表是没有太大优势的. 但若希望从第 i 个位置, 插入 10 个结点, 对于顺序存储结构来说每次插入都需要 \\(O(n)\\); 单链表只需要在第一次时找到第 i 个位置的指针, 此时为 \\(O(n)\\) , 接下来只是简单地移动指针, 时间复杂度都是 O(1) . 因此, 对于插入或删除数据越频繁的操作, 单链表的效率优势就越是明显 单链表的整表创建 创建单链表的过程是一个动态生成链表的过程. 即从&quot;空表&quot;的初始状态起, 依次建立各元素结点, 并逐个插入链表 头插法: 类似于插队, 始终让新结点在第一的位置 思路: 创建空表 循环以下动作: 创建新结点, 随机生成数字赋给新结点的数据域 将头指针的值赋给新结点的后继 将新结点插入到头结点之后 实现代码如下: 123456789101112131415161718192021/* n 为要建立的单链表长度 */void CreateListHead(LinkList *list, int n){ LinkList p; // 初始化随机数种子 srand(time(0)); // 先建立一个带头结点的单链表 *list = (LinkList) malloc(sizeof(Node)); (*list)-&gt;next= NULL; for(int i = 0; i &lt; n; i++) { p = (LinkList) malloc(sizeof(Node)); // 生成新结点 p-&gt;data = rand() % 100 + 1; // 随机生成 100 以内的数字 p-&gt;next = (*list)-&gt;next; // 设置结点的后继 (*list)-&gt;next = p; // 插入到表头 }} 尾插法 思路: 创建空表 需要一个指针来记录尾部结点(以下称 r) 循环以下动作: 创建新结点, 随机生成数字赋给新结点的数据域 将尾部结点(也就是 r)的后继设为新结点的地址 将新结点设为尾部结点(r = 新结点) 实现代码如下: 1234567891011121314151617181920212223/* n 为要建立的单链表长度 */void CreateListTail(LinkList *list, int n){ LinkList p, r; // 初始化随机数种子 srand(time(0)); // 先建立一个带头结点的单链表 *list = (LinkList) malloc(sizeof(Node)); r = *list; // r 记录尾部结点的地址(这里表刚创好只有一个结点所以赋 *list) for(int i = 0; i &lt; n; i++) { p = (LinkList) malloc(sizeof(Node)); // 生成新结点 p-&gt;data = rand() % 100 + 1; // 随机生成 100 以内的数字 r-&gt;next = p; // 将表尾结点的后继指向新结点 r = p; // 将新结点定义为表尾结点 } r-&gt;next = NULL; // 别忘了初始化表尾结点的后继} 单链表的整表删除 单链表整表删除: 思路: 新建一个指针 p 存储第一个结点 向后不断遍历结点的后继并删除当前结点, 将 p 不断后移 最终将头指针置空 实现代码如下:123456789101112131415int ClearList(LinkList *list){ LinkList p = (*list)-&gt;next; // p 初始化指向第一个结点 while(p) // 循环直到 p 为 NULL { LinkList q = p-&gt;next; // 需要一个临时变量来存储地址 free(p); p = q; // 将下一结点的地址赋给 p } // 最后将头指针设为空 (*list)-&gt;next = NULL; return OK;} 顺序存储结构和单链表结构的比较 存储分配方式 时间性能 空间性能 * 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素* 单链表采用链式存储结构, 用一组任意的存储单元存放线性表的元素 * 查找 * 顺序存储结构 O(1) * 单链表 O(n)* 插入和删除 * 顺序存储结构需要平均移动表长一半的元素, 时间为 O(n) * 单链表在找出某位置的指针(O(n))后, 插入和删除时间仅为 O(1) * 顺序存储结构需要预分配存储空间, 分大了, 浪费, 分小了易发生上溢* 单链表不需要分配存储空间, 只要有就可以分配, 元素个数也不受限制 若线性表需要频繁查找, 很少进行插入和删除操作时, 宜采用顺序存储结构. 若需要频繁插入和删除时, 宜采用单链表结构 当线性表中的元素个数变化较大或者根本不知道有多大时, 最好用单链表结构, 这样可以不需要考虑存储空间的大小问题. 而如果事先知道线性表的大致长度, 用顺序存储结构效率会高很多 静态链表 用数组储存结点的链表叫做静态链表(游标实现法). 为了方便插入数据, 通常会把数组建得大一些, 以防止空间不够而溢出 1234567#define MAXSIZE 1000typedef struct{ ElemType data; int cur; // 游标(Cursor), 为 0 时表示无指向} Component, StaticLinkList[MAXSIZE]; 如图所示, 静态链表中: 数组中未被使用的空间称为备用链表 数组的第一个结点和终端结点作为特殊结点, 不存数据. 第一个结点(下标为 0)的 cur 存放备用链表的第一个结点的下标; 终端结点的 cur 存放第一个有数值结点的下标(相当于单链表中的头指针), 若整个链表为空时, 则为 0 . 实现代码如下:123456789101112131415161718192021222324// 假设 MAXSIZE = 1000int InitList(StaticLinkList list){ // 初始化数组下标 0~998 的游标 for(int i = 0; i &lt; MAXSIZE -1; i++) list[i].cur = i + 1; // 将终端结点(下标 999)的游标置为 0 list[MAXSIZE - 1].cur = 0; return OK;}// 通过遍历游标并统计遍历次数的方法得到表长int ListLength(StaticLinkList list){ int length = 0; int lastCursor = list[MAXSIZE - 1].cur; while(lastCursor) { lastCursor = list[lastCursor].cur; length++; } return length;} 举个例子: 假设已经将数据存入静态链表, 比如分别存放着&quot;甲&quot;、“乙”、“丁”、“戊”、“己”、&quot;庚&quot;等数据 静态链表的插入操作 首先要解决的是: 如何用静态(预分配了内存空间)模拟动态链表的存储空间分配, 即需要时申请, 无用时释放. 解决方案是将数组上所有未被使用的及已删除的分量用游标链成一个备用链表, 每当进行插入时, 便可以从备用链表取它的第一个分量作为待插入的新结点 实现代码如下: 12345678910// 若备用链表非空, 则返回备用链表第一个分量的下标, 否则返回 0int Malloc_SLL(StaticLinkList list){ // 根据静态链表定义, 当前数组第一个结点的cur存的值, 即为备用链表第一个分量的下标 int i = list[0].cur; if(list[0].cur) // 判断是否还有下一个分量 list[0].cur = list[i].cur; // 将它的下一个分量赋给第一个结点的cur return i;} 插入为第 i 结点: 思路: 首先从备用链表获得一个分量的游标, 然后将数据赋给此分量. 从终端结点的游标开始遍历, 直到第 i-1 号结点的下标; 然后参考单链表的插入操作 实现代码如下: 1234567891011121314151617181920212223242526// i 为要插入的下标int ListInsert(StaticLinkList list, int i, ElemType e){ int lastCursor, spaceCursor; lastCursor = MAXSIZE - 1; // 首先将这个记录用变量初始化为终端结点的下标 if (i &lt; 1 || i &gt; ListLength(list) + 1) return ERROR; spaceCursor = Malloc_SSL(list); if (spaceCursor) { // 将数据 e 赋给此分量 list[spaceCursor].data = e; // 类似于单链表, 找到第 i-1 结点 for (int j = 1; j &lt;= i - 1; j++) lastCurser = list[lastCursor].cur; // 参考单链表的插入操作 list[spaceCursor].cur = list[lastCursor].cur; list[lastCursor].cur = spaceCursor; return OK; } return ERROR;} 静态链表实现了在数组中, 不移动元素, 却插入了数据的操作. (但失去了随机读取的特性) 静态链表的删除操作 首先需要考虑把删除的空间回收到备用链表1234567// 回收第 i 结点void Free_SSL(StaticLinkList list, int i){ // 采用头插法 list[i].cur = list[0].cur; list[0].cur = k;} 删除第 i 结点:1234567891011121314151617int ListDelete(StaticLinkList list, int i){ int j, lastCursor; if (i &lt; 1 || i &gt; ListLength(list)) return ERROR; lastCursor = MAXSIZE - 1; // 类似于单链表, 找到第 i-1 结点 for (j = 1; j &lt;= i - 1; j++) lastCursor = list[lastCursor].cur; j = list[lastCursor].cur; // j 重复利用 list[lastCursor].cur = list[j].cur; // 将 i-1 结点的后继设为 i+1 (跳过第 i 结点) Free_SSL(list, j); return OK} 静态链表优缺点 优点 缺点 * 在插入和删除操作时, 只需要修改游标, 不需要移动元素, 从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点 * 没有解决连续存储分配带来的表长难以确定的问题* 失去了顺序存储结构随机读取的特性 循环链表 将单链表中终端结点的后继由空指针改为指向头结点, 就使整个单链表形成一个环, 称为单循环链表, 简称循环链表(Circular Linked List) 示意图: 空的循环链表(只有一个头结点): 非空的循环链表 循环列表的特点 循环链表和单链表的主要区别在于循环的判断条件上, 原来是判断 p-&gt;next 是否为空, 现在则是 p-&gt;next 不等于头结点, 则循环未结束. 有头结点的单链表可以用 \\(O(1)\\) 的时间访问第一个结点, 访问到终端结点却需要 \\(O(n)\\) 的时间, 因为需要将单链表全部遍历一遍 尾循环列表 为了解决终端结点访问效率低的问题, 再改造一下这个循环链表, 不用头指针而用指向终端结点的尾指针来表示链表. 尾循环列表的特点 终端结点用尾指针 rear 表示, 查找终端结点时间为 \\(O(1)\\) , 第一个结点是 rear-&gt;next-&gt;next , 时间也为 \\(O(1)\\) 合并多个尾循环列表 将尾指针分别是 rearA 和 rearB 的两个循环链表合并成一个表: 合并后: 如图所示, 具体操作为: 将 B 表的 rearB 指向 A 表的头结点 将 A 表的 rearA 指向 B 表的第一个结点, 同时释放 B 表的头结点 实现代码为: 1234CircularLinkList p = rearA-&gt;next; // 保存 A 表的头结点rearA-&gt;next = rearB-&gt;next-&gt;next; // 将 A 表的头结点替换为 B 表的第一个结点free(rearB-&gt;next); // 释放 B 表的头结点(不再需要)rearB-&gt;next = p; // 将 B 表尾指针指向 A 表的头结点 双向链表 双向链表(Double linked list)是在单链表的每个结点中, 再设置一个指向其前驱结点的指针域. 双向链表中的结点都有两个指针域, 一个指向后继, 一个指向后驱 123456typedef struct DuLinkNode{ ElemType data; struct DuLinkNode *prior; // 前驱指针 struct DuLinkNode *next; // 后继指针} DuLinkNode, *DuLinkList; 这里我们讨论循环+双向列表的情况 示意图: 空的循环双向链表: 非空的循环链表 双向链表插入结点 思路: 先搞定 s 的前驱和后继, 再搞定后结点的前驱, 最后解决前结点的后继 实现代码如下:1234s-&gt;prior = p; // 1. s 的前驱是 ps-&gt;next = p-&gt;next; // 2. s 的后继是 p-&gt;nextp-&gt;next-&gt;prior = s; // 3. 后结点的前驱是 sp-&gt;next = s; // 3. 前结点的后继是 s 双向列表删除结点 思路: 先搞定前结点的后继, 再搞定后结点的前驱, 最后释放 p 的空间123p-&gt;prior-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = p-&gt;prior;free(p) 栈与队列 栈的定义 栈(Stack)是限定仅在表尾进行插入和删除操作的线性表 栈顶(top) 允许数据插入和删除, 另一端叫栈底(bottom) 栈又被称为 后进先出(Last In, First Out) 的线性表, 简称LIFO结构 栈的插入操作称作压栈、进栈或入栈 栈的删除操作称作弹栈或出栈 栈的抽象数据类型 12345678910111213ADT 栈(Stack)Data 同线性表. 元素具有相同的类型, 相邻元素具有前驱和后继关系Operation InitStack(*S) : 初始化操作, 建立一个空栈 S DestroyStack(*S) : 将栈销毁 ClearStack(*S) : 将栈清空 StackEmpty(S) : 若栈为空, 返回 true ; 否则返回 false GetTop(S, *e) : 用 e 返回栈 S 的栈顶元素 Push(*S, e) : 插入新元素 e 到栈 S 中并成为栈顶元素. 又称: 压栈, 进栈, 入栈 Pop(*S, *e) : 删除栈 S 中栈顶元素, 并用 e 返回其值. 又称: 弹栈, 出栈 StackLength(S) : 返回栈 S 的元素个数endADT 栈的顺序存储结构及实现 栈的顺序存储结构(Stack Sequence) 栈顶指针top指向当前栈顶部元素的地址. 它在空栈时为 -1 , 存在一个元素时为 0 .1234567// SElemType类型根据实际情况而定, 这里假设为 inttypedef int SElemTypetypedef struct{ SElemType data[MAXSIZE]; int top; // 栈顶指针(下标)} SqStack; 顺序栈的进栈 1234567891011// 插入元素 e 为新的栈顶元素int Push(SqStack *S, SElemType e){ if (S-&gt;top == MAXSIZE - 1) // 栈满 return ERROR; S-&gt;top++; // 栈顶指针+1 S-&gt;data[S-&gt;top] = e; // 将新加入的元素赋给栈顶空间 // 以上两句可以合并为 S-&gt;data[++S-&gt;top] = e; return OK;} 顺序栈的出栈1234567891011// 删除栈顶元素, 用 e 返回其值int Pop(SqStack *S, SElemType *e){ if (S-&gt;top == -1) // 若栈为空 return ERROR; *e = S-&gt;data[S-&gt;top]; // 将要删除的栈顶元素赋值给 e S-&gt;top--; // 栈顶指针-1 // 以上两句可以合并为 *e = S-&gt;data[S-&gt;top--]; return OK;} 值得一提的是, 出栈并没有清除数据, 因为栈在创建时即分配了固定的内存空间, 没有必要清理数据. 时间复杂度分析 入栈和出栈的时间复杂度均是 \\(O(1)\\) 两栈共享空间 两栈共享空间 将一个数组分为两个顶部相连的栈, 一个栈的栈底为数组的始端, 另一个栈的栈顶为数组的末端 实现代码如下:123456typedef struct{ SElemType data[MAXSIZE] int top1; // 栈 1 栈顶指针 int top2; // 栈 2 栈顶指针} SqDoubleStack; 共享栈的进栈 对于两栈共享空间的 Push() 方法, 除了要插入元素值参数外, 还需要有一个判断是栈 1 还是栈 2 的栈号参数 stackNumber123456789101112int Push(SqDoubleStack *S, SElemType e, int stackNumber){ if (S-&gt;top1 + 1 == S-&gt;top2) // 两个栈顶相挨, 说明栈已满 return ERROR; if (stackNumber == 1) S-&gt;data[++S-&gt;top1] = e; // 栈 1 同普通栈 else if (stackNumber == 2) S-&gt;data[--S-&gt;top2] = e; // 栈 2 要先 top2-1 后给数组元素赋值 return OK;} 共享栈的出栈 对于两栈共享空间的 Pop() 方法, 同样需要增加判断栈 1 还是栈 2 的参数 stackNumber12345678910111213141516171819int Pop(SqDoubleStack *S, SElemType *e, int stackNumber){ if (stackNumber == 1) { if (S-&gt;top1 == -1) // 若栈 1 是空栈 return ERROE; *e = S-&gt;data[S-&gt;top1--]; // 栈 1 栈顶元素出栈 } else if (stackNumber == 2) { if (S-&gt;top2 == MAXSIZE) // 若栈 2 已经是空栈, 栈 2 的栈底是 MAXSIZE return ERROR; *e = S-&gt;data[S-&gt;top2++]; // 栈 2 栈顶元素出栈 } return OK;} 栈的作用 栈的引入简化了程序设计的问题, 划分了不同的关注层次, 使得思考范围缩小, 更加聚焦于要解决的问题核心. 反之, 像数组等, 因为要分散精力去考虑数组的下标增减等细节问题, 反而掩盖了问题的本质. 栈的应用 递归 斐波那契数列实现 斐波那契数列介绍 月数 1 2 3 4 5 6 7 8 9 10 11 12 兔子对数 1 1 2 3 5 8 13 21 34 55 89 144 如图, 编号 ① 的一对兔子经过六个月变成8对兔子 数学定义: \\(F(n) = \\begin{cases} 0 &amp; n=0 \\\\ 1 &amp; n=1 \\\\ F(n-1)+F(n-2) &amp; n&gt;1 \\end{cases}\\) 发现规律了吗? 斐波那契数列第 i 个月(i &gt; 1, 第零月算0)的值等于前两个月的和 打印前 40 位的斐波那契数列数, 实现代码如下: 1234567891011121314151617181920212223242526272829303132333435#include &quot;stdio.h&quot;int Fbi(int i) // 斐波那契的递归函数{ if (i &lt; 2) return i == 0 ? 0 : 1; return Fbi(i-1) + Fbi(i-2); // 递归调用(即调用自己)}int main(){ int i; int a[40]; // 方法1 使用迭代来实现斐波那契数列 printf(&quot;迭代显示斐波那契数列: \\n&quot;); a[0]=0; a[1]=1; printf(&quot;&amp;d &quot;, a[0]); printf(&quot;%d &quot;, a[1]); for(i = 2; i &lt; 40; i++) { a[i] = a[i-1] + a[i-2] printf(&quot;%d &quot;, a[i]); } printf(&quot;\\n&quot;); // 方法2 使用迭代来实现斐波那契数列 printf(&quot;递归显示斐波那契数列: \\n&quot;); for(i = 0; i &lt; 40; i++) printf(&quot;%d &quot;, Fbi(i)); return 0;} Fbi(i) 函数当 i=5 的执行过程(分析递归的方法): 递归和迭代的区别 迭代 递归 循环结构 选择结构 不需要反复调用函数和占用额外的内存 使程序结构更清晰简洁, 更容易让人理解, 从而减少读懂代码的时间. 但是大陆的递归调用会建立函数的副本, 从而耗费大量的时间和内存 你可能注意到本章似乎并没有提及栈的内容, 为什么呢? 在前行阶段, 对于每一层递归, 函数的局部变量、参数值以及返回地址都被压入栈中. 在退回阶段, 位于栈顶的局部变量、参数值和返回地址被弹出, 用于返回调用层次中执行代码的其余部分, 也就是恢复了调用的状态. 后缀表达式 我们平时描述数字表达式用的是中缀表达法, 但计算机解析它需要递归, 从而耗费大量的资源 后缀表达式能够解决这个问题 后缀表示法(逆波兰表示法): 逆波兰表达式去掉括号也不会有歧义 9+(3-1)*3+10÷2 = 9 (3 1-) 3*+ 10 2/+ = 9 3 1- 3*+ 10 2/+ 后缀表达式的计算方法 规则: 从左到右遍历表达式的每个数字和符号, 遇到数字就进栈, 遇到符号就将两个数字出栈, 进行运算, 再将运算结果进栈. 重复以上步骤直到最终获得结果. 以 9+(3-1)*3+10÷2 = 9 3 1- 3*+ 10 2/+ 为例 初始化一个空栈用来对要运算的数字进出使用. 后缀表达式中前三个都是数字, 所以 9, 3, 1 进栈, 如图 接下来是减号&quot;-&quot;, 所以将栈中的 1 出栈作为减数, 3 出栈作为被减数, 并运算 3-2 , 再将得到的结果 2 进栈, 如图 接着是数字 3 进栈 … 总之最后得到结果 20, 出栈变为空栈 中缀表达式转后缀表达式 9+(3-1)*3+10÷2 ----&gt; 9 3 1- 3*+ 10 2/+ 规则: 从左到右遍历中缀表达式的每个数字和符号, 若是数字就输出; 若是符号, 则判断其优先级不高于栈顶符号(遵循乘除优先加减, 左边高于右边)则将栈内元素依次出栈并输出, 并将当前符号进栈, 直到输出完整的后缀表达式. 若是右括号, 则栈内元素依次出栈直到对应的左括号出栈 初始化一个空栈, 用于存储读取的符号. 第一个字符是9, 输出9, 后面是符号&quot;+&quot;, 进栈. 第三个字符是&quot;(“, 进栈. 后面是数字3, 进栈. 接着是”-&quot;, 进栈 接下来是数字1, 输出. 后面是符号&quot;)“, 所以栈顶依次出栈, 直到”(“出栈为止. 接着是符号”*“, 因为此时的栈顶符号为”+“号, 优先级低于”*&quot;, 因此不输出, &quot;*&quot;进栈. 接着说数字3, 输出. … 读到最后, 将栈中元素全部出栈并输出. 得到后缀表达式结果: 9 3 1- 3*+ 10 2/+ 队列的定义 队列(queue)是只允许在一端进行插入操作, 而在另一端进行删除操作的线性表 队列是一组先进先出(First In First Out)的线性表, 简称FIFO. 允许插入的一端称为队尾, 允许删除的一端称为队头. 队列的抽象数据类型 12345678910111213ADT 队列(Queue)Data 同线性表. 元素具有相同的类型, 相邻元素具有前驱和后续关系.Operation InitQueue(*Q) : 初始化操作, 建立一个空队列Q DestroyQueue(*Q): 若队列Q存在, 则销毁它 ClearQueue(*Q) : 将队列Q清空 QueueEmpty(Q) : 若队列为空, 返回true, 否则返回false GetHead(Q, *e) : 用e返回队列Q的队头元素 EnQueue(*Q, e) : 插入新元素e到队列Q中并成为队尾元素 DeQueue(*Q, *e) : 删除队列Q中队头元素, 并用e返回其值 QueueLength(Q) : 返回队列Q的元素个数endADT 循环队列 队列顺序存储的不足 入列操作就是在队尾追加一个元素, 不需要移动任何元素, 时间复杂度为 \\(O(1)\\) 出列操作, 队列中的所有元素都得向前移动, 以保证队列的队头不为空, 此时时间复杂度为 \\(O(1)\\) 为了避免当只有一个元素时, 队头和队尾重合使处理变得麻烦, 引入俩个指针: 指向队头元素的 front 和指向队尾元素的下一个位置的 rear. 当 front 等于 rear 时, 队列为空. 循环队列定义 队列的这种头尾相接的顺序存储结构称为循环队列 (即指针 rear 可以在指针 front 的前面) 队列已满判断 如果我们再入队两个元素: 如何判断此时的队列已满呢? 方法1: 设置一个标志变量 flag , 当 front==rear且 flag=0 时队列空; 当 front==rear 且 flag=1 时队列满. 方法2: 当队列空时, 条件就是 front=rear, 当队列满时, 认为 (rear+1)%MAXSIZE == front 即为队列满 (取模MAXSIZE相当于让 rear&gt;4 时自动-4). 也就是说, 数组中保留一个空闲单元, 不允许右边的情况出现. 一般用第二种方法 队列实际长度的计算 当 rear 在 front 之后(即 front &lt; rear), 队列长度为 rear - front 当 rear 在 front 之前(即 front &gt; rear), 队列长度分为两段, 一段是 0 + rear, 另一段是 MAXSIZE - front. 整合起来就是: rear - front + MAXSIZE 结合两种情况, 得到通用的公式: (rear - front + MAXSIZE)%MAXSIZE 循环队列的具体实现 循环队列顺序存储结构123456typedef struct{ QElemType data[MAXSIZE] int front; int rear;} SqQueue; 循环队列初始化 InitQueue(*Q)123456int InitQueue(SqQueue *Q){ Q-&gt;front = 0; Q-&gt;rear = 0; return OK;} 循环队列求长度 QueueLength(Q)1234int QueueLength(SqQueue Q){ return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;} 循环队列入队操作 EnQueue(*Q, e)123456789int EnQueue(SqQueue *Q, QElemType e){ if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front) // 队列满的判断 return ERROR; Q-&gt;data[Q-&gt;rear] = e; // 将e赋给队尾 Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; // rear后移一位置, 若在最后则转到头部 return OK;} 循环队列出列操作 DeQueue(*Q, *e)12345678910int DeQueue(SqQueue *Q, QElemType *e){ if (Q-&gt;front == Q-&gt;rear) // 队列空的判断 return ERROR; *e = Q-&gt;data[Q-&gt;front]; // 将队头元素赋给e Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE; // front指针后移一位置, 若在最后则转到数组头部 return OK;} 队列的链式存储结构及实现 队列的链式存储结构即为只能尾进头出的单链表, 简称链队列. 空队列时, front 和 rear 都指向头结点 链队列的结构12345678910111213// QElemType类型根据实际情况而定, 这里假设为inttypedef int QElemType;typedef struct QNode // 结点结构{ QElemType data; struct QNode *next;} QNode, *QueuePtr;typedef struct // 队列的链表结构{ QueuePtr front, rear; // 队头, 队尾指针} LinkQueue; 入队操作 入队操作就是在链表尾部插入结点 实现代码如下:1234567891011121314int EnQueue(LinkQueue *Q, QElemType e){ QueuePtr newNode = (QueuePtr) malloc(sizeof(QNode)); if(!newNode) // 存储分配失败 exit(OVERFLOW); newNode-&gt;data = e; newNode-&gt;next = NULL; Q-&gt;rear-&gt;next = newNode; // 将新阶段设置为原队尾结点后继 Q-&gt;rear = newNode; // 将新结点设置为队尾结点 return OK;} 出队操作 出队操作时就是将第一个结点(头结点的后继)结点出队, 再将头结点的后继改为它后面的结点. 若链表除头结点外只剩一个元素时, 则需将 rear 指向头结点 实现代码如下:123456789101112131415161718int DeQueue(LinkQueue *Q, QElemType *e){ QueuePtr p; if (Q-&gt;front == Q-&gt;rear) // 若队列为空 return ERROR; p = Q-&gt;front-&gt;next; // 记下欲删除的结点地址 *e = p-&gt;data; // 将欲删除结点的值赋给e Q-&gt;front-&gt;next = p-&gt;next; // 将头结点后继改为欲删除结点的后继 if (Q-&gt;rear == p) // 若队头就是队尾, 则将rear指向头结点 Q-&gt;rear = Q-&gt;front; free(p); return OK;} 循环队列与链队列比较 时间上, 基本操作都为 \\(O(1)\\) , 不过循环队列是事先分配好空间, 使用期间不释放; 而对于链队列, 每次申请和释放结点也会有额外的时间开销, 如果入队出队频繁, 则两者还是有细微差异. 空间上, 循环队列必须有一个固定的长度, 所以就有空间浪费的问题. 而链队列不存在这个问题, 尽管它每个结点额外需要一个指针域, 会产生一些空间上的开销, 但也可以接受. 所以在空间上, 链队列更加灵活. 在可以确定队列长度最大值的情况下, 建议用循环队列, 如果无法预估队列的长度时, 则用链队列. 串 串的定义 串(string) 是由零个或多个字符组成的有限序列, 又名叫字符串 一般记为 \\(s=“a_1a_2\\dots a_n”(n\\geqslant 0)\\) , \\(s\\) 是串的名称, 用双引号(或单引号)括起来的是串的值. \\(a_i(1\\leqslant i\\leqslant n\\) 可以是字母、数字或其他字符. 空串(nullstring), 它的长度为零, 可以直接用两双引号 “” 表示, 也可以用希腊字母 Φ 来表示. 空格串, 只包含空格的串. 可以不止一个空格 串中任意个数的连续字符组成的串叫子串. 相应地, 包含子串的串称为主串. 串的比较 串的比较是通过组成串的字符之间的编码来进行的, 字符的编码指字符在对应字符集(如ASCII)中的序号. ASCII编码由7位二进制表示一个字符, 共能表示128个字符; 扩展ASCII码由8位二进制数表示一个字符, 共能表示256个字符 Unicode编码由16位二进制数表示一个字符, 共能表示 \\(2^16\\) 个字符(约6.5万), 为了与ASCII码兼容, Unicode的前256个字符与ASCII码完全相同 在C语言中比较两个串相等, 必须是串的长度和对应字符都相等. 两个串不相等时, 若对应字符不同, 比对应字符在ASCII码表的编码号. 若对应字符相同, 比两个串的长度. 串的抽象数据类型 线性表关注的是单个元素的操作 串关注的是多个元素的操作, 如查找子串位置, 得到指定位置子串, 替换子串等操作 串的抽象数据类型 12345678910111213141516171819202122232425262728ADT 串(string)Data 串中单个元素仅由一个字符组成, 相邻元素具有前驱和后继关系.Operation StrAssign(T, *chars) : 生成一个值为*chars的串T StrCopy(T, S) : 若串S存在, 由串S复制得串T ClearString(S) : 若串S存在, 将串清空 StringEmpty(S) : 若串S为空, 返回true, 否则返回false StrLength(S) : 返回串S的长度 StrCompare(S, T) : 若 S&gt;T, 返回值 &gt;0; 若 S=0 返回 0; 若 S&lt;T, 返回值 &lt;0 Concat(T, S1, S2) : 用T返回由S1和S2联接而成的新串 SubString(Sub, S, pos, len) : 若串S存在, 且 1 ≤ pos ≤ StrLength(S) , 0 ≤ len ≤ StrLength(S) - pos + 1 . 返回截取从pos起长度为len的子串Sub Index(S, T, pos) : 若串S和串T存在, T是非空串, 且 1 ≤ pos ≤ StrLength(S) . 若主串S中存在和串T相同的子串, 则返回它在主串S中第pos个字符起第一次出现的位置, 否则返回 -1 Replace(S, T, V) : 若串S、T、V存在, 且T是非空串. 用V替换主串S中出现的所有与T相等的子串. StrInsert(S, pos, T) : 若串S和T存在, 且 1 ≤ pos ≤ StrLength(S) + 1 . 在串S第pos个字符之前插入串T StrDelete(S, pos, len) : 若串S存在, 且 1 ≤ pos ≤ StrLength(S) - len + 1 . 从串S中删除以第pos个字符起长度为len的子串endADT 串的存储结构 串的顺序存储结构 串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列. 一般用数组来定义. C语言中, 串的最后用&quot;\\0&quot;来表示串值的终结. 串的链式存储结构 由于串结构的特殊性, 结构中每个元素数据是一个字符, 如果也简单地一个结点对应一个字符, 就会存在很大的空间浪费. 因此, 一个结点也可以考虑存放多个字符, 最后一个结点若是未被占满时, 可以用&quot;#&quot;或其他字符填充. 串的链式存储结构除了在连接串与串操作时有一定方便之外, 总的来说不如顺序存储灵活, 性能也不如顺序存储结构好 朴素的模式匹配算法 子串的定位操作通常称做串的模式匹配(Pattern matching) 举个例子: 从主串 S=“goodgoogle” 中找到 T=“google” 这个子串的位置 (图中, 竖直线表示相等, 闪电状弯折表示不等.) 主串 S 第一位开始, S 与 T 前三个字母都匹配成功, 但 S 第四个字符是 ‘d’ 而子串 T 的是 ‘g’, 因此第一位匹配失败. 从主串 S 第二位开始, 首字母是 ‘o’, 与 T 的 ‘g’ 不同, 匹配失败 从主串 S 第三位开始, 首字母还是 ‘o’, 与 T 的 ‘g’ 不同, 匹配失败 从主串 S 第四位开始, s首字母是 ‘d’, 与 T 的 ‘g’ 不同, 匹配失败 从主串 S 第五位开始, 6 个字母全匹配, 匹配成功 操作 Index(S, T, pos) 的实现算法 思路: 主串 S 从 pos 之后, 不断截取长度为 Strlength(T) 的子串与 T 进行比较 123456789101112131415161718int Index(String S, String T, int pos){ int n, m, i; String sub; if(pos &gt; 0) { n = StrLength(S); // 得到主串S长度 m = Strlength(T); // 得到子串T长度 for(i = pos; i &lt;= n - m + 1; i++) { SubString(sub, S, i, m); if (StrCompare(sub, T) == 0) // 如果两串相等 return i; } } return -1; // 若无子串与T相等, 返回 -1} 不用StrLength(), SubString(), StrCompare() 的实现 123456789101112131415161718192021int Index(String S, String T){ int i, j; // i, j 分别记录循环在 S, T 比较的下标 for (i = 1, j = 1; i &lt;= S.[0] &amp;&amp; j &lt;= T.[0];) { if (S[i] == T[j]) { i++; j++; } else // 如果比较失败 { i = i - j + 2; // i 回溯并+1 j = 1; // j 回溯 } if (j = T.[0]) return (i - T.[0]; else return 0; }} 时间复杂度分析: 最坏情况下, 每次不成功的匹配都发生在串 T 的最后一个字符 设 S 和 T 长度分别为 n=32, m=8 如主串 S=“00000000000000000000000000000001”, 而要匹配的子串 T=“00000001”, 所以最坏情况时间复杂度为 m(n-m+1)=O(m(n-m)) KMP模式匹配算法 KMP (Knuth, Morris, Pratt 三人发现) KMP算法的改进之处在于主串的 i 指针不用回溯, 而是利用之前&quot;匹配程度&quot;(以 j 指针来反应)将匹配串T向右滑动尽可能远的距离后继续比较. 如何决定滑动的距离呢? 定义一个数组 next[j] 表示当子串T中第j个字符与主串第i个字符不等时, 下一次比较的位置为 T[next[j]] 如图中 next[6] = 3, 则将 T[3]与 S[6] 比较 在此贴上 next[i] 的定义: \\(next[j]=\\begin{cases} 0, 当 j=1 时 \\\\ Max\\{k|1&lt;k&lt;j, 且 “a_1 a_2 \\dots a_{k=1}=a_{j-k+1} a_{j-k+1}\\dots a_{j-1}”\\} \\\\ 1, 其他情况\\end{cases}\\) 具体实现代码: 12345678910111213141516171819202122232425262728293031323334353637383940void get_next(String T, int *next){ int j, k; j = 1; k = 0; next[1] = 0; while(j &lt; T.[0]) // 此处T[0]表示串T的长度 { if (k == 0 || T[j] == T[k]) // { j++; k++; next[j] = k; } else k = next[k]; // k 值回溯, 同样利用了KMP, 利用之前已经算好的next[k] }}int Index_KMP(String S, String T, int pos){ int i = pos; int j = 1; int next[255]; get_next(T, next); while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) { if (j == 0 || S[i] == T[i]) { i++; j++; } else j = next[i]; } if (j &gt; T[0]) return i - T[0]; else return 0;} 时间复杂度分析 TODO 树 树的定义 树(Tree) 是 n (n≥0) 个结点的有限集, n=0 时称为空树. 在任意一颗非空树中: 有且仅有一个特定的根(Root)结点 当 n&gt;1 时, 其余结点可分为 m (m&gt;0) 个互不相交的有限集 \\(T_1, T_2, \\dots, T_m\\) , 其中每一个集合本身又是一棵树, 并且称为根的子树 如下图, 子树 \\(T_1\\) 和 \\(T_2\\) 是根结点 A 的子树 (D、G、H、I是以B为根结点的子树, E、J是以C为根结点的子树) 子数之间一定是互不相交的, 下图的两个结构就不符合树的定义 结点的分类 树的结点包含数据元素和若干指向其子树的分支. 结点的子树数量称为结点的度(Degree). 度为0的结点称为叶结点或终端结点; 度不为0的结点称为分支结点或非终端结点, 非根结点的分支结点也叫内部结点. 树的度为树内各结点的度的最大值. 举个例子: 此树的度为3 结点间关系 孩子(Child), 双亲(Parent), 兄弟(Sibling) 树的其他相关概念 结点的层次(Level) 一个 深度(Depth) 或 高度 为4的树 如果将树中结点的各子树看出从左至右是有次序的, 不能互换的, 则称该树为有序树, 否则称为无序树. 森林(Forest) 是 m (m≥0) 课互不相交的树的集合. 对树中每个结点而言, 其子树的集合即为森林. 树的抽象数据类型 1234567891011121314151617181920ADT 树(tree)Data 树是由一个根结点和若干课子树构成, 树中结点具有相同数据类型及层次关系Operation InitTree(*T) : 构造空树T DestroyTree(*T) : 摧毁树T CreateTree(*T, definition) : 按definition中给出的树的定义来构造树 ClearTree(*T) : 若树T存在, 则将树T清空 TreeEmpty(T) : 若T为空树, 返回true, 否则返回false TreeDepth(T) : 返回树T的深度 Root(T) : 返回树T的根结点 Value(T, cur_e) : cur_e是树T中一个结点, 返回此结点的数据 Assign(T, cur_e, value) : 给树T的结点cur_e赋值为value Parent(T, cur_e) : 若cur_e是树T的非根结点, 返回它的双亲, 否则返回空 LeftChild(T, cur_e) : 若cur_e是树T的非叶结点, 则返回它最左边的孩子, 否则返回空 RightSibling(T, cur_e) : 若cur_e有右兄弟, 则返回它的右兄弟, 否则返回空 InsertChild(*T, *p, i, c) : p指向树T的某个结点, i为所指结点p的度加上1, 非空树c与T不相交 操作结果为插入树c为树T中p所指结点的第i颗子树 DeleteChile(*T, *p, i) : 其中p指向树T的某个结点, i为所指结点p的度, 操作结果为删除树T中p所指结点的第i颗子树endADT 树的存储结构 双亲表示法 假设以一组连续空间存储树的结点, 同时在每个结点中, 附设一个治时期指示其双亲结点在数组中的位置. 每个结点除了知道自己是谁以外, 还知道它的双亲在哪里123456789101112131415#define MAX_TREE_SIZE 100typedef int TElemType; // 假设储存的是整型typedef struct PTNode{ TElemType data; // 结点数据 int parent; // 双亲位置} PTNode; // 结点结构typedef struct{ PTNode nodes[MAX_TREE_SIZE]; // 结点数组 int r, n; // 根的位置和结点数} PTree; 由于根结点没有双亲, 约定根结点的 parent 设为 -1 改进: 增加一个存储最左边孩子的 长子域(firstChild), 如果结点没有孩子, 就设为 -1 增加一个存储右兄弟的域(rightsib), 如果结点没有右兄弟, 就设为 -1 孩子表示法 由于树中每个结点可能有多颗子树, 可以考虑多重链表, 即每个指针指向一棵子树的根结点, 这种方法叫多重链表表示法. 方案一: 指针域的个数等于树的度 TODO: 补充不重要内容 方案二: 按需分配空间 TODO: 补充不重要内容 孩子表示法: 设置两种结构, 一个是孩子链表的孩子结点, 另一个是表头数组的表头结点. 把每个结点的孩子结点以单链表形式排列起来 12345678910111213141516171819#define MAX_TREE_SIZE 100typedef int TElemType;typedef struct CTNode // 孩子结点{ int child; // 存储该孩子在表头数组中的下标 struct CTNode *next; // 指向某结点的下一个孩子结点的指针} *ChildPtr;typedef struct // 表头结点{ TElemType data; ChildPtr firstchild;} CTBox;typedef struct{ CTBox nodes[MAX_TREE_SIZE]; // 表头数组 int r, n; // 根的位置和结点数} CTree; 这样的结构对于要查找某个结点的某个孩子, 或者某结点的兄弟, 只需要查找这个结点的孩子链表即可. 但要知道某结点的双亲是谁比较麻烦, 需要遍历整棵树才行. 双亲孩子表示法: 在孩子表示法的表头数组中, 元素增加一个记录双亲的域. 孩子兄弟表示法 设置两个指针, 分别指向该结点的第一个孩子和右兄弟 12345typedef struct CSNode{ TElemType data; struct CSNode *firstchild, *rightsib;} CSNode, *CSTree; 这种表示法, 查找某个结点的某个孩子只需要找到此结点的长子 firstchild, 再通过遍历长子结点的兄弟 rightsib 找到具体的孩子 这个表示法的最大好处是把一颗复杂的树变成了一颗二叉树 二叉树的定义 二叉树的特点 每个结点最多有两颗子树(左子树和右子树), 即二叉树中不存在度大于2的结点 左子树和右子树是有顺序的, 不能任意颠倒. 即使某结点只有一颗子树也要区分左子树和右子树. 二叉树的五种基本形态 空二叉树 只有一个根结点 根结点只有左子树 根结点只有右子树 树既有左子树也要右子树 特殊二叉树 斜树 所有的结点都只有左子树的二叉树叫作左斜树(从上往下斜); 所有的结点都只有右子树的二叉树叫作右斜树. 特点: 线性表也可以理解为斜树 斜树的结点个数根该树的深度相同 满二叉树 所有的分支结点都存在左子树和右子树, 并且所有叶子都在同一层上, 这样的二叉树称为满二叉树. 特点: 叶子只能出现在最下一层, 出现在其他车就不是满二叉树 非叶子结点的度一定是2 在同样深度的二叉树中, 满二叉树的结点个数最多, 叶子最多 完全二叉树 对一颗具有 n 给结点的二叉树按层序编号, 如果编号为 i(1≤i≤n) 的结点与同样深度的满二叉树中编号 为 i 的结点位置相同, 则这颗二叉树为完全二叉树 (简单点说就是除了最后一层没有满编其他地方与满二叉树都相同) 完全二叉树是满二叉树的必要但不充分条件 完全二叉树的特点: 叶子结点只能出现在最下两层 最下层的叶子一定集中在左部连续位置 倒数两层, 若有叶子结点, 一个都在右部连续位置 同样结点数的二叉树, 完全二叉树的深度最小 二叉树的性质 (下一层结点是上一层的2倍, 得到性质1和2) 性质1 二叉树的第i层上至多有 \\(2^{i-1}\\) 个结点 性质2 深度为k的二叉树至多有 \\(2^{k}-1\\) 个结点 性质3 对任何一颗二叉树T, 如果其终端结点数(叶子数)为 \\(n_0\\) , 度为 2 的结点数为 \\(n_2\\) , 则 \\(n_0=n_2+1\\) (一棵二叉树中, 除了叶子外, 剩下的就是度为 1 或 2 的结点了, 设 \\(n_1\\) 为度为 1 的结点数, 则数的总结点数 \\(n=n_0+n_1+n_2\\)) 性质4 具有 n 个结点的完全二叉树的深度为 \\(\\llcorner\\log_2 n\\lrcorner +1\\) (\\(\\llcorner xxx\\lrcorner\\)表示不大于xxx的最大整数) 深度为 k 的满二叉树的结点数 \\(n=2^k-1\\) , 倒推得到满二叉树的深度为 \\(k=\\log_2 (n+1)\\) . 比如结点数 15 的满二叉树, 深度为 4 . 完全二叉树的叶子只会出现在最下面两层. 结点数一定少于同样深度的满二叉树 \\(2^k-1\\), 但一定多于少一层的满二叉树 \\(2^{k-1}-1\\) 即满足 \\(2^{k-1}-1 &lt; n \\leqslant 2^k-1\\) . \\(n\\leqslant 2^k-1 \\rArr n &lt; 2^k\\) , \\(n &gt; 2^{k-1}-1 \\rArr n \\geqslant 2^{k-1}\\) 因此 \\(2^{k-1}\\leqslant n &lt; 2^k\\) , 不等式两边取对数得 \\(k-1 \\leqslant \\log_2 n &lt; k\\) 所以 \\(k=\\llcorner\\log_2 n\\lrcorner +1\\) 性质5 具有 n 个结点的完全二叉树(深度\\(\\llcorner\\log_2 n\\lrcorner +1\\)) 的结点按层序编号, 对任一结点 i (1≤i≤n) 有: 如果 i=1, 则结点 i 是二叉树的根; 如果 i&gt;1 则双亲是结点 \\(\\llcorner\\frac{i}{2}\\lrcorner\\) 如果 2i&gt;n, 则结点 i 无左孩子(即结点 i 为叶子); 否则其左孩子是结点 2i 如果 2i+1&gt;n, 则结点 i 无右孩子; 否则其右孩子是结点 2i+1 二叉树的存储结构 完全二叉树的存储 二叉树顺序结构是用一维数组存储二叉树中的结点, 并且结点的存储位置(即数组下标)要能体现结点之间的逻辑关系, 比如双亲与孩子的关系, 左右兄弟的关系 将这颗二叉树存入到数组中, 相应的下标对于其同样的位置 完全二叉树存入到数组中, 相应的下标对应同样的位置, 一般的二叉树层序编号不能反映逻辑关系, 但可以将其补全为完全二叉树来编号, 把不存在的结点设置为&quot;^&quot; 但使用这种方式编号也有缺点, 一种机端的情况是一颗深度为 k 的右斜树, 它只有 k 个结点, 却需要分配 \\(2^k-1\\) 个存储单元, 会造成对空间的极度浪费, 所以顺序结构一般只用于完全二叉树 二叉链表 二叉树每个结点最多有两个孩子, 设计一个数据域和两个指针域 结构定义代码如下: 12345typedef struct BiTNode // 结点结构{ TElemType data; struct BiTNode *lchild, *rchild; // 左右孩子指针} BiTNode, *BiTree; 结构示意图: 遍历二叉树 二叉树遍历方法 前序遍历 若二叉树为空, 则空操作返回, 否则 先访问根结点 前序遍历左子树 前序遍历右子树 图中遍历的顺序为:ABDGHCEIF 实现代码如下: 1234567891011/* 二叉树前序遍历递归算法 */void PreOrderTraverse(BiTree T){ if (T == NULL) // 也可用 if (T) 包裹全部 return; printf(&quot;%c&quot;, T-&gt;data); PreOrderTraverse(T-&gt;lchild); // 前序遍历左子树 PreOrderTraverse(T-&gt;rchild); // 前序遍历右子树} 中序遍历 若二叉树为空, 则空操作返回, 否则 从根结点开始(注意不是先访问根结点) 中序遍历根结点的左子树, 然后是访问根结点 中序遍历右子树 图中遍历的顺序为: GDHBAEICF 实现代码如下: 123456789101112/* 二叉树中序遍历递归算法 */void InOrderTraverse(BiTree T){ if (T == NULL) return; InOrderTraverse(T-&gt;lchild); // 中序遍历左子树 printf(&quot;%c&quot;, T-&gt;data); InOrderTraverse(T-&gt;rchild); // 中序遍历右子树} 后序遍历 若二叉树为空, 则空操作返回, 否则 从左到右先叶子后结点的方式遍历访问左右子树 最后是访问根结点 图中遍历的顺序为: GHDBIEFCA 实现代码如下: 123456789void PostOrderTraverse(BiTree T){ if (T == NULL) return; PostOrderTraverse(T-&gt;lchild); // 后续遍历左子树 PostOrderTraverse(T-&gt;rchild); // 后续遍历右子树 printf(&quot;%c&quot;, T-&gt;data);} 层序遍历 若树为空, 则空操作返回, 否则 从树的第一层, 也就是根结点开始访问 从上而下逐层遍历 中同一层中, 按从左到右的顺序对结点逐个访问 推导遍历结果 已知前序遍历序列和中序遍历序列, 能够唯一确定一颗二叉树 已知后序遍历序列和中序遍历序列, 能够唯一确定一颗二叉树 已知前序和后续遍历, 不能唯一确定一颗二叉树 二叉树的建立 要建立一颗普通的二叉树, 将这颗二叉树中每一个结点的空指针引出一个虚结点, 其值为一特定值, 比如&quot;#&quot;. 处理好的二叉树为扩展二叉树, 扩展二叉树能够通过一个&quot;前序&quot;或&quot;后序&quot;遍历序列确定一颗二叉树 (这样就方便用一串字符序列来建立二叉树了) 图中前序遍历序列为AB#D##C## 实现代码如下: 123456789101112131415161718// 按前序输入二叉树中各点的值void CreateBitree(Bitree *T){ TElemType ch; scanf(&quot;%c&quot;, &amp;ch); // 输入结点数据字符 if(ch == '#') *T = NULL; else { *T = (BiTree) malloc(sizeof(BiTNode)); if(!*T) // 如果分配失败 exit(OVERFLOW); (*T)-&gt;data = ch; // 给结点数据域赋值 CreateBiTree(&amp;(*T)-&gt;lchild); // 构造左孩子(子树) CreateBiTree(&amp;(*T)-&gt;rchild); // 构造右孩子(子树) }} 线索二叉树 线索二叉树原理 一个有 n 个结点的二叉链表. 每一个结点有指向左右孩子的两个指针域, 一共有 2n 个指针域. 如图, n 个结点的二叉树一共拥有 n-1 条分支线(根结点无前驱), 存在 2n - (n-1) = n+1 个空指针域 指向前驱和后继的指针称为线索, 加上线索的二叉链表则称为线索链表; 加上线索的的二叉树称为线索二叉树(Threaded Binary Tree) 树的线索化: 中序遍历后(图中为HDIBJEAFCG) 将所有空指针域中的 rchild, 改为指向它的后继结点. 如图, H 的后继是 D, I 的后继是 B, J 的后继是 E, E的后继是 A, F的后继是C, G的后继因为不存在而指向NULL. 此时共有6个空指针域被利用 将这颗二叉树的所有空指针域中的 lchild 改为指向当前结点的前驱. 如图, H 的前驱是 NULL, I 的前驱是 D, J 的前驱是 B, F 的前驱是 A, G 的前驱是 C. 一共5个空指针域被利用. 将上面两种方法整合后, 正好11个空指针域被利用 线索二叉树, 等于是把一颗二叉树转变成了一个双向链表, 对插入删除、查找某个结点都带来了方便. 对二叉树以某种次序遍历使其变为线索二叉树的过程称作是线索化 如图, 空心箭头实线为前驱, 虚线黑箭头为后继 每个结点再增设两个标志域 ltag 和 rtag, ltag 和 rtag 是布尔型变量, 它们的值取决于结点是否存在左右孩子 ltag 为 0 是指向该结点的左孩子, 为 1 时指向该结点的前驱 rtag 为 0 时指向该结点的右孩子, 为 1 时指向该结点的后继 线索二叉树结构实现 二叉树的线索存储结构定义代码如下: 123456789101112// 创建一个枚举类型用来给下面的 LTag, RTag 赋值// Link 的值为 0, 指向左右孩子指针// Thread 的值为 1, 指向前驱或后继typedef eum { Link, Thread } PointerTag;typedef struct BiThrNode{ TElemType data; struct BiThrNode *lchild, *rchild; PointerTag LTag; PointerTag RTag;} BiThrNode, *BiThrTree; 线索化的实现(在遍历二叉树的过程中修改空指针) 实现代码如下: 12345678910111213141516171819202122232425// 中序线索化BiThrTree pre; // 全局变量(因为递归要用), 存储刚刚访问过的结点(当前结点的前驱)void InThreading(BitThrTree p){ if (p) { InThreading(p-&gt;lchild); // 中序遍历 (1/2) if (!p-&gt;lchild) // 若结点无左孩子 { p-&gt;LTag = Thread; // 设置该结点 ltag p-&gt;lchild = pre; // 左孩子指针指向前驱 } if (!pre-&gt;rchild) // 若该结点的前驱没有右孩子 { pre-&gt;RTag = Thread; // 设置前驱的 ltag pre-&gt;rchild = p; // 前驱右孩子指针指向当前结点 } pre = p; // 设置为当前访问的结点 InThreading(p-&gt;rchild); // 中序遍历 (2/2) }} 双向线索链表: 在线索链表上加入一个头结点. 它的 lchild 域指向二叉树根结点; rchild 域指向中序序列最后一个结点. 中序序列第一个结点的 lchild 和最后一个结点的 rchild 域均指向头结点. 这样的优点是方便从第一个结点起顺后继进行遍历, 也能从最后一个结点起顺前驱进行遍历 TODO: 补充图片 遍历双向线索链表: 实现代码如下: 12345678910111213141516171819202122// T 指向头结点// 中序遍历, 时间复杂度为 O(n)int InOrderTraverse_Thr(BitThrTree T){ BitThrTree p; p = T-&gt;lchild; // p 指向根结点 while (p != T) // 空树或遍历结束时, p == T { while (p-&gt;LTag == Link) // 遍历到当前树的最左边 p = p-&gt;lchild; printf(&quot;%c&quot;, p-&gt;data); // 输出结点数据 while (p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T) // 若当前结点p的后继是线索化的, 且p的后继不是头结点 { p = p-&gt;rchild; // 进入后继结点(退到上级) printf(&quot;%c&quot;, p-&gt;data); } p = p-&gt;rchild; // p 进入当前结点的右子树 } return OK;} 如果所用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继, 那么采用线索二叉树的存储结构就是非常不错的选择 树、森林与二叉树的转换 二叉树中, 左孩子代表孩子, 右孩子代表兄弟 树转换为二叉树 加线. 在所有兄弟结点之间加一条线 去线. 对树中每个结点, 只保留它与第一个孩子的连线. (对于作图的)层次调整. 一树的根结点为轴心, 将整棵树顺时针旋转一定的角度, 使之结构层次分明. TODO: 补充图片 森林转换为二叉树 森林是由若干颗树组成的, 可以理解为森林中的每一颗树都是兄弟, 可以按照兄弟的处理方法来操作: 把每个树转换为二叉树 第一款二叉树不懂, 依次把后一颗二叉树的根结点作为前一颗二叉树的根结点的右孩子. TODO: 补充图片 二叉树转换为树 二叉树转换为树就是树转换为二叉树的逆过程 加线. 若某结点的左孩子结点存在, 则将这个左孩子的 n 个右孩子结点都作为此结点的孩子. 将该结点的与这些右孩子结点用线连接 去线. 删除原二叉树中所有结点与其右孩子结点的连线 (对于作图的)层次调整. 使之结构层次分明 TODO: 补充图片 二叉树转换为森林 判断一颗二叉树能否转换成森林, 看二叉树的根结点有右孩子 从根结点开始, 若右孩子存在, 则把与右孩子的连线删除; 再查看分离后的二叉树, 若右孩子存在, 则连线删除…, 直到分离后树的根结点没有右孩子. 再将每颗分离后的二叉树转换为树即可 TODO: 补充图片 树与森林的遍历 树的遍历分为两种方式: 先根遍历. 即先访问树的根结点, 然后依次先根遍历根的每颗子树 后根遍历. 即先依次后根遍历每颗子树, 然后再访问根结点 如图, 先根遍历序列为ABEFCDG, 后根遍历为EFBCGDA TODO: 补充图片 森林的遍历也分为两种方式: 前序遍历: 从左到右依次先根遍历森林中的每棵树 后序遍历: 从左到右依次后根遍历森林中的每棵树 如图, 前序遍历序列为ABCDEFGHJI, 后序遍历序列为BCDAFEJHIG TODO: 补充图片 将森林转换为二叉树后, 森林的前序遍历和二叉树的前序遍历结果相同, 森林的后序遍历和二叉树的中序遍历结果相同 TODO: 补充图片 当以二叉链表作为树的存储结构时, 树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现 赫夫曼树及其应用 赫夫曼定义与原理 TODO: 补充图片 从树中一个结点到另一个结点之间的分支(线段)构成两个结点之间的路径, 路径上的分支(线段)数目称作路径长度 树的路径长度: 从树根到每一结点的路径长度之和 如图, 二叉树 a 中, 根结点到 D 的路径长度为 4 . 二叉树 a 的树路径长度为 1+1+2+2+3+3+4+4=20; 二叉树 b 的树路径为 1+1+2+2+2+2+3+3=16 如果考虑到带权结点, 结点的带权路径长度为: 从该结点到树根之间的路径长度 × 结点的权. 假设有 n 个权值 \\(w_1, w_2, \\dots, w_n\\) , 构造一颗有 n 个叶子结点的二叉树, 每个叶子结点带权 \\(w_k\\) , 每个叶子的路径长度为 \\(l_k\\) , 则其中带权路径长度(WPL)最小的的二叉树称作赫夫曼树(最优二叉树). 二叉树a的 \\(\\text{WPL}=51+152+403+304+104=315\\) 二叉树b的 \\(\\text{WPL}=53+153+402+302+102\\) 它们都不是赫夫曼树 构造赫夫曼树: 先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列. 即: A5, E10, B15, D30, C40 取头两个最小权值的结点作为一个新结点 \\(N_1\\) 的两个叶子, 相对较小的是左孩子, 这里就是A为 \\(N_1\\) 的左孩子, E为 \\(N_1\\) 的右孩子, 新结点的权值为两个叶子权值的和(5+10=15) 用新结点 \\(N_1\\) 替换A与E, 插入有序序列中, 保存从小到大排列. 即: \\(N_1\\)15, B15, D30, C40 重复步骤2和3, \\(N_2=N_1 15+B15=30\\), 有序序列: \\(N_2\\)30, D30, C40 重复步骤2和3, \\(N_3=N_2 30+D30=60\\), 有序序列: \\(N_3\\) 60, C40 重复步骤2. 将\\(N_3\\) 与C作为新结点T的两个叶子, 由于T是根结点, 完成赫夫曼树的构造 WPL=40x1+30x2+15x3+10x4+5x4=205 构造赫夫曼树的赫夫曼算法描述: 根据给定的n个权值 \\(w_1, w_2, \\dots, w_n\\) 构成n颗二叉树的集合 \\(F=T_1, T_2, \\dots, T_n\\) , 其中每颗二叉树 \\(T_i\\) 中只有一个 \\(w_i\\) 的根结点, 其左右子树均为空. 在F中选取两颗根结点的权值最小的树作为左右子树构造一棵新的二叉树, 新的二叉树根结点的权值为其左右子树根结点的权重之和. 在F中删除这两棵树, 同时将新的到的二叉树加入F中 重复2和3步骤, 直到F只含一棵树位置. 这棵树便是赫夫曼树 赫夫曼编码 传输文字内容为&quot;BADCADFEED&quot;, 相应的二进制数据表示如下 字母 A B C D E F 二进制字符 000 001 010 011 100 101 真正传输的数据就是编码后的&quot;01000011010000011101100100011&quot; 假设六个字母的频率(权重)为 A27, B8, C15, E30, F5, 合起来正好是 100%. 完全可以重新按照赫夫曼树来规划它们 TODO: 补充图片 左图为构造赫夫曼树的权值显示. 右图为将权值左分支改为0, 右分支改为1的赫夫曼树 对这六个字母用从树根到叶子所经过路径的0或1来编码, 可以得到如表所示这样的定义: 字母 A B C D E F 二进制字符 01 1001 101 00 11 1000 将文字内容为&quot;BADCADFEED&quot;再次编码, 对比可以看到结果串变小了 数据被压缩了, 节约了大约17%的存储和传输成本. 随着字符的增加和多字符权重的不同, 这种压缩会更加显出其优势. 若要设计长短不等的编码, 则必须是任一字符的编码都不是另一个字符的编码的前缀(否则会造成歧义), 这种编码称作前缀编码 在解码时, 还要用到赫夫曼树, 即发送方和接收方必须要约定好同样的赫夫曼编码规则 设需要编码的字符集为 \\(d_1, d_2, \\dots, d_n\\) , 各个字符在电文中出现的次数(或频率)集合为 \\(w_1, w_2, \\dots, w_n\\) , 以 \\(d_1, d_2, \\dots, d_n\\) 作为叶子结点, 以 \\(w_1, w_2, \\dots, w_n\\) 作为相应叶子结点的权值来构造一颗赫夫曼树. 规定赫夫曼树的左分支代表0, 右分支代表1, 则从根结点到叶子所经过的路径分支组成序列便为该结点对应字符的编码, 也就是赫夫曼编码 图 图的定义 图(Graph)是由顶点构成的有穷非空集合和顶点之间边的集合组成 通常表示为: G(V, E), 其中G表示一个图, V是图G中顶点的集合, E是图G中边的集合 TODO: 补充图片 线性表中数据元素叫元素, 树中数据元素叫结点, 图中数据元素叫顶点(Vertex) 线性表中可以没有数据元素, 称为空表; 树中可以没有结点, 叫作空树; 但图结构中不允许没有顶点. 在定义中, 若V是顶点的集合, 则强调了顶点集合V有穷非空 线性表中, 相邻的数据元素之间具有线性关系; 树结构中, 相邻两层的结点具有层次关系; 图中任意两个顶点之间都可能有关系, 顶点之间的逻辑关系用边来表示, 边集可以是空的 各种图的定义 若顶点 \\(v_i\\) 到 \\(v_j\\) 之间的边没有方向, 则称这条边为无向边(Edge), 用无序偶对 \\((v_i, v_j)\\) 来表示. 如果图中任意两个顶点之间的边都是无向边, 则称该图为无向图(Undirected graphs) TODO: 补充图片 无序对(A,D)也可以写成(D,A) 对于无向图 \\(G_1\\) : \\(G_1=(V_1, \\{E_1\\})\\) 顶点集合 \\(V_1=\\{A, B, C, D\\}\\) 边集合 \\(E_1=\\{(A,B),(B,C),(C,D),(D,A),(A,C)\\}\\) 若从顶点 \\(v_i\\) 到 \\(v_j\\) 的边有方向, 则称这条边为有向边, 也称为弧(Arc). 用有序偶对&lt;\\(v_i\\), \\(v_j\\)&gt;来表示, \\(v_i\\) 称为弧尾(Tail), \\(v_j\\) 称为弧头(Head). 如果图中任意两个顶点之间的边都是有向边, 则称该图为有向图(Directed graphs) TODO: 补充图片 有序对&lt;A,D&gt;, A是弧尾, D是弧头, 不能写成&lt;D,A&gt; 对于有向图 \\(G_2\\) : \\(G_2=(V_2, \\{E_2\\})\\) 顶点集合 \\(V_2=\\{A,B,C,D\\}\\) 弧集合 \\(E_2=\\{&lt;A,D&gt;,&lt;B,A&gt;,&lt;C,A&gt;,&lt;B,C&gt;\\}\\) 无向边用小括号&quot;()“表示, 而有向边用尖括号”&lt;&gt;&quot;表示 在图中, 若同一条边不重复出现(如左图), 且不存在顶点到其自身的边(如右图), 则称这样的图为简单图 TODO: 补充图片 在无向图中, 如果任意两个顶点之间都存在边, 则称该图为无向完全图. 含有n个顶点的无向完全图有 \\(\\frac{n(n-1)}{2}\\) 条边 TODO: 补充图片 在有向图中, 如果任意两个顶点之间都存在方向互为相反的两条弧, 则称该图为有向完全图. 含有n个顶点的有向完全图有 \\(n(n-1)\\) 条边 TODO: 补充图片 有很少条边或弧的图称为稀疏图, 反之称为稠密图. 稀疏和稠密是模糊的概念, 是相对而言的 有些图的边或弧具有权(Weight). 这些权可以表示从一个顶点到另一个顶点的距离或耗费. 这种带权的图通常称为网(Network) TODO: 补充图片 假设有两个图 G=(V,{E}) 和 G’=(V’,{E’}), 如果 V’∈V 且 E’∈E , 则称 G’ 为 G 的子图(Sub-graph) TODO: 补充图片 图的顶点与边间关系 对于无向图 G=(V,{E}) , 如果边 (v, v’)∈E, 则称顶点 v 和 v’ 互为邻接点(Adjacent), 即 v 和 v’ 相邻接. 边 (v,v’) 依附(Incident)于顶点 v 和 v’, 或者说 (v,v’) 与顶点 v 和 v’ 相关联. 顶点 v 的度(Degree)是和 v 相关联的边的数目, 记为 TD(v). 边数是各顶点度数和的一半, 多出的一半是因为重复两次记数, \\(e=\\frac{1}{2}\\displaystyle\\sum_{i=1}^n TD\\{V_i\\}\\) 对于有向图 G=(V,{E}), 如果弧 &lt;v,v’&gt;∈E, 则称顶点 v 和 v’ 互为邻接点. 弧 &lt;v,v’&gt; 和顶点 v, v’ 相关联. 以顶点 v 为头的弧的数目称为 v 的入度(InDegree), 记为 ID(v); 以 v 结尾的弧的数目称为v的出度(OutDegree), 记为 OD(v) 顶点 v 的度为 TD(v)=ID(v)+OD(v), \\(e=\\displaystyle\\sum_{i=1}^n ID\\{V_i\\}=\\displaystyle\\sum_{i=1}^n OD\\{V_i\\}\\) 路径的长度是路径上的边或弧的数目 无向图 G=(V,{E}) 中从顶点 v 到顶点 v’ 的路径(Path)是一个顶点序列 \\(v=v_{i,0},v_{i,1},\\dots,v’=v_{i,m}\\) , 其中 \\((v_{i,j-1},v_{i,j})\\in E, 1\\leqslant j\\leqslant m\\) 如图, 顶点B到D有四种不同路径 如果G是有向图, 则路径也是有向的, 顶点序列应满足 \\(&lt;v_{i,j-1}, v_{i,j}&gt;\\in E, 1\\leqslant j\\leqslant m\\) TODO: 补充图片 第一个顶点和最后一个顶点相同的路径称为回路或环(Cycle). 序列中顶点不重复出现的路径称为简单路径. 除了第一个顶点和最后一个顶点之外, 其余顶点不重复出现的回路, 称为简单回路或简单环 如图, 两图的的粗线都构成环, 左侧属于简单环; 右侧的环由于顶点C的重复不是简单环 TODO: 补充图片 连通图相关术语 在无向图 G 中, 如果从顶点 v 到顶点 v’ 有路径, 则称 v 和 v’ 是连通的. 如果对于图中任意两个顶点 \\(v_i, v_j\\in V\\) , \\(v_i\\) 和 \\(v_j\\) 都是连通的, 则称 G 是连通图(Connected Graph) 如图, 图1显然顶点 A、B、C、D 与顶点 E 或 F 就无路径, 因此不能算是连通图; 图2顶点 A、B、C、D 都是相互连通的, 所以是连通图 TODO:补充图片, 补充下面的图片. (共两张) 无向图中的极大连通子图称为连通分量. 强调: 要是子图 子图是连续的 连通子图含有极大顶点数 具有极大定点数的连通子图包含依附于这些顶点的所有边 比如刚才的图中, 图1是一个无向非连通图. 它有两个连通分量(即图2和图3). 而图4尽管是图1的子图, 但是它不满足连通子图极大顶点数. 因此它不是图1的连通分量 在有向图 G 中, 如果对于每一对 \\(v_i,v_j\\in V \\quad(v_i\\neq v_j)\\) , 从 \\(v_i\\) 到 \\(v_j\\) 和从 \\(v_j\\) 到 \\(v_i\\) 都存在路径, 则称 G 是强连通图. 有向图中的极大强连通子图称作有向图的强连通分量 如图, 图1不是强连通图, 因为 &lt;D,A&gt; 不存在. 图2是强连通图, 且是图1的强连通分量 TODO: 补充图片 连通图的生成树是一个极小连通子图, 它含有图中全部的 n 个顶点, 但只有足以构成一棵树的 n-1 条边 如图, 图1是普通树, 当去掉两条构成环的边后(图2和图3), 就满足 n 个顶点 n-1 条边且连通的定义, 它们都是生成树. 逻辑关系: 多于 n-1 条边 是 构成环 的充分必要条件; 小于 n-1 条边 是 非连通图 的充分必要条件; 等于 n-1 条边 是 生成树 的必要但不充分条件(图4) TODO: 补充图片 如果一个有向图恰好有一个顶点的入读为0, 其余顶点的入度均为1, 则是一个有向树. 入度为 0 相当于树中的根结点, 其余顶点入度为 1 意味着树中非根结点的双亲只有一个. 一个有向图可分解为若干颗不相交的有向树, 它们组成了含有图中全部顶点的生成森林 TODO: 补充图片 总结 按照有无方向: 无向图和有向图 按照边的多少: 稀疏图和稠密图 顶点之间有邻接点的概念, 边有依附的概念. 无向图顶点的边数叫度, 有向图顶点的边分为入度和出度. 图上的边带权则称为网 若路径最终回到起始点称为环, 不重复叫简单路径. 若顶点两两相连， 称为连通图, 有向则称强连通图. 极大连通子图称为连通分量, 有向则称强连通分量 无向图中连通且 n 个顶点 n-1 条边叫生成树. 有向图中一顶点入度为0其余顶点入度为1的叫有向树. 有向图可分解为若干颗有向树构成生成森林 图的抽象数据类型 123456789101112131415161718ADT 图(Graph)Data 顶点的有穷非空集合和边的集合Operation CreateGraph(*G, V, VR) : 按照顶点集合V和边弧集VR的定义构造图G DestroyGraph(*G) : 图G存在则销毁 LocateVex(G, u) : 若图G中存在顶点 u, 则返回图中的位置 GetVex(G, v) : 返回图G中顶点 v 的值 PutVex(G, v, value) : 将图 G 中顶点 v 赋为 value FirstAdjVex(G, *v) : 返回顶点 v 的一个邻接顶点, 若顶点在 G 中无邻接顶点返回 NULL NextAdjVex(G, v, *w) : 返回顶点 v 相对于顶点 w 的下一个邻接顶点, 若 w 是 v 的最后一个邻接点则返回 NULL InsertVex(*G, v) : 在图G中增添新顶点 v DeleteVex(*G, v) : 删除图 G 中顶点 v 及其相关的弧 InsertArc(*G, v, w) : 在图G中增添弧 &lt;v,w&gt;, 若 G 是无向图, 还需要增添对称弧 &lt;w,v&gt; DeleteArc(*G, v, w) : 在图G中删除弧 &lt;v,w&gt;, 若 G 是无向图, 还需要删除对称弧 &lt;w,v&gt; DESTraverse(G) : 对图 G 中进行深度优先遍历, 以在在遍历过程中对每个顶点调用 HFSTraverse(G) : 对图 G 中进行广度优先遍历, 以在在遍历过程中对每个顶点调用endADT 图的存储结构 从图的逻辑结构定义来看, 任意顶点都可看作第一个顶点, 顶点间的逻辑关系与顶点所在位置无关 TODO: 补充图片 邻接矩阵 图的邻接矩阵（Adjacency Matrix)存储方式是用两个数组来表示图. 一个一维数组存储图中顶点信息, 一个二维数组(即邻接矩阵)存储图中的边或弧的信息 设 G 有 n 个顶点, 则邻接矩阵是一个 n×n 的方阵, 定义为: \\(arc[i][j]=\\begin{cases} 1, \\text{若}(v_i, v_j)\\in E \\text{或} &lt;v_i, v_j&gt;\\in E \\\\ 0, 反之 \\end{cases}\\) TODO: 补充图片 顶点数组为 \\(\\text{vertex}[4]=\\{v_0, v_1, v_2, v_3\\}\\) , 边数组 \\(\\text{arc}[4][4]\\) 为右图这样的一个矩阵. 矩阵的主对角线的值全为 0 是因为不存在顶点到自身的边, 无向图的边数组是一个对称矩阵. 对称矩阵就是 n 阶矩阵的元满足 \\(a_{ij}=a_{ji} \\quad(0\\leqslant i, j\\leqslant n)\\) , 即从矩阵左上至右下角的主对角线为轴呈对称关系 特点: 判定任意两顶点是否邻接 要知道顶点 \\(v_i\\) 的度, 可求 \\(v_i\\) 在邻接矩阵中第i行(或第i列)的元素之和(有向图中横向出度统计, 纵向入度统计) 有向图的邻接矩阵 顶点数组为 \\(\\text{vertex}[4]=\\{v_0, v_1, v_2, v_3\\}\\) , 边数组 \\(\\text{arc}[4][4]\\) 为右图这样的一个矩阵. 对角线上数值依旧为0, 此矩阵并不对称 TODO: 补充图片 特点: 有向图讲究入度与出度, 如顶点 \\(v_1\\) 入度为第 i 纵列总和, 出度为第 i 横行总和 判断从顶点 \\(v_i\\) 到 \\(v_j\\) 是否存在弧, 只需要查找矩阵中 arc[i][j] 是否为 1 网图的邻接矩阵 设图 G 是网图, 有 n 个顶点, 则邻接矩阵是一个 n×n 的方阵, 定义为: \\(\\text{arc}[i][j]=\\begin{cases} W_{ij} &amp; \\text{if } (v_i, v_j)\\in E \\text{ or } &lt;v_i, v_j&gt;\\in E \\\\ 0 &amp; \\text{if } i=j \\\\ \\infty &amp; \\text{other} \\end{cases}\\) TODO: 补充图片 ∞ 表示一个计算机允许的、大于所有边上权值的值, 也就是一个不可能的极限值 网图的邻接矩阵存储结构代码: 123456789101112#define MAXVEX 100 // 最大顶点数#define INFINITY 65535 // 用 65535 代替网图邻接矩阵的 ∞typedef char VertexType; // 顶点类型, 假设为 chartypedef int EdgeType; // 边上的权值类型, 假设为 inttypedef struct{ VertexType vexs[MAXVEX]; // 顶点表 EdgeType arc[MAXVEX][MAXVEX]; // 邻接矩阵(边表) int numVertexes, numEdges; // 图的当前顶点数和边数} NGraph; 无向网图的邻接矩阵结构 CreateGraph() : 123456789101112131415161718192021222324void CreateNGraph(NGraph *G){ int i, j, k, w; printf(&quot;输入顶点数和边数:\\n&quot;); scanf(&quot;%d,%d&quot;, &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges); // 给顶点表赋值 for (i = 0; i &lt; G-&gt;numVertexes; i++) scanf(&amp;G-&gt;vexs[i]); // 邻接矩阵初始化 for (i = 0; i &lt; G-&gt;numVertexes; i++) for (j = 0; j &lt; numVertexes; j++) G-&gt;arc[i][j] = INFINITY; for (k = 0; k &lt; G-&gt;numEdges; k++) { printf(&quot;输入边 (v_i, v_j) 的 i、j 和该边的权 w :\\n&quot;); scanf(&quot;%d,%d,%d&quot;, &amp;i, &amp;j, &amp;w); G-&gt;arc[i][j] = w; G-&gt;arc[j][i] = G-&gt;arc[i][j]; // 因为是无向图, 矩阵对称 (有向则没有这句) }} 时间复杂度分析: n 个顶点和 e 条边的无向网图的创建, 时间复杂度为 \\(O(n+n^2+e)\\) 邻接矩阵存储结构对于边数相对顶点较少的图来说极大浪费存储空间 邻接表 数组与链表相结合的存储方法称为邻接表(Adjacency List) 邻接表的处理方法: 顶点用一个一维数组存储. 顶点数组中, 每个元素还有一个指针域, 指向该顶点的第一个邻接点 图中每个顶点的所有邻接点构成一个线性表(存储邻接点在顶点数组中的下标), 由于邻接点的个数不定, 所以用单链表存储 无向图称为顶点 \\(v_i\\) 的边表; 有向图则称为顶点 \\(v_i\\) 的出边表(有向图也可以建立一个逆邻接表, 即为每个顶点建立一个入边表) 对于带权值的网图, 可以在边表顶点定义在再增加一个数据域存储权值 TODO: 补充图片, 补充下一张图片, 补充下一张图片 特点: 要想查某个顶点的度, 就去查这个顶点的边表中顶点的个数. 若要判断顶点 \\(v_i\\) 到 \\(v_j\\) 是否存在边, 只需测试顶点 \\(v_i\\) 的边表中是否存在顶点 \\(v_j\\) 的下标 j . 边表顶点定义代码: 12345678910111213141516171819202122232425#define MAXVEX 100 // 最大顶点数typedef char VertexType; // 顶点类型, 假设为 chartypedef int EdgeType; // 边上的权值类型, 假设为 int// 边表顶点typedef struct EdgeNode{ int adjVex; // 邻接点域, 存储该顶点对应下标 EdgeType weight; // 存储权值, 非网图可以不需要 struct EdgeNode *next;} EdgeNode;// 顶点表元素typedef struct VertexNode{ VertexType data; // 顶点域, 存储顶点信息 EdgeNode *firstEdge; // 该顶点边表的头指针} VertexNode, AdjList[MAXVEX];typedef struct{ AdjList adjList; int numVertexes, numEdges; // 图的当前顶点数和边数} GraphAdjList; 无向图的邻接表结构 CreateGraph() : 123456789101112131415161718192021222324252627282930313233void CreateALGraph(GraphAdjList *G){ int i, j, k; EdgeNode *e; printf(&quot;输入顶点数和边数:\\n&quot;); scanf(&quot;%d,%d&quot;, &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges); for (i = 0; i &lt; G-&gt;numVertexes; i++) { scanf(&amp;G-&gt;adjList[i].data); // 输入顶点信息 G-&gt;adjList[i].firstEdge = NULL; // 初始化边表指针 } for (k = 0; l &lt; G-&gt;numEdges; k++) { printf(&quot;输入边 (v_i, v_j) 上的顶点序号:\\n&quot;); scanf(&quot;%d,%d&quot;, &amp;i, &amp;j); // 创建边表新顶点 e = (EdgeNode*) malloc(sizeof(EdgeNode)); e-&gt;adjVex = j; // 邻接顶点下标为 j // 使用头插法 e-&gt;next = G-&gt;adjList[i].firstEdge; G-&gt;adjList[i].firstEdge = e; // 因为是无向图, 添加对应邻接顶点的边表顶点 (有向则没有下面的内容) e = (EdgeNode*) malloc(sizeof(EdgeNode)); e-&gt;adjVex = i; e-&gt;next = G-&gt;adjList[j].firstEdge; G-&gt;adjList[j].firstEdge = e; }} 时间复杂度分析: 本算法对于 n 个顶点 e 条边来说是 O(n+e) 邻接表的缺陷: 只关心出度问题, 想了解入度就必须遍历整个图 逆邻接表解决了入度却不了解出度的情况 十字链表 把邻接表和逆邻接表结合起来的存储结构叫十字链表(Orthogonal List) TODO: 做成表格 重新定义顶点表顶点结构: data, firstin(指向逆邻接表第一个顶点), firstout(指向邻接表第一个顶点) 重新定义边表顶点结构: tailvex, headvex, headlink, taillink (headlink逆邻接表的下一个顶点, taillink邻接表下一个顶点) TODO: 补充图片(最好把图片改一改, 划分一下区域) 十字链表的优势: 把邻接表和逆邻接表整合在了一起, 容易找到以 \\(v_i\\) 为尾的弧和以 \\(v_i\\) 为头的弧, 容易求得顶点的出度和入度 除了结构复杂一点外, CreateGraph() 的时间复杂度和邻接表相同 邻接多重表 重新定义边表顶点结构: ivex, ilink, jvex, jlink ivex和jvex是某条边依附的两个顶点的下标. link指向依附顶点ivex的下一条边, jlink指向依附顶点jvex的下一条边 ilink指向顶点的jvex一定要和它本身的ivex的值相同 TODO: 补充下下张图片(一张) 邻接多重表和邻接表的区别: 在邻接多重表中同一条边只有一个顶点. 若要删除左图的 \\((v_0, v_2)\\) 这条边, 只需要将右图的 ⑥⑨ 的链接改为 ∧ 即可 边集数组 边集数组是由两个一维数组构成. 一个存储顶点的信息(vexs[MAXVEX]); 另一个存储边的信息(edges[MAXEDGE]) TODO: 做成表格 边数组中每个元素的结构: begin, end, weight TODO: 补充图片 边集数组关注的是边的集合, 在边集数组中要查找一个顶点的度需要扫描整个边数组, 效率并不高. 因此他更适合对边依次进行处理的操作, 而不适合对顶点相关的操作 图的遍历 从图中某一顶点出发访遍图中其余顶点且每个顶点仅被访问一次, 这一过程称为图的遍历(Traversing Graph) 深度优先遍历(Depth First Search) 也称深度优先搜索, 简称DFS. 类似于树的前序遍历 (深度优先指的是: 优先找邻接点, 贯穿整个图) 从图中某个顶点 \\(v_i\\) 出发, 然后从 \\(v_i\\) 周围的(未被访问的)邻接点 \\(v_j\\) 出发找邻接点, 重复此过程直至图中所有和 \\(v_i\\) 有路径相通的顶点都被访问到. 以上说的只是连通图, 对于非连通图, 只需要对它的连通分量分别进行深度优先遍历. 即进行一次深度优先遍历后, 若图中尚有顶点未被访问, 则另选图个一个未被访问的顶点作为起始点, 再次进行深度优先遍历. 重复此过程直到所有顶点都被访问过 访问数组 visited[n], n 是图中顶点的个数, 数组中元素初值为 0, 访问后为 1 邻接矩阵的深度优先遍历算法: 12345678910111213141516171819202122232425262728293031typedef enum { false, true } bool; // C++ 中自带 bool 类型, 可以不用这句bool visited[MAX]; // MAX 等于图的 numVertexes// 邻接矩阵的深度优先递归算法, i 为当前遍历顶点的下标void DFS(MGraph G, int i){ int j; visited[i]=true; printf(&quot;%c&quot;, G.vexs[i]) // 打印顶点数据, 也可以是其他操作 for (j = 0; j &lt; G.numVertexes; j++) { if (G.arc[i][j] == 1 &amp;&amp; !visited[j]) // 找任何与 v_i 邻接的邻接点(未被访问过的) DFS(G, j); // 对要访问的邻接点递归调用 DFS() }}// 从这个函数开始void DFSTraverse(MGraph G){ int i; // 初始化 visited 数组 for (i = 0; i &lt; G.numVertexes; i++) visited[i] = false; for (i = 0; i &lt; G.numVertexes; i++) if (!visited[i]) DFS(G, i); // 对未访问过的顶点调用 DFS() (若是连通图这行代码只会执行一次)} 对于邻接表结构的图, DFS() 会稍有不同 邻接表的深度优先遍历算法: 123456789101112131415161718192021222324252627282930313233typedef enum { false, true } bool; // C++ 中自带 bool 类型, 可以不用这句bool visited[MAX]; // MAX 等于图的 numVertexes// i 为当前遍历顶点的下标void DFS(GraphAdjList GL, int i){ EdgeNode *p; visited[i] = true; printf(&quot;%c&quot;, GL-&gt;adjList[i].data); p = GL-&gt;adjList[i].firstEdge; while (p) { if (!visited[p-&gt;adjVex]) DFS(GL, p-&gt;adjvex); // 对要访问的邻接点递归调用 DFS() p = p-&gt;next; }}void DFSTraverse(GraphAdjList GL){ int i; // 初始化 visited 数组 for (i = 0; i &lt; GL-&gt;numVertexes; i++) visited[i] = false; for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (!visited[i]) DFS(GL, i); // 对未访问过的顶点调用 DFS() (若是连通图这行代码只会执行一次)} 时间复杂度分析: 如果是邻接矩阵结构表示的图, 每次找邻接点都需要把顶点下标遍历一遍, 时间复杂度 \\(O(n^2)\\) 而邻接表结构表示的图, 找邻接点所需时间取决于该顶点的出边数量, 时间复杂度 \\(O(n+e)\\) 对于点多边少的稀疏图来说, 邻接表结构的优势更大 广度优先遍历(Breadth First Search) 也称广度优先搜索, 简称BFS. 类似于树的层序遍历 如图, 将第一幅图稍微变形. 规则是顶点 A 放置在最上第一层, 使与它邻接的顶点 B、F 为第二层, 再让与 B 和 F 邻接的 C、I、G、E 为第三层, 再将与这四个顶点邻接的 D、H 放在第四层. TODO: 补充图片 邻接矩阵的广度优先遍历算法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344typedef enum { false, true } bool; // C++ 中自带 bool 类型, 可以不用这句bool visited[MAX]; // MAX 等于图的 numVertexesvoid BFSTraverse(MGraph G){ int i, j, k; Queue Q; // 临时存储顶点下标用队列 // 初始化 visited 数组 for (i = 0; i &lt; G.numVertexes; i++) visited[i] = false; InitQueue(&amp;Q); // 初始化队列 for (i = 0; i &lt; G.numVertexes; i++) { if (!visited[i]) // 对未访问过的顶点进行广度优先遍历 (若是连通图 if 内的代码只会执行一次) { // 将起始顶点进行打印等操作后加入队列 visited[i] = true; // 将当前顶点设置为被访问过 printf(&quot;%c&quot;, G.vexs[i]); // 打印顶点, 也可以是其他操作 EnQueue(&amp;Q, i); // 将此顶点加入队列 while (!QueueEmpty(Q)) // 若当前队列不为空 { DeQueue(&amp;Q, &amp;k); // 将队列中元素取出赋给变量 k for (j = 0; j &lt; G.numVertexes; j++) { if (G.arc[k][j] == 1 &amp;&amp; !visited[j]) // 遍历当前顶点 v_k 的邻接点并加入队列 { visited[j] = true; // 将找到的邻接点设置为已访问 printf(&quot;%c&quot;, G.vexs[j]); // 打印顶点, 也可以是其他操作 EnQueue(&amp;Q, j); } } } } }} 邻接矩阵的广度优先遍历算法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef enum { false, true } bool; // C++ 中自带 bool 类型, 可以不用这句bool visited[MAX]; // MAX 等于图的 numVertexesvoid BFSTraverse(GraphAdjList GL){ int i; EdgeNode *p; Queue Q; // 临时存储顶点下标用队列 // 初始化 visited 数组 for (i = 0; i &lt; GL-&gt;numVertexes; i++) visited = false; InitQueue(&amp;Q); for (i = 0; i &lt; GL-&gt;numVertexes; i++) { if (!visited[i]) { visited[i] = true; printf(&quot;%c&quot;, GL-&gt;adjList[i].data); // 打印顶点, 也可以是其他操作 EnQueue(&amp;Q, i); // 起始顶点加入队列 while (!QueueEmpty(Q)) { DeQueue(&amp;Q, &amp;i); // 遍历该顶点的边表 p = GL-&gt;adjList[i].firstEdge; while (p) { if (!visited[p-&gt;adjVex]) // 若此顶点未被访问 { visited[p-&gt;adjVex] = true; printf(&quot;%c&quot;, GL-&gt;adjList[p-&gt;adjVex].data); // 打印顶点, 也可以是其他操作 EnQueue(&amp;Q, p-&gt;adjVex); // 将此顶点加入列 } p = p-&gt;next; } } } }} 时间复杂度分析: 图的深度优先算法的时间复杂度和广度优先算法一样, 不同之处仅在于对顶点的访问次序. 深度优先算法更适合目标比较明确的, 以找到目标为主要目的的情况; 而广度优先算法更适合在不断扩大的遍历范围时找到相对最优解的情况 最小生成树 最小生成树: 将一个连通加权无向图变为生成树(即只剩 n-1 条边), 其中权值总和最小的生成树就叫最小生成树 普里姆(Prim)算法 TODO: 补充图片 思路: 设 adjVex[j] 存储当前到顶点 j 权值最小的顶点, lowCost[j] 存储当前已知的到顶点 j 最小的权值. 将 adjVex 和 lowCost 初始化为顶点 v_0 到其他点的权值(读取邻接矩阵第 v_0 行) 从 v_0 开始, 将 v_0 到附近顶点的权重计入数组 lowCost, 将 lowCost 中权重最小的下标作为最小生成树的下一个顶点(假设为 v_k) 再将 v_k 到附近的点(假设为 v_j)的权重与当前数组 lowCost[j] 对应的值比较, 如果 v_k 到 v_j 的权重更小则计入 lowCost[j]. 重复, 将 lowCost 中权重最小的下标作为生成树的下一个顶点…直到所有顶点都被纳入最小生成树中(每次循环增加一个顶点, 所以循环 MAXVEX 次). 实现代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#define INFINITY 65535// Prim 算法生成最小生成树void MiniSpanTree_Prim(MGraph MG){ int min, i, j, k; int adjVex[MAXVEX]; // 存储当前到顶点 j 权值最小的顶点 int lowCost[MAXVEX]; // 存储当前已知的到顶点 j 最小的权值. adjVex[0] = 0; // 初始顶点为 v_0 顶点 lowCost[0] = 0; // 值为 0 表示该顶点被纳入最小生成树 for (i = 1; i &lt; MG.numVertexes; i++) // 遍历除下标为0外的全部顶点 { lowCost[i] = MG.arc[0][i]; // 读取矩阵第一行数据赋给lowCost adjVex[i] = 0; } for (i = 1; i &lt; MG.numVertexes; i++) { min = INFINITY; k = 0; // 从 lowCost 找当前最小的权值, 以作为生成树的下一个顶点(设下一个顶点为 v_k) for (j = 1; j &lt; MG.numVertexes; j++) { if (lowCost[j] != 0 &amp;&amp; lowCost[j] &lt; min) // lowCost[j] != 0 排除已纳入最小生成树的顶点 { min = lowCost[j]; k = j; } } printf(&quot;(%d, %d)&quot;, adjVex[k], k); // 打印最小生成树的边, 可以是其他操作 lowCost[k] = 0; // 将 v_k 纳入最小生成树中 // 找 v_k 到邻接点的权值, 如果更小则更新 lowCost 和 adjVex for (j = 1; j &lt; MG.numVertexes; j++) { // 如果顶点 v_k 到附近的邻接点权值比起始点到那个点小 if (lowCost[j] != 0 &amp;&amp; MG.arc[k][j] &lt; lowCost[j]) // 查找邻接矩阵第 k 行的各个权值 { adjVex[j] = k; // 从 v_k 点到 v_j 点权值更低 lowCost[j] = MG.arc[k][j]; // 设置当前到 v_j 的最小权值 } } }} 时间复杂度分析: 由算法代码中的循环嵌套可得知此算法的时间复杂度为 \\(O(n^2)\\) 克鲁斯卡尔(Kruskal)算法 将邻接矩阵转化为右图所示的边集数组, 将它们按权值从小到大排序, 且 begin &lt; end 然后按权值从小到大的顺序开始生成最小生成树, 如果这条边的两个顶点都已经被纳入最小生成树(即这两个顶点已经相通), 跳过这条边 TODO: 补充图片 如何判断两个顶点已经相通呢? 使用并查集思想, 见下面具体代码 实现代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243// 边集数组 Edge 的元素结构typedef struct{ int begin; int end; int weight;} Edge;// 查找该顶点的最终好友int Find(int *buddy, int f){ while (buddy[f] &gt; 0) // 如果该顶点有好友(好友指可以不邻接但是已经连通) f = buddy[f]; // 从它的好友开始继续判断还有无别的好友 return f;}// Kruskal 算法生成最小生成树void MiniSpanTree_Kruskal(MGraph G){ int i, n, m; Edge edges[MAXEDGE]; // 边集数组, MAXEDGE 为原图的边数 int buddy[MAXVEX]; // 定义数组 buddy 来帮助判断边与边是否形成环路 // 这里用到了并查集思想 // 即 buddy[a]==c, buddy[b]==d, 若 buddy[c]==buddy[d] 则说明 a 已经连通 b // 初始化数组 buddy for (i = 0; i &lt; G.numVertexes; i++) { buddy[i] = 0; // 初始化为 0 是因为边集的 end 不可能是 0 } // 依次遍历 edge 数组 for (i = 0; i &lt; G.numEdges; i++) { n = Find(buddy, edges[i].begin); m = Find(buddy, edges[i].end); if (n != m) // n != m 代表这条边两个顶点的最终好友不同(所以还未连通) { buddy[n] = m; // 将这两个顶点建立好友关系 printf(&quot;(%d, %d) %d&quot;, edges[i].begin, edges[i].end, edges[i].weight) // 打印最小生成树的边, 可以是其他操作 } }} 实际复杂度分析: 设 n 为边数, 克鲁斯卡尔算法的时间复杂度为 \\(O(n\\log n)\\) (其中 Find() 函数时间花费 \\(O(\\log n\\)) 克鲁斯卡尔算法主要是针对边来展开, 边数少时效率会非常高, 对于稀疏图有很大的优势; 普里姆算法对于稠密图, 即边数非常多的情况会更好一些 最短路径 非网图的最短路径, 是指两顶点之间经过的边数最少的路径; 网图的最短路径是指两顶点之间经过的边上权值之和最少的路径. 称路径上的第一个顶点是源点, 最好一个顶点是终点 距离就是两顶点间权值之和, 非网图可理解为所有边权值都为 1 的网图 迪杰斯特拉(Dijkstra)算法 思路 设起始点为 v_0, PathWeight 存储 v_0 到各点的最短路径权值和, PathPrior[w] 存储 v_0 到 v_w 最短路径中 v_w 的前驱 从 v_0 开始, 首先找到 v_0 权值最小的邻接点 v_k, 将其纳入最短路径并接着找 v_k 的邻接点, 继而将 v_k 的邻接点到 v_0 路径的权值纳入 PathWeight (别忘了同时更新 PathPrior) 这样一番操作之后, v_0 到 v_k 的那些邻接点的权值就不再是 ∞ 了(即被认为和 v_0 连通), 继续按照这种方式遍历剩下的和 v_0 连通的顶点和它们的邻接点, 发现权值和更小的就更新 PathWeight 和 PathPrior. 直到所有顶点都被纳入最短路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#define MAXVEX 9#define INFINITY 65535typedef int PathPrior[MAXVEX] // 用于存储最短路径对应顶点前驱的数组, 即 PathPrior[w] == k 代表从 v_0 到 v_w 的最短路径中, v_w 的前驱是 v_k (接着持续遍历即可得到完整的最短路径)typedef int PathWeight[MAXVEX]; // 用于存储到各点最短路径的权值和// v_0 为起始点, PathPrior 为用于存储到各个点最短路径的数组, void ShortestPath_Dijkstar(MGraph G, int v_0, PathPrior pathPrior, PathWeight pathWeight){ int v, w, k, min; int final[MAXVEX]; // 标记已求得最短路径的顶点, final[w] = 1 表示已经求得顶点v_0到 v_w 的最短路径 // 初始化这三个数组 for (v = 0; v &lt; G.numVertexes; v++) { final[v] = 0; pathWeight[v] = G.arc[v_0][v]; // 将 v_0 到各点的权值依次赋给 pathWeight pathPrior[v] = 0; } final[v_0] = 1; // v_0 到 v_0 不需要路径 for (v = 1; v &lt; G.numVertexes; v++) { min = INFINITY; // 遍历 v_0 当前到各个顶点的权值, 记录 v_0 权值最小的(未被记录到路径中的)邻接点 for (w = 0; w &lt; G.numVertexes; w++) { if (!final[w] &amp;&amp; pathWeight[w] &lt; min) { k = w; min = pathWeight[w]; } } final[k] = 1; // 将此邻接点纳入最小路径 // 此时 v_k 为 v_0 附近(刚纳入最小路径)权值最小的邻接点 for (w = 0; w &lt; G.numVertexes; w++) { // 遍历 v_k 到各点(设为 v_w)的权值, 加上 v_i 到 v_k 的权值, 然后与 pathWeight 当前存储的到 v_w 的值比较 // 如果比现有记录的短, 更新到 pathWeight 和 pathPrior 中 if (!final[w] &amp;&amp; (G.arc[k][w] + min &lt; pathWeight[w])) { pathWeight[w] = min + G.arc[k][w]; pathPrior[w] = k; } } }} 时间复杂度分析: 从嵌套循环得到此算法的时间复杂度为 \\(O(n^2)\\) 弗洛伊德(Floyd)算法 该算法可求得图中任意顶点到顶点间的最短路径, 用矩阵(二维数组) PathMatrix 和 PathWeight 存储 原理也很简单, 具体实现如下: 123456789101112131415161718192021222324252627282930313233typedef int PathMatrix[MAXVEX][MAXVEX];typedef int PathWeight[MAXVEX][MAXVEX];void ShortestPath_Floyd(MGraph G, PathMatrix pathMatrix, PathWeight pathWeight){ int v, w, k; for (v = 0; v &lt; G.numVertexes; v++) { for (w = 0; w &lt; G.numVertexes; w++) { pathWeight[v][w] = G.arc[v][w]; // 初始化与网图的邻接矩阵保持一致 pathMatrix[v][w] = w; // 初始化为 pathMatrix[v][j] == j } } // 每次试探一个中继顶点都会将表中所有顶点间的当前路径检测一遍, 所有不用担心会有漏的. (因此嵌套顺序不能变) for (k = 0; k &lt; G.numVertexes; k++) { for (v = 0; v &lt; G.numVertexes; v++) { for (w = 0; w &lt; G.numVertexes; w++) { // 如果从 v_v 到 v_w, 经过下标为 k 的顶点路径比当前记录的更短 if (pathWeight[v][w] &gt; pathWeight[v][k] + pathWeight[k][w]) { pathWeight[v][w] = pathWeight[v][k] + pathWeight[k][w]; pathMatrix[v][w] = pathMatrix[v][k]; // 路径设置经过顶点 k } } } }} 输出弗洛伊德算法得到的最短路径: 12345678910111213141516for (v = 0; v &lt; G.numVertexes; v++){ for (w = v + 1; w &lt; G.numVertexes; w++) { printf(&quot;v%d-v%d weight: %d&quot;, v, w, pathWeight[v][w]); // 打印这条最短路径的权 k = pathMatrix[v][w]; printf(&quot; path: %d&quot;, v); // 打印源点 while (k != w) // 如果路径顶点不是终点 { printf(&quot; -&gt; %d&quot;, k); // 打印路径顶点 k = pathWeight[k][w]; // 获得下一个路径顶点 } printf(&quot; -&gt; %d\\n&quot;, w); // 循环结束, 说明抵达终点, 打印终点 } printf(&quot;\\n&quot;);} 时间复杂度分析: 时间复杂度为 \\(O(n^3)\\) 拓补排序 拓扑排序介绍 无环: 没有回路的图 AOV 网(Activity On Vertex Network): 用顶点表示活动, 用弧表示活动之间的优先关系. AOV 网中不能存在回路, 属于有向无环图 如图所示就是一个 AOV 网(图中省略了权值)和它的邻接表形式数据结构 TODO: 补充图片(在拓扑排序算法那里) 拓扑序列: 设 G=(V, E) 是一个具有 n 个顶点的有向图 满足若从顶点 \\(v_i\\) 到 \\(v_j\\) 有一条路径, 则在顶点序列 V 中 \\(v_i\\) 必在 \\(v_j\\) 之前. 称 V 为拓扑序列 拓扑排序: 对一个有向图构造拓扑序列的过程. 构造时会有两个结果: 如果此网的全部顶点都被输出, 说明这个网图不存在环(回路), 是 AOV 网 如果输出顶点数少了, 说明这个网图存在环(回路), 不是 AOV 网 拓扑排序算法 拓扑排序的基本思路是: 从网中选择一个入度为 0 的顶点输出, 然后删去此顶点, 并删除此顶点的出边, 继续重复此步骤, 直到输出全部顶点(是 AOV 网)或者网中不存在入度为 0 的顶点为止(不是 AOV 网) 以邻接表形式表达该网图. 考虑到算法要查找入度为 0 的顶点, 因此在原来的顶点表结点结构中, 增加一个入度域 in 以记录一个顶点的入度: 12345678910111213141516171819typedef struct EdgeNode // 边表结点{ int adjVex; int weight; struct EdgeNode *next;} EdgeNode;typedef struct VertexNode // 顶点表结点{ int in; // 增加了这个入度域 int data; EdgeNode *firstEdge;} VertexNode, AdjList[MAXVEX];typedef struct{ AdjList adjList; int numVertexes, numEdges;} GraphAdjList; 在算法中还需要栈来存储处理过程中入度为 0 的顶点, 目的是避免每次查找时都要遍历顶点表中有没有入度为 0 的顶点. 实现代码如下: 123456789101112131415161718192021222324252627282930313233int TopoLogicalSort(GraphAdjList GL){ EdgeNode *e; int i, k, gettop; // gettop 存储当前出栈元素 int top = -1; // 栈的 top 指针 int count = 0; // 用于统计输出顶点数 int *stack = (int*) malloc(GL-&gt;numVertexes * sizeof(int)); // 用于存储入度为 0 的顶点, 根据顶点数分配内存空间 // 遍历顶点表, 将入度为 0 的顶点入栈 for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (GL-&gt;adjList[i].in == 0) stack[++top] = i; while (top != -1) { gettop = stack[top--]; // 出栈 count++; // 统计输出顶点数 printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data); // 打印此顶点, 可更改为其他操作 for (e = GL-&gt;adjList[gettop].firstEdge; e; e = e-&gt;next) // 遍历此顶点的出边(中的邻接点) { k = e-&gt;adjVex; if (--GL-&gt;adjList[k].in == 0) // 若失去此顶点后邻接点的入度变为 0, 将邻接点也加入到栈中 stack[++top] = k; } } if (count &lt; GL-&gt;numVertexes) // 如果count小于顶点数, 说明存在环, 不是 AOV 网 return -1; else return OK;} 时间复杂度分析: 对于具有 n 条顶点 e 条弧的网图, 时间复杂度为 O(n+e) 关键路径 AOE 网(Activity On Edge Network): 用顶点表示时间, 用有向边表示活动, 用边上的权值表示活动的持续时间. AOE 网是有向图 AOE 网中没有入边的顶点称为始点或源点, 没有出边的顶点称为终点或汇点 如图, \\(v_0\\) 是源点, 表示一个工程的开始, \\(v_9\\) 是汇点, 表示整个工程的结束, 顶点 \\(v_0, v_1, \\dots, v_9\\) 分别表示事件, 弧 \\(&lt;v_0, v_1&gt;\\), \\(&lt;v_0, v_2&gt;\\), …, \\(&lt;v_8, v_9&gt;\\) 都表示一个活动, 用 \\(a_0, a_1, \\dots, a_12\\) 表示, 它们的值(权值)代表着活动持续的事件 TODO: 补充图片 AOV 与 AOE 的区别 AOV 用顶点表示活动, 它只描述活动之间的制约关系; AOE 用边表示活动, 要建立在活动之间制约关系没有矛盾的基础之上. 用于分析完成整个工程至少需要多少时间, 或者为了缩短工程所需时间, 应当加快哪些活动等问题. TODO: 补充图片(2张) 关键路径: 从源点到汇点具有最大长度的路径叫关键路径 关键路径算法原理 定义如下几个参数: 事件最早发生时间 etv (earliest time of vertex) 事件最晚发生时间 ltv (latest time of vertex) 活动最早开工时间 ete (earliest time of edge) 活动最晚开工时间 lte (latest time of edge) 某条路径上的活动, 最早开工时间和最晚开工时间如果相等意味着该路径上的活动不可延后, 是关键活动, 该路径为关键路径 由 1 和 2 可以求得 3 和 4, 然后根据 ete[k] 是否与 lte[k] 相等来判断 \\(a_k\\) 是否是关键活动 关键路径算法 以邻接表结构表达 AOE 网, 弧链表增加了 weight 域, 用来存储弧的权 TODO: 补充图片 计算顶点 \\(v_k\\) 的 etv[k] 的数学定义是: TODO: 补充图片 求事件最早发生事件 etv 的过程, 可放在拓扑排序算法中. 因此在求关键路径之前, 需要先调用一次拓扑排序算法来得到 etv 和拓扑序列列表. 秘诀: 从前面加权是最早时间, 从后面减权是最晚时间 实现代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091int *etv, *ltv; // 事件最早发生时间和最晚发生时间数组int *stack2; // 用于存储拓扑序列的栈int top2; // 用于栈 stack2 的指针// 改进过的拓扑排序算法int TopoLogicalSort(GraphAdjList GL){ EdgeNode *e; int i, k, gettop; int top = -1; // 栈的 top 指针 int count = 0; // 用于统计输出顶点个数 int *stack = (int*) malloc(GL-&gt;numVertexes * sizeof(int)); // 用于存储入度为 0 的顶点, 根据顶点数分配内存空间 // 遍历顶点表, 将当前入度为 0 的顶点入栈 for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (GL-&gt;adjList[i].in == 0) stack[++top] = i; etv = (int*) malloc(GL-&gt;numVertexes * sizeof(int)); // 给 etv 分配空间 for (i = 0; i &lt; GL-&gt;numVertexes; i++) etv[i] = 0; // 初始化 etv 数组, 每个顶点的 etv 默认为 0 stack2 = (int*) malloc(GL-&gt;numVertexes * sizeof(int)); // 给存储拓扑序列的栈分配空间 top2 = -1; // 空栈的 top 指针默认为 -1 while (top != -1) { gettop = stack[top--]; // 将入度为 0 的顶点出栈 count++; stack2[++top2] = gettop; // 将弹出的顶点下标压入存储拓扑序列的栈 stack2 中 // 遍历当前顶点的弧链表, 看是否有失去当前结点后入度为 0 的邻接点 for (e = GL-&gt;adjList[gettop].firstEdge; e; e = e-&gt;next) { k = e-&gt;adjVex; // k 为当前顶点的邻接点 if (--GL-&gt;adjList[k].in == 0) // 若 k 的入度 -1 后为 0 stack[++top] = k; // 入栈 // 若当前顶点(gettop)的 etv 加上当前顶点到 k 所需的时间大于已记录的 etv[k] if ((etv[gettop] + e-&gt;weight) &gt; etv[k]) etv[k] = etv[gettop] + e-&gt;weight; // 更新 etv[k], 因为 k 的前置活动(顶点 gettop)首先要完成 } } if (count &lt; GL-&gt;numVertexes) // 如果 count 小于顶点数, 说明存在环 return -1; else return OK;}void CriticalPath(GraphAdjList GL){ EdgeNode *e; int i, gettop, k, j; int ete, lte; // 活动最早发生时间和最晚发生时间 TopoLogicalSort(GL); // 求拓扑序列, 得到 etv 和 stack2 ltv = (int*) malloc(GL-&gt;numVertexes * sizeof(int)); // 事件的最晚发生时间 for (i = 0; i &lt; GL-&gt;numVertexes; i++) ltv[i] = etv[GL-&gt;numVertexes - 1]; // 初始化 ltv 数组, 每个顶点的 ltv 默认为最后一个事件发生的时间 while (top2 != -1) { gettop = stack2[top2--]; // 拓扑序列出栈(序列从后往前遍历) // 遍历顶点 gettop 的弧链表 for (e = GL-&gt;adjList[gettop].firstEdge; e; e = e-&gt;next) { k = e-&gt;adjVex; // 顶点 k 为顶点 gettop 的下一个事件 // 若该顶点 gettop 到下一个顶点 k 的最晚时间小于当前记录的最晚发生时间 if (ltv[k] - e-&gt;weight &lt; ltv[gettop]) ltv[gettop] = ltv[k] - e-&gt;weight; // 更新 ltv[gettop] } } for (j = 0; j &lt; GL-&gt;numVertexes; j++) { for (e = GL-&gt;adjList[j].firstEdge; e; e = e-&gt;next) { k = e-&gt;adjVex; ete = etv[j]; // 活动(当前的弧)最早开工时间等于(当前弧尾)最早发生时间 lte = ltv[k] - e-&gt;weight; // 活动(当前的弧)最晚开工时间 为 下个事件(弧头)的最晚发生事件减去当前活动所需时间 if (ete == lte) // 如果最早开工时间和最晚开工时间相同(开工时间无法延后), 说明当前路径为关键路径 printf(&quot;&lt;v%d, v%d&gt; length: %d, &quot;, GL-&gt;adjList[j].data, GL-&gt;adjList[k].data, e-&gt;weight); } }} 时间复杂度分析: 拓扑排序 \\(O(n+e)\\) + 初始化 ltv \\(O(n)\\) + 求 ltv \\(O(n+e)\\) + 检测是否关键路径 \\(O(n+e)\\) 所以最早时间复杂度依然是 \\(O(n+e)\\) 查找 查找概论 查找(Searching)就是根据给定的值, 在查找表中确定给定值与记录的关键字相同的记录(数据元素) 关键字(Key): 记录中某个数据项的值, 又称键值 主关键字(Primary Key): 唯一地标识一个记录的关键字(用主关键字查找只会返回唯一的一条记录) 次关键字(Secondary Key): 多个记录共有的关键字(用次关键字查找会返回所有含有该关键字的记录) 查找表(Search Table): 由同一类型的记录构成的集合 静态查找表(Static Search Table): 只作查找操作的查找表 动态查找表(Dynamic Search Table): 可在查找过程的同时插入查找表中不存在的记录, 或者从查找表中删除已存在的某个记录 顺序表查找 顺序查找(Sequential Search)又叫线性查找, 是最基本的查找技术 查找过程是: 从表中第一个(或最后一个)记录开始, 逐个进行对给定值和记录的关键字比较 若某个记录的关键字和给定值相等, 则查找成功, 找到所查的记录 如果直到最后一个(或第一个)记录, 没有与给定值相等的关键字, 则表中没有所查的记录, 查找失败 顺序表查找算法:12345678910int Sequential_Search(int *searchTable, int length, int key){ int i; for (i = 1; i &lt;= length; i++) if (searchTable[i] == key) return i; // 若查找成功, 返回查找到的记录在记录表中的下标 return -1; // 查找不成功} 顺序表查找优化 设置一个哨兵, 可以免去 for 循环本身的比较12345678910111213// 查找表 searchTable 的第一个下标需要预留给哨兵int Sequential_Search(int *searchTable, int length, int key){ int i; searchTable[0] = key; // 设置哨兵, 它的关键字为给定值 // 循环从数组尾部开始 i = length - 1; while (searchTable[i] != key) i--; return i; // 若返回的是哨兵的未知(下标0), 说明查找失败} 时间复杂度分析: 时间复杂度为 \\(O(n)\\), 顺序查找算法在 n 很大时, 查找效率极为低下. 优点是算法非常简单, 对静态查找表的记录没有任何要求. 在一些小型数据的查找时, 是可以适用的. 如果对表进行排序, 将查找频率高的记录放在前面, 不常用的放在后面, 效率可以大幅提高. 有序表查找 折半查找(Binary Search)技术, 又称为二分查找. 前提是线性表中的记录必须是关键字有序(通常从小到大有序), 且线性表必须采用顺序存储. 折半查找的思想: 在有序表中, 取中间记录作为比较对象, 若给定值与中间记录的关键字相等, 则查找成功; 若给定值小于中间记录的关键字, 则在中间记录的左半区继续查找; 若给定值大于中间记录的关键字, 则在中间记录的右半区继续查找. 不断重复上述过程, 直到查找成功, 或者没有所查的记录, 查找失败 实现代码如下: 1234567891011121314151617181920int Binary_Search(int *searchTable, int length, int key){ int low, high, mid; low = 0; // 定义最低下标为查找表首位 high = length - 1; // 定义最高下标为查找表末尾 while (low &lt;= high) { mid = (low + high) / 2; // 折半 if (key &lt; searchTable[mid]) // 若给定值比当前中值小 high = mid - 1; else if (key &gt; searchTable[mid]) // 若给定值比当前中值小大 low = mid + 1; else return mid; // 若相等返回该下标 } return -1; // 循环结束, 没有找到所查记录, 查找失败} 折半算法的时间复杂度为 \\(O(\\log n)\\) 插值查找(Interpolation Search) 折半查找可改进为 \\(\\text{mid}=\\text{low}+\\frac{\\text{key}-\\text{searchTable[low]}}{\\text{searchTable[high]-searchTable[low]}}(\\text{high}-\\text{low})\\) 即通过计算 key 在当前 (high-low) 这段中的大致位置, 可以更快的跳转到目标位置. 在折半查找算法的代码中改动如下 12- mid = (low + high) / 2; // 折半+ mid = low + (key - searchTable[low]) / (searchTable[high] - searchTable[low]) * (high - low) 插值查找时间复杂度同样为 \\(O(\\log n)\\) 对于表长较大, 关键字分布又比较均匀的查找表, 插值查找算法的平均性能比折半查找要好得多 斐波那契查找 根据斐波那契数列的性质来二分 TODO: 补充图片(需要将图中-1的部分修掉) 1234567891011121314151617181920212223242526272829303132333435363738// Fibonacci[k] 为斐波那契数列, | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 | 89 | 144 |int Fibonacci_Search(int *searchTable, int length, int key){ int low, high, mid, i, k; low = 0; high = length - 1; k = 0; while (length &gt; Fibonacci[k] - 1) // 取得 n 位于斐波那契数列中的位置 k++; for (i = length, i &lt; Fibonacci[k]; i++) // 数组的大小要与斐波那契查找对应值相等, 将不满的用最后一个记录的值补全 searchTable[i] = searchTable[length - 1]; while (low &lt;= high) { mid = low + Fibonacci[k - 1]; if (key &lt; searchTable[mid]) // 若查找记录小于当前分隔记录 { high = mid - 1; k--; // 斐波那契数列下标减一位 } else if (key &gt; searchTable[mid]) // 若查找记录大于当前分隔记录 { low = mid + 1; k -= 2; // 斐波那契数列下标减两位, 因为Fibonacci[k-2]+Fibonacci[k-1]=Fibonacci[k] } else { if (mid &lt;= length) return mid; // 若相等则说明 mid 即为查找到的位置 else return length - 1; // 若 mid &gt; n 说明是补全数值, 返回 n } } return -1;} 时间复杂度同样为 \\(O(\\log n)\\) 就平均性能来说, 斐波那契查找要优于折半查找. 如果是最坏情况， 比如要查找的记录在查找表的极左侧, 则斐波那契查找效率要低于折半查找. 线性索引查找 索引: 把一个关键字与它对应的记录相关联的过程, 一个索引由若干个索引项构成, 每个索引项至少应包含关键字和其对应的记录在存储器中的位置信息. 线性索引: 将索引项集合组织为线性结构, 也称为索引表 稠密索引 每个记录对应一个索引项的叫稠密索引 对于稠密索引表来说, 索引项一定是按照关键字有序的排列. TODO: 补充图片 分块索引 把数据集中的记录分为若干块, 将每块对应一个索引项, 并且这些块需要满足两个条件: 块内无序, 每一块内的记录不要求有序 块间有序, 比如第二块中所有记录的关键字都要大于第一块中所有记录的关键字 分块索引表的索引项结构分三个域: 最大关键字, 存储块中最大关键字(特性: 下一块中的最小关键字也比这一块中最大的关键字要大) 块长, 即块中有多少记录 指针域, 指向关联的块 TODO: 补充图片 在分块索引表中查找分两步进行: 在分块索引表中查找给定值所在的块. 由于分块索引表是块间有序的, 可利用折半、插值等算法确定目标记录所在的块. 在块中顺序查找关键码. 因为块内无序, 只能顺序查找. 分块索引的平均查找长度: 设 n 个记录的数据集被平均分成 m 块, 每个块中有 t 条记录, 显然 \\(m=\\frac{n}{t}\\) . \\(L_b\\) 为在索引表查找块的平均查找长度, 因最好(1 次)与最差(m 次)的等概率原则, \\(L_b\\) 的平均长度为 \\(\\frac{1+m}{2}\\) . \\(L_w\\) 为在块中查找记录的平均查找长度, 同理可知平均查找长度为 \\(\\frac{1+t}{2}\\) . 这样分块索引查找的平均查找长度 \\(ASL_w\\) 为: \\(ASL_w=L_b+L_w=\\frac{1+m}{2}+\\frac{1+t}{2}=\\frac{1}{2}(m+t)+1=\\frac{1}{2}(\\frac{n}{t}+t)+1\\) 最佳情况是分的块数与块中记录相等(即 \\(m=t\\) )， 此时 \\(n=m\\cdot t=t^2\\) \\(ASL_w=\\frac{1}{2}(\\frac{n}{t}+t)+1=t+1=\\sqrt{n}+1\\) 倒排索引 多个次关键字指向同一个记录, 一个次关键字指向多个记录 索引项的通用结构是: 次关键字, 如图中的&quot;英文单词&quot; 记录号表, 存储具有该次关键字的所有记录的记录号(可以是指向记录的指针或者是该记录的主关键字), 如图中的&quot;文章编号&quot; TODO: 补充图片 倒排索引源于实际应用中需要根据属性(或字段、次关键码)的值来查找记录. 这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址. 由于不是由记录来确定属性值, 而是由属性值来确定记录的位置, 因而称为倒排索引 二叉排序树 设集合 {62, 88, 58, 47, 35, 73, 51, 99, 37, 93} 将其变为一颗中序遍历序列为 {35, 37, 47, 51, 58, 62, 73, 88, 93, 99} 的二叉排序树 TODO: 补充图片, 没懂写的啥 二叉排序树(Binary Sort Tree), 又称为二叉查找树. 二叉排序树具有以下性质: 若左子树不空, 则左子树上所有结点的值均小于它的根结点 若右子树不空, 则右子树上所有结点的值均大于它的根结点 左、右子树也为二叉排序树 二叉排序树查找操作: 1234567891011121314151617181920212223/*** 递归查找二叉排序树 T 中是否存在 key* 指针 f 指向 T 的前驱(双亲), 初始值为 NULL* 若查找成功, 指针 p 指向该数据结点并返回 TRUE* 若查找失败, 指针 p 指向查找路径上访问的最后一个结点并返回 FALSE*/int SearchBST(BiTree T, int key, BiTree f, BiTree *p){ if (!T) // 如果已经没有结点 { *p = f; // 查找失败, 指向上一结点的地址 return FALSE; } else if (key == T-&gt;data) // 如果当前结点的值等于给定值, 查找成功 { *p = T; return TRUE; } else if (key &lt; T-&gt;data) // 否则继续查找下一结点 return SearchBST(T-&gt;lchild, key, T, p); // 在左子树中继续查找 else return SearchBST(T-&gt;rchild, key, T, p); // 在右子树中继续查找} 二叉排序树插入操作(附二叉排序树的创建) 12345678910111213141516171819202122int InsertBST(BiTree *T, int key){ BiTree p, s; if (!SearchBST(*T, key, NULL, &amp;p)) // 调用后指针 p 会指向查找路径上访问的最后一个结点 { // 创建新结点 s = (BiTree) malloc(sizeof(BiTNode)); s-&gt;data = key; s-&gt;lchild = s-&gt;rchild = NULL; if (!p) // 若经过 SearchBST() 后 p 为 null, 说明该树中没有结点 *T = s; // 插入s为新的根结点 else if (key &lt; p-&gt;data) // 否则根据与双亲结点的比较决定是左孩子还是右孩子 p-&gt;lchild = s; // 插入 s 为 p 的左孩子 else p-&gt;rchild = s; // 插入 s 为 p 的右孩子 return TRUE; } else return FALSE; // 如果已有相同结点, 返回 False} 实现二叉排序树的创建: 1234567int i;int a[10] = { 62, 88, 58, 47, 35, 73, 51, 99, 37, 93 };// 新建二叉树 TBiTree T = (BiTree) malloc(sizeof(BiTNode));for (i = 0; i &lt; 10; i++) // 遍历数组并插入为新结点 InsertBST(&amp;T, a[i]) 二叉排序树删除操作 情况1: 如果待删结点是叶子, 直接将双亲结点的对应后继设为 null 即可 TODO: 补充图片 情况2: 如果待删结点只有左子树或只有右子树, 将它的左子树或右子树整个移动到被删除结点的位置 TODO: 补充图片 情况3: 如果待删结点既有左右子树均不空, 根据二叉树的中序序列 用该结点在序列中的前驱代替该结点, 并删除前驱, 接上该前驱的子树; 或者用该结点在序列中的后继代替该结点, 并删除后继, 接上该后继的子树 TODO: 补充图片 具体先根据关键值找到该结点, 然后再根据以上三种情况作处理 实现代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int Delete(BiTree *p){ BiTree q, s; if ((*p)-&gt;rchild == NULL) // 右子树空则只需重接它的左子树(待删结点是叶子也走此分支) { q = *p; *p = (*p)-&gt;lchild; free(q); } else if ((*p)-&gt;lchild == NULL) // 只需重接它的右子树 { q = *p; *p = (*p)-&gt;rchild; free(q); } else // 左右子树均不空 { q = *p; s = (*p)-&gt;lchild; // s 初始化为待删结点的左子树 while (s-&gt;rchild) // 找待删结点在中序序列中的前驱(他的左子树中最右孩子或者左子树根结点(如果左子树根结点没有右孩子)), 用变量 s 记录, 用 q 记录 s 的双亲 { q = s; s = s-&gt;rchild; } (*p)-&gt;data = s-&gt;data; // 用前驱代替待删结点 if (q == *p) // 前驱的双亲等于待删结点, 意味着待删结点的左子树根结点没有右孩子 q-&gt;lchild = s-&gt;lchild; // 接上待删结点左子树的左子树 else q-&gt;rchild = s-&gt;lchild; // 接上最右孩子的左子树(因为最右孩子肯定没有右孩子) free(s); // 清理待删结点的前驱 }}int DeleteBST(BiTree *T, int key){ if(!*T) // 如果已经没有结点, 说明查找失败 return FALSE; else { if (key == (*T)-&gt;data) // 如果找到关键字等于 key 的结点 return Delete(T); // 调用 Delete() 删除该结点 else if (key &lt; (*T)-&gt;data) return DeleteBST(&amp;(*T)-&gt;lchild, key); else return DeleteBST(&amp;(*T)-&gt;rchild, key); }} 二叉排序树总结 二叉排序树是以链表的方式存储, 保持了链式存储结构在执行插入或删除操作时不用移动元素的优点, 只要找到合适的插入和删除位置后, 仅需修改链接指针即可 额外特性: 对于二叉排序树的查找, 走的就是从根结点到要查找的结点的路径, 其比较次数等于给定值的结点在二叉排序树的层数. 最少为1次, 即根结点就是要找的结点, 最多不会超过树的深度. 平衡二叉树(AVL树) TODO: 这节未完成 平衡二叉树(Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree), 是一种二叉排序树, 其中每一个结点的左子树和右子树的高度差至多等于 1 二叉树结点的左子树深度减去右子树深度的值称为平衡因子 BF(Balance Factor), 平衡二叉树上所有结点的平衡因子只可能是 -1、0、1. 最小不平衡树: 如图, 当新插入结点37时, 距离它最近的平衡因子绝对值超过 1 的结点是 58 (58左子树高度3, 右子树高度 1), 所以从 58 为跟的子树为最小不平衡树 TODO: 补充图片 平衡二叉树实现原理 构建平衡二叉树的基本思想就是在构建过程中, 每当插入一个结点时, 先检查是否因插入而破坏了树的平衡. 若是, 则找出最小不平衡树. 在保证二叉排序树特性的前提下, 调整最小不平衡子树中各结点之间的链接关系, 进行相应的旋转, 使之成为新的平衡子树. 平衡二叉树实现算法 平衡二叉树结构定义代码如下: 123456typedef struct BiTNode // 结点结构{ int data; int bf; // 结点平衡因子 struct BiTNode *lchild, *rchild;} BiTNode, *BiTree; 实现代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// 右旋操作void R_Rotate(BiTree *P){ BiTree L; L = (*P)-&gt;lchild; // L 为 P 的左子树根结点 (*P)-&gt;lchild = L-&gt;rchild; // 将 P 左子树的右子树挂接为 P 的左子树 L-&gt;rchild = (*P); // 将 L 的右子树根结点设为 P *P = L; // P 的新根结点为 L}// 左旋操作void L_Rotate(BiTree *P){ BiTree R; R = (*P)-&gt;rchild; // R 为 P 的右子树根结点 (*P)-&gt;rchild = R-&gt;lchild; // 将 P 右子树的左子树挂接为 P 的右子树 R-&gt;lchild = (*P); // 将 R 的左子树根结点设为 P *P = R; // P 的新根结点为 R}#define LH 1#define EH 0#define RH -1// 对二叉树 T 作左平衡旋转(即树的左边高于右边的情况, 此时 T-&gt;bf == 2)void LeftBalance(BiTree *T){ BiTree L, Lr; L = (*T)-&gt;lchild; // L 指向 T 的左子树根结点 switch (L-&gt;bf) // 检查 T 的左子树平衡因子 { case LH: // 新插入结点在 T 的左孩子的左子树上, 要作右旋处理 (*T)-&gt;bf = L-&gt;bf = EH; // 右旋后 T, L 结点均变为平衡(由作图分析得到) R_Rotate(T); break; case RH: // 新插入结点在 T 的左孩子的右子树上, 要作双旋处理(左子树左旋, 根结点右旋) Lr = L-&gt;rchild; // Lr 指向 T 的左孩子的右子树根 switch (Lr-&gt;bf) // 根据Lr 的平衡因子设定双旋后 T, L 结点的平衡情况(由作图分析得到) { case LH: L-&gt;bf = EH; (*T)-&gt;bf = RH; break; case EH: (*T)-&gt;bf = L-&gt;bf = EH; break; case RH: L-&gt;bf = LH; (*T)-&gt;bf = EH; break; } Lr-&gt;bf = EH; L_Rotate(&amp;(*T)-&gt;lchild); // 将 T 的左子树左旋, Lr 变为左子树根结点 R_Rotate(T); // 将 T 右旋, Lr 变为根结点 }}int InsertAVL(BiTree *T, int e, bool *taller){ if (!*T) { *T = (BiTree) malloc(sizeof(BiTNode)); (*T)-&gt;data = e; (*T)-&gt;lchild = (*T)-&gt;rchild = NULL; (*T)-&gt;bf = EH; *taller = true; } else { if (e == (*T)-&gt;data) { *taller = false; return false; } if (e &lt; (*T)-&gt;data) { if (!InvertAVL(&amp;(*T)-&gt;lchild, e, taller)) return false; if (taller) { switch((*T)-&gt;bf) { case LH: LeftBalance(T); *taller = false; break; case EH: (*T)-&gt;bf = LH; *taller = true; break; case RH: (*T)-&gt;bf = EH; *taller = false; break; } } } else { if (!InsertAVL(&amp;(*T)-&gt;rchild, e, taller)) return false; if(*taller) { switch((*T)-&gt;bf) { case LH: (*T)-&gt;bf = EH; *taller = false; break; case EH: (*T)-&gt;bf = RH; *taller = true; break; case RH: RightBalance(T); *taller = false; break; } } } } return true;} 多路查找树(B树) 散列表查找(哈希表)概述 散列表查找定义 通过某个函数 f, 使得: 存储位置=f(关键字) 散列技术是在记录的的存储位置和它的关键字之间建立一个确定的对应关系, 使得每个关键字 key 对于一个存储位置 f(key) 函数 f 称为散列函数, 又称哈希(Hash)函数. 采用散列技术将记录存储在一块连续的存储空间中, 这块连续存储空间称为散列表或哈希表(Hash table). 关键字对应记录的存储位置称为散列地址 这样查找关键字不需要比较就可获得需要的记录的存储位置 散列表查找步骤 在存储时, 所有记录都需要经过散列函数计算出地址再存储 查找记录时, 通过同样的散列函数计算记录的散列地址从而访问该地址 因此散列计算既是一种存储方法, 也是一种查找方法. 散列技术最适合的场景是查找某个指定的记录 散列技术不适合: 一个关键字对应多条记录的情况 范围查找 在理想情况下, 不同的关键字, 通过散列函数计算出来的地址都是不一样的, 可现实中时常会碰到两个关键字 key1≠key2, 但 f(key1)=f(key2) 的情况, 这种现象称为冲突(collision), 此时 key1 和 key2 称为这个散列函数的同义词(synonym) 散列函数的构造方法 两个原则: 计算简单. 散列函数的计算时间不应该超过其他查找技术与关键字比较的时间 散列地址分布均匀. 尽量让散列地址均匀地分布在存储空间中, 保证存储空间的有效利用, 减少未处理冲突而耗费的时间 直接定址法 对 0~100 岁的人口数字统计表, 对年龄这个关键字就可以直接用年龄的数字作为地址. 此时 f(key)=key TODO: 补充图片 统计 1980 后出生年份的人口数, 对出生年份这个关键字可以用年份减去 1980 来作为地址. 此时 f(key)=key-1980 TODO: 补充图片 可以取关键字的某个线性函数为散列地址, 即 f(key) = a × key + b 这样的散列函数优点是简单、均匀、不产生冲突, 但问题是需要事先知道关键字的分布情况, 适合查找表较小且连续的情况, 由于这样的限制, 此方法在现实中并不常用. 数字分析法 如果关键字是位数较多的数字, 比如 11 位手机号前三位是接入号, 一般对应不同运营商公司的子品牌; 中间四位是 HLR 识别号, 表示归属地; 后四位才是真正的用户号. TODO: 补充图片 如果用手机号作为关键字, 极有可能前 7 位都是相同的. 那么选择后四位作为散列地址就是不错的选择. 数字分析法是使用关键字的一部分来计算散列存储位置的方法, 通常适合处理关键字位数比较大的情况. 如果事先知道关键字的分布且关键字的若干位分布较均匀, 可以考虑用此方法 平方取中法 关键字 1234 的平方是 1522756, 抽取中间的三位 227 用作散列地址. 平方取中法适合于不知道关键字的分布, 而位数又不是很大的情况. 折叠法 折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数不够时可以短些), 然后将这几部分叠加求和, 并按散列表表长, 取后几位作为散列地址 关键字 9876543210, 分为四组 |987|654|321|0, 叠加求和 987+654+321+0=1962, 散列表表长为三位(0~999), 得到散列地址为962 有时还不能保证分布均匀, 不妨从一端向另一端来回折叠后对齐相加. 比如 987 和 321 反转, 在与 654 和 0 相加, 变成 789 + 654 + 123 + 0 = 1566, 此时散列地址为 566 折叠法事先不需要知道关键字的分布, 适合关键字位数较多的情况 除留余数法 除留余数法为最常用的散列函数方法. 对于散列表长度为 m 的散列函数公式为: f(key)=key % p (p ≤ m) 此方法不仅可以对关键字直接取模, 也可在折叠、平方取中后再取模. 本方法的关键在于选择合适的 p, p 如果选的不好, 可能会容易产生同义词. 极端情况: 对于如下数据, 让p为12, 所有的关键字都能整除 12, 都得到了 0 这个散列地址 TODO: 补充图片 通常选择 p 为小于等于表长的最小质数或质因子不小于 20 的合数 随机数法 选择一个随机数, 取关键字的随机函数值为它的散列地址. 即 f(key)=random(key) random() 是伪随机函数. 当关键字的长度不等时, 采用这个方法构造散列函数比较合适. 应该视不同的情况采用不同的散列函数. 考虑因素: 计算散列地址所需的时间 关键字的长度 散列表的大小 关键字的分布情况 记录查找的频率 处理散列冲突的方法 开放地址法 也称线性探测法. 指一旦发生冲突, 就去寻找下一个空的散列地址, 只要散列表足够大, 空的散列地址总能找到, 并将记录存入 公式(m 为散列表表长): \\(f_i(\\text{key}=(f(\\text{key}+d_i) \\% m (1 \\leqslant d_i \\leqslant m-1)))\\) 堆积: 本来不是同义词却需要争夺一个地址的情况. 堆积的出现需要不断处理冲突, 无论存入还是查找效率都会大大降低 二次探测法: 给增加平方运算, 目的是为了不让关键字聚集在某一块区域, 减少堆积的出现. \\(f_i(key)=(f(key)+d_i) \\% m (d_i=1^2, -1^2, 2^2, -2^2, \\dots, q^2, -q^2)(q\\leqslant \\frac{m}{2})\\) 还有一种方法是在冲突时, 对于位移量 \\(d_i\\) 采用随机函数计算得到, 称之为随机探测法 开放定址法只要在散列表未填满时, 总能找到不发生冲突的地址, 是常用的解决冲突的办法 再散列函数法 事先准备多个散列函数, 每当发生散列地址冲突时, 就换一个散列函数计算. 这种方法能够使得关键字不产生聚集, 但也增加了计算的时间 链地址法 将所有关键字为同义词的记录存储在一个单链表中, 称这种表为同义词子表, 在散列表中只存储所有同义词子表的头指针 举个例子: 对关键字集合 {12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34}, 散列函数为除留余数法, 用 12 作为除数 TODO: 补充图片 链地址法提供了绝不会出现找不到地址的保障. 但也带来了查找时需要遍历单链表的性能损耗 公共溢出区法 增加一个专门存储同义词的溢出表 举个例子: 关键字 37, 48, 34 与之前的关键字位置有冲突, 将它们存储到溢出表 TODO: 补充图片 查找时, 对给定值通过散列函数计算出散列地址后, 先与基本表的相应位置进行比对, 如果相等, 则查找成功; 如果不相等, 则到溢出表去进行顺序查找. 如果相对于基本表, 有冲突的数据很少的情况下, 公共溢出区法的性能还是非常高的 散列表查找实现 散列表查找算法实现 HashTable 是散列表结构, 结构中 *elements 为一个动态数组. 1234567typedef struct{ int *elements; // 数据元素存储基址, 动态数组 int count; // 当前数据元素个数} HashTable;int HashTableLength = 0; // 散列表表长, 全局变量 对散列表初始化 123456789101112131415#define HASHSIZE 12 // 假设表长为 12#define NULLKEY -32768 // 初始键值, 选择一个关键字取不到的值int InitHashTable(HashTable *H){ int i; HashTableLength = HASHSIZE // 设置散列表表长 H-&gt;count = HashTableLength; H-&gt;elements = (int*) malloc(HashTableLength * sizeof(int)); for (i = 0; i &lt; HashTableLength; i++) // 初始化 elements 数组 H-&gt;elem[i] = NULLKEY; return OK;} 选择一个散列函数, 这里选择了除留余数法: 1234int Hash(int key){ return key % HashTableLength;} 插入操作函数: 12345678void InsertHash(HashTable *H, int key){ int addr = Hash(key); while (H-&gt;elements[addr] != NULLKEY) // 如果该地址不等于初始值, 说明已被别的键值占有, 冲突了 addr = (addr + 1) % HashTableLength; // 这里用开放地址法解决冲突 H-&gt;elements[addr] = key;} 查找操作函数: 1234567891011121314151617// 查找成功后 *addr 指向该关键字的散列地址int SearchHash(HashTable H, int key, int *addr){ *addr = Hash(key); // 获取散列地址 while (H.elements[*addr] != key) // 如果该地址下元素与要找的不同, 说明之前发生过冲突 { *addr = (*addr + 1) % HashTableLength; // 因为之前用开放地址法解决冲突, 所有同样用这个方法找散列地址 // 前者判断在该记录未存入散列表的情况下为 true, 基于开放地址法的特性. (同时散列表也不能删除已存入元素) // 后者判断在散列表全满的情况下为 true if (H.elements[*addr] == NULLKEY || *addr == Hash(key)) { return ERROR; } } return OK;} 散列表查找性能分析 散列查找的平均查找长度取决因素: 散列函数是否均匀 处理冲突的方法 散列表的装填因子 装填因子形容散列表装满的程度, 符号 \\(\\alpha=\\frac{\\text{当前表中记录个数}}{\\text{散列表长度}}\\) \\(\\alpha\\) 越大, 产生冲突的可能性就越大. 冲突越多, 平均查找长度同样也越长. 解决方法是选择一个合适的装填因子以便将平均查找长度限定在一个范围之内, 此时散列查找的时间复杂度是 \\(O(n)\\) 通常都是将散列表的空间设置得比查找集合大, 虽然是浪费了一定的空间, 但换来的是查找效率的大大提升 排序 排序的基本概念与分类 设有 n 个记录的序列 \\(\\{r_1, r_2, \\dots, r_n\\}\\) 记录对应的关键字为 \\(\\{k_1, k_2, \\dots, k_n\\}\\) 需确定一种排列 \\(p_1, p_2, \\dots, p_n\\) 满足 \\(k_{p_1}, k_{p_2}, \\dots, k_{p_n}\\) 按顺序或逆序排列 使序列成为按关键字有序的序列 \\(\\{r_{p_1}, r_{p_2}, \\dots, r_{p_n}\\}\\) 排序的稳定性 假设 \\(k_i=j_j \\enspace(1\\leqslant i , 1\\leqslant j\\leqslant n , i \\neq j)\\) 且在排序前的序列中 \\(r_i\\) 领先于 \\(r_j\\) . 如果排序后 \\(r_i\\) 仍领先于 \\(r_j\\) 则称所用的排序方法是稳定的; 反之, 若可能使得排序后序列中 \\(r_j\\) 领先于 \\(r_i\\) 则称所用的排序方法是不稳定的. 即两个关键字一样的记录, 排序后顺序不变的说明排序方法是稳定的 TODO: 补充图片 内排序与外排序 根据在排序过程中待排序的记录是否全部被放置在内存中, 将排序分为内排序和外排序. 内排序是在整个排序过程中, 待排序的记录全部放在内存中. 外排序是由于排序的记录太多, 在整个排序过程中, 需要在内外存之间多次交换数据. 对于内排序, 排序算法性能主要受 3 个方面影响 时间性能 内排序中, 主要进行两种操作: 比较和移动. 高效率的内排序算法是尽可能少的关键字比较次数和记录移动次数 辅助空间 除了存放排序所占用的存储空间之外, 执行算法所需要的其他存储空间 算法的复杂性 指算法代码的复杂度, 不是算法的时间复杂度. 算法过于复杂也会影响排序的性能 排序用到的结构与函数 排序用的顺序表结构 123456#define MAXSIZE 10typedef struct{ int r[MAXSIZE + 1]; // r[0] 用作哨兵或临时变量, 所以要 MAXSIZE + 1 int length;} SqList; 数组两元素的交换函数 123456void swap(SqList *L, int i, int j){ int temp = L-&gt;r[i]; L-&gt;r[i] = L-&gt;r[j]; L-&gt;r[j] = temp;} 冒泡排序 最简单排序实现 12345678910111213141516// 不算标准的冒泡排序, 从小到大排列// 思路是让每一个关键字都和它后面的每一个关键字比较, 如果大则交换// 这样这个关键字在一次循环后一定变成它后面数中的最小值void NotBubbleSort(SqList *L){ int i, j; // 将每个 r[i] 与 i 之后的每个 r[j] 比一遍 for (i = 1; i &lt; L-&gt;length; i++) { for (j = i + 1; j &lt;= L-&gt;length; j++) { if (L-&gt;r[i] &gt; L-&gt;r[j]) swap(L, i, j); } }} 时间复杂度为: \\(\\frac{n(n-1)}{2}=O(n^2)\\) , 该算法的效率非常低 冒泡排序算法 冒泡排序(Bubble Sort)是一种交换排序 基本思想是: 两两比较相邻记录的关键字, 如果反序则交换, 直到没有反序的记录为止 正宗的冒泡算法: 1234567891011121314void BubbleSort(SqList *L){ int i, j; for (i = 1; i &lt; L-&gt;length; i++) { // j 从后往前循环, 比较时 j 是前者, j + 1 是后者 for (j = L-&gt;length - 1; j &gt;= i; j--) { // 若前者大于后者, 交换它们的位置 if (L-&gt;r[j] &gt; L-&gt;r[j + 1]) swap(L, j, j + 1); } }} 每次 j 的循环结束后, r[i] 位置的关键字总是后面的记录中最小的. 每次 j 的循环, 最小的关键字都会向泡泡一个依次&quot;浮&quot;上来 时间复杂度同样为 \\(O(n^2)\\) 冒泡排序优化 增加一个标记变量flag, 如果某轮 j 循环没有任何数据交换, 说明此序列已经有序,不需要再继续后面的排序工作. 1234567891011121314151617void BubbleSort2(SqList *L){ int i, j; bool flag = true; for (i = 1; i &lt; L-&gt;length &amp;&amp; flag; i++) // 增加对 flag 的判断 { flag = false; // i 循环每轮初始值为 false for (j = L-&gt;length - 1; j &gt;= i; j--) { if (L-&gt;r[j] &gt; L-&gt;r[j + 1]) { swap(L, j, j + 1); flag = true; // 如果有数据交换, 则 flag 为 true, 下次循环继续 } } }} 设待排序的序列是 {2, 1, 3, 4, 5, 6, 7, 8, 9} TODO: 补充图片 冒泡排序复杂度分析 最好情况: 要排序的表本身就是有序的, 放在冒泡排序优化版只有 n-1 次的比较, 没有数据交换, 时间复杂度为 \\(O(n)\\) 最坏情况: 排序表是逆序的情况, 此时需要比较 \\(\\frac{n(n-1)}{2}\\) 次并作等量的移动操作, 时间复杂度为 \\(O(n^2)\\) 简单选择排序 简单选择排序算法 简单选择排序法(Simple Selection Sort)是通过 n-i 次关键字间的比较, 从 n-i+1 个记录中选出关键字最小的记录, 并和第 i 个记录交换 123456789101112131415void SelectSort(SqList *L){ int i, j, min; for (i = 1; i &lt; L-&gt;length; i++) { min = i; // min 记录当前找到的最小值, 初始化值为 i for (j = i + 1; j &lt;= L-&gt;length; j++) // 在 i 之后的记录中找最小值 { if (L-&gt;r[min] &gt; L-&gt;r[j]) // 如果有比 min 小的 min = j; // 将该值赋给 min } if (i != min) // 若 min 不等于 i, 说明找到最小值, 交换 swap(L, i, min); }} 简单选择排序复杂度分析 简单排序相比冒泡排序的优点是交换记录位置的次数相当少. 对于交换次数, 最好情况为顺序表交换 0 次, 最坏情况为逆序表 n-1 次. 但无论最好最差的情况, 其比较次数都是 \\(\\frac{n(n-1)}{2}\\) 次. 因此, 时间复杂度依然为 \\(O(n^2)\\) 尽管与冒泡排序同为 \\(O(n^2)\\) , 但实际情况简单选择排序的性能还是略优于冒泡排序 直接插入排序 直接插入排序算法 直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中, 从而得到一个新的、记录数增 1 的有序表 实现代码如下: 123456789101112131415161718void InsertSort(SqList *L){ int i, j; for (i = 2; i &lt;= L-&gt;length; i++) { // r[i] 为后者, r[i - 1] 为前者, 如果后者小于前者, 说明后者需要插到前面去 if (L-&gt;r[i] &lt; L-&gt;r[i - 1]) { L-&gt;r[0] = L-&gt;r[i]; // 将后者的值存入哨兵 // 将记录后移, 给插入提供空间 for (j = i - 1; L-&gt;r[j] &gt; L-&gt;r[0]; j--) // 用 j 遍历 i 前面的记录. 如果 r[j] 大于哨兵的值 L-&gt;r[j + 1] = L-&gt;r[j] // 将该记录后移 L-&gt;r[j + 1] = L-&gt;r[0] // 循环结束后, j+1 抵消最后一次循环结束后的 j--, 即为合适的插入位置 } }} 直接插入排序复杂度分析 最好情况: 表本身有序, 共比较了 n-1 次, 没有移动记录的操作, 时间复杂度为 \\(O(n)\\) 最坏情况: 表是逆序, 需要比较 \\(2+3+…+n=\\frac{(n+2)(n-1)}{2}\\) 次, 记录移动次数 \\(\\displaystype\\sum_{i=2}^n (i+1)=\\frac{(n+4)(n-1)}{2}\\) 评价情况: 根据等概率原则, 评价比较和移动次数约为 \\(\\frac{n^2}{4}\\) 因此时间复杂度同样为 \\(O(n^2)\\) 但直接插入排序法比冒泡和简单选择排序的性能要好 希尔排序 希尔排序原理 将原本的大量记录进行分组, 分割成若干个子序列. 此时每个子序列按排序的记录个数比较少, 然后在这些子序列内分别进行直接插入排序, 当整个序列都基本有序时, 再对全体记录进行依次直接插入排序 基本有序: 小的关键字基本在前面, 大的基本在后面, 不大不小的基本在中间 {2,1,3,6,4,7,5,8,9} 可以称为基本有序. {1,5,9,3,7,8,2,4,6} 的 9 在第三位, 谈不上基本有序, 其中的 {1, 5, 9} 算局部有序 跳跃分割策略: 将相距某个&quot;增量&quot;的记录组成一个子序列, 以保证直接插入排序后的子序列是基本有序而不是局部有序 希尔排序算法 123456789101112131415161718192021222324void ShellSort(SqList *L){ int i, j; int increment = L-&gt;length; // 增量, 初始化为表的长度 do { // 确定增量大小, 每完成一次循环, 增量都会逐步减小 increment = increment / 3 + 1; // 后面 +1 是为了确保增量大于等于1, 增量等于零时此算法相当于直接插入排序 for (i = increment + 1; i &lt;= L-&gt;length; i++) { if (L-&gt;r[i] &lt; L-&gt;r[i - increment]) // 将 i 和前一个子序列对应的值比较, 小则交换位置 { L-r[0] = L-&gt;r[i]; // 暂存在L-&gt;r[0] for (j = i - increment; j &gt; 0 &amp;&amp; L-&gt;r[j] &gt; L-&gt;r[0]; j -= increment) // 从后往前, 将 L-r[0] 与每个子序列中相应位置记录比较 { L-&gt;r[j + increment] = L-&gt;r[j]; // 如果大于 L-r[0], 将该记录移到后一个子序列表相应位置中(第一次位置为 r[i] 的位置) } L-&gt;r[j + increment] = L-&gt;r[0]; // 循环结束后, 抵消最后一次循环结束后的 j -= increment, 即为合适的插入位置 } } } while (increment &gt; 1);} 希尔排序复杂度分析 希尔排序的关键是将相隔某个距离的记录组成一个个子序列, 实现跳跃式的排序, 使得排序的效率提高. 希尔排序时间复杂度为 \\(O(n^2)\\) . 由于记录是跳跃式的移动, 希尔排序并不是一种稳定的排序算法 堆排序 堆是具有下列性质的完全二叉树: 每个结点的值都大于或等于其左右孩子的值, 称为大顶堆; 或每个结点的值都小于或等于其左右孩子的值, 称为小顶堆 根结点一定是堆中所有结点最大(小)者 较大(小)的结点靠近根结点(不绝对) TODO: 补充图片 按照层序遍历的方式给 n 个结点从 1 开始编号, 结点之间满足如下关系: \\(\\begin{cases} k_i\\geqslant k_{2i} \\ k_i\\geqslant k_{2i+1} \\end{cases}\\) 或 \\(\\begin{cases} k_i\\leqslant k_{2i} \\ k_i\\leqslant k_{2i+1} \\end{cases} (1\\leqslant i\\leqslant \\frac{n}{2})\\) (可以回顾完全二叉树的存储) 将大顶堆或小顶堆用层序遍历存入数组: TODO: 补充图片 堆排序算法 堆排序(Heap Sort)是利用堆(假设利用大顶堆)进行排序的方法. 基本思想是将待排序的序列构造成一个大顶堆. 此时序列的最大值就是根节点, 将他移至序列末尾(与末尾记录交换), 然后将剩余的序列重新构造成一个堆, 这样就会得到次大值. 如此反复执行, 便能得到一个有序序列. 实现需要解决两个问题: 如何由无序序列构建成一个堆 如何在输出堆顶元素后, 调整剩余元素成为一个新堆 实现代码如下: 1234567891011121314151617181920212223242526272829303132// 堆调整函数(大顶堆), 使堆顶为当前最大的数, 调用时应确认树中子堆应该已经调整过void HeapAdjust(SqList *L, int s, int m){ int temp, j; temp = L-&gt;r[s]; // temp 存储原本堆顶的值 for (j = 2 * s; j &lt;= m; j *= 2) // 循环遍历左孩子 { if (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + 1]) // 如果 j &lt; m 说明不是最后一个结点, 左孩子小于右孩子 j++; // j 指针加 1 以使其指向右孩子 if (temp &gt;= L-&gt;r[j]) // 如果 temp 的值大于 j 指向的较大的孩子 break; // 结束循环(考虑到下面的子堆已经调整过, j 下面已经不可能会有比堆顶还大的数) L-&gt;r[s] = L-&gt;r[j]; // 否则将此孩子的值赋给当前堆顶 s = j; // 接下来调整子堆, 将指向堆顶的 s 指针指向当前孩子 j } L-&gt;r[s] = temp; // 将原本堆顶的值存入 s 指向的地方}void HeapSort(SqList *L){ int i; // 构建堆, 将数组调整为一个大顶堆 for (i = L-&gt;length / 2; i &gt; 0; i--) // 从子堆开始调整 HeapAdjust(L, i, L-&gt;length); for (i = L-&gt;length; i &gt; 1; i--) { swap(L, 1, i); // 将堆顶记录和 i 交换(i 从后往前) HeapAdjust(L, 1, i - 1); // 重新调整堆 }} 堆排序复杂度分析 运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上 构建堆: 因为是完全二叉树从最下层最右边的非终端结点开始构建, 将它与其孩子进行比较和若有必要的互换, 对于每个非终端结点, 最多进行两次比较和互换操作, 时间复杂度为 \\(O(n)\\) 正式排序: 第 i 次取堆顶记录重建堆需要用 \\(O(\\log i)\\) 的时间(完全二叉树的某个结点到根结点的距离为 \\(\\log_2 i + 1\\) , 并且需要取 n-1 次堆顶记录, 因此重建堆的时间复杂度为 \\(O(n\\log_n)\\) ​ 总体堆排序的时间复杂度为 \\(O(nlogn)\\) 由于记录的比较与交换是跳跃式进行, 堆排序也是一种不稳定的排序方法 由于初始构建堆所需的比较次数较多, 不适合待排序序列个数较少的情况 空间复杂度上只有一个用来交换的暂存单元 归并排序 归并排序算法 归并: 将两个或两个以上的有序表组合成一个新的有序表 假设初始序列含有 n 个记录, 把它看成 n 个长度为 1 的有序子序列, 然后两两归并, 得到 \\(\\ulcorner\\frac{n}{2}\\urcorner\\) (\\(\\ulcorner x\\urcorner\\) 表示大于 x 的最小整数)个长度为 2 或 1 的有序子序列. 再次两两归并, 如此重复, 直至得到一个长度为 n 的有序序列为止. 这种排序方法称为 2 路归并排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// SR 为当前分段, TR 为输出数组(SR 和 TR 两者不能为同一个), 此函数将两个有序序列 SR[i~m] 和 SR[m+1~n] 归并void Merge(int SR[], int TR[], int i, int m, int n){ int j, k, l; // 将 SR 中记录由小到大归并入 TR, i 由 i~m j 由 m+1~n for (k = i, j = m + 1; i &lt;= m &amp;&amp; j &lt;= n; k++) { // 因为两个序列有序, 只需要逐个比较然后填入 TR if (SR[i] &lt; SR[j]) TR[k] = SR[i++]; else TR[k] = SR[j++]; } // 循环结束后某一边的序列会全部填入 TR //接下来判断是否还有剩余未填入 if (i &lt;= m) { for (l = 0; l &lt;= m - i; l++) TR[k + l] = SR[i + l]; // 将剩余的 SR[i~m] 填入 TR } if (j &lt;= n) { for (l = 0; l &lt;= n - j; l++) TR[k + l] = SR[j + l]; // 将剩余的 SR[j~n] 填入 TR }}// SR为输入数组, TR1 为排序后的输出数组, s 为起始下标, t 为终端下标// 第一次传入的 TR1 只会在递归的最后赋值, 所以 SR 和 TR1 可以是同一个地址void MSort(int SR[], int TR1[], int s, int t){ int m; int TR2[t + 1]; if (s == t) // 如果已经分到了最小 TR1[s] = SR[s]; // 将 SR[s] 回递给上级递归的 TR2[s] (开始调用 Merge() 归并) else { // 将 SR 平分为 SR[s~m] 和 SR[m+1~t] m = (s + t) / 2; MSort(SR, TR2, s, m); MSort(SR, TR2, m + 1, t); Merge(TR2, TR1, s, m, t); // 将 SR[s~m] 和 SR[m+1~t] 归并到 TR1 }}void MergeSort(SqList *L){ MSort(L-&gt;r, L-&gt;r, 0, L-&gt;length - 1);} 具体递归的分析: 123456789101112131415161718假设有数组 SR == [50 10 90 30 70], 长度为5MSort(L-&gt;r, L-&gt;r, 0, 4) MSort(SR, TR2, 0, 2) [50,10,90] MSort(SR, TR2, 0, 1) MSort(SR, TR2, 0, 0) 确定上级递归 TR2 有 SR[0] == 50 MSort(SR, TR2, 1, 1) 确定上级递归 TR2 有 SR[1] == 10 于是确定此级递归的 TR2 == [50,10,null,null,null] Merge(TR2, TR1, 0, 0, 1) TR2[50,10,null,null,null] -&gt; 上级递归的 TR2[10,50,null,null,null] MSort(SR, TR2, 2, 2) 确定上级递归 TR2 有 SR[2] == 90 于是确定此级递归的 TR2 == [50,10,90,null,null] Merge(TR2, TR1, 0, 1, 2) TR2[10,50,90,null,null] -&gt; 上级递归的 TR2[10,50,90,null,null] MSort(SR, TR2, 3, 4) 30 70 MSort(SR, TR2, 3, 3) 确定上级递归 TR2 有 SR[3] == 30 MSort(SR, TR2, 4, 4) 确定上级递归 TR2 有 SR[4] == 70 于是确定此级递归的 TR2 == [null,null,null,30,70] Merge(TR2, TR1, 3, 3, 4) TR2[null,null,null,30,70] -&gt; 上级递归的 TR2[null,null,null,30,70] (加上先前的递归, 实际为 TR2[10,50,90,30,70]) Merge(TR2, TR1, 0, 2, 4) TR2[10,50,90,30,70] -&gt; TR1[10,30,50,70,90] 归并排序复杂度分析 一趟归并需要将 SR[1]~SR[n] 中相邻的有序序列进行两两归并并将结果放到 TR1 中, 需要将待排序序列中的所有记录扫描一遍, 耗时 \\(O(n)\\) 整个归并的路线可以想象成一颗完全二叉树, 由完全二叉树的深度可知, 整个归并排序需要进行 \\(\\log_2 n\\) 次, 因此总的时间复杂度为 \\(O(n\\log n)\\) 由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间, 存放归并结果以及递归时深度为 \\(\\log_2 n\\) 的栈空间, 因此空间复杂度为 \\(O(n+\\log n)\\) Merge() 函数中归并排序是两两比较, 不存在跳跃, 因此归并排序是一种稳定的排序算法 归并排序是一种比较占用内存，但却效率高且稳定的算法 非递归实现归并排序 1234567891011121314151617181920212223242526272829303132333435363738// 省略了函数 Merge()// 将 SR[] 中相邻长度为 distance 的子序列两两归并到TR[], length 为 SR[] 长度void MergePass(int SR[], int TR[], int distance, int length){ int i = 0; int j; while (i &lt;= length - 2 * distance) // 循环, 直到后面没有满足两个相邻子序列的空间 { // 归并 SR[i ~ i+(distance-1)] 和 SR[i+distance ~ i+distance+(distance-1)] (合并后就是 SR[i+distance ~ i+2×distance-1]) Merge(SR, TR, i, i + distance - 1, i + 2 * distance - 1); i += 2 * distance; // i ~ i+2×distance-1 之间长度为(包含两端本身) (i+2×distance-1) - i + 1 = 2×distance } // 归并最后两个序列 (前者的序列长度=distance ; 0 &lt; 后者的序列长度 &lt; distance) if (i &lt; length - distance) Merge(SR, TR, i, i + distance - 1, length - 1); else // 若最后只剩下 长度 ≤ distance 的单个子序列, 直接填入TR[] (或者没有剩余, 此时循环条件不满足, 不执行) for (j = i; j &lt; length; j++) TR[j] = SR[j];}// 对顺序表L作归并非递归排序void MergeSort2(SqList *L){ int *TR = (int*) malloc(L-&gt;length * sizeof(int)); int k = 1; // k 存储当前分割间距 while (k &lt; L-&gt;length) { // 在TR和L-&gt;r之间不断轮换并扩大子序列长度, 最终完成归并排序 MergePasss(L-&gt;r, TR, k, L-&gt;length); // 将 L-&gt;r 中相邻长度为当前 k 的子序列两两归并到 TR k *= 2; // 子序列长度加倍 MergePass(TR, L-&gt;r, k, L-&gt;length); // 将 TR 中相邻长度为当前 k 的子序列两两归并到 L-&gt;r k *= 2; // 子序列长度加倍 }} 非递归的迭代方法, 避免了递归时深度为的栈空间, 空间只是用到申请归并临时用的TR数组, 空间复杂度为 \\(O(n)\\) 避免递归在时间性能上也有一定的提升 快速排序 快速排序算法 快速排序(Quick Sort)的基本思想是 通过一趟排序将待排记录分割成独立的两部分, 其中一部分记录的关键字均比另一部分记录的关键字小, 分别对这两部分记录继续排序, 达到整个序列有序 1234567891011121314151617181920212223242526272829303132333435363738// 任务是选择某个记录作为枢轴, 将比它小的放左边, 比它大的放右边, 然后返回分好后枢轴的下标int Partition(SqList *L, int low, int high){ int pivotkey = L-&gt;r[low]; // 用子表的第一个记录作枢轴 // 从表的两端交替向中间扫描, 指针 low &lt; high 是前提条件 while (low &lt; high) { while (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) // 如果当前 high 指向的关键字比枢轴大 high--; // high 指针左移 swap(L, low, high); // 继续交换 low 与 high 指向的记录, 如果 high 没有右移, 则代表撤回上一次的 swap() 操作 while (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) // 如果当前 low 指向的关键字比枢轴小 low++; // low 指针右移 swap(L, low, high); // 继续交换 low 与 high 指向的记录, 如果 low 没有右移, 则代表撤回上一次的 swap() 操作 } // 每一次 swap() 操作, 如果在接下来的判断中满足与 pivotkey 的关系, 则移动指针 high 或 low 以继续下一步 swap(), 否则 swap() 操作会被撤回 // 循环中, pivotkey 不断在 low 和 high 的位置交换, 最后被递到中间(此时 low == high), 结束循环. return low; // 循环结束后 low 等于 high 等于 pivotkey 的下标.}// 对表 L 的子序列 L-&gt;r[low~high] 作快速排序void QSort(SqList *L, int low, int high){ int pivot; if (low &lt; high) { pivot = Partition(L, low, high); // 将 L-&gt;r[low~high] 一分为二, 返回枢轴的下标(枢轴左边的值都比它小, 右边的值都比它大) // 对左子表(r[low ~ pivot-1])递归排序 QSort(L, low, pivot - 1); // 对右子表(r[pivot+1 ~ high])递归排序 QSort(L, pivot + 1, high); }}void QuickSort(SqList *L){ QSort(L, 0, L-&gt;length - 1);} 递归的推算: 12345678910111213141516QSort(L, 0, 8) [50,10,90,30,70,40,80,60,20] -&gt; 执行完余下的递归后 [10,20,30,40,50,60,70,80,90] pivot=4 [20,10,40,30,50,70,80,60,90] QSort(L, 0, 3) [20,10,40,30,...] -&gt; 执行完余下的递归后 [10,20,30,40] pivot=1 [10,20,40,30,...] QSort(L, 0, 0) QSort(L, 2, 3) [x,x,40,30,...] pivot=2 [x,x,30,40,...] QSort(2,1) QSort(3,3) QSort(L, 5, 8) [...,70,80,60,90] -&gt; 执行完余下的递归后 [...,60,70,80,90] pivot=6 [...,60,70,80,90] QSort(L,5,5) QSort(L,7,8) [...,80,90] pivot=7 QSort(L,7,6) QSort(8,8) 快速排序复杂度分析 递归的运算可以想象成一颗递归树 在最优情况下, Partition() 每次都划分得很均匀, 如果排序 n 个关键字，其递归树的深度为\\(log_2 n + 1\\) 即仅需递归 \\(\\log_2 n\\) 次. 每次划分扫描耗时 \\(O(n)\\) 因此在最优情况下快速排序算法的时间复杂度为 \\(O(n\\log n)\\) 在最坏情况下, 待排序序列为正序或者逆序, 每次划分只得到比上一次划分少一个记录的子序列. 如果用递归树表示就是一颗斜树. 深度为 \\(n-1\\). 第 i 次划分需要 n-i 次比较, 即 \\(\\displaystyle\\sum_{i=1}^{n-1} n-i=O(n)\\) 因此在最坏情况下快速排序算法的时间复杂度为 \\(O(n^2)\\) 平均情况为 \\(O(n\\log n)\\) 由于关键字的比较和交换是跳跃进行的, 快速排序是一种不稳定的排序方法","link":"/zh-cn/learn/2020/data-structure/"},{"title":"Introduction to Linear Algebra","text":"This is an excerpt of both brief summary and worked examples of each section in the Introduction to Linear Algebra (Fifth Edition) by Gilbert Strang MIT Course 18.06, Spring 2022 TODO: draw svg format figure by using tikz; Using gather* or align* or array while there is a line break in display mode LaTex. .content { font-family: KaTeX_Main, 'FZYaSongS-R-GB'; } article.article .content { font-size: 1.3em; } .katex .base { font-size: 0.8em; } /* .katex-display { overflow-x: hidden; } */ .content ol.worked-examples { list-style-type: none; margin-left: 0em; } .content ol.worked-examples > li { margin-bottom: 1.5em; } .content ol.worked-examples > li > span.list-head, span.list-head { font-family: Ubuntu, Roboto, 'Open Sans'; font-weight: bold; } .content details summary span.list-summary { font-family: Ubuntu, Roboto, 'Open Sans'; font-weight: bold; color: RoyalBlue; } .list-table { border-collapse: collapse; width:100%; } .list-table tr > td:nth-child(1) { white-space: nowrap; text-align: right; vertical-align: top; border: none; padding: 0; width: 1%; } .list-table tr > td:nth-child(2) { text-align: left; vertical-align: top; border: none; padding: 0; } Chapter 1 Introduction to Vectors Vectors and Linear Combinations \\(3\\bm{v}+5\\bm{w}\\) is a typical linear combination \\(c\\bm{v}+d\\bm{w}\\) of the vectors \\(\\bm{v}\\) and \\(\\bm{w}\\). For \\(\\bm{v}=\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\) and \\(\\bm{w}=\\begin{bmatrix} 2 \\\\ 3 \\end{bmatrix}\\) that combination is \\(3\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}+5\\begin{bmatrix} 2 \\\\ 3 \\end{bmatrix}=\\begin{bmatrix} 3+10 \\\\ 3+15 \\end{bmatrix}=\\begin{bmatrix} 13 \\ 18 \\end{bmatrix}\\). The vector \\(\\begin{bmatrix} 2 \\\\ 3 \\end{bmatrix}=\\begin{bmatrix} 2 \\\\ 0 \\end{bmatrix}+\\begin{bmatrix} 0 \\\\ 3 \\end{bmatrix}\\) goes across to \\(x=2\\) and up to \\(y=3\\) in the \\(xy\\) plane. The combinations \\(c\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}+d\\begin{bmatrix} 2 \\\\ 3 \\end{bmatrix}\\) fill the whole \\(xy\\) place. They produce every \\(\\begin{bmatrix} x \\\\ y \\end{bmatrix}\\). The combinations \\(c\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}+d\\begin{bmatrix} 2 \\\\ 3 \\\\ 4 \\end{bmatrix}\\) fill a plane in \\(xyz\\) space. Same plane for \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\), \\(\\begin{bmatrix} 3 \\\\ 4 \\\\ 5 \\end{bmatrix}\\). But \\(\\begin{array}{l} c+2d=1 \\\\ c+3d=0 \\\\ c+4d=0 \\end{array}\\) has no solution because its right side \\(\\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}\\) is not on that plane. &dagger; WORKED EXAMPLES &dagger; 1.1 A&emsp;The linear combinations of \\(\\bm{v}=(1,1,0)\\) and \\(\\bm{w}=(0,1,1)\\) fill a plane in \\(\\mathbf{R}^3\\). Describe that plane. Find a vector that is not a combination of \\(\\bm{v}\\) and \\(\\bm{w}\\)&mdash;not on the plane. Solution&emsp;The plane of \\(\\bm{v}\\) and \\(\\bm{w}\\) contains all combinations \\(c\\bm{v}+d\\bm{w}\\). The vectors in that plane allow any \\(c\\) and \\(d\\). The plane of Figure 1.3 fills in between the two lines. &dagger; Figure 1.3 &dagger; $$ \\text{Combinations}\\quad c\\bm{v}+d\\bm{w}=c\\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix}+d\\begin{bmatrix} 0 \\\\ 1 \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} c \\\\ c+d \\\\ d \\end{bmatrix} \\text{fill a plane.} $$ Four vectors in that plane are \\((0,0,0)\\) and \\((2,3,1)\\) and \\((5,7,2)\\) and \\((\\pi,2\\pi,\\pi)\\). The second component \\(c+d\\) is always the sum of the first and third components. Like most vectors, \\((1,2,3)\\) is not in the plane, because \\(2\\neq 1+3\\). &emsp;&ensp;Another description of this plane through \\((0,0,0)\\) is to know that \\(\\bm{n}=(1,-1,1)\\) is perpendicular to the plane. Section 1.2 will confirm that 90&deg; angle by testing dot products: \\(\\bm{v}\\cdot\\bm{n}=0\\) and \\(\\bm{w}\\cdot\\bm{n}=0\\). Perpendicular vectors have zero dot products. 1.1 B&emsp;For \\(\\bm{v}=(1,0)\\) and \\(\\bm{w}=(0,1)\\), describe all points \\(c\\bm{v}\\) with (1) whole numbers \\(c\\) (2) nonnegative numbers \\(c\\geq 0\\). Then add all vectors \\(d\\bm{w}\\) and describe all \\(c\\bm{v}+d\\bm{w}\\). Solution (1)&ensp; The vectors \\(c\\bm{v}=(c,0)\\) with whole numbers \\(c\\) are equally spaced points along the \\(x\\) axis (the direction of \\(\\bm{v}\\)). They include \\((-2,0)\\), \\((-1,0)\\), \\((0,0)\\), \\((1,0)\\), \\((2,0)\\). (2)&ensp; The vectors \\(c\\bm{v}\\) with \\(c\\geq 0\\) fill a half-line. It is the positive \\(x\\) axis. This half-line starts at \\((0,0)\\) where \\(c=0\\). It includes \\((100,0)\\) and \\((\\pi,0)\\) but not \\((-100,0)\\). (1ʹ)&ensp; Adding all vectors \\(d\\bm{w}=(0,d)\\) puts a vertical line through those equally spaced \\(c\\bm{v}\\). We have infinitely many parallel lines from (whole number \\(c\\), any number \\(d\\)). (2ʹ)&ensp; Adding all vectors \\(d\\bm{w}\\) puts a vertical line through every \\(c\\bm{v}\\) on the half-line. Now we have a half-plane. The right half of the \\(xy\\) plane has any \\(x\\geq 0\\) and any \\(y\\). 1.1 C&emsp;Find two equations for \\(c\\) and \\(d\\) so that the linear combination \\(c\\bm{v}+d\\bm{w}\\) equals \\(\\bm{b}\\): $$ \\bm{v}=\\begin{bmatrix*}[r] 2 \\\\ -1 \\end{bmatrix*}\\qquad \\bm{w}=\\begin{bmatrix*}[r] -1 \\\\ 2 \\end{bmatrix*}\\qquad \\bm{b}=\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\text{.} $$ Solution&emsp;In applying mathematics, many problems have two parts: &emsp;1&ensp;Modeling part&emsp;Express the problem by a set of equations. &emsp;2&ensp;Computational part&emsp;Solve those equations by a fast and accurate algorithm. Here we are only asked for the first part (the equations). Chapter 2 is devoted to the second part (the solution). Our example fits into fundamental model for linear algebra: $$ \\text{Find $n$ numbers $c_1,\\ldots,c_n$ so that $c_1\\bm{v}_1+\\cdots+c_n\\bm{v}_n=\\bm{b}$.} $$ For \\(n=2\\) we will find a formula for the \\(\\bm{c}\\)'s. The &ldquo;elimination method&rdquo; in Chapter 2 succeeds far beyond \\(n=1000\\). For \\(n\\) greater than 1 billion, see Chapter 11. Here \\(n=2\\): $$ \\colorbox{e8f1fe}{$ \\begin{array}{l} \\textbf{Vector equation} \\\\ c\\bm{v}+d\\bm{w}=\\bm{b} \\end{array} \\qquad c\\begin{bmatrix*}[r] 2 \\\\ -1 \\end{bmatrix*}+d\\begin{bmatrix*}[r] -1 \\\\ 2 \\end{bmatrix*}=\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} $} $$ The required equations for \\(c\\) and \\(d\\) just come from the two components separately: $$ \\textcolor{RoyalBlue}{\\textbf{Two ordinary equations}}\\qquad \\begin{alignedat}{2.5} % Using alignedat for no space between columns. For parameter there is +0.5 per column (pair of rl columns), columms align are col1=right, col2=left, col3=right... && 2c- && d=1 \\\\ - && c+ && 2d=0 \\end{alignedat} $$ Each equation produces a line. The two lines cross at the solution \\(c=\\dfrac{2}{3}\\), \\(d=\\dfrac{1}{3}\\). Why not see this also as a matrix equation, since that is where we are going: $$ \\textbf{2 by 2 matrix}\\qquad \\begin{bmatrix*}[r] \\bm{2} & \\bm{-1} \\\\ \\bm{-1} & \\bm{2} \\end{bmatrix*} \\begin{bmatrix} c \\\\ d \\end{bmatrix}=\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\text{.} $$ Lengths and Dot Products The “dot product” of \\(\\bm{v}=\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}\\) and \\(\\bm{w}=\\begin{bmatrix} 4 \\\\ 5 \\end{bmatrix}\\) is \\(\\bm{v}\\cdot\\bm{w}=(1)(4)+(2)(5)=4+10=\\bm{14}\\). \\(\\bm{v}=\\begin{bmatrix} 1 \\\\ 3 \\\\ 2 \\end{bmatrix}\\) and \\(\\bm{w}=\\begin{bmatrix*}[r] 4 \\\\ -4 \\\\ 4 \\end{bmatrix*}\\) are perpendicular because \\(\\bm{v}\\cdot\\bm{w}\\) is zero: \\((1)(4)+(3)(-4)+(2)(4)=\\bm{0}\\). The length squared of \\(\\bm{v}=\\begin{bmatrix} 1 \\\\ 3 \\\\ 2 \\end{bmatrix}\\) is \\(\\bm{v}\\cdot\\bm{v}=1+9+4=14\\). The length is \\(\\|\\bm{v}\\|=\\sqrt{\\bm{14}}\\). Then \\(\\bm{u}=\\dfrac{\\bm{v}}{\\|\\bm{v}\\|}=\\dfrac{\\bm{v}}{\\sqrt{14}}=\\dfrac{1}{\\sqrt{14}}\\begin{bmatrix} 1 \\\\ 3 \\\\ 2 \\end{bmatrix}\\) has length \\(\\|\\bm{u}\\|=\\bm{1}\\). Check \\(\\dfrac{1}{14}+\\dfrac{9}{14}+\\dfrac{4}{14}=1\\). The angle \\(\\theta\\) between \\(\\bm{v}\\) and \\(\\bm{w}\\) has \\(\\cos\\theta=\\dfrac{\\bm{v}\\cdot\\bm{w}}{\\|\\bm{v}\\|\\|\\bm{w}\\|}\\). The angle between \\(\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\) and \\(\\begin{bmatrix} 1 \\\\ 1\\end{bmatrix}\\) has \\(\\cos\\theta=\\dfrac{1}{(1)(\\sqrt{2})}\\). That angle is \\(\\theta=45\\degree\\). All angles have \\(|\\cos\\theta|\\leq 1\\). So all vectors have \\(\\boxed{|\\bm{v}\\cdot\\bm{w}|\\leq\\|\\bm{v}\\|\\|\\bm{w}\\|}\\). &dagger; WORKED EXAMPLES &dagger; 1.2 A&emsp;For the vectors \\(\\bm{v}=(3,4)\\) and \\(\\bm{w}=(4,3)\\) test the Schwarz inqeuality on \\(\\bm{v}\\cdot\\bm{w}\\) and the triangle inqeuality on \\(\\|\\bm{v}+\\bm{w}\\|\\). Find \\(\\cos\\theta\\) for the angle between \\(\\bm{v}\\) and \\(\\bm{w}\\). Which \\(\\bm{v}\\) and \\(\\bm{w}\\) give equality \\(\\|\\bm{v}\\cdot\\bm{w}\\|=\\|\\bm{v}\\|\\|\\bm{w}\\|\\) and \\(\\|\\bm{v}+\\bm{w}\\|=\\|\\bm{w}\\|+\\|\\bm{w}\\|\\)? Solution&emsp;The dot product is \\(\\bm{v}\\cdot\\bm{w}=(3)(4)+(4)(3)=24\\). The length of \\(\\bm{v}\\) is \\(\\|\\bm{v}\\|=\\sqrt{9+16}=5\\) and also \\(\\|\\bm{w}\\|=5\\). The sum \\(\\bm{v}+\\bm{w}=(7,7)\\) has length \\(7\\sqrt{2}\\lt 10\\). $$ \\begin{array}{ll} \\textbf{Schwarz inequality} & \\text{$|\\bm{v}\\cdot\\bm{w}|\\leq\\|\\bm{v}\\|\\|\\bm{w}\\|$\\quad is\\quad$24\\lt 25$.} \\\\ \\textbf{Triangle inequality} & \\text{$\\|\\bm{v}+\\bm{w}\\|\\leq\\|\\bm{v}\\|+\\|\\bm{w}\\|$\\quad is\\quad$7\\sqrt{2}\\lt 5+5$.} \\\\ \\textbf{Cosine of angle} & \\text{$\\cos\\theta=\\frac{24}{25}$\\quad Thin angle from $\\bm{v}=(3,4)$ to $\\bm{w}=(4,3)$.} \\end{array} $$ Equality: One vector is a multiple of the other as in \\(\\bm{w}=c\\bm{v}\\). Then the angle is 0&deg; or 180&deg;. In this case \\(|\\cos\\theta|=1\\) and \\(|\\bm{v}\\cdot\\bm{w}|\\) equals \\(\\|\\bm{v}\\|\\|\\bm{w}\\|\\). If the angle is 0&deg;, as in \\(\\bm{w}=2\\bm{v}\\), then \\(\\|\\bm{v}+\\bm{w}\\|=\\|\\bm{v}\\|+\\|\\bm{w}\\|\\) (both sides give \\(3\\|\\bm{v}\\|\\)). This \\(\\bm{v}\\), \\(2\\bm{v}\\), \\(3\\bm{v}\\) triangle is flat! 1.2 B&emsp;Find a unit vector \\(\\bm{u}\\) in the direction of \\(\\bm{v}=(3,4)\\). Find a unit vector \\(\\bm{U}\\) that is perpendicular to \\(\\bm{u}\\). How many possibilities for \\(\\bm{U}\\)? Solution&emsp;For a unit vector \\(\\bm{u}\\), divide \\(\\bm{v}\\) by its length \\(\\|\\bm{v}\\|=5\\). For a perpendicular vector \\(\\bm{V}\\) we can choose \\((-4,3)\\) since the dot product \\(\\bm{v}\\cdot\\bm{V}\\) is \\((3)(-4)+(4)(3)=0\\). For a unit vector perpendicular to \\(\\bm{u}\\), divide \\(\\bm{V}\\) by its length \\(\\|\\bm{V}\\|\\): $$ \\bm{u}=\\frac{\\bm{v}}{\\|\\bm{v}\\|}=\\left(\\frac{3}{5},\\frac{4}{5}\\right)\\qquad \\bm{U}=\\frac{\\bm{V}}{\\|\\bm{V}\\|}=\\left(-\\frac{4}{5},\\frac{3}{5}\\right)\\qquad \\bm{u}\\cdot\\bm{U}=0 $$ The only other perpendicular unit vector would be \\(-\\bm{U}=(\\frac{4}{5},-\\frac{3}{5})\\). 1.2 C&emsp;Find a vector \\(\\bm{x}=(c,d)\\) that has dot products \\(\\bm{x}\\cdot\\bm{r}=1\\) and \\(\\bm{x}\\cdot\\bm{s}=0\\) with two given vectors \\(\\bm{r}=(2,-1)\\) and \\(\\bm{s}=(-1,2)\\). Solution&emsp;Those two dot products give linear equations for \\(c\\) and \\(d\\). Then \\(\\bm{x}=(c,d)\\). $$ \\begin{alignedat}{3} \\bm{x}\\cdot\\bm{r}=1\\qquad\\text{is}\\qquad & & 2c- && d=1\\qquad & \\textbf{The same equations as} \\\\ \\bm{x}\\cdot\\bm{s}=0\\qquad\\text{is}\\qquad & - & c+ && 2d=0\\qquad & \\textbf{in Worked Example 1.1 C} \\end{alignedat} $$ &emsp;&ensp;Comment on n equations for \\(x=(x_1,\\ldots,x_n)\\) in n-dimensional space Section 1.1 would start with columns \\(\\bm{v}_j\\). The goal is to produce \\(x_1\\bm{v}_1+\\cdots+x_n\\bm{v}_n=\\bm{b}\\). This section would start from rows \\(\\bm{r}_i\\). Now the goal is to find \\(\\bm{x}\\) with \\(\\bm{x}\\cdot\\bm{r}_i=b_i\\). &emsp;&ensp;Soon the \\(\\bm{v}\\)'s will be columns of a matrix \\(A\\), and the \\(\\bm{r}\\)'s will be the rows of \\(A\\). Then the (one and only) problem will be to solve \\(A\\bm{x}=\\bm{b}\\). Matrices \\(A=\\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ 5 &amp; 6 \\end{bmatrix}\\) is a 3 by 2 matrix : \\(m=3\\) rows and \\(n=2\\) columns. \\(A\\bm{x}=\\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ 5 &amp; 6 \\end{bmatrix}\\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix}\\) is a combination of the columns \\(A\\bm{x}=x_1\\begin{bmatrix} 1 \\\\ 3 \\\\ 5 \\end{bmatrix}+x_2\\begin{bmatrix} 2 \\\\ 4 \\\\ 6 \\end{bmatrix}\\). The 3 components of \\(A\\bm{x}\\) are dot products of the 3 rows of \\(A\\) with the vector \\(\\bm{x}\\): $$ \\textbf{Row at a time}\\qquad \\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\\\ 5 & 6 \\end{bmatrix}\\begin{bmatrix} 7 \\\\ 8 \\end{bmatrix} = \\begin{bmatrix} 1\\cdot 7+2\\cdot 8 \\\\ 3\\cdot 7+4\\cdot 8 \\\\ 5\\cdot 7+6\\cdot 8 \\end{bmatrix} = \\begin{bmatrix} 23 \\\\ 53 \\\\ 83 \\end{bmatrix} \\text{.} $$ Equations in matrix form \\(A\\bm{x}=\\bm{b}\\): \\(\\begin{bmatrix} 2 &amp; 5 \\\\ 3 &amp; 7 \\end{bmatrix}\\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix}=\\begin{bmatrix} b_1 \\\\ b_2 \\end{bmatrix}\\) replaces \\(\\begin{array}{l} 2x_1+5x_2=b_1 \\\\ 3x_1+7x_2=b_2 \\end{array}\\). The solution to \\(A\\bm{x}=\\bm{b}\\) can be written as \\(\\bm{x}=A^{-1}\\bm{b}\\). But some matrices don’t allow \\(A^{-1}\\). &dagger; WORKED EXAMPLES &dagger; 1.3 A&emsp;Change the southwest entry \\(a_{31}\\) of \\(A\\) (row 3, column 1) to \\(a_{31}=\\bm{1}\\): $$ A\\bm{x}=\\bm{b}\\qquad \\begin{bmatrix*}[r] 1 & 0 & 0 \\\\ -1 & 1 & 0 \\\\ \\bm{1} & -1 & 1 \\end{bmatrix*}\\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{bmatrix} = \\left[\\begin{alignedat}{1} & x_1 \\\\ - & x_1+x_2 \\\\ & \\bm{x_1}-x_2+x_3 \\end{alignedat}\\right] = \\begin{bmatrix} b_1 \\\\ b_2 \\\\ b_3 \\end{bmatrix} \\text{.} $$ Find the solution \\(\\bm{x}\\) for any \\(\\bm{b}\\). From \\(\\bm{x}=A^{-1}\\bm{b}\\) read off the inverse matrix \\(A^{-1}\\). Solution&emsp;Solve the (linear triangular) system \\(A\\bm{x}=\\bm{b}\\) from top to bottom: $$ \\begin{alignedat}{3} & \\text{first}\\quad && x_1=b_1 && \\\\ & \\text{then}\\quad && x_2=b_1+ && b_2 \\\\ & \\text{then}\\quad && x_3= && b_2+b_3 \\end{alignedat} \\text{ This says that $\\bm{x}=A^{-1}\\bm{b}= \\begin{bmatrix} 1 & 0 & 0 \\\\ 1 & 1 & 0 \\\\ 0 & 1 & 1 \\end{bmatrix}\\begin{bmatrix} b_1 \\\\ b_2 \\\\ b_3 \\end{bmatrix}$ . } $$ This is good practice to see the columns of the inverse matrix multiplying \\(b_1\\), \\(b_2\\), and \\(b_3\\). The first column of \\(A^{-1}\\) is the solution for \\(\\bm{b}=(1,0,0)\\). The second column is the solution for \\(\\bm{b}=(0,1,0)\\). The third column \\(\\bm{x}\\) of \\(A^{-1}\\) is the solution for \\(A\\bm{x}=\\bm{b}=(0,0,1)\\). &emsp;&ensp;The three columns of \\(A\\) are still independent. They don't lie in a plane. The combinations of those three columns, using the right weights \\(x_1\\), \\(x_2\\), \\(x_3\\), can produce any three-dimensional vector \\(\\bm{b}=(b_1,b_2,b_3)\\). Those weights come from \\(\\bm{x}=A^{-1}\\bm{b}\\). 1.3 B&emsp;This \\(E\\) is an elimination matrix. \\(E\\) has a subtraction and \\(E^{-1}\\) has an addition. $$ % Sorry for the type, will reformat as soon as KaTex support multicolumn. \\bm{b}=E\\bm{x}\\qquad \\begin{bmatrix} b_1 \\\\ b_2 \\end{bmatrix} = \\begin{bmatrix} x_1 \\\\ x_2-\\ell x_1 \\end{bmatrix} = \\begin{bmatrix*}[r] \\bm{1} & 0 \\\\ -\\bm{\\ell} & \\bm{1} \\end{bmatrix*}\\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix}\\qquad E=\\begin{bmatrix*}[r] \\bm{1} & 0 \\\\ -\\bm{\\ell} & \\bm{1} \\end{bmatrix*} $$ The first equation is \\(x_1=b_1\\). The second equation is \\(x_2-\\ell x_1=b_2\\). The inverse will add \\(\\ell b_1\\) to \\(b_2\\), because the elimination matrix subtracted : $$ \\bm{x}=E^{-1}\\bm{b}\\qquad \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} = \\left[\\begin{alignedat}{1} & b_1 \\\\ \\ell & b_1+b_2 \\end{alignedat}\\right] = \\begin{bmatrix} \\bm{1} & 0 \\\\ \\bm{\\ell} & \\bm{1} \\end{bmatrix}\\begin{bmatrix} b_1 \\\\ b_2 \\end{bmatrix}\\qquad E^{-1}=\\begin{bmatrix} \\bm{1} & 0 \\\\ \\bm{\\ell} & \\bm{1} \\end{bmatrix} $$ 1.3 C&emsp;Change \\(C\\) from a cyclic difference to a centered difference producing \\(x_3-x_1\\): $$ \\begin{equation} C\\bm{x}=\\bm{b}\\qquad \\begin{bmatrix*}[r] 0 & 1 & 0 \\\\ -1 & 0 & 1 \\\\ 0 & -1 & 0 \\end{bmatrix*}\\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{bmatrix} = \\left[\\begin{alignedat}{1} x_2 & -0 \\\\ x_3 & -x_1 \\\\ 0 & -x_2 \\end{alignedat}\\right] = \\begin{bmatrix} b_1 \\\\ b_2 \\\\ b_3 \\end{bmatrix} \\text{.} \\end{equation} $$ \\(C\\bm{x}=\\bm{b}\\) can only be solved when \\(b_1+b_3=x_2-x_2=0\\). That is a plane of vectors \\(\\bm{b}\\) in three-dimensional space. Each column of \\(C\\) is in the plane, the matrix has no inverse. So this plane conatins all combinations of those columns (which are all the vectors \\(C\\bm{x}\\)). &emsp;&ensp;I included the zeros so you could see that this \\(C\\) produces &ldquo;centered differences&rdquo;. Row \\(i\\) of \\(C\\bm{x}\\) is \\(x_{i+1}\\) (right of center) minus \\(x_{i-1}\\) (left of center). Here is 4 by 4: $$ \\begin{equation} \\begin{array}{l} C\\bm{x}=\\bm{b} \\\\ \\textbf{Centered} \\\\ \\textbf{differences} \\end{array}\\qquad \\begin{bmatrix*}[r] 0 & 1 & 0 & 0 \\\\ -1 & 0 & 1 & 0 \\\\ 0 & -1 & 0 & 1 \\\\ 0 & 0 & -1 & 0 \\end{bmatrix*} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\end{bmatrix} = \\left[\\begin{alignedat}{1} x_2 & -0 \\\\ x_3 & -x_1 \\\\ x_4 & -x_2 \\\\ 0 & -x_3 \\end{alignedat}\\right] = \\begin{bmatrix} b_1 \\\\ b_2 \\\\ b_3 \\\\ b_4 \\end{bmatrix} \\end{equation} $$ Surprisingly this matrix is now invertible! The first and last rows tell you \\(x_2\\) and \\(x_3\\). Then the middle rows give \\(x_1\\) and \\(x_4\\). It is possible to write down the inverse matrix \\(C^{-1}\\). But 5 by 5 will be singular (not invertible) again&mldr; Chapter 2 Solving Linear Equations Vectors and Linear Equations The column picture of \\(A\\bm{x}=\\bm{b}\\) : a combination of \\(n\\) columns of \\(A\\) produces the vector \\(\\bm{b}\\). This is a vector equation \\(A\\bm{x}=x_1\\bm{a}_1+\\cdots+x_n\\bm{a}_n=\\bm{b}\\) : the columns of \\(A\\) are \\(\\bm{a}_1,\\bm{a}_2,\\ldots,\\bm{a}_n\\). When \\(\\bm{b}=\\bm{0}\\), a combination \\(A\\bm{x}\\) of the columns is zero : one possibility is \\(\\bm{x}=(0,\\ldots,0)\\). The row picture of \\(A\\bm{x}=\\bm{b}\\) : \\(m\\) equations from \\(m\\) rows give \\(m\\) planes meeting at \\(\\bm{x}\\). A dot product gives the equation of each plane : \\((\\textbf{row 1})\\cdot\\bm{x}=b_1,\\ldots,(\\textbf{row }\\bm{m})\\cdot\\bm{x}=b_m\\) When \\(\\bm{b}=\\bm{0}\\), all the planes \\((\\textbf{row }\\bm{i})\\cdot\\bm{x}=0\\) go through the center point \\(\\bm{x}=(0,0,\\ldots,0)\\). &dagger; WORKED EXAMPLES &dagger; 2.1 A&emsp;Describe the column picture of these three equations \\(A\\bm{x}=\\bm{b}\\). Solve by careful inspection of the columns (instead of elimination): $$ \\begin{array}{r} x+3y+2z=-3 \\\\ 2x+2y+2z=-2 \\\\ 3x+5y+6z=-5 \\end{array}\\qquad\\text{which is}\\qquad\\begin{bmatrix} 1 & \\bm{3} & 2 \\\\ 2 & \\bm{2} & 2 \\\\ 3 & \\bm{5} & 6 \\end{bmatrix}\\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}=\\begin{bmatrix*}[r] -3 \\\\ -2 \\\\ -5 \\end{bmatrix*} $$ Solution&emsp;The column picture asks for a linear combination that produces \\(\\bm{b}\\) from the three columns of \\(A\\). In this example \\(\\bm{b}\\) is minus the second column. So the solution is \\(x=0\\), \\(y=-1\\), \\(z=0\\). To show that \\((0,-1,0)\\) is the only solution we have to know that &ldquo;\\(A\\) is invertible&rdquo; and &ldquo;the columns are independent&rdquo; and &ldquo;the determinant isn't zero.&rdquo; &emsp;&ensp;Those words are not yet defined but the test comes from elimination: We need (and for this matrix we find) a full set of three nonzero pivots. &emsp;&ensp;Suppose the right side changes to \\(\\bm{b}=(4,4,8)=\\) sum of the first two columns. Then the good combination has \\(x=1\\), \\(y=1\\), \\(z=0\\). The solution becomes \\(\\bm{x}=(1,1,0)\\). 2.1 B&emsp;This system has no solution. The planes in the row picture don't meet at a point. $$ \\textcolor{RoyalBlue}{\\textit{\\textbf{No combination of the three columns produces b. How to show this?}}} \\\\ \\begin{array}{r} x+3y+5z=4 \\\\ x+2y-3z=5 \\\\ 2x+5y+2z=8 \\end{array}\\qquad\\begin{bmatrix*}[r] 1 & 3 & 5 \\\\ 1 & 2 & -3 \\\\ 2 & 5 & 2 \\end{bmatrix*}\\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}=\\begin{bmatrix} 4 \\\\ 5 \\\\ 8 \\end{bmatrix}=\\bm{b} $$ Idea&emsp;Add \\((\\text{equation 1})+(\\text{equation 2})-(\\text{equation 3})\\). The result is \\(\\bm{0}=\\bm{1}\\). This system cannot have a solution. We could say: The vector \\((1,1,-1)\\) is orthogonal to all three columns of \\(A\\) but not orthogonal to \\(\\bm{b}\\). &ensp;(1)&ensp;Are any two of the three planes parallel? What are the equations of planes parallel to \\(x+3y+5z=4\\)? &ensp;(2)&ensp;Take the dot product of each column of \\(A\\) (and also \\(\\bm{b}\\)) with \\(\\bm{y}=(1,1,-1)\\). How do those dot products show that no combination of columns equals \\(\\bm{b}\\)? &ensp;(3)&ensp;Find three different right side vectors \\(\\bm{b}^{*}\\) and \\(\\bm{b}^{**}\\) and \\(\\bm{b}^{***}\\) that *do* allow solutions. Solution&emsp; &ensp;(1)&ensp;The planes don't meet at a point, even though no two planes are parallel. For a plane parallel to \\(x+3y+5z=4\\). Change the &ldquo;4&rdquo;. The parallel plane \\(x+3y+5z=0\\) goes through the origin \\((0,0,0)\\). And the equation multiplied by any nonzero constant still gives the same plane, as in \\(2x+6y+10z=8\\). &ensp;(2)&ensp;The dot product of each column of \\(A\\) with \\(\\bm{y}=(1,1,-1)\\) is zero. On the right side, \\(\\bm{y}\\cdot\\bm{b}=(1,1,-1)\\cdot(4,5,8)=\\bm{1}\\) is not zero. \\(A\\bm{x}=\\bm{b}\\) led to \\(0=1\\): no solution. &ensp;(3)&ensp;There is a solution when \\(\\bm{b}\\) is a combination of the columns. These three choices of \\(\\bm{b}\\) have solutions including \\(\\bm{x}^{*}=(1,0,0)\\) and \\(\\bm{x}^{**}=(1,1,1)\\) and \\(\\bm{x}^{***}=(0,0,0)\\): $$ \\bm{b}^{*}=\\begin{bmatrix} 1 \\\\ 1 \\\\ 2 \\end{bmatrix}=\\text{first column}\\qquad\\bm{b}^{**}=\\begin{bmatrix} 9 \\\\ 0 \\\\ 9 \\end{bmatrix}=\\text{sum of columns}\\qquad\\bm{b}^{***}=\\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix} $$ The Idea of Elimination For \\(\\bm{m}=\\bm{n}=3\\), there are three equations \\(A\\bm{x}=\\bm{b}\\) and three unknowns \\(x_1\\), \\(x_2\\), \\(x_3\\). The first two equations are \\(a_{11}x_1+\\cdots=b_1\\) and \\(a_{21}x_1+\\cdots=b_2\\) Multiply the first equation by \\(a_{21}/a_{11}\\) and subtract from the second : then \\(x_1\\) is eliminated. The corner entry \\(a_{11}\\) is the first “pivot” and the ratio \\(a_{21}/a_{11}\\) is the first “multiplier.” Eliminate \\(x_1\\) from every remaining equation \\(i\\) by subtracting \\(a_{i1}/a_{11}\\) times the first equation. Now the last \\(n-1\\) equations contain \\(n-1\\) unknowns \\(x_2,\\ldots,x_n\\). Repeat to eliminate \\(x_2\\). Elimination breaks down if zero appears in the pivot. Exchanging two equations may save it. &dagger; WORKED EXAMPLES &dagger; 2.2 A&emsp;When elimination is applied to this matrix \\(A\\), what are the first and second pivots? What is the multiplier \\(\\ell_{21}\\) in the first step (\\(\\ell_{21}\\) times row 1 is subtracted from row 2)? $$ A=\\begin{bmatrix} 1 & 1 & 0 \\\\ 1 & 2 & 1 \\\\ 0 & 1 & 2 \\end{bmatrix}\\longrightarrow\\begin{bmatrix} 1 & 1 & 0 \\\\ 0 & 1 & 1 \\\\ 0 & 1 & 2 \\end{bmatrix}\\longrightarrow\\begin{bmatrix} 1 & 1 & 0 \\\\ 0 & 1 & 1 \\\\ 0 & 0 & 1 \\end{bmatrix}=U $$ What entry in the 2,2 position (instead of 2) would force an exchange of rows 2 and 3? Why is the lower left multiplier \\(\\ell_{31}=0\\), subtracting zero times row 1 from row 3? If you change the corner entry from \\(a_{33}=2\\) to \\(a_{33}=1\\), why does elimination fail? Solution&emsp;The first pivot is 1. The multiplier \\(\\ell_{21}\\) is 1,1. When 1 times row 1 is subtracted from row 2, the second pivot is revealed as another 1. If the original middle entry had been 1 instead of 2, that would have forced a row exchange. &emsp;&ensp;The multiplier \\(\\ell_{31}\\) is zero because \\(a_{31}=0\\). A zero at the start of a row needs no elimination. This \\(A\\) is a \"band matrix\". Everything stays zero outside the band. &emsp;&ensp;The last pivot is also 1. So if the original corner \\(a_{33}=2\\) reduced by 1, elimination would produce 0. No third pivot, elimination fails. 2.2 B&emsp;Suppose \\(A\\) is already a triangular matrix (upper triangular or lower triangular). Where do you see its pivots? When does \\(A\\bm{x}=\\bm{b}\\) have exactly one solution for every \\(\\bm{b}\\)? Solution&emsp;The pivots of a triangular matrix are already set along the main diagonal. Elimination succeeds when all those numbers are nonzero. Use back substitution when \\(A\\) is upper triangular, go forward when \\(A\\) is lower triangular. 2.2 C&emsp;Use elimination to reach upper triangular matrices \\(U\\). Solve by back substitution or explain why this is impossible. What are the pivots (never zero)? Exchange equations when necessary. The only difference is the \\(-x\\) in the last equation. $$ \\begin{array}{rrrr} \\textbf{Success}\\quad & x+y+z=7 & \\qquad\\textbf{Failure}\\quad & x+y+z=7 \\\\ & x+y-z=5 & & x+y-z=5 \\\\ & x-y+z=3 & & -x-y+z=3 \\end{array} $$ Solution&emsp;For the first system, subtract equation 1 from equations 2 and 3 (the multipliers are \\(\\ell_{21}=1\\) and \\(\\ell_{31}=1\\)). The 2,2 entry becomes zero, so exchange equations 2 and 3 : $$ \\textbf{Success}\\qquad \\begin{alignedat}{3.5} x+ && y+ && z= && 7 \\\\ && \\bm{0}y- && 2z= && -2 \\\\ -&& 2y+ && 0z= && -4 \\end{alignedat} \\qquad\\text{exchanges into}\\qquad \\begin{alignedat}{3.5} x+ && y+ && z= && 7 \\\\ \\bm{-} && \\bm{2}y+ && 0z= && -4 \\\\ && - && 2z= && -2 \\end{alignedat} $$ Then back substitution gives \\(z=1\\) and \\(y=2\\) and \\(x=4\\). The pivots are 1, &minus;2, &minus;2. &emsp;&ensp;For the second system, subtract equation 1 from equation 2 as before. Add equation 1 to equation 3. This leaves zero in the 2,2 entry and also below : $$ \\textbf{Failure}\\qquad \\begin{alignedat}{4} x+ && y+ && z= && 7 & \\qquad\\text{There is \\textbf{no pivot in column 2} (it was \\textemdash\\space column 1)} \\\\ && \\bm{0}y- && 2z= && -2 & \\qquad\\text{A further elimination step gives $\\bm{0z=8}$} \\\\ && \\bm{0}y+ && 2z= && 10 & \\qquad\\text{The three planes \\textbf{don't meet}} \\end{alignedat} $$ Plane 1 meets plane 2 in a line. Plane 1 meets plane 3 in a parallel line. No solution. &emsp;&ensp;If we change the &ldquo;3&rdquo; in the original third equation to &ldquo;&minus;5&rdquo; then elimination would lead to \\(0=0\\). There are infinitely many solutions! The three planes now meet along a whole line. &emsp;&ensp;Changing 3 to &minus;5 moved the third plane to meet the other two. The second equation gives \\(z=1\\). Then the first equation leaves \\(x+y=6\\). No pivot in column 2 makes \\(\\bm{y}\\) free (free variables can have any value). Then \\(x=6-y\\). Elimination Using Matrices The first step multiplies the equations \\(A\\bm{x}=\\bm{b}\\) by a matrix \\(E_{21}\\) to produce \\(E_{21}A\\bm{x}=E_{21}\\bm{b}\\). That matrix \\(E_{21}A\\) has a zero in row 2, column 1 because \\(x_1\\) is eliminated from equation 2. \\(E_{21}\\) is the identity matrix (diagonal of 1’s) minus the multiplier \\(a_{21}/a_{11}\\) in row 2, column. Matrix-matrix multiplication is \\(n\\) matrix-vector multiplications: \\(\\bm{EA}=\\begin{bmatrix} \\bm{Ea_1} &amp; \\ldots &amp; \\bm{Ea_n} \\end{bmatrix}\\) We must also multiply \\(E\\bm{b}\\)! So \\(E\\) is multiplying the augmented matrix \\(\\begin{bmatrix} A &amp; \\bm{b} \\end{bmatrix}=\\begin{bmatrix} \\bm{a}_1 &amp; \\ldots &amp; \\bm{a}_n &amp; \\bm{b} \\end{bmatrix}\\). Elimination multiplies \\(A\\bm{x}=\\bm{b}\\) by \\(E_{21}\\), \\(E_{31}\\), \\(\\ldots\\), \\(E_{n1}\\), then \\(E_{32}\\), \\(E_{42}\\), \\(\\ldots\\), \\(E_{n2}\\), and onward. The row exchange matrix is not \\(E_{ij}\\) but \\(P_{ij}\\). To find \\(P_{ij}\\), exchange rows \\(i\\) and \\(j\\) of \\(I\\). &dagger; WORKED EXAMPLES &dagger; 2.3 A&emsp;What 3 by 3 matrix \\(E_{21}\\) subtracts 4 times row 1 from row 2? What matrix \\(P_{32}\\) exchanges row 2 and row 3? If you multiply \\(A\\) on the right instead of the left, describe the results \\(AE_{21}\\) and \\(AP_{32}\\). Solution&emsp;By doing those operations on the identity matrix \\(I\\), we find $$ E_{21}=\\begin{bmatrix*}[r] 1 & 0 & 0 \\\\ -4 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix*} \\qquad\\text{and}\\qquad P_{32}=\\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 1 & 0 \\end{bmatrix} $$ Multiplying by \\(E_{21}\\) on the right side will subtract 4 times column 2 from column 1. Multiplying by \\(P_{32}\\) on the right will exchange columns 2 and 3. 2.3 B&emsp;Write down the augmented matrix \\(\\begin{bmatrix} A & \\bm{b} \\end{bmatrix}\\) with an extra column: $$ \\begin{array}{r} x+2y+2z=1 \\\\ 4x+8y+9z=3 \\\\ 3y+2z=1 \\end{array} $$ Apply \\(E_{21}\\) and then \\(P_{32}\\) to reach a triangular system. Solve by back substitution. What combined matrix \\(P_{32}E_{21}\\) will do both steps at once? Solution&emsp;\\(E_{21}\\) removes the 4 in column 1. But zero also appears in column 2: $$ \\begin{bmatrix} A & \\bm{b} \\end{bmatrix}= \\begin{bmatrix} 1 & 2 & 2 & 1 \\\\ \\bm{4} & 8 & 9 & 3 \\\\ 0 & 3 & 2 & 1 \\end{bmatrix} \\qquad\\text{and}\\qquad E_{21}\\begin{bmatrix} A & \\bm{b} \\end{bmatrix}= \\begin{bmatrix*}[r] 1 & 2 & 2 & 1 \\\\ \\bm{0} & \\bm{0} & 1 & -1 \\\\ 0 & 3 & 2 & 1 \\end{bmatrix*} $$ Now \\(P_{32}\\) exchanges rows 2 and 3. Back substitution produces \\(z\\) then \\(y\\) and \\(x\\). $$ P_{32}E_{21}\\begin{bmatrix} A & \\bm{b} \\end{bmatrix}= \\begin{bmatrix*}[r] 1 & 2 & 2 & 1 \\\\ 0 & 3 & 2 & 1 \\\\ 0 & 0 & 1 & -1 \\end{bmatrix*} \\qquad\\text{and}\\qquad \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}=\\begin{bmatrix*}[r] 1 \\\\ 1 \\\\ -1 \\end{bmatrix*} $$ For the matrix \\(P_{32}E_{21}\\) that does both steps at once, apply \\(P_{32}\\) to \\(E_{21}\\). $$ \\begin{array}{l} \\textbf{One matrix} \\\\ \\textbf{Both steps} \\end{array} \\qquad P_{32}E_{21}=\\text{exchange the rows of }E_{21}=\\begin{bmatrix*} 1 & 0 & 0 \\\\ 0 & 0 & 1 \\\\ -4 & 1 & 0 \\end{bmatrix*}\\text{.} $$ 2.3 C&emsp;Multiply these matrices in two ways. First, rows of \\(A\\) times columns of \\(B\\). Second, columns of \\(\\bm{A}\\) times rows of \\(\\bm{B}\\). That unusual way produces two matrices that add to \\(AB\\). How many separate ordinary multiplications are needed? $$ \\textbf{Both ways}\\qquad AB=\\begin{bmatrix} 3 & 4 \\\\ 1 & 5 \\\\ 2 & 0 \\end{bmatrix}\\begin{bmatrix} 2 & 4 \\\\ 1 & 1 \\end{bmatrix}=\\begin{bmatrix*}[r] \\bm{10} & \\bm{16} \\\\ \\bm{7} & \\bm{9} \\\\ \\bm{4} & \\bm{8} \\end{bmatrix*} $$ Solution&emsp;Rows of \\(A\\) times columns of \\(B\\) are dot products of vectors: $$ \\begin{alignedat}{1.5} (\\text{row 1})\\cdot(\\text{column 1})= \\begin{matrix} \\begin{bmatrix} 3 & 4 \\end{bmatrix} \\\\ \\\\ \\text{} \\end{matrix} \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix} = && \\bm{10}\\qquad\\text{is the (1,1) entry of $AB$} \\\\ \\\\ (\\text{row 2})\\cdot(\\text{column 1})= \\begin{bmatrix} 1 & 5 \\end{bmatrix}\\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix} = && \\bm{7}\\qquad\\text{is the (2,1) entry of $AB$} \\end{alignedat} $$ We need 6 dot products, 2 multiplications each, 12 in all (3 &sdot; 2 &sdot; 2). The same \\(AB\\) comes from columns of \\(A\\) times rows of \\(B\\). A column times a row is a matrix. $$ AB= \\begin{bmatrix} 3 \\\\ 1 \\\\ 2 \\end{bmatrix} \\begin{matrix} \\begin{bmatrix} 2 & 4 \\end{bmatrix} \\\\ \\text{} \\end{matrix} + \\begin{bmatrix} 4 \\\\ 5 \\\\ 0 \\end{bmatrix} \\begin{matrix} \\\\ \\begin{bmatrix} 1 & 1 \\end{bmatrix} \\end{matrix} = \\begin{bmatrix*}[r] \\bm{6} & \\bm{12} \\\\ \\bm{2} & \\bm{4} \\\\ \\bm{4} & \\bm{8} \\end{bmatrix*} + \\begin{bmatrix} \\bm{4} & \\bm{4} \\\\ \\bm{5} & \\bm{5} \\\\ \\bm{0} & \\bm{0} \\end{bmatrix} $$ Rules for Matrix Operations Matrices \\(A\\) with \\(n\\) columns multiply matrices \\(B\\) with \\(n\\) rows : \\(\\boxed{A_{\\bm{m}\\times\\bm{n}}B_{\\bm{n}\\times\\bm{p}}=C_{\\bm{m}\\times\\bm{p}}}\\). Each entry in \\(AB=C\\) is a dot product : \\(C_{ij}=(\\text{row $i$ of $A$})\\cdot(\\text{column $j$ of $B$})\\). This rule is chosen so that \\(\\bm{AB}\\) times \\(C\\) equals \\(A\\) times \\(BC\\). And \\((AB)\\bm{x}=A(B\\bm{x})\\) More ways to compute \\(AB\\) : \\((\\text{$A$ times columns of $B$})\\), \\((\\text{rows of $A$ times $B$})\\), \\((\\textit{columns times rows})\\). It is not usually true that \\(AB=BA\\). In most cases \\(A\\) doesn’t commute with \\(B\\). Matrices can be multiplied by blocks : \\(A=\\begin{bmatrix} A_1 &amp; A_2 \\end{bmatrix}\\) times \\(B=\\begin{bmatrix} B_1 \\\\ B_2 \\end{bmatrix}\\) is \\(A_1B_1+A2B_2\\). &dagger; WORKED EXAMPLES &dagger; 2.4 A&emsp;A graph or a network has \\(n\\) nodes. Its adjacency matrix \\(S\\) is \\(n\\) by \\(n\\). This is a 0&ndash;1 matrix with \\(s_{ij}=1\\) when nodes \\(i\\) and \\(j\\) are connected by an edge. The matrix \\(S^2\\) has a useful interpretation. \\(\\bm{(S^2)_{ij}}\\) counts the walks of length 2 between node \\(i\\) and node \\(j\\). Between nodes 2 and 3 the graph has two walks: go via 1 or go via 4. From node 1 to node 1, there are also two walks: 1&ndash;2&ndash;1 and 1&ndash;3&ndash;1. $$ S^2= \\begin{bmatrix} \\bm{2} & 1 & 1 & 2 \\\\ 1 & 3 & \\bm{2} & 1 \\\\ 1 & 2 & 3 & 1 \\\\ 2 & 1 & 1 & 2 \\end{bmatrix} \\qquad S^3= \\begin{bmatrix} 2 & \\bm{5} & 5 & 2 \\\\ 5 & 4 & 5 & 5 \\\\ 5 & 5 & 4 & 5 \\\\ 2 & 5 & 5 & 2 \\end{bmatrix} $$ Can you find 5 walks of length 3 between nodes 1 and 2? &emsp;&ensp;The real question is why \\(S^N\\) counts all the \\(N\\)-step paths between pairs of nodes. Start with \\(S^2\\) and look at matrix multiplication by dot products: $$ \\begin{equation} (S^2)_{ij}=(\\text{row $i$ of $S$})\\cdot(\\text{column $j$ of $S$})=s_{i1}s_{1j}+s_{i2}s_{2j}+s_{i3}s_{3j}+s_{i4}s_{4j} \\end{equation} $$ If there is a 2-step path \\(i\\rarr 1\\rarr j\\), the first multiplication gives \\(s_{i1}s_{1j}=(1)(1)=1\\). If \\(i\\rarr 1\\rarr j\\) is not a path, then either \\(i\\rarr 1\\) is missing or \\(1\\rarr j\\) is missing. So the multiplication gives \\(s_{i1}s_{1j}=0\\) in that case. &emsp;&ensp;\\((S^2)_{ij}\\) is adding up 1's for all the 2-step paths \\(i\\rarr k\\rarr j\\). So it counts those paths. In the same way \\(S^{N-1}S\\) will count \\(N\\)-step paths, because those are \\((N-1)\\)-step paths from \\(i\\) to \\(k\\) followed by one step from \\(k\\) to \\(j\\). Matrix multiplication is exactly suited to counting paths on a graph&mdash;channels of communcation between employees in a company. 2.4 B&emsp;For these matrices, when does \\(AB=BA\\)? When does \\(BC=CB\\)? When does \\(A\\) times \\(BC\\) equal \\(AB\\) times \\(C\\)? Give the conditions on their entries \\(p\\), \\(q\\), \\(r\\), \\(z\\) : $$ A=\\begin{bmatrix} p & 0 \\\\ q & r \\end{bmatrix} \\qquad B=\\begin{bmatrix} 1 & 1 \\\\ 0 & 1 \\end{bmatrix} \\qquad C=\\begin{bmatrix} 0 & z \\\\ 0 & 0 \\end{bmatrix} $$ If \\(p\\), \\(q\\), \\(r\\), \\(1\\), \\(z\\) are 4 by 4 blocks instead of numbers, do the answers change? Solution&emsp;First of all, \\(A\\) times \\(BC\\) always equals \\(AB\\) times \\(C\\). Parentheses are not needed in \\(A(BC)=(AB)C=ABC\\). But we must keep the matrices in this order : $$ \\begin{array}{l} \\textbf{Usually }\\bm{AB\\neq BA}\\qquad AB=\\begin{bmatrix} p & p \\\\ q & q+r \\end{bmatrix}\\qquad BA=\\begin{bmatrix} p+q & r \\\\ q & r \\end{bmatrix}\\text{.} \\\\ \\\\ \\textbf{By chance }\\bm{BC=CB}\\qquad BC=\\begin{bmatrix} 0 & z \\\\ 0 & 0 \\end{bmatrix}\\qquad CB=\\begin{bmatrix} 0 & z \\\\ 0 & 0 \\end{bmatrix}\\text{.} \\end{array} $$ \\(B\\) and \\(C\\) happen to commute. Part of the explanation is that the diagonal of \\(B\\) is \\(I\\), which commutes with all 2 by 2 matrices. When \\(p\\), \\(q\\), \\(r\\), \\(z\\) are 4 by 4 blocks and 1 changes to \\(I\\), all these products remain correct. So the answers are the same. Inverse Matrices If the square matrix \\(A\\) has an inverse, then both \\(A^{-1}A=I\\) and \\(AA^{-1}=I\\) The algorithm to test invertibility is elimination : \\(A\\) must have \\(n\\) (nonzero) pivots. The algebra test for invertibility is the determinant of \\(A\\) : \\(\\det A\\) must not zero. The equation that tests for invertibility is \\(A\\bm{x}=\\bm{0}\\) : \\(\\bm{x=0}\\) must be the only solution. If \\(A\\) and \\(B\\) (same size) are invertible then so is \\(AB\\) : \\(\\boxed{(AB)^{-1}=B^{-1}A^{-1}}\\) . \\(AA^{-1}=I\\) is \\(n\\) equations for \\(n\\) columns of \\(A^{-1}\\). Gauss-Jordan eliminates \\(\\begin{bmatrix} A &amp; I \\end{bmatrix}\\) to \\(\\begin{bmatrix} I &amp; A^{-1} \\end{bmatrix}\\). The last section of this page gives 14 equivalent conditions for a square \\(A\\) to be invertible. &dagger; WORKED EXAMPLES &dagger; 2.5 A&emsp;The inverse of a triangular difference matrix \\(A\\) is a triangular sum matrix \\(S\\) : $$ \\begin{alignedat}{1} \\begin{bmatrix} A & I \\end{bmatrix} & = \\left[\\begin{array}{rrr|rrr} 1 & 0 & 0 & 1 & 0 & 0 \\\\ -1 & 1 & 0 & 0 & 1 & 0 \\\\ 0 & -1 & 1 & 0 & 0 & 1 \\end{array}\\right] \\rarr \\left[\\begin{array}{rrr|rrr} 1 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 1 & 0 & 1 & 1 & 0 \\\\ 0 & -1 & 1 & 0 & 0 & 1 \\end{array}\\right] \\\\ & \\rarr \\left[\\begin{array}{rrr|rrr} 1 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 1 & 0 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 1 \\end{array}\\right] =\\begin{bmatrix} I & A^{-1} \\end{bmatrix} =\\begin{bmatrix} I & \\textit{sum matrix} \\end{bmatrix} \\end{alignedat} $$ It I change \\(a_{13}\\) to \\(-1\\), then all rows of \\(A\\) add to zero. The equation \\(A\\bm{x}=0\\) will now have the nonzero solution \\(\\bm{x}=(1,1,1)\\). A clear signal : This new \\(A\\) can't be inverted. 2.5 B&emsp;Three of these matrices are invertible, and three are singular. Find the inverse when it exists. Give reasons for noninvertibility (zero determinant, too few pivots, nonzero solution to \\(A\\bm{x}=\\bm{0}\\)) for the other three. The matrices are in the order \\(A\\), \\(B\\), \\(C\\), \\(D\\), \\(S\\), \\(E\\) : $$ \\begin{bmatrix} 4 & 3 \\\\ 8 & 6 \\end{bmatrix} \\qquad \\begin{bmatrix} 4 & 3 \\\\ 8 & 7 \\end{bmatrix} \\qquad \\begin{bmatrix} 6 & 6 \\\\ 6 & 0 \\end{bmatrix} \\qquad \\begin{bmatrix} 6 & 6 \\\\ 6 & 6 \\end{bmatrix} \\qquad \\begin{bmatrix} 1 & 0 & 0 \\\\ 1 & 1 & 0 \\\\ 1 & 1 & 1 \\end{bmatrix} \\qquad \\begin{bmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 0 \\\\ 1 & 1 & 1 \\end{bmatrix} $$ Solution $$ B^{-1}=\\frac{1}{4}\\begin{bmatrix*}[r] 7 & -3 \\\\ -8 & 4 \\end{bmatrix*} \\qquad C^{-1}=\\frac{1}{36}\\begin{bmatrix*}[r] 0 & 6 \\\\ 6 & -6 \\end{bmatrix*} \\qquad S^{-1}=\\begin{bmatrix*} 1 & 0 & 0 \\\\ -1 & 1 & 0 \\\\ 0 & -1 & 1 \\end{bmatrix*} $$ \\(A\\) is not invertible because its determinant is \\(4\\cdot 6-3\\cdot 8=24-24=0\\). \\(D\\) is not invertible because there is only one pivot; the second row becomes zero when the first row is subtracted. \\(E\\) has two equal rows (and the second column minus the first column is zero). In other words \\(E\\bm{x}=\\bm{0}\\) has the solution \\(\\bm{x}=(-1,1,0)\\). &emsp;&ensp;Of course all three reasons for noninvertibility would apply to each of \\(A\\), \\(D\\), \\(E\\). 2.5 C&emsp;Apply the Gauss-Jordan method to invert this triangular &ldquo;Pascal matrix&rdquo; \\(L\\). You see Pascal's triangle&mdash;adding each entry to the entry on its left gives the entry below. The entries of \\(L\\) are &ldquo;binomial coefficients&rdquo;. The next row would be \\(1,4,6,4,1\\). $$ \\textbf{Triangular Pascal matrix}\\quad \\bm{L}= \\begin{bmatrix} \\bm{1} & 0 & 0 & 0 \\\\ \\bm{1} & \\bm{1} & 0 & 0 \\\\ \\bm{1} & \\bm{2} & \\bm{1} & 0 \\\\ \\bm{1} & \\bm{3} & \\bm{3} & \\bm{1} \\end{bmatrix} =\\textsf{abs(pascal(4,1))} $$ Solution&emsp;Gausss-Jordan starts with \\(\\begin{bmatrix} L & I \\end{bmatrix}\\) and produces zeros by subtracting row 1: $$ \\begin{bmatrix} \\bm{L} & \\bm{I} \\end{bmatrix} = \\left[\\begin{array}{cccc|cccc} \\bm{1} & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\\\ \\bm{1} & \\bm{1} & 0 & 0 & 0 & 1 & 0 & 0 \\\\ \\bm{1} & \\bm{2} & \\bm{1} & 0 & 0 & 0 & 1 & 0 \\\\ \\bm{1} & \\bm{3} & \\bm{3} & \\bm{1} & 0 & 0 & 0 & 1 \\end{array}\\right] \\rarr \\left[\\begin{array}{rrrr|rrrr} 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\\\ \\bm{0} & 1 & 0 & 0 & \\bm{-1} & 1 & 0 & 0 \\\\ \\bm{0} & 2 & 1 & 0 & \\bm{-1} & 0 & 1 & 0 \\\\ \\bm{0} & 3 & 3 & 1 & \\bm{-1} & 0 & 0 & 1 \\end{array}\\right] \\text{.} $$ The next stage creates zeros below the second pivot, using multipliers 2 and 3. Then the last stage subtracts 3 times the new row 3 from the new row 4: $$ \\rarr \\left[\\begin{array}{rrrr|rrrr} 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 & -1 & 1 & 0 & 0 \\\\ 0 & \\bm{0} & 1 & 0 & \\bm{1} & \\bm{-2} & 1 & 0 \\\\ 0 & \\bm{0} & 3 & 1 & \\bm{2} & \\bm{-3} & 0 & 1 \\end{array}\\right] \\rarr \\left[\\begin{array}{rrrr|rrrr} 1 & 0 & 0 & 0 & \\bm{1} & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 & \\bm{-1} & \\bm{1} & 0 & 0 \\\\ 0 & 0 & 1 & 0 & \\bm{1} & \\bm{-2} & \\bm{1} & 0 \\\\ 0 & 0 & 0 & 1 & \\bm{-1} & \\bm{3} & \\bm{-3} & \\bm{1} \\end{array}\\right] = \\begin{bmatrix} \\bm{I} & \\bm{L^{-1}} \\end{bmatrix} \\text{.} $$ All the pivots were 1! So we didn't need to divide rows by pivots to get \\(I\\). The inverse matrix \\(L^{-1}\\) look like \\(L\\) itself, except odd-numbered diagonals have minus signs. &emsp;&ensp;The same pattern continues to \\(n\\) by \\(n\\) Pascal matrices. \\(L^{-1}\\) has &ldquo;alternating diagonals&rdquo;. Elimination = Factorization: A=LU Each elimination step \\(E_{ij}\\) is inverted by \\(L_{ij}\\). Off the main diagonal change \\(-\\ell_{ij}\\) to \\(+\\ell_{ij}\\). The whole forward elimination process (with no row exchanges) is inverted by \\(\\bm{L}\\) : $$ \\bm{L}=(L_{21}L_{31}\\ldots L_{n1})(L_{32}\\ldots L_{n2})(L_{43}\\ldots L_{n3})\\ldots(L_{n\\space n-1})\\text{.} $$ That product matrix \\(\\bm{L}\\) is still lower triangular. Every multiplier \\(\\bm{\\ell_{ij}}\\) is in row \\(\\bm{i}\\), column \\(\\bm{j}\\). The original \\(A\\) is recovered from \\(U\\) by \\(\\bm{A}=\\bm{LU}=(\\text{lower triangular})(\\text{upper triangular})\\). Elimination on \\(A\\bm{x}=\\bm{b}\\) reaches \\(U\\bm{x}=\\bm{c}\\). Then back-substitution solves \\(U\\bm{x}=\\bm{c}\\) Solving a triangular system takes \\(n^2/2\\) multiply-subtracts. Elimination to find \\(U\\) takes \\(n^3/3\\). &dagger; WHY &dagger; In elimination, to find new entries below the first pivot row requires \\(n^2-n\\) multiplications and subtractions. Here we using \\(n^2\\) and for simplicity ignore that the row 1 is actually does not change (In CS this is the usual case&mdash;focus on most affected factors in time complexicity). The next stage will has \\((n-1)^n\\) multiplications and subtractions. The matrices are getting smaller as elimination goes forward. The rough count to reach \\(U\\) is the sum of squares: $$ n^2+(n-1)^2+\\cdots+2^2+1^2=\\frac{1}{3}n(n+\\frac{1}{2})(n+1)\\approx\\frac{1}{3}n^3 $$ (When \\(n\\) is large, the \\(\\frac{1}{2}\\) and the \\(1\\) are not important). &emsp;&ensp;For solving a triangular system, in back substitution, the routh count of the multiplications: $$ 1+2+\\cdots+n=\\frac{(1+n)n}{2}\\approx\\frac{n^2}{2} $$ and the routh count of the subtractions: $$ 0+1+\\cdots+(n-1)=\\frac{(n-1)n}{2}\\approx\\frac{n^2}{2} $$ &dagger; WORKED EXAMPLES &dagger; 2.6 A&emsp;The lower triangular Pascal matrix \\(L\\) contains the famous &ldquo;Pascal triangle&rdquo;. Gauss-Jordan inverted \\(L\\) in the worked example 2.5 C. Here we factor Pascal. &emsp;&ensp;The symmetric Pascal matrix \\(\\bm{P}\\) is a product of triangular Pascal matrices \\(L\\) and \\(U\\). The symmetric \\(P\\) has Pascal's triangle tilted, so each entry is the sum of entry above and the entry to the left. The \\(n\\) by \\(n\\) symmetric \\(P\\) is \\(\\textsf{pascal(n)}\\) in \\(\\textsf{MATLAB}\\). Problem: Establish the amazing lower-upper factorization \\(P=LU\\). $$ \\textsf{pascal(4)}= \\begin{bmatrix} \\bm{1} & \\bm{1} & \\bm{1} & \\bm{1} \\\\ \\bm{1} & \\bm{2} & \\bm{3} & 4 \\\\ \\bm{1} & \\bm{3} & 6 & 10 \\\\ \\bm{1} & 4 & 10 & 20 \\end{bmatrix} = \\begin{bmatrix} \\bm{1} & 0 & 0 & 0 \\\\ \\bm{1} & \\bm{1} & 0 & 0 \\\\ \\bm{1} & \\bm{2} & \\bm{1} & 0 \\\\ \\bm{1} & \\bm{3} & \\bm{3} & \\bm{1} \\end{bmatrix} \\begin{bmatrix} \\bm{1} & \\bm{1} & \\bm{1} & \\bm{1} \\\\ 0 & \\bm{1} & \\bm{2} & \\bm{3} \\\\ 0 & 0 & \\bm{1} & \\bm{3} \\\\ 0 & 0 & 0 & \\bm{1} \\end{bmatrix} =LU\\text{.} $$ Then predict and check the next row and column for 5 by 5 Pascal matrices. Solution&emsp;You could multiply \\(LU\\) to get \\(P\\). Better to start with the symmetric \\(P\\) and reach the upper triangular \\(U\\) by elimination : $$ P= \\begin{bmatrix} 1 & 1 & 1 & 1 \\\\ 1 & 2 & 3 & 4 \\\\ 1 & 3 & 6 & 10 \\\\ 1 & 4 & 10 & 20 \\end{bmatrix} \\rarr \\begin{bmatrix} 1 & 1 & 1 & 1 \\\\ 0 & 1 & 2 & 3 \\\\ 0 & 2 & 5 & 9 \\\\ 0 & 3 & 9 & 19 \\end{bmatrix} \\rarr \\begin{bmatrix} 1 & 1 & 1 & 1 \\\\ 0 & 1 & 2 & 3 \\\\ 0 & 0 & 1 & 3 \\\\ 0 & 0 & 3 & 10 \\\\ \\end{bmatrix} \\rarr \\begin{bmatrix} 1 & 1 & 1 & 1 \\\\ 0 & 1 & 2 & 3 \\\\ 0 & 0 & 1 & 3 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} =U $$ The multipliers \\(\\ell_{ij}\\) that entered these steps go perfectly into \\(L\\). Then \\(P=LU\\) is a paticularly neat example. Notice that every pivot is \\(1\\) on the diagonal of \\(U\\). &emsp;&ensp;The next section will show how symmetry produces a special relationship between the triangular \\(L\\) and \\(U\\). For Pascal, \\(U\\) is the &ldquo;transpose&rdquo; of \\(\\bm{L}\\). &emsp;&ensp;You might expect the \\(\\textsf{MATLAB}\\) command \\(\\textsf{lu(pascal(4))}\\) to produce these \\(L\\) and \\(U\\). That doesn't happen because \\(\\textbf{\\textsf{lu}}\\) subroutine chooses the largest available pivot in each column. The second pivot will change from 1 to 3. But a &ldquo;Cholesky factorization&rdquo; does no row exchanges: \\(U=\\textsf{chol(pascal(4))}\\) &emsp;&ensp;The full proof of \\(P=LU\\) for all Pascal sizes is quite fascinating. The paper &ldquo;Pascal Matrices&rdquo; is on the course web page web.mit.edu/18.06 which is also available through MIT's OpenCourseWare at ocw.mit.edu. These Pascal matrices have so many remarkable properties&mdash;we will see them again. 2.6 B&emsp;The problem is: Solve \\(P\\bm{x}=\\bm{b}=(1,0,0,0)\\). This right side \\(=\\) column of \\(I\\) means that \\(\\bm{x}\\) will be the first column of \\(P^{-1}\\). That is Gauss-Jordan, matching the columns of \\(PP^{-1}=I\\). We already know the Pascal matrices \\(L\\) and \\(U\\) as factors of \\(P\\): $$ \\textbf{Two triangular systems}\\qquad L\\bm{c}=\\bm{b}\\text{ (forward)}\\qquad U\\bm{x}=\\bm{c}\\text{ (back).} $$ Solution&emsp;The lower triangular system \\(L\\bm{c}=\\bm{b}\\) is solved top to bottum: $$ \\begin{alignedat}{3.5} c_1 & & & & && =1 \\\\ c_1 & + & c_2 & & && =0 \\\\ c_1 & + & 2c_2 & + & c_3 && =0 \\\\ c_1 & + & 3c_2 & + & 3c_3 && +c_4=0 \\end{alignedat} \\qquad \\text{gives} \\qquad \\begin{alignedat}{0.5} c_1=+1 \\\\ c_2=-1 \\\\ c_3=+1 \\\\ c_4=-1 \\end{alignedat} $$ Forward elimination is multiplication by \\(L^{-1}\\). It produces the upper triangular system \\(U\\bm{x}=\\bm{c}\\). The solution \\(\\bm{x}\\) comes as always by back substitution, bottom to top: $$ \\begin{alignedat}{3.5} x_1+x_2+ && x_3+ && x_4= && 1 \\\\ x_2+ && 2x_3+ && 3x_4= && -1 \\\\ && x_3+ && 3x_4= && 1 \\\\ && && x_4= && -1 \\end{alignedat} \\qquad \\text{gives} \\qquad \\begin{alignedat}{0.5} x_1=\\bm{+4} \\\\ x_2=\\bm{-6} \\\\ x_3=\\bm{+4} \\\\ x_4=\\bm{-1} \\end{alignedat} $$ I see a pattern in that \\(\\bm{x}\\), but I don't know where it comes from. Try \\(\\textsf{inv(pascal(4))}\\). Transposes and Permutations The transposes of \\(A\\bm{x}\\) and \\(AB\\) and \\(A^{-1}\\) are \\(\\bm{x}^\\mathrm{T}A^\\mathrm{T}\\) and \\(B^\\mathrm{T}A^\\mathrm{T}\\) and \\((A^\\mathrm{T})^{-1}\\). &dagger; WHY &dagger; To understand \\((AB)^\\mathrm{T}=B^\\mathrm{T}A^\\mathrm{T}\\), start with \\((A\\bm{x})^\\mathrm{T})=\\bm{x}^\\mathrm{T}A^\\mathrm{T}\\) when \\(B\\) is just a vector: $$ \\textcolor{RoyalBlue}{ \\textit{\\textbf{$A\\bm{x}$ combines the columns of $A$ while $\\bm{x}^\\mathrm{T}A^\\mathrm{T}$ combines the rows of $A^\\mathrm{T}$}} } $$ In algebra language, this is: $$ \\begin{alignedat}{1} (A\\bm{x})^\\mathrm{T} & = \\left( \\begin{bmatrix} \\bm{a}_1 & \\bm{a}_2 & \\cdots & \\bm{a}_n \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\end{bmatrix} \\right)^\\mathrm{T} \\\\ & =(x_1\\bm{a}_1+x_2\\bm{a}_2+\\cdots+x_n\\bm{a}_n)^\\mathrm{T} \\\\ & =x_1\\bm{a}_1^\\mathrm{T}+x_2\\bm{a}_2^\\mathrm{T}+\\cdots+x_n\\bm{a}_n^\\mathrm{T} \\\\ \\bm{x}^\\mathrm{T}A^\\mathrm{T} & = \\begin{bmatrix} x_1 & x_2 & \\cdots & x_n \\end{bmatrix} \\begin{bmatrix} \\bm{a}_1^\\mathrm{T} \\\\ \\bm{a}_2^\\mathrm{T} \\\\ \\vdots \\\\ \\bm{a}_n^\\mathrm{T} \\end{bmatrix} \\\\ & =x_1\\bm{a}_1^\\mathrm{T}+x_2\\bm{a}_2^\\mathrm{T}+\\cdots+x_n\\bm{a}_n^\\mathrm{T} \\\\ & \\therefore (A\\bm{x})^\\mathrm{T}=\\bm{x}^\\mathrm{T}A^\\mathrm{T} \\end{alignedat} $$ Now we can prove the formula \\((AB)^\\mathrm{T}=B^\\mathrm{T}A^\\mathrm{T}\\), let \\(B=\\begin{bmatrix} \\bm{b}_1 & \\bm{b}_2 & \\bm{b}_n \\end{bmatrix}\\): $$ (AB)^\\mathrm{T}= \\left(\\begin{bmatrix} A\\bm{b}_1 & A\\bm{b}_2 & \\cdots & A\\bm{b}_n \\end{bmatrix}\\right)^\\mathrm{T} = \\begin{bmatrix} \\bm{b}_1^\\mathrm{T}A^\\mathrm{T} \\\\ \\bm{b}_2^\\mathrm{T}A^\\mathrm{T} \\\\ \\vdots \\\\ \\bm{b}_n^\\mathrm{T}A^\\mathrm{T} \\end{bmatrix} = \\begin{bmatrix} \\bm{b}_1^\\mathrm{T} \\\\ \\bm{b}_2^\\mathrm{T} \\\\ \\vdots \\\\ \\bm{b}_n^\\mathrm{T} \\end{bmatrix}A^\\mathrm{T} =B^\\mathrm{T}A^\\mathrm{T} $$ Apply this rule by transposing both sides of \\(A^\\mathrm{-1}A=I\\): $$ (A^{-1}A)^\\mathrm{T}=I^\\mathrm{T} \\harr A^\\mathrm{T}(A^{-1})^\\mathrm{T}=I \\harr (A^{-1})^\\mathrm{T}=(A^\\mathrm{T})^{-1} $$ The dot product (inner product) is \\(\\bm{x}\\cdot\\bm{y}=\\bm{x}^\\mathrm{T}\\bm{y}\\). This is \\((1\\times n)(n\\times 1)=(1\\times 1)\\). The outer product is \\(\\bm{xy^\\mathrm{T}}=\\text{column times row}=(n\\times 1)(1\\times n)=n\\times n\\text{ matrix}\\). The idea behind \\(A^\\mathrm{T}\\) is that \\(A\\bm{x}\\cdot\\bm{y}\\) equals \\(\\bm{x}\\cdot A^\\mathrm{T}\\bm{y}\\) because \\((A\\bm{x})^\\mathrm{T}\\bm{y}=\\bm{x}^\\mathrm{T}A^\\mathrm{T}\\bm{y}=\\bm{x}^\\mathrm{T}(A^\\mathrm{T}\\bm{y})\\). A symmetric matrix has \\(\\bm{S^\\mathrm{T}=S}\\) (and the product \\(A^\\mathrm{T}A\\) is always symmetric). An orthogonal matrix has \\(\\bm{Q^\\mathrm{T}=Q^{-1}}\\). The columns of \\(Q\\) are orthogonal unit vectors. A permutation matrix \\(\\bm{P}\\) has the same rows as \\(I\\) (in any order). There are \\(\\bm{n!}\\) different orders. Then \\(P\\bm{x}\\) puts the components \\(x_1\\), \\(x_2\\), \\(\\ldots\\), \\(x_n\\) in that new order. And \\(P^\\mathrm{T}\\) equals \\(P^{-1}\\). &dagger; WORKED EXAMPLES &dagger; 2.7 A&emsp;Applying the permutation \\(P\\) to the rows of \\(S\\) destorys its symmetry: $$ P=\\begin{bmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 1 & 0 & 0 \\end{bmatrix} \\qquad S=\\begin{bmatrix} 1 & 4 & 5 \\\\ 4 & \\bm{2} & 6 \\\\ 5 & 6 & \\bm{3} \\end{bmatrix} \\qquad PS=\\begin{bmatrix} 4 & \\bm{2} & 6 \\\\ 5 & 6 & \\bm{3} \\\\ 1 & 4 & 5 \\end{bmatrix} $$ What permutation \\(Q\\) applied to the columns of \\(PS\\) will recover symmetry in \\(PSQ\\)? The numbers \\(1\\), \\(2\\), \\(3\\) must come back to the main diagonal (not necessarily in order). Show that \\(Q\\) is \\(P^\\mathrm{T}\\), so that symmetry is saved by \\(PSP^\\mathrm{T}\\). Solution&emsp;To recover symmetry and put &ldquo;2&rdquo; back on the diagonal, column 2 of \\(PS\\) must move to column 1. Column 3 of \\(PS\\) (containing &ldquo;3&rdquo;) must move to column 2. Then the &ldquo;1&rdquo; moves to the 3,3 position. The matrix that permutes columns is \\(Q\\): $$ PS=\\begin{bmatrix} 4 & \\bm{2} & 6 \\\\ 5 & 6 & \\bm{3} \\\\ 1 & 4 & 5 \\end{bmatrix} \\qquad Q=\\begin{bmatrix} 0 & 0 & 1 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{bmatrix} \\qquad PSQ=\\begin{bmatrix} \\bm{2} & 6 & 4 \\\\ 6 & \\bm{3} & 5 \\\\ 4 & 5 & 1 \\end{bmatrix} \\text{is symmetric.} $$ The matrix \\(\\bm{Q}\\) is \\(\\bm{P^\\textbf{\\textrm{T}}}\\). This choice always recovers symmetry, because \\(PSP^\\mathrm{T}\\) is guaranteed to be symmetric. (Its transpose is again \\(PSP^\\mathrm{T}\\).) The matrix \\(Q\\) is also \\(P^{-1}\\), because the inverse of every permutation matrix is its transpose. If \\(D\\) is a diagonal matrix, we are finding that \\(PDP^\\mathrm{T}\\) is also diagonal. When \\(P\\) moves row 1 down to row 3, \\(P^\\mathrm{T}\\) on the right will move column 1 to column 3. The (1,1) entry moves down to (3,1) and over to (3,3). 2.7 B&emsp;Find the symmetric factorization \\(S=LDL^\\mathrm{T}\\) for the matrix \\(S\\) above. Solution&emsp;To factor \\(S\\) into \\(LDL^{-1}\\) we eliminate as usual to reach \\(U\\): $$ S= \\begin{bmatrix} 1 & 4 & 5 \\\\ 4 & 2 & 6 \\\\ 5 & 6 & 3 \\end{bmatrix} \\longrightarrow \\begin{bmatrix} 1 & 4 & 5 \\\\ 0 & -14 & -14 \\\\ 0 & -14 & -22 \\end{bmatrix} \\longrightarrow \\begin{bmatrix} 1 & 4 & 5 \\\\ 0 & -14 & -14 \\\\ 0 & 0 & -8 \\end{bmatrix} =U $$ The multipliers were \\(\\ell_{21}=4\\) and \\(\\ell_{31}=5\\) and \\(\\ell_{32}=1\\). The pivots 1, &minus;14, &minus;8 go into \\(\\bm{D}\\). When we divide the rows of \\(U\\) by those pivots, \\(L^\\mathrm{T}\\) should appear: $$ \\begin{array}{l} \\textbf{Symmetric} \\\\ \\textbf{factorization} \\\\ \\textbf{when $\\bm{S=S^\\textrm{T}}$} \\end{array} \\qquad \\bm{S}=\\bm{LDL^\\mathrm{T}}= \\begin{bmatrix} 1 & 0 & 0 \\\\ 4 & 1 & 0 \\\\ 5 & 1 & 1 \\end{bmatrix} \\begin{bmatrix} 1 & & \\\\ & -14 & \\\\ & & -8 \\end{bmatrix} \\begin{bmatrix} 1 & 4 & 5 \\\\ 0 & 1 & 1 \\\\ 0 & 0 & 1 \\end{bmatrix} \\text{.} $$ This matrix \\(S\\) is invertible because it has three pivots. Its inverse is \\((L^\\mathrm{T})^{-1}D^{-1}L^{-1}\\) and \\(S^{-1}\\) is also symmetric. The numbers 14 and 8 will turn up in the denominators of \\(S^{-1}\\). The &ldquo;determinant&rdquo; of \\(S\\) is the product of the pivots \\((1)(-14)(-8)=122\\). 2.7 C&emsp;For a rectangular \\(A\\), this saddle-point matrix \\(\\bm{S}\\) is symmetric and important: $$ \\begin{array}{l} \\textbf{Block matrix} \\\\ \\textbf{from least squares} \\end{array} \\qquad \\bm{S}=\\begin{bmatrix} \\bm{I} & \\bm{A} \\\\ \\bm{A^\\textbf{\\textrm{T}}} & \\bm{0} \\end{bmatrix}=\\bm{S^\\textbf{\\textrm{T}}} \\text{ has size $m+n$.} $$ Applying block elimination to find a block factorization \\(S=LDL^\\mathrm{T}\\). Then test invertibility: $$ \\textcolor{RoyalBlue}{ \\bm{S}\\textit{\\textbf{ is invertible}}\\quad\\Longleftrightarrow\\quad\\bm{A^\\textbf{\\textrm{T}}A}\\textit{\\textbf{ is invertible $\\quad\\Longleftrightarrow\\quad\\bm{Ax\\neq 0}$ whenever $\\bm{x\\neq 0}$}} } $$ Solution&emsp;The first block pivot is \\(I\\). Subtract \\(A^\\mathrm{T}\\) times row 1 from row 2: $$ \\textbf{Block elimination}\\quad S=\\begin{bmatrix} I & A \\\\ A^\\mathrm{T} & 0 \\end{bmatrix} \\quad\\text{goes to}\\quad \\begin{bmatrix} I & A \\\\ 0 & \\bm{-A^\\textbf{\\textrm{T}}A} \\end{bmatrix} \\text{.\\quad This is $U$.} $$ The block pivot matrix \\(D\\) contains \\(I\\) and \\(-A^\\mathrm{T}A\\). Then \\(L\\) and \\(L^\\mathrm{T}\\) contain \\(A^\\mathrm{T}\\) and \\(A\\): $$ \\boxed{ \\qquad \\textbf{Block factorization}\\quad S=LDL^\\mathrm{T}= \\begin{bmatrix} I & 0 \\\\ A^\\mathrm{T} & I \\end{bmatrix} \\begin{bmatrix} I & 0 \\\\ 0 & -A^\\mathrm{T}A \\end{bmatrix} \\begin{bmatrix} I & A \\\\ 0 & I \\end{bmatrix} \\text{.} \\qquad } $$ \\(L\\) is certainly invertible, with diagonal 1's. The inverse of the middle matrix involves \\((A^\\mathrm{T}A)^{-1}\\). Section 4.2 answers a key question about the matrix \\(A^\\mathrm{T}A\\). $$ \\textcolor{RoyalBlue}{ \\begin{array}{l} \\textbf{When is $\\bm{A^\\textrm{T}A}$ invertible?}\\textit{ Answer: $A$ must have independent columns.} \\\\ \\textbf{Then $A\\bm{x}=\\bm{0}$ only if $\\bm{x}=\\bm{0}$. Otherwise $A\\bm{x}=\\bm{0}$ will lead to $A^\\mathrm{T}A\\bm{x}=0$.} \\end{array} } $$ Chapter 3 Vector Spaces and Subspaces Spaces of Vectors The standard \\(n\\)-dimensional space \\(\\mathbf{R}^n\\) contains all real column vectors with \\(n\\) components. If \\(\\bm{v}\\) and \\(\\bm{w}\\) are in a vector space \\(\\bm{S}\\), every combination \\(c\\bm{v}+d\\bm{w}\\) must be in \\(\\bm{S}\\). The “vectors” in \\(\\bm{S}\\) can be matrices or functions of \\(x\\). The 1-point space \\(\\bm{Z}\\) consists of \\(\\bm{x}=\\bm{0}\\). A subspace of \\(\\mathbf{R}^n\\) is a vector space inside \\(\\mathbf{R}^n\\). Example: The line \\(y=3x\\) inside \\(\\mathbf{R}^2\\). The column space of \\(A\\) contains all combinations of the columns of \\(A\\) : a subspace of \\(\\mathbf{R}^m\\). The column space contains all the vectors \\(A\\bm{x}\\). So \\(A\\bm{x}=\\bm{b}\\) is solvable when \\(\\bm{b}\\) is in \\(\\bm{C}(A)\\). &dagger; WORKED EXAMPLES &dagger; 3.1 A&emsp;We are given three different vectors \\(\\bm{b}_1\\), \\(\\bm{b}_2\\), \\(\\bm{b}_3\\). Construct a matrix so that the equations \\(A\\bm{x}=\\bm{b}_1\\) and \\(A\\bm{x}=\\bm{b}_2\\) are solvable, but \\(A\\bm{x}=\\bm{b}_3\\) is not solvable. How can you decide if this is possible? How could you construct \\(A\\)? Solution&emsp; We want to have \\(b_1\\) and \\(b_2\\) in the column space of \\(A\\). Then \\(A\\bm{x}=\\bm{b}_1\\) and \\(A\\bm{x}=\\bm{b}_2\\) will be solvable. The quickest way is to make \\(\\bm{b}_1\\) and \\(\\bm{b}_2\\) the two columns of \\(A\\). Then the solutions are \\(\\bm{x}=(1,0)\\) and \\(\\bm{x}=(0,1)\\). &emsp;&ensp;Also, we don't want \\(A\\bm{x}=\\bm{b}_3\\) to be solvable. So don't make the column space any larger! Keeping only the columns \\(\\bm{b}_1\\) and \\(\\bm{b}_2\\), the question is: $$ \\text{Is $A\\bm{x}=\\begin{bmatrix} & \\\\ \\bm{b}_1 & \\bm{b}_2 \\\\ & \\end{bmatrix}\\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix}=\\bm{b}_3$ solvable?} \\qquad \\text{Is $\\bm{b}_3$ a combination of $\\bm{b}_1$ and $\\bm{b}_2$?} $$ If the answer is no, we have the desired matrix \\(A\\). If the answer is yes, then it is not possible to construct \\(A\\). When the column space contains \\(\\bm{b}_1\\) and \\(\\bm{b}_2\\), it will have to contain all their linear combinations. So \\(\\bm{b}_3\\) would necessarily be in that column space and \\(A\\bm{x}=\\bm{b}_3\\) would necessarily be solvable. 3.1 B&emsp;Describe a subspace \\(\\mathbf{S}\\) of each vector space \\(\\mathbf{V}\\), and then a subspace \\(\\mathbf{SS}\\) of \\(\\mathbf{S}\\). $$ \\begin{array}{l} \\mathbf{V}_1=\\text{all combinations of $(1,1,0,0)$ and $(1,1,1,0)$ and $(1,1,1,1)$} \\\\ \\mathbf{V}_2=\\text{all vectors perpendicular to $\\bm{u}=(1,2,1)$, so $\\bm{u}\\cdot\\bm{v}=0$} \\\\ \\mathbf{V}_3=\\text{all symmetric 2 by 2 matrices (a subspace of $\\mathbf{M}$)} \\\\ \\mathbf{V}_4=\\text{all solutions to the equation $\\mathrm{d}^4y/\\mathrm{d}x^4=0$ (a subspace of $\\mathbf{F}$)} \\end{array} $$ Describe each \\(\\mathbf{V}\\) two ways: &ldquo;All combinations of&mldr;&rdquo; &ldquo;All solutions of the equations&mldr;&rdquo; Solution&emsp;\\(\\mathbf{V}_1\\) starts with three vectors. A subspace \\(\\mathbf{S}\\) comes from all combinations of the first two vectors \\((1,1,0,0)\\) and \\((1,1,1,0)\\). A subspace \\(\\mathbf{SS}\\) of \\(\\mathbf{S}\\) comes from all multiples \\((c,c,0,0)\\) of the first vector. So many possibilities. &emsp;&ensp;A subspace \\(\\mathbf{S}\\) of \\(\\mathbf{V}_2\\) is the line through \\((1,-1,1)\\). This line is perpendicular to \\(\\bm{u}\\). The vector \\(\\bm{x}=(0,0,0)\\) is in \\(\\bm{S}\\) and all its multiples \\(c\\bm{x}\\) give the smallest subspace \\(\\mathbf{SS}=\\mathbf{Z}\\). &emsp;&ensp;The diagonal matrices are a subspace \\(\\mathbf{S}\\) of the symmetric matrices. The multiples \\(cI\\) are a subspace \\(\\mathbf{SS}\\) of the diagonal matrices. &emsp;&ensp;\\(\\mathbf{V}_4\\) contains all cubic polynomials \\(y=a+bx+cx^2+dx^3\\), with \\(\\mathrm{d}^4y/\\mathrm{d}x^4=0\\). The quadratic polynomials give a subspace \\(\\mathbf{S}\\). The linear polynomials are one choice of \\(\\mathbf{SS}\\). The constants could be \\(\\mathbf{SSS}\\). &emsp;&ensp;In all four parts we could take \\(\\mathbf{S}=\\mathbf{V}\\) itself, and \\(\\mathbf{SS}=\\) the zero subspace \\(Z\\). &emsp;&ensp;Each \\(\\mathbf{V}\\) can be described as all combinations of&mldr; and as all solutions of&mldr;: $$ \\begin{array}{ll} \\mathbf{V}_1=\\text{all combinations of the 3 vectors} & \\mathbf{V}_1=\\text{all solutions of }v_1-v_2=0 \\\\ \\mathbf{V}_2=\\text{all combinations of $(1,0,-1)$ and $(1,-1,1)$} & \\mathbf{V}_2=\\text{all solutions of }\\bm{u}\\cdot\\bm{v}=0 \\\\ \\mathbf{V}_3=\\text{all combinations of }\\left[\\begin{smallmatrix} 1 & 0 \\\\ 0 & 0 \\end{smallmatrix}\\right],\\left[\\begin{smallmatrix} 0 & 1 \\\\ 1 & 0 \\end{smallmatrix}\\right],\\left[\\begin{smallmatrix} 0 & 0 \\\\ 0 & 1 \\end{smallmatrix}\\right] & \\mathbf{V}_3=\\text{all solutions $\\left[\\begin{smallmatrix} a & b \\\\ c & d \\end{smallmatrix}\\right]$ of }b=c \\\\ \\mathbf{V}_4=\\text{all combinations of }1,x,x^2,x^3 & \\mathbf{V}_4=\\text{all solutions to }\\mathrm{d}^4y/\\mathrm{d}x^4=0 \\end{array} $$ The Nullspace of A: Solving Ax=0 and Rx=0 The nullspace \\(\\bm{N}(A)\\) in \\(\\mathbf{R}^n\\) contains all solutions \\(\\bm{x}\\) to \\(A\\bm{x}=\\bm{0}\\). This includes \\(\\bm{x}=\\bm{0}\\) Elimination (from \\(A\\) to \\(U\\) to \\(R\\)) does not change the nullspace: \\(\\bm{N}(A)=\\bm{N}(U)=\\bm{N}(R)\\). The reduced row echelon form \\(\\bm{R=\\textbf{\\textsf{rref(A)}}}\\) has all pivots \\(=1\\), with zeros above and below. If column \\(j\\) of \\(R\\) is free (no pivot), there is a “special solution” to \\(A\\bm{x}=\\bm{0}\\) with \\(x_j=1\\). Number of pivots = number of nonzero rows in \\(R=\\textbf{rank }\\bm{r}\\). There are \\(n-r\\) free columns. Every matrix with \\(m\\lt n\\) has nonzero solution to \\(A\\bm{x}=\\bm{0}\\) in its nullspace. &dagger; WORKED EXAMPLES &dagger; 3.2 A&emsp;Why do \\(A\\) and \\(R\\) have the same nullspace if \\(EA=R\\) and \\(E\\) is invertible? Solution&emsp; If \\(A\\bm{x}=\\bm{0}\\) then \\(R\\bm{x}=EA\\bm{x}=E\\bm{0}=\\bm{0}\\) If \\(R\\bm{x}=\\bm{0}\\) then \\(A\\bm{x}=E^{-1}R\\bm{x}=E^{-1}\\bm{0}=\\bm{0}\\) \\(A\\) and \\(R\\) also have the same row space and the same rank. 3.2 B&emsp;Create a 3 by 4 matrix \\(R\\) whose special solutions to \\(R\\bm{x}=\\bm{0}\\) are \\(\\bm{s}_1\\) and \\(\\bm{s}_2\\): $$ \\bm{s_1}=\\begin{bmatrix*}[r] -3 \\\\ 1 \\\\ 0 \\\\ 0 \\end{bmatrix*} \\quad\\text{and}\\quad \\bm{s_2}=\\begin{bmatrix*}[r] -2 \\\\ 0 \\\\ -6 \\\\ 1 \\end{bmatrix*} \\qquad \\begin{array}{l} \\text{pivot columns 1 and 3} \\\\ \\text{free varibales $x_2$ and $x_4$} \\end{array} $$ Describe all possible matrices \\(A\\) with this nullspace \\(\\bm{N}(A)=\\) all combinations of \\(\\bm{s}_1\\) and \\(\\bm{s}_2\\). Solution&emsp; The reduced matrix \\(R\\) have pivots \\(=1\\) in columns 1 and 3. There is no third pivot, so row 3 of \\(R\\) is all zeros. The free columns 2 and 4 will be combinations of the pivot columns: 3, 0, 2, 6 in \\(R\\) come from -3, -0, -2, -6 in \\(s_1\\) and \\(s_2\\). Every \\(\\bm{A=ER}\\). &emsp;&ensp;Every 3 by 4 matrix has at least one special solution. These matrices have two. $$ R= \\begin{bmatrix} \\bm{1} & \\bm{3} & 0 & \\bm{2} \\\\ 0 & \\bm{0} & \\bm{1} & \\bm{6} \\\\ 0 & 0 & 0 & 0 \\end{bmatrix} \\quad\\text{has}\\quad R\\bm{s}_1=\\bm{0} \\quad\\text{and}\\quad R\\bm{s}_2=\\bm{0} \\text{.} $$ 3.2 C&emsp;Find the row reduced form \\(R\\) and the rank \\(r\\) of \\(A\\) and \\(B\\) (those depend on \\(c\\)). Which are the pivot coumns of \\(A\\)? What are the special solutions? $$ \\textbf{Find special solutions}\\qquad A= \\begin{bmatrix} 1 & 2 & 1 \\\\ 3 & 6 & 3 \\\\ 4 & 8 & c \\end{bmatrix} \\quad\\text{and}\\quad B= \\begin{bmatrix} c & c \\\\ c & c \\end{bmatrix} \\text{.} $$ Solution&emsp;The matrix \\(A\\) has \\(\\text{row 2}=3(\\text{row 1})\\). The rank of \\(A\\) is \\(r=2\\) except if \\(\\bm{c=4}\\). \\(\\text{Row 4}-4(\\text{row 1})\\) ends in \\(c-4\\). The pivots are in columns 1 and 3. The second variable \\(x_2\\) is free. Notice the form of \\(R\\): Row 3 has moved up into row 2. $$ \\bm{c\\neq 4}\\quad R= \\begin{bmatrix} \\bm{1} & 2 & 0 \\\\ 0 & 0 & \\bm{1} \\\\ 0 & 0 & 0 \\end{bmatrix} \\qquad \\bm{c=4}\\qquad R= \\begin{bmatrix} \\bm{1} & 2 & 1 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix} \\text{.} $$ Two pivots leave one free variable \\(x_2\\). But when \\(c=4\\), the only pivot is in column 1 (rank one). The second and third variables are free, producing two special solutions: $$ c\\neq 4\\quad\\text{Special solution $(-2,1,0)$} \\qquad c=4\\quad\\text{Another special solution $(-1, 0, 1)$.} $$ &emsp;&ensp;The 2 by 2 matrix \\(B=\\left[\\begin{smallmatrix} c & c \\\\ c & c \\end{smallmatrix}\\right]\\) has rank \\(r=1\\) except if \\(\\bm{c=0}\\), when the rank is zero! $$ \\bm{c\\neq 0}\\quad R=\\begin{bmatrix} 1 & 1 \\\\ 0 & 0 \\end{bmatrix} \\qquad \\bm{c=0}\\quad R=\\begin{bmatrix} 0 & 0 \\\\ 0 & 0 \\end{bmatrix}\\quad\\text{all nullspace$=\\mathbf{R}^2$.} $$ The Complete Solution to Ax=b Complete solution to \\(A\\bm{x}=\\bm{b}\\): \\(\\bm{x}=(\\text{one particular solution $\\bm{x}_p$})+(\\text{any $\\bm{x}_n$ in the nullspace})\\). Elimination on \\(\\begin{bmatrix} A &amp; \\bm{b} \\end{bmatrix}\\) leads to \\(\\begin{bmatrix} R &amp; \\bm{d} \\end{bmatrix}\\). Then \\(A\\bm{x}=\\bm{b}\\) is equivalent to \\(R\\bm{x}=\\bm{d}\\). \\(A\\bm{x}=\\bm{b}\\) and \\(R\\bm{x}=\\bm{d}\\) are solvable only when all zero rows of \\(R\\) have zeros in \\(\\bm{d}\\). When \\(R\\bm{x}=\\bm{d}\\) is solvable, one very particular solution \\(\\bm{x}_p\\) has all free variables equal to zero. \\(A\\) has full column rank \\(\\bm{r=n}\\) when its nullspace \\(\\bm{N}(A)=\\text{zero vector}\\): no free variables. \\(A\\) has full row rank \\(\\bm{r=m}\\) when its column space \\(\\bm{C}(A)\\) is \\(\\mathbf{R}^m\\): \\(A\\bm{x}=\\bm{b}\\) is always solvable. The four cases are \\(r=m=n\\) (\\(A\\) is invertible) and \\(r=m\\lt n\\) (every \\(A\\bm{x}=\\bm{b}\\) is solvable) and \\(r=n\\lt m\\) (\\(A\\bm{x}=\\bm{b}\\) has 1 or 0 solutions) and \\(r\\lt m\\), \\(r\\lt n\\) (0 or ∞ solutions). &dagger; WORKED EXAMPLES &dagger; 3.3 A&emsp;This question connects elimination (pivot columns and back substitution) to column space-nullspace-rank-solvability. \\(A\\) has rank 2: $$ A\\bm{x}=\\bm{b} \\quad\\text{is}\\quad \\begin{alignedat}{1.5} x_1+2x_2+3x_3+ && 5x_4=b_1 \\\\ 2x_1+4x_2+8x_3+ && 12x_4=b_2 \\\\ 3x_1+6x_2+7x_3+ && 13x_4=b_3 \\end{alignedat} $$ &emsp;&ensp;1.&ensp; Reduce \\(\\begin{bmatrix} A & \\bm{b} \\end{bmatrix}\\) to \\(\\begin{bmatrix} U & \\bm{c} \\end{bmatrix}\\), so that \\(A\\bm{x}=\\bm{b}\\) becomes a triangular system \\(U\\bm{x}=\\bm{c}\\). &emsp;&ensp;2.&ensp; Find the condition on \\(b_1\\), \\(b_2\\), \\(b_3\\) for \\(A\\bm{x}=\\bm{b}\\) to have a solution. &emsp;&ensp;3.&ensp; Describe the column space of \\(A\\). Which plane in \\(\\mathbf{R}^3\\)? &emsp;&ensp;4.&ensp; Describe the nullspace of \\(A\\). Which special solutions in \\(\\mathbf{R}^4\\)? &emsp;&ensp;5.&ensp; Reduce \\(\\begin{bmatrix} U & \\bm{c} \\end{bmatrix}\\) to \\(\\begin{bmatrix} R & \\bm{d} \\end{bmatrix}\\): Special solutions from \\(R\\), particular solution from \\(\\bm{d}\\). &emsp;&ensp;6.&ensp; Find a particular solution to \\(A\\bm{x}=(0,6,-6)\\) and then the complete solution. Solution &emsp;&ensp;1.&ensp; The multipliers in elimination are 2 and 3 and -1. They take \\(\\begin{bmatrix} A & \\bm{b} \\end{bmatrix}\\) to \\(\\begin{bmatrix} U & \\bm{c} \\end{bmatrix}\\). $$ \\begin{bmatrix*}[r] 1 & 2 & 3 & 5 & \\mathbf{b_1} \\\\ 2 & 4 & 8 & 12 & \\mathbf{b_2} \\\\ 3 & 6 & 7 & 13 & \\mathbf{b_3} \\end{bmatrix*} \\rarr \\left[\\begin{array}{rrrr|l} 1 & 2 & 3 & 5 & \\mathbf{b_1} \\\\ 0 & 0 & 2 & 2 & \\mathbf{b_2-2b_1} \\\\ 0 & 0 & -2 & -2 & \\mathbf{b_3-3b_1} \\end{array}\\right] \\rarr \\left[\\begin{array}{cccc|l} 1 & 2 & 3 & 5 & \\mathbf{b_1} \\\\ 0 & 0 & 2 & 2 & \\mathbf{b_2-2b_1} \\\\ 0 & 0 & 0 & 0 & \\mathbf{b_3+b_2-5b_1} \\end{array}\\right] $$ &emsp;&ensp;2.&ensp; The last equation shows the solvability condition \\(b_3+b_2-5b_1=0\\). Then \\(0=0\\). &emsp;&ensp;3.&ensp; First description: The column space is the plane containing all combinations of the pivot columns \\((1,2,3)\\) and \\((3,8,7)\\). The pivots are in columns 1 and 3. Second description: The column space contains all vectors with \\(b_3+b_2-5b_1=0\\). That makes \\(A\\bm{x}=\\bm{b}\\) solvable, so \\(\\bm{b}\\) is in the column space. All columns of \\(A\\) pass this test \\(b_3+b_2-5b_1=0\\). This is the equation for the plane in the first description! &emsp;&ensp;4.&ensp; The special solutions have free variables \\(x_2=1\\), \\(x_4=0\\) and then \\(x_2=0\\), \\(x_4=1\\): $$ \\begin{array}{l} \\textbf{Special solutions to }A\\bm{x}=\\bm{0} \\\\ \\textbf{Back substitution in }U\\bm{x}=\\bm{0} \\\\ \\textbf{or change signs of 2, 2, 1 in }\\bm{R} \\end{array} \\qquad s_1=\\begin{bmatrix*}[r] -2 \\\\ 1 \\\\ 0 \\\\ 0 \\end{bmatrix*} \\qquad s_2=\\begin{bmatrix*}[r] -2 \\\\ 0 \\\\ -1 \\\\ 1 \\end{bmatrix*} $$ The nullspace \\(\\bm{N}(A)\\) in \\(\\mathbf{R}^4\\) contains all \\(\\bm{x}_n=c_1\\bm{s}_1+c_2\\bm{s}_2\\). &emsp;&ensp;5.&ensp; In the reduced form \\(R\\), the third column changes from \\((3,2,0)\\) in \\(U\\) to \\((0,1,0)\\). The right side \\(\\bm{c}=(0,6,0)\\) becomes \\(\\bm{d}=(-9,3,0)\\) showing &minus;9 and 3 in \\(\\bm{x}_p\\): $$ \\begin{bmatrix} U & \\bm{c} \\end{bmatrix}= \\begin{bmatrix} 1 & 2 & 3 & 5 & \\bm{0} \\\\ 0 & 0 & 2 & 2 & \\bm{6} \\\\ 0 & 0 & 0 & 0 & \\bm{0} \\end{bmatrix} \\rarr \\begin{bmatrix} R & \\bm{d} \\end{bmatrix}= \\begin{bmatrix*}[r] 1 & 2 & 0 & 2 & \\bm{-9} \\\\ 0 & 0 & 1 & 1 & \\bm{3} \\\\ 0 & 0 & 0 & 0 & \\bm{0} \\end{bmatrix*} $$ &emsp;&ensp;6.&ensp; One particular solution \\(\\bm{x}_p\\) has free variables = zero. Back substitute in \\(U\\bm{x}=\\bm{c}\\): $$ \\begin{array}{l} \\textbf{Particular solution to }A\\bm{x}_p=\\bm{b} \\\\ \\textbf{Bring $\\mathord{-}9$ and $3$ from the vector }\\bm{d} \\\\ \\textbf{Free variables $x_2$ and $x_4$ are zero} \\end{array} \\quad \\bm{x}_p=\\begin{bmatrix*}[r] -9 \\\\ 0 \\\\ 3 \\\\ 0 \\end{bmatrix*} $$ The complete solution to \\(A\\bm{x}=(0,6,-6)\\) is \\(\\bm{x}=\\bm{x}_p+\\bm{x}_n=x_p+c_1\\bm{s}_1+c_2\\bm{s}_2\\). 3.3 B&emsp;Suppose you have this information about the solutions to \\(A\\bm{x}=\\bm{b}\\) for a specific \\(\\bm{b}\\). What does that tell you about \\(m\\) and \\(n\\) and \\(r\\) (and \\(A\\) itself)? And possibly about \\(\\bm{b}\\). &emsp;&ensp;1.&ensp; There is exactly one solution. &emsp;&ensp;2.&ensp; All solutions to \\(A\\bm{x}=\\bm{b}\\) have the form \\(\\bm{x}=\\left[\\begin{smallmatrix} 2 \\\\ 1 \\end{smallmatrix}\\right]+c\\left[\\begin{smallmatrix} 1 \\\\ 1 \\end{smallmatrix}\\right]\\). &emsp;&ensp;3.&ensp; There are no solutions. &emsp;&ensp;4.&ensp; All solutions to \\(A\\bm{x}=\\bm{b}\\) have the form \\(\\bm{x}=\\left[\\begin{smallmatrix} 1 \\\\ 1 \\\\ 0 \\end{smallmatrix}\\right]+c\\left[\\begin{smallmatrix} 1 \\\\ 0 \\\\ 1 \\end{smallmatrix}\\right]\\). &emsp;&ensp;5.&ensp; There are infinitely many solutions. Solution&emsp;In case 1, with exactly one solution, \\(A\\) must have full column rank \\(r=n\\). The nullspace of \\(A\\) contains only the zero vector. Necessarily \\(m\\geq n\\). &emsp;&ensp;In case 2, \\(A\\) must have \\(n=2\\) columns (and \\(m\\) is arbitrary). With \\(\\left[\\begin{smallmatrix} 1 \\\\ 1 \\end{smallmatrix}\\right]\\) in the nullspace of \\(A\\), column 2 is the negative of column 1. Also \\(A\\neq 0\\): the rank is 1. With \\(\\bm{x}=\\left[\\begin{smallmatrix} 2 \\\\ 1 \\end{smallmatrix}\\right]\\) as a solution, \\(\\bm{b}=2(\\text{column 1})+(\\text{column 2})\\). My choice for \\(\\bm{x}_p\\) would be \\((1,0)\\). &emsp;&ensp;In case 3 we only know that \\(\\bm{b}\\) is not in the column space of \\(A\\). The rank of \\(A\\) must be less than \\(m\\). I guess we know \\(\\bm{b}\\neq\\bm{0}\\), otherwise \\(\\bm{x}=\\bm{0}\\) would be a solution. &emsp;&ensp;In case 4, \\(A\\) must have \\(n=3\\) columns. With \\((1,0,1)\\) in the nullspace of \\(A\\), column 3 is the negative of column 1. Column 2 must not be a multiple of column 1, or the nullspace would contain another special solution. So the rank of \\(A\\) is \\(3-1=2\\). Necessarily \\(A\\) has \\(m\\geq 2\\) rows. The right side \\(\\bm{b}\\) is \\(\\text{column 1}+\\text{column 2}\\). &emsp;&ensp;In case 5 with infinitely many solutions, the nullspace must contain nonzero vectors. The rank \\(r\\) must be less than \\(n\\) (no full column rank), and \\(\\bm{b}\\) must be in the column space of \\(A\\). We don't know if every \\(\\bm{b}\\) is in the column space, so we don't know if \\(r=m\\). 3.3 C&emsp;Find the complete solution \\(\\bm{x}=\\bm{x}_p+\\bm{x}_n\\) by forward elimination on \\(\\begin{bmatrix} A & \\bm{b} \\end{bmatrix}\\): $$ \\begin{bmatrix} 1 & 2 & 1 & 0 \\\\ 2 & 4 & 4 & 8 \\\\ 4 & 8 & 6 & 8 \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\end{bmatrix} = \\begin{bmatrix*}[r] 4 \\\\ 2 \\\\ 10 \\end{bmatrix*} \\text{.} $$ Find numbers \\(y_1\\), \\(y_2\\), \\(y_3\\) so that \\(y_1(\\text{row 1})+y_2(\\text{row 2})+y_3(\\text{row 3})=\\textit{\\textbf{zero row}}\\). Check that \\(\\bm{b}=(4,2,10)\\) satisfies the condition \\(y_1b_1+y_2b_2+y_3b_3=0\\). Why is this the condition for the equations to be solvable and \\(\\bm{b}\\) to be in the column space? Solution&emsp;Forward elimination on \\(\\begin{bmatrix} A & \\bm{b} \\end{bmatrix}\\) produces a zero row in \\(\\begin{bmatrix} U & \\bm{c} \\end{bmatrix}\\). The third equation becomes \\(0=0\\) and the equations are consistent (and solvable): $$ \\begin{bmatrix*}[r] 1 & 2 & 1 & 0 & \\bm{4} \\\\ 2 & 4 & 4 & 8 & \\bm{2} \\\\ 4 & 8 & 6 & 8 & \\bm{10} \\end{bmatrix*} \\rarr \\begin{bmatrix*}[r] 1 & 2 & 1 & 0 & \\bm{4} \\\\ 0 & 0 & 2 & 8 & \\bm{-6} \\\\ 0 & 0 & 2 & 8 & \\bm{-6} \\end{bmatrix*} \\rarr \\begin{bmatrix*}[r] 1 & 2 & 1 & 0 & \\bm{4} \\\\ 0 & 0 & 2 & 8 & \\bm{-6} \\\\ 0 & 0 & 0 & 0 & \\bm{0} \\end{bmatrix*} \\text{.} $$ Columns 1 and 3 contain pivots. The variables \\(x_2\\) and \\(x_4\\) are free. If we set those to zero we can solve (back substitution) for the particular solution or we continue to \\(R\\). &emsp;&ensp;\\(R\\bm{x}=\\bm{d}\\) shows that the particular solution with \\(\\text{free variables}=0\\) is \\(\\bm{x}_p=(7,0,-3,0\\). $$ \\begin{bmatrix*}[r] 1 & 2 & 1 & 0 & \\bm{4} \\\\ 0 & 0 & 2 & 8 & \\bm{-6} \\\\ 0 & 0 & 0 & 0 & \\bm{0} \\end{bmatrix*} \\rarr \\begin{bmatrix*}[r] 1 & 2 & 1 & 0 & \\bm{4} \\\\ 0 & 0 & 1 & 4 & \\bm{-3} \\\\ 0 & 0 & 0 & 0 & \\bm{0} \\end{bmatrix*} \\rarr \\begin{bmatrix*}[r] 1 & 2 & 0 & -4 & \\bm{7} \\\\ 0 & 0 & 1 & 4 & \\bm{-3} \\\\ 0 & 0 & 0 & 0 & \\bm{0} \\end{bmatrix*} . $$ For the nullspace part \\(\\bm{x}_n\\) with \\(\\bm{b}=\\bm{0}\\), set the free variables \\(x_2\\), \\(x_4\\), to \\(1,0\\) and also \\(0,1\\): $$ \\textbf{Special solutions}\\qquad \\bm{s}_1=(-2,1,0,0) \\quad\\text{and}\\quad \\bm{s}_2=(4,0,-4,1) $$ Then the complete solution to \\(A\\bm{x}=\\bm{b}\\) (and \\(R\\bm{x}=\\bm{d}\\)) is \\(\\bm{x}_\\text{complete}=\\bm{x}_p+c_1\\bm{s}_1+c_2\\bm{s}_2\\). &emsp;&ensp;The rows of \\(A\\) produced the zero row from \\(2(\\text{row 1})+(\\text{row 2})-(\\text{row 3})=(0,0,0,0)\\). Thus \\(\\bm{y}=(2,1,-1)\\). The same combination for \\(\\bm{b}=(4,2,10)\\) gives \\(2(4)+(2)-1(10)=0\\). &emsp;&ensp;If a combination of the rows (on the left side) gives the zero row, then the same combination must give zero on the right side. Of course! Otherwise no solution. &emsp;&ensp;Later we will say this again in different words: If every column of \\(A\\) is perpendicular to \\(\\bm{y}=(2,1,-1)\\), then any combination \\(\\bm{b}\\) of those columns must also be perpendicular to \\(\\bm{y}\\). Otherwise \\(\\bm{b}\\) is not in the column space and \\(A\\bm{x}=\\bm{b}\\) is not solvable. &emsp;&ensp;And again: If \\(\\bm{y}\\) is in the nullspace of \\(A^\\mathrm{T}\\) then \\(\\bm{y}\\) must be perpendicular to every \\(\\bm{b}\\) in the column space of \\(A\\). Just looking ahead&mldr; Independence, Basis and Dimension Independent columns of \\(A\\): The only solution to \\(A\\bm{x}=\\bm{0}\\) is \\(\\bm{x}=\\bm{0}\\). The nullspace is \\(\\bm{Z}\\). Independent vectors: The only zero combination \\(c_1\\bm{v}_1+\\cdots+c_k\\bm{v}_k=\\bm{0}\\) has all \\(c\\text{'s}=0\\). A matrix with \\(m\\lt n\\) has dependent columns: At least \\(n-m\\) free variables/special solutions. The vectors \\(\\bm{v}_1,\\ldots,\\bm{v}_k\\) span the space \\(\\bm{S}\\) if \\(\\bm{S}=\\text{all combinations of the $\\bm{v}$'s}\\). The vectors \\(\\bm{v}_1,\\ldots,\\bm{v}_k\\) are a basis for \\(S\\) if they are independent and they span \\(\\bm{S}\\). The dimension of a space \\(\\bm{S}\\) is the number of vectors in every basis for \\(\\bm{S}\\). If \\(A\\) is 4 by 4 and invertible, its columns are a basis for \\(\\mathbf{R}^4\\). The dimension of \\(\\mathbf{R}^4\\) is 4. &dagger; WORKED EXAMPLES &dagger; 3.4 A&emsp;Start with the vectors \\(\\bm{v}_1=(1,2,0)\\) and \\(\\bm{v}_2=(2,3,0)\\).&emsp;(a) Are they linearly independent?&emsp;(b) Are they a basis for any space?&emsp;(c) What space \\(\\mathbf{V}\\) do they span?&emsp;(d) What is the dimension of \\(\\mathbf{V}\\)?&emsp;(e) Which matrices \\(A\\) have \\(\\mathbf{V}\\) as their column space?&emsp;(f) Which matrices have \\(\\mathbf{V}\\) as their nullspace?&emsp;(g) Describe all vectors \\(\\bm{v}_3\\) that complete a basis \\(\\bm{v}_1\\), \\(\\bm{v}_2\\), \\(\\bm{v}_3\\) for \\(\\mathbf{R}^3\\). Solution &emsp;&ensp;(a)&ensp; \\(\\bm{v}_1\\) and \\(\\bm{v}_2\\) are independent&mdash;the only combination to give \\(\\bm{0}\\) is \\(0\\bm{v}_1+0\\bm{v}_2\\). &emsp;&ensp;(b)&ensp; Yes, they are a basis for the space they span. &emsp;&ensp;(c)&ensp; That space \\(\\mathbf{V}\\) contains all vectors \\((x,y,0)\\). It is the \\(xy\\) plane in \\(\\mathbf{R}^3\\). &emsp;&ensp;(d)&ensp; The dimension of \\(\\mathbf{V}\\) is 2 since the basis contains two vectors. &emsp;&ensp;(e)&ensp; This \\(\\mathbf{V}\\) is the column space of any 3 by \\(n\\) matrix \\(A\\) of rank 2, if every column is a combination of \\(\\bm{v}_1\\) and \\(\\bm{v}_2\\). In particular \\(A\\) could just have columns \\(\\bm{v}_1\\) and \\(\\bm{v}_2\\). &emsp;&ensp;(f)&ensp; This \\(\\mathbf{V}\\) is the nullspace of any \\(m\\) by 3 matrix \\(B\\) of rank 1, if every row is a multiple of \\((0,0,1)\\). In particular take \\(B=\\begin{bmatrix} 0 & 0 & 1\\end{bmatrix}\\). Then \\(B\\bm{v}_1=\\bm{0}\\) and \\(B\\bm{v}_2=\\bm{0}\\). &emsp;&ensp;(g)&ensp; Any third vector \\(\\bm{v}_3=(a,b,c)\\) will complete a basis for \\(\\mathbf{R}^3\\) provided \\(c\\neq 0\\). 3.4 B&emsp;Start with three independent vectors \\(\\bm{w}_1\\), \\(\\bm{w}_2\\), \\(\\bm{w}_3\\). Take combinations of those vectors to produce \\(\\bm{v}_1\\), \\(\\bm{v}_2\\), \\(\\bm{v}_3\\). Write the combinations in matrix form as \\(V=WB\\): $$ \\begin{alignedat}{2.5} & \\bm{v}_1=\\bm{w}_1+ & \\bm{w}_2 & &\\\\ & \\bm{v}_2=\\bm{w}_1+ & 2\\bm{w}_2 & + & \\bm{w}_3 \\\\ & \\bm{v}_3= & \\bm{w}_2 & + & c\\bm{w}_3 \\end{alignedat} \\quad\\text{which is}\\quad \\begin{bmatrix} & & \\\\ \\bm{v}_1 & \\bm{v}_2 & \\bm{v}_3 \\\\ & & \\end{bmatrix} = \\begin{bmatrix} & & \\\\ \\bm{w}_1 & \\bm{w}_2 & \\bm{w}_3 \\\\ & & \\end{bmatrix} \\begin{bmatrix} 1 & 1 & 0 \\\\ 1 & 2 & 1 \\\\ 0 & 1 & c \\end{bmatrix} $$ What is the test on \\(B\\) to see if \\(V=WB\\) has independent columns? If \\(c\\neq 1\\) show that \\(\\bm{v}_1\\), \\(\\bm{v}_2\\), \\(\\bm{v}_3\\) are linearly independent. If \\(c=1\\) show that the \\(\\bm{v}\\)'s are linearly dependent. Solution&emsp;The test on \\(V\\) for independence of its columns was in our first definition: The nullspace of \\(V\\) must contain only the zero vector. Then \\(\\bm{x}=(0,0,0)\\) is the only combination of the columns that gives \\(V\\bm{x}=\\text{zero vector}\\). &emsp;&ensp;If \\(c=1\\) in our problem, we can see dependence in two ways. First, \\(\\bm{v}_1+\\bm{v}_3\\) will be the same as \\(\\bm{v}_2\\). (If you add \\(\\bm{w}_1+\\bm{w}_2\\) to \\(\\bm{w}_2+\\bm{w}_3\\) you get \\(\\bm{w}_1+2\\bm{w}_2+\\bm{w}_3\\) which is \\(\\bm{v}_2\\).) In other words \\(\\bm{v}_1-\\bm{v}_2+\\bm{v}_3=\\bm{0}\\)&mdash;which says that the \\(\\bm{v}\\)'s are not independent. &emsp;&ensp;The other way is to look at the nullspace of \\(B\\). If \\(c=1\\), the vector \\(\\bm{x}=(1,-1,1)\\) is in that nullspace, and \\(B\\bm{x}=\\bm{0}\\). Then certainly \\(WB\\bm{x}=\\bm{0}\\) which is the same as \\(V\\bm{x}=\\bm{0}\\). So the \\(\\bm{v}\\)'s are dependent. This specific \\(\\bm{x}=(1,-1,1)\\) from the nullspace tells us again that \\(\\bm{v}_1-\\bm{v}_2+\\bm{v}_3=\\bm{0}\\). &emsp;&ensp;Now suppose \\(c\\neq 1\\). Then the matrix \\(B\\) is invertible. So if \\(\\bm{x}\\) is any nonzero vector we know that \\(B\\bm{x}\\) is nonzero. Since the \\(\\bm{w}\\)'s are given as independent, we further know that \\(WB\\bm{x}\\) is nonzero. Since \\(V=WB\\), this says that \\(\\bm{x}\\) is not in the nullspace of \\(V\\). In other words \\(\\bm{v}_1\\), \\(\\bm{v}_2\\), \\(\\bm{v}_3\\) are independent. &emsp;&ensp;The general rule is &ldquo;independent \\(\\bm{v}\\)'s from independent \\(\\bm{w}\\)'s when \\(B\\) is invertible&rdquo;. And if these vectors are in \\(\\mathbf{R}^3\\), they are not only independent&mdash; they are a basis for \\(\\mathbf{R}^3\\). &ldquo;Basis of \\(\\bm{v}\\)'s from basis of \\(\\bm{w}\\)'s when the change of basis matrix \\(B\\) is invertible.&rdquo; 3.4 C&emsp;(Important example) Suppose \\(\\bm{v}_1,\\ldots,\\bm{v}_n\\) is a basis for \\(\\mathbf{R}^n\\) and the \\(n\\) by \\(n\\) matrix \\(A\\) is invertible. Show that \\(A\\bm{v}_1,\\ldots,A\\bm{v}_n\\) is also a basis for \\(\\mathbf{R}^n\\). Solution&emsp;In matrix language: Put the basis vectors \\(\\bm{v}_1,\\ldots,\\bm{v}_n\\) in the columns of an invertible(!) matrix \\(V\\). Then \\(A\\bm{v}_1,\\ldots,A\\bm{v}_n\\) are the columns of \\(AV\\). Since \\(A\\) is invertible, so is \\(AV\\) and its columns give a basis. &emsp;&ensp;In vector language: Suppose \\(c_1A\\bm{v}_1+\\cdots+c_nA\\bm{v}_n=\\bm{0}\\). This is \\(A\\bm{v}=\\bm{0}\\) with \\(\\bm{v}=c_1\\bm{v}_1+\\cdots+c_n\\bm{v}_n\\). Multiply by \\(A^{-1}\\) to reach \\(\\bm{v}=\\bm{0}\\). By linear independence of the \\(\\bm{v}\\)'s, all \\(c_i=0\\). This shows that the \\(A\\bm{v}\\)'s are independent. &emsp;&ensp;To show that the \\(A\\bm{v}\\)'s span \\(\\mathbf{R}^n\\), solve \\(c_1A\\bm{v}_1+\\cdots+c_nA\\bm{v}_n=\\bm{b}\\) which is the same as \\(c_1\\bm{v}_1+\\cdots+c_n\\bm{v}_n=A^{-1}\\bm{b}\\). Since the \\(\\bm{v}\\)'s are a basis, this must be solvable. Dimensions of the Four Subspaces The column space \\(\\bm{C}(A)\\) and the row space \\(\\bm{C}(A^\\mathrm{T})\\) both have dimension \\(r\\) (the rank of \\(A\\)). The nullspace \\(\\bm{N}(A)\\) has dimension \\(n-r\\). The left nullspace \\(\\bm{N}(A^\\mathrm{T})\\) has dimension \\(m-r\\). Elimination produces bases for the row space and nullspace of \\(A\\): They are the same as for \\(R\\). Elimination often changes the column space and left nullspace (but dimensions don’t change). Rank one matrices: \\(A=\\bm{uv}^\\mathrm{T}=\\text{column times row}\\): \\(\\bm{C}(A)\\) has basis \\(\\bm{u}\\), \\(\\bm{C}(A^\\mathrm{T})\\) has basis \\(\\bm{v}\\). &dagger; WORKED EXAMPLES &dagger; 3.5 A&emsp;Put four 1's into a 5 by 6 matrix of zeros, keeping the dimension of its row space as small as possible. Describe all the ways to make the dimension of its column space as small as possible. How to make the sum of the dimensions of all four subspaces small ? Solution&emsp;The rank is 1 if the four 1's go into the same row, or into the same column. They can also go into two rows and two columns (so \\(a_{ii}=a_{ij}=a_{ji}=a_{jj}=1\\)). Since the column space and row space always have the same dimensions, this answers the first two questions: Dimension 1. &emsp;&ensp;The nullspace has its smallest possible dimension \\(6-4=1\\) when the rank is \\(r=4\\). To achieve rank 4, the 1's must go into four different rows and four different columns. &emsp;&ensp;You can't do anything about the sum \\(r+(n-r)+r+(m-r)=\\bm{n+m}\\). It will be \\(6+5=11\\) no matter how the 1's are placed. The sum is 11 even if there aren't any 1's&mldr; &emsp;&ensp;If all the orhter entries of \\(A\\) are 2's instead of 0's, how do these answers change? 3.5 B&emsp;Fact: All the rows of \\(AB\\) are combinations of the rows of \\(B\\). So the row space of \\(AB\\) is contained in (possibly equal to) the row space of \\(B\\). \\(\\textbf{Rank($\\bm{AB}$)$\\bm{\\leq}$rank($\\bm{B}$)}\\). &emsp;&ensp;All columns of \\(AB\\) are combinations of the columns of \\(A\\). So the column space of \\(AB\\) is contained in (possibly equal to) the column space of \\(A\\). \\(\\textbf{Rank($\\bm{AB}$)$\\bm{\\leq}$rank($\\bm{A}$)}\\). &emsp;&ensp;If we multiply by an invertible matrix, the rank will not change. The rank can't drop, because when we multiply by the inverse matrix the rank can't jump back. Chapter 4 Orthogonality Orthogonality of the Four Subspaces Orthogonal vectors have \\(\\bm{v}^\\mathrm{T}\\bm{w}=0\\). Then \\(\\|\\bm{v}\\|^2+\\|\\bm{w}\\|^2=\\|\\bm{v}+\\bm{w}\\|^2=\\|\\bm{v}-\\bm{w}\\|^2\\). Subspaces \\(\\bm{V}\\) and \\(\\bm{W}\\) are orthogonal when \\(\\bm{v}^\\mathrm{T}\\bm{w}=0\\) for every \\(\\bm{v}\\) in \\(\\bm{V}\\) and every \\(\\bm{w}\\) in \\(\\bm{W}\\). The row space of \\(A\\) is orthogonal to the nullspace. The column space is orthogonal to \\(\\bm{N}(A^\\mathrm{T})\\). One pair of dimensions adds to \\(r+(n-r)=n\\). The other pair has \\(r+(m-r)-m\\). Row space and nullspace are orthogonal complements: Every \\(\\bm{x}\\) in \\(\\mathbf{R}^n\\) splits into \\(\\bm{x}_\\textbf{row}+\\bm{x}_\\textbf{null}\\). Suppose a space \\(\\bm{S}\\) has dimension \\(d\\). Then every basis for \\(\\bm{S}\\) consists of \\(d\\) vectors. If \\(d\\) vectors in \\(\\bm{S}\\) are independent, they span \\(\\bm{S}\\). If \\(d\\) vectors span \\(\\bm{S}\\), they are independent. &dagger; WORKED EXAMPLES &dagger; 4.1 A&emsp;Suppose \\(\\bm{S}\\) is a six-dimensional subspace of nine-dimensional space \\(\\mathbf{R}^n\\) &emsp;&ensp;(a)&ensp; What are the possible dimensions of subspaces orthogonal to \\(\\bm{S}\\)? &emsp;&ensp;(b)&ensp; What are the possible dimensions of the orthogonal complement \\(\\bm{S}^\\perp\\) of \\(\\bm{S}\\)? &emsp;&ensp;(c)&ensp; What is the smallest possible size of a matrix \\(A\\) that has row space \\(\\bm{S}\\)? &emsp;&ensp;(d)&ensp; What is the smallest possible size of a matrix \\(B\\) that has nullspace \\(\\bm{S}^\\perp\\)? Solution &emsp;&ensp;(a)&ensp; If \\(\\bm{S}\\) is six-dimensional in \\(\\mathbf{R}^9\\), subspaces orthogonal to \\(\\bm{S}\\) can have dimensions 0, 1, 2, 3. &emsp;&ensp;(b)&ensp; The complement \\(\\bm{S}^\\perp\\) is the largest orthogonal subspace, with dimension 3. &emsp;&ensp;(c)&ensp; The smallest matrix \\(A\\) is 6 by 9 (its six rows will be a basis for \\(\\bm{S}\\)) &emsp;&ensp;(d)&ensp; This is the same as question (c)! &emsp;&ensp;If a new row 7 of \\(B\\) is a combination of the six rows of \\(A\\), then \\(B\\) has the same row space as \\(A\\). It also has the same nullspace. The special solutions \\(\\bm{s}_1\\), \\(\\bm{s}_2\\), \\(\\bm{s}_3\\) to \\(A\\bm{x}=\\bm{0}\\), will be the same for \\(B\\bm{x}=0\\). Elimination will change row 7 of \\(B\\) to all zeros. 4.1 B&emsp;The equation \\(x-3y-4z=0\\) describes a plane \\(\\bm{P}\\) in \\(\\mathbf{R}^3\\) (actually a subspace). &emsp;&ensp;(a)&ensp; The plane \\(\\bm{P}\\) is the nullspace \\(\\bm{N}(A)\\) of what 1 by 3 matrix \\(A\\)? Ans: \\(A=\\begin{bmatrix} 1 & -3 & -4 \\end{bmatrix}\\). &emsp;&ensp;(b)&ensp; Find a basis \\(\\bm{s}_1\\), \\(\\bm{s}_2\\) of special solutions of \\(x-3y-4z=0\\) (these would be the columns of the nullspace matrix \\(N\\)). Answer: \\(\\bm{s}_1=(3,1,0)\\) and \\(\\bm{s}_2=(4,0,1)\\). &emsp;&ensp;(c)&ensp; Find a basis for the line \\(\\bm{P}^\\perp\\) that is perpendicular to \\(\\bm{P}\\). Answer: \\((1,-3,-4)\\)! Projections The projection of a vector \\(\\bm{b}\\) onto the line through \\(\\bm{a}\\) is the closest point \\(\\bm{p}=\\bm{a}(\\bm{a^\\mathrm{T}b}/\\bm{a^\\mathrm{T}a})\\). &dagger; WHY &dagger; When projection onto a line, the projection \\(\\bm{p}\\) will be some multiple of \\(\\bm{a}\\). Call it \\(\\bm{p}=\\widehat{x}\\bm{a}=\\text{\\textquotedblleft$x$ hat\\textquotedblright\\space times $\\bm{a}$}\\). &emsp;&ensp;The dotted line from \\(\\bm{b}\\) to \\(\\bm{p}\\) is perpendicular to \\(\\bm{a}\\), which is called the \"error\": \\(\\bm{e}=\\bm{b}-\\bm{p}=\\bm{b}-\\widehat{x}\\bm{a}\\). Use the fact that \\(\\bm{a}\\cdot\\bm{e}=0\\): $$ \\bm{a}^\\mathrm{T}\\bm{e}=0 \\harr \\bm{a}^\\mathrm{T}(\\bm{b}-\\widehat{x}\\bm{a})=0 \\harr \\bm{a}^\\mathrm{T}\\bm{b}-\\widehat{x}\\bm{a}^\\mathrm{T}\\bm{a}=0 \\harr \\widehat{x}=\\frac{\\bm{a}^\\mathrm{T}\\bm{b}}{\\bm{a}^\\mathrm{T}\\bm{a}} $$ Then \\(\\bm{p}=\\widehat{x}\\bm{a}=\\frac{\\bm{a}^\\mathrm{T}\\bm{b}}{\\bm{a}^\\mathrm{T}\\bm{a}}\\bm{a}\\). The error \\(\\bm{e}=\\bm{b}-\\bm{p}\\) is perpendicular to \\(\\bm{a}\\): Right triangle \\(\\bm{b\\space p\\space e}\\) has \\(\\|\\bm{p}\\|^2+\\|\\bm{e}\\|^2=\\|\\bm{b}\\|^2\\) The projection of \\(\\bm{b}\\) onto a subspace \\(\\bm{S}\\) is the closest vector \\(\\bm{p}\\) in \\(\\bm{S}\\); \\(\\bm{b}-\\bm{p}\\) is orthogonal to \\(\\bm{S}\\). \\(A^\\mathrm{T}A\\) is invertible (and symmetric) only if \\(A\\) has independent columns: \\(\\bm{N}(A^\\mathrm{T}A)=\\bm{N}(A)\\). Then the projection of \\(\\bm{b}\\) onto the column space of \\(A\\) is the vector \\(\\bm{p}=A(A^\\mathrm{T}A)^{-1}A^\\mathrm{T}\\bm{b}\\). &dagger; WHY &dagger; As we know a subspace can be described as the column space of a matrix \\(A\\), when projection onto a subspace, we are actually looking for the combination of the columns of \\(A\\) that is closest to a given vector \\(\\bm{b}\\): $$ \\bm{p}=\\widehat{x}_1\\bm{a}_1+\\cdots+\\widehat{x}_n\\bm{a}_n=A\\widehat{\\bm{x}} \\qquad \\text{Here $\\widehat{\\bm{x}}$ comes a vector} $$ The error vector \\(\\bm{b}-A\\widehat{\\bm{x}}\\) is perpendicular to the subspace, which means every columns of \\(A\\) times \\(\\bm{e}\\) is zero: $$ \\begin{bmatrix} \\bm{a}_1^\\mathrm{T} \\\\ \\vdots \\\\ \\bm{a}_n^\\mathrm{T} \\end{bmatrix} \\begin{bmatrix} \\bm{b}-A\\widehat{\\bm{x}} \\end{bmatrix} = \\bm{0} \\harr A^\\mathrm{T}(\\bm{b}-A\\widehat{\\bm{x}})=\\bm{0} \\harr A^\\mathrm{T}A\\widehat{\\bm{x}}=A^\\mathrm{T}\\bm{b} $$ Here \\(A^\\mathrm{T}A\\) is a \\(n\\) by \\(n\\) symmetric matrix. It is invertible if the \\(\\bm{a}\\)'s are independent. (Be aware \\(A\\) might not invertible as it may not a square matrix.) Solve this system we find \\(\\widehat{\\bm{x}}\\) and then \\(p=A\\widehat{\\bm{x}}=A(A^\\mathrm{T}A)^{-1}A^\\mathrm{T}\\bm{b}\\). &emsp;&ensp;From Math StackExchange. To prove \\(A^\\mathrm{T}A\\) is invertible we can work on the statement &ldquo;\\(A^\\mathrm{T}A\\bm{x}=\\bm{0}\\) has only one solution \\(\\bm{x}=\\bm{0}\\)&rdquo;. Because \\(A^\\mathrm{T}\\bm{y}=\\bm{0}\\) may have solutions \\(\\bm{y}\\neq\\bm{0}\\), we must prove that \\(\\bm{y}=\\bm{0}\\) while \\(\\bm{y}=A\\bm{x}\\): &emsp;&ensp;\\(A\\bm{x}\\) is a combination in \\(\\bm{C}(A)\\) which is also in \\(\\bm{N}(A^\\mathrm{T})\\). However \\(\\bm{N}(A^\\mathrm{T})\\) and \\(\\bm{C}(A)\\) are orthogonal complements, the only vector that can be in both a subspace and the orthogonal complement of its subspace is the zero vector, so \\(A\\bm{x}\\) must produce zero vector. &emsp;&ensp;For \\(A\\bm{x}=\\bm{0}\\) there is obviously only one solution \\(\\bm{x}=\\bm{0}\\). Then \\(A^\\mathrm{T}A\\bm{x}=\\bm{0}\\harr\\bm{x}=\\bm{0}\\) if \\(A\\) has independent columns. The projection matrix onto \\(\\bm{C}(A)\\) is \\(\\boxed{P=A(A^\\mathrm{T}A)^{-1}A^\\mathrm{T}}\\). It has \\(\\bm{p}=P\\bm{b}\\) and \\(P^2=P=P^\\mathrm{T}\\). &dagger; WORKED EXAMPLES &dagger; 4.2 A&emsp;Project the vector \\(\\bm{b}=(3,4,4)\\) onto the line through \\(\\bm{a}=(2,2,1)\\) and then onto the plane that also contains \\(\\bm{a}^*=(1,0,0)\\). Check that the first error vector \\(\\bm{b}-\\bm{p}\\) is perpendicular to \\(\\bm{a}\\), and the second error vector \\(\\bm{e}^*=\\bm{b}-\\bm{p}^*\\) is also perpendicular to \\(\\bm{a}^*\\). &emsp;&ensp;Find the 3 by 3 projection matrix \\(P\\) onto that plane of \\(\\bm{a}\\) and \\(\\bm{a}^*\\). Find a vector whose projection onto the plane is the zero vector. Why is it exactly the error \\(\\bm{e}^*\\)? Solution&emsp;The projection of \\(\\bm{b}=(3,4,4)\\) onto the line through \\(\\bm{a}=(2,2,1)\\) is \\(\\bm{p}=2\\bm{a}\\). $$ \\textbf{Onto a line}\\qquad \\bm{p}=\\frac{\\bm{a^\\mathrm{T}b}}{\\bm{a^\\mathrm{T}a}}\\bm{a}=\\frac{18}{9}(2,2,1)=(4,4,2)=2\\bm{a}. $$ The error vector \\(\\bm{e}=\\bm{b}-\\bm{p}=(-1,0,2)\\) is perpendicular to \\(\\bm{a}=(2,2,1)\\). So \\(\\bm{p}\\) is correct. &emsp;&ensp;The plane of \\(\\bm{a}=(2,2,1)\\) and \\(\\bm{a}^*=(1,0,0)\\) is the column space of \\(A=\\begin{bmatrix} \\bm{a} & \\bm{a}^* \\end{bmatrix}\\): $$ A=\\begin{bmatrix} 2 & 1 \\\\ 2 & 0 \\\\ 1 & 0 \\end{bmatrix}\\quad A^\\mathrm{T}A=\\begin{bmatrix} 9 & 2 \\\\ 2 & 1 \\end{bmatrix}\\quad (A^\\mathrm{T}A)^{-1}=\\frac{1}{5}\\begin{bmatrix*}[r] 1 & -2 \\\\ -2 & 9 \\end{bmatrix*}\\quad P=\\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & .8 & .4 \\\\ 0 & .4 & .2 \\end{bmatrix} $$ Now \\(\\bm{p}^*=P\\bm{b}=(3,4.8,2.4\\). The error \\(\\bm{e}^*=\\bm{b}-\\bm{p}^*=(0,-.8,1.6\\) is perpendicular to \\(\\bm{a}\\) and \\(\\bm{a}^*\\). This \\(\\bm{e}^*\\) is in the nullspace of \\(P\\) and its projection is zero! Note \\(P^2=P=P^\\mathrm{T}\\). 4.2 B&emsp;Suppose your pulse is measured at \\(x=70\\) beats per minute, then at \\(x=80\\), then at \\(x=120\\). Those three equations \\(A\\bm{x}=\\bm{b}\\) in one unknown have \\(A^\\mathrm{T}=\\begin{bmatrix} 1 & 1 & 1 \\end{bmatrix}\\) and \\(\\bm{b}=(70,80,120)\\). The best \\(\\widehat{\\bm{x}}\\) is the ____ of \\(\\bm{70,80,120}\\). Use calculus and projection: Minimize \\(E=(x-70)^2+(x-80)^2+(x-120)^2\\) by solving \\(\\mathrm{d}E/\\mathrm{d}x=0\\). Project \\(\\bm{b}=(70,80,120)\\) onto \\(\\bm{a}=(1,1,1)\\) to find \\(\\widehat{x}=\\bm{a}^\\mathrm{T}\\bm{b}/\\bm{a}^\\mathrm{T}\\bm{a}\\). Solution&emsp;The colsest horizontal line to the heights 70, 80 120 is the average \\(\\widehat{x}=90\\): $$ \\begin{array}{l} \\dfrac{\\mathrm{d}E}{\\mathrm{d}x}=2(x-70)+2(x-80)+2(x-120)=0 \\quad\\text{gives}\\quad \\widehat{x}=\\dfrac{70+80+120}{3}=90 . \\\\ \\textbf{Also by projection:}\\qquad \\widehat{x}=\\dfrac{\\bm{a^\\mathrm{T}b}}{\\bm{a^\\mathrm{T}a}}=\\dfrac{(1,1,1)^\\mathrm{T}(70,80,120)}{(1,1,1)^\\mathrm{T}(1,1,1)}=\\dfrac{70+80+120}{3}=90 . \\end{array} $$ In recursive least squares, a fourth measurement 130 changes the average \\(\\widehat{x}_\\text{old}=90\\) to \\(\\widehat{x}_\\text{new}=100\\). Verify the updage formula \\(\\widehat{x}_\\text{new}=\\widehat{x}_\\text{old}+\\frac{1}{4}(130-\\widehat{x}_\\text{old})\\). When a new measurement arrives, we don't have to average all the old measurements again! Least Squares Approximations Solving \\(\\boxed{A^\\mathrm{T}A\\widehat{\\bm{x}}=A^\\mathrm{T}\\bm{b}}\\) gives the projection \\(\\bm{p}=A\\widehat{\\bm{x}}\\) of \\(\\bm{b}\\) onto the column space of \\(A\\). When \\(A\\bm{x}=\\bm{b}\\) has no solution, \\(\\widehat{\\bm{x}}\\) is the “leqst-squares solution”: \\(\\|\\bm{b}-A\\widehat{\\bm{x}}\\|^2=\\text{minimum}\\). Setting partial derivatives of \\(E=\\|A\\bm{x}-\\bm{b}\\|^2\\) to zero \\(\\left(\\dfrac{\\partial E}{\\partial x_i}=0\\right)\\) also produces \\(A^\\mathrm{T}A\\widehat{\\bm{x}}=A^\\mathrm{T}\\bm{b}\\). &dagger; WHY &dagger; Treat \\(E=\\|A\\bm{x}-\\bm{b}\\|^2\\) as a error function. Most functions are minimized by calculus! The graph bottoms out and the derivative in every direction is zero. &emsp;&ensp;For example: $$ \\begin{array}{c} A=\\begin{bmatrix} 1 & 0 \\\\ 1 & 1 \\\\ 1 & 2 \\end{bmatrix} \\qquad \\bm{x}=\\begin{bmatrix} C \\\\ D \\end{bmatrix} \\qquad \\bm{b}=\\begin{bmatrix} 6 \\\\ 0 \\\\ 0 \\end{bmatrix} \\\\\\\\ E=\\|A\\bm{x}-\\bm{b}\\|^2=(C+D\\cdot 0-6)^2+(C+D\\cdot 1)^2+(C+D\\cdot 2)^2 \\end{array} $$ Here the function \\(E\\) to be minimized is a sum of squares \\(e_1^2+e_2^2+e_3^2\\) (the square of the error in each equation). &emsp;&ensp;The unknowns are \\(C\\) and \\(D\\). With two unknowns there are two derivatives&mdash;both zero at the minimum. They are &ldquo;partial derivatives&rdquo; because \\(\\partial E/\\partial D\\) treats \\(D\\) as constant and \\(\\partial E/\\partial D\\) treats \\(C\\) as constant: $$ \\begin{alignedat}{3.5} & \\partial E/\\partial C=2(C+D\\cdot 0-6) && +2(C+D\\cdot 1) && +2(C+D\\cdot 2) & =0 \\\\ & \\partial E/\\partial D=2(C+D\\cdot 0-6)(\\bm{0}) && +2(C+D\\cdot 1)(\\bm{1}) && +2(C+D\\cdot 2)(\\bm{2}) & =0 \\end{alignedat} $$ \\(\\partial E/\\partial D\\) contains the extra factors \\(\\bm{0}\\), \\(\\bm{1}\\), \\(\\bm{2}\\) from the chain rule. Those factors are just \\(\\bm{1}\\), \\(\\bm{1}\\), \\(\\bm{1}\\) in \\(\\partial E/\\partial C\\) &emsp;&ensp;It is no accident that those factors \\(\\bm{1}\\), \\(\\bm{1}\\), \\(\\bm{1}\\) and \\(\\bm{0}\\), \\(\\bm{1}\\), \\(\\bm{2}\\) in the derivatives of \\(\\|A\\bm{x}-\\bm{b}\\|^2\\) are the columns of \\(A\\). Now cancel 2 from every term and collect all \\(C\\)'s and \\(D\\)'s: $$ \\begin{array}{l} \\text{The $C$ derivative is zero:}\\quad 3C+3D=6 \\\\ \\text{The $D$ derivative is zero:}\\quad 3C+5D=0 \\end{array} \\quad \\textbf{This matrix $\\begin{bmatrix} 3 & 3 \\\\ 5 & 5 \\end{bmatrix}$ is $A^\\mathrm{T}A$} $$ These equations are identical with \\(A^\\mathrm{T}A\\widehat{\\bm{x}}=A^\\mathrm{T}\\bm{b}\\). The best \\(C\\) and \\(D\\) are the components of \\(\\widehat{\\bm{x}}\\). The equations from calculus are the same as the &ldquo;normal equations&rdquo; from linear algebra. To fit points \\((t_1,b_1),\\ldots,(t_m,b_m)\\) by a straight line, \\(A\\) has columns \\(1,\\ldots,1\\) and \\(t_1,\\ldots,t_m\\). In that case \\(A^\\mathrm{T}A\\) is the 2 by 2 matrix \\(\\begin{bmatrix} m &amp; \\bm{\\Sigma}t_i \\\\ \\bm{\\Sigma}t_i &amp; \\bm{\\Sigma}t_i^2 \\end{bmatrix}\\) and \\(A^\\mathrm{T}\\bm{b}\\) is the vector \\(\\begin{bmatrix*}[l] \\bm{\\Sigma}b_i \\\\ \\bm{\\Sigma}t_ib_i \\end{bmatrix*}\\). &dagger; WORKED EXAMPLES &dagger; 4.3 A&emsp;Start with nine measurements \\(b_1\\) to \\(b_9\\), all zero, at time \\(t=1,\\ldots,9\\). The tenth measurement \\(b_{10}=40\\) is an outlier. Find the best horizontal line \\(\\bm{y=C}\\) to fit the ten points \\((1,0)\\), \\((2,0)\\), &mldr;, \\((9,0)\\), \\((10,40)\\) using three options for the error \\(E\\): (1)&ensp;Least squares \\(E_2=e_1^2+\\cdots+e_{10}^2\\) (then the normal equation for \\(C\\) is linear). (2)&ensp;Least maximum error \\(E_\\infty=|e_\\text{max}|\\). (3)&ensp;Least sum of errors \\(E_1=|e_1|+\\cdots+|e_{10}|\\). Solution&emsp;(1)&ensp;The least squares fit to \\(0,0,\\ldots,0,40\\) by a horizontal line is \\(\\bm{C=4}\\): $$ A=\\text{column of 1's}\\quad A^\\mathrm{T}A=10\\quad A^\\mathrm{T}\\bm{b}=\\text{sum of $b_i=40$.\\quad So $10C=40$.} $$ (2)&ensp;The least maximum error requires \\(\\bm{C=20}\\), halfway between 0 amd 40. (3)&ensp;The least sum requires \\(\\bm{C=0}\\) (!!). The sum of errors \\(9|C|+|40-C|\\) would increase if \\(C\\) moves up from zero. &emsp;&ensp;The least sum comes from the median measurement (the median of \\(0,\\ldots,0,40\\) is zero). Many statisticians feel that the least squares solution is too heavily influenced by outliers like \\(b_{10}=40\\), and they prefer least sum. But the equations become nonlinear. &emsp;&ensp;Now find the least squares line \\(C+D\\bm{t}\\) through those ten points \\((1,0)\\) to \\((10,40)\\): $$ A^\\mathrm{T}A= \\begin{bmatrix} 10 & \\sum t_i \\\\ \\sum t_i & \\sum t_i^2 \\end{bmatrix} = \\begin{bmatrix} 10 & 55 \\\\ 55 & 385 \\end{bmatrix} \\qquad A^\\mathrm{T}\\bm{b}= \\begin{bmatrix} \\sum b_i \\\\ \\sum t_ib_i \\end{bmatrix} = \\begin{bmatrix} 40 \\\\ 400 \\end{bmatrix} $$ Those come from equation (8). Then \\(A^\\mathrm{T}A\\widehat{\\bm{x}}=A^\\mathrm{T}\\bm{b}\\) gives \\(C=-8\\) and \\(D=24/11\\). &dagger; Equation (8) &dagger; The line \\(C+D\\bm{t}\\) minimizes \\(e_1^2+\\cdots+e_m^2=\\|A\\bm{x}+\\bm{b}\\|^2\\) when \\(A^\\mathrm{T}A\\widehat{\\bm{x}}=A^\\mathrm{T}\\bm{b}\\): $$ \\begin{equation}\\tag{8} A^\\mathrm{T}A\\widehat{\\bm{x}}=A^\\mathrm{T}\\bm{b}\\qquad \\begin{bmatrix} m & \\sum t_i \\\\ \\sum t_i & \\sum t_i^2 \\end{bmatrix} \\begin{bmatrix} C \\\\ D \\end{bmatrix} = \\begin{bmatrix} \\sum b_i \\\\ \\sum t_ib_i \\end{bmatrix} . \\end{equation} $$ &emsp;&ensp;What happens to \\(C\\) and \\(D\\) if you multiply \\(\\bm{b}=(0,0,\\ldots,40)\\) by 3 and then add 30 to get \\(\\bm{b}_\\text{new}=(30,30,\\ldots,150)\\)? Linearity allows us to rescale \\(\\bm{b}\\). Multiplying \\(\\bm{b}\\) by 3 will multiply \\(C\\) and \\(D\\) by 3. Adding 30 to all \\(b_i\\) will add 30 to \\(C\\). 4.3 B&emsp;Find the parabola \\(C+Dt+Et^2\\) that comes closest (least squares error) to the values \\(\\bm{b}=(0,0,1,0,0)\\) at the times \\(t=-2,-1,0,1,2\\). First write down the five equations \\(A\\bm{x}=\\bm{b}\\) in three unknowns \\(\\bm{x}=(C,D,E)\\) for a parabola to go through the five points. No solution because no such parabola exists. Solve \\(A^\\mathrm{T}A\\widehat{\\bm{x}}=A^\\mathrm{T}\\bm{b}\\). &emsp;&ensp;I would predict \\(D=0\\). Why should the best parabola be symmetric around \\(t=0\\)? In \\(A^\\mathrm{T}A\\widehat{\\bm{x}}=A^\\mathrm{T}\\bm{b}\\), equation 2 for \\(D\\) should uncouple from equations 1 and 3. Solution&emsp;The five equations \\(A\\bm{x}=\\bm{b}\\) have a rectangular Vandermonde matrix \\(A\\): $$ \\begin{alignedat}{3.5} C+D && (-2)+E && (-2)^2=0 \\\\ C+D && (-1)+E && (-1)^2=0 \\\\ C+D && (0)+E && (0)^2=1 \\\\ C+D && (1)+E && (1)^2=0 \\\\ C+D && (2)+E && (2)^2=0 \\\\ \\end{alignedat} \\quad A= \\begin{bmatrix*}[r] 1 & -2 & 4 \\\\ 1 & -1 & 1 \\\\ 1 & 0 & 0 \\\\ 1 & 1 & 1 \\\\ 1 & 2 & 4 \\end{bmatrix*} \\quad A^\\mathrm{T}A=\\begin{bmatrix} 5 & \\bm{0} & 10 \\\\ \\bm{0} & 10 & \\bm{0} \\\\ 10 & \\bm{0} & 34 \\end{bmatrix} $$ Those zeros in \\(A^\\mathrm{T}A\\) mean that column 2 of \\(A\\) is orthogonal to columns 1 and 3. We see this directly in \\(A\\) (the times \\(-2,-1,0,1,2\\) are symmetric). The best \\(C\\), \\(D\\), \\(E\\) in the parabola \\(C+Dt+Et^2\\) come from \\(A^\\mathrm{T}A\\widehat{\\bm{x}}=A^\\mathrm{T}\\bm{b}\\), and \\(D\\) is uncoupled from \\(C\\) and \\(E\\): $$ \\begin{bmatrix} 5 & 0 & 10 \\\\ 0 & 10 & 0 \\\\ 10 & 0 & 34 \\end{bmatrix} \\begin{bmatrix} C \\\\ D \\\\ E \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\quad\\text{leads to}\\quad \\begin{array}{l} C=34/70 \\\\ D=0\\text{ as predicted} \\\\ E=-10/70 \\end{array} $$ Orthonormal Bases and Gram-Schmidt The columns \\(\\bm{q}_1,\\ldots,\\bm{q}_n\\) are orthonormal if \\(\\bm{q}_i^\\mathrm{T}\\bm{q}_j=\\left\\{\\begin{array}{l} \\text{0 for $i\\neq j$} \\\\ \\text{1 for $i=j$} \\end{array}\\right\\}\\). Then \\(\\boxed{Q^\\mathrm{T}Q=I}\\). If \\(Q\\) is also square, then \\(QQ^\\mathrm{T}=I\\) and \\(\\boxed{Q^\\mathrm{T}=Q^{-1}}\\). \\(Q\\) is an “orthogonal matrix”. The least squares solution to \\(Q\\bm{x}=\\bm{b}\\) is \\(\\widehat{\\bm{x}}=Q^\\mathrm{T}\\bm{b}\\). Projection of \\(\\bm{b}\\): \\(\\bm{p}=QQ^\\mathrm{T}\\bm{b}=P\\bm{b}\\). The Gram-Schmidt process takes independent \\(\\bm{a}_i\\) to orthonormal \\(\\bm{q}_i\\). Start with \\(\\bm{q}_1=\\bm{a}_1/\\|\\bm{a}_1\\|\\). \\(\\bm{q}_i\\) is \\((\\bm{a}_i-\\text{projection }\\bm{p}_i)/\\|\\bm{a}_i-\\bm{p}_i\\|\\); projection \\(\\bm{p}_i=(\\bm{a}_i^\\mathrm{T}\\bm{q}_1)\\bm{q}_1+\\cdots+(\\bm{a}_i^\\mathrm{T}\\bm{q}_{i-1})\\bm{q}_{i-1}\\). &dagger; WHY &dagger; The one and only idea of the Gram-Schmidt process is that subtract from every new vector its projections in the directions already set. &emsp;&ensp;Begin by choosing \\(\\bm{\\alpha}=\\bm{a}\\), the first direction is accepted as it comes. Then (at the end may be easiest) divide its length to get \\(\\bm{q}_i=\\bm{\\alpha}_i/\\|\\bm{\\alpha}_i\\|\\). Start with \\(\\bm{a}_2\\) subtract its projection along \\(\\bm{a}_1\\). This leaves the perpendicular part, which is the orthogonal vector \\(\\bm{\\alpha}_2\\): $$ \\textbf{First Gram-Schmidt step}\\quad \\begin{alignedat}{1} \\bm{\\alpha}_2 & = \\bm{a}_2-\\bm{\\alpha}_1(\\cfrac{\\bm{\\alpha}_1^\\mathrm{T}\\bm{a}_2}{\\bm{\\alpha}_1^\\mathrm{T}\\bm{\\alpha}_1}) \\\\ & = \\bm{a}_2-\\cfrac{\\bm{\\alpha}_1(\\bm{\\alpha}_1^\\mathrm{T}\\bm{a}_2)}{\\|\\bm{\\alpha}_1\\|^2} \\\\ & = \\bm{a}_2-\\bm{q}_1(\\bm{q}_1^\\mathrm{T}\\bm{a}_2) \\end{alignedat} $$ The third direction starts with \\(\\bm{a}_3\\). Subtract off its components in those two directions to get a perpendicular direction \\(\\bm{\\alpha}_3\\): $$ \\textbf{Next Gram-Schmidt step}\\quad \\begin{alignedat}{1} \\bm{\\alpha}_3 & = \\bm{a}_3-\\bm{\\alpha}_1(\\cfrac{\\bm{\\alpha}_1^\\mathrm{T}\\bm{a}_3}{\\bm{\\alpha}_1^\\mathrm{T}\\bm{\\alpha}_1})-\\bm{\\alpha}_2(\\cfrac{\\bm{\\alpha}_2^\\mathrm{T}\\bm{a}_3}{\\bm{\\alpha}_2^\\mathrm{T}\\bm{\\alpha}_2}) \\\\ & = \\bm{a}_3-\\bm{q}_1(\\bm{q}_1^\\mathrm{T}\\bm{a}_3)-\\bm{q}_2(\\bm{q}_2^\\mathrm{T}\\bm{a}_3) \\end{alignedat} $$ Each \\(\\bm{a}_i\\) will be a combination of \\(\\bm{q}_1\\) and \\(\\bm{q}_i\\). Then \\(\\bm{A=QR}\\): orthogonal \\(Q\\) and triangular \\(R\\). &dagger; WORKED EXAMPLES &dagger; 4.4 A&emsp;Add two more columns with all entries 1 or &minus;1, so the columns of this 4 by 4 &ldquo;Hadamard matrix&rdquo; are orthogonal. How do you turn \\(H_4\\) into an orthogonal matrix \\(Q\\)? $$ H_2=\\begin{bmatrix*}[r] 1 & 1 \\\\ 1 & -1 \\end{bmatrix*} \\quad H_4= \\begin{bmatrix*}[r] 1 & 1 & x & x \\\\ 1 & -1 & x & x \\\\ 1 & 1 & x & x \\\\ 1 & -1 & x & x \\end{bmatrix*} \\quad\\text{and}\\quad Q_4= \\begin{bmatrix} & & & \\\\ & & & \\\\ & & & \\\\ & & & \\end{bmatrix} $$ The block matrix \\(H_8=\\begin{bmatrix*}[r] H_4 & H_4 \\\\ H_4 & -H_4 \\end{bmatrix*}\\quad\\begin{array}{l} \\text{is the next Hadamard matrix with 1's and $\\mathord{-}1$'s.} \\\\ \\text{What is the product $H_8^\\mathrm{T}H_8$?} \\end{array}\\) The projection of \\(\\bm{b}=(6,0,0,2)\\) onto the first column of \\(H_4\\) is \\(\\bm{p}_1=(2,2,2,2)\\). The projection onto the second column is \\(\\bm{p}_2=(1,-1,1,-1)\\). What is the projection \\(\\bm{p}_{1,2}\\) of \\(\\bm{b}\\) onto the 2-dimensional space spanned by the first two columns? Solution&emsp;\\(H_4\\) can be built from \\(H_2\\) just as \\(H_8\\) is built from \\(H_4\\): $$ H_4= \\begin{bmatrix*}[r] H_2 & H_2 \\\\ H_2 & -H_2 \\end{bmatrix*} = \\begin{bmatrix*}[r] 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 \\end{bmatrix*} \\quad \\text{has orthogonal columns.} $$ Then \\(Q=H/2\\) has orthonormal columns. Dividing by 2 gives unit vectors in \\(Q\\). A 5 by 5 Hadamard matrix is impossible because the dot product of columns would have five 1's and/or &minus;1's and could not add to zero. \\(H_8\\) has orthogonal columns of length \\(\\sqrt{8}\\). $$ H_8^\\mathrm{T}H_8= \\begin{bmatrix*}[r] H^\\mathrm{T} & H^\\mathrm{T} \\\\ H^\\mathrm{T} & -H^\\mathrm{T} \\end{bmatrix*} \\begin{bmatrix*}[r] H & H \\\\ H & -H \\end{bmatrix*} = \\begin{bmatrix} 2H^\\mathrm{T}H & 0 \\\\ 0 & 2H^\\mathrm{T}H \\end{bmatrix} = \\begin{bmatrix} 8I & 0 \\\\ 0 & 8I \\end{bmatrix} .\\space Q_8=\\frac{H_8}{\\sqrt{8}} $$ 4.4 B&emsp;What is the key point of orthogonal columns? Answer: \\(A^\\mathrm{T}A\\) is diagonal and easy to invert. We can project onto lines and just add. The axes are orthogonal. $$ \\textbf{Add $\\bm{p}$'s}\\quad\\text{Projection $\\bm{p}_{1,2}$ onto a plane equals $\\bm{p}_1+\\bm{p}_2$ onto orthogonal lines.} $$ Chapter 5 Determinants The properties of Determinants The determinant of \\(A=\\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix}\\) is \\(\\bm{ad-bc}\\). Singular matrix \\(A=\\begin{bmatrix} a &amp; xa \\\\ c &amp; xc \\end{bmatrix}\\) has \\(\\bm{\\det=0}\\) \\(\\begin{array}{l} \\textbf{Row exchange} \\\\ \\textbf{reverses signs} \\end{array} PA=\\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}\\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix}=\\begin{bmatrix} c &amp; d \\\\ a &amp; b \\end{bmatrix}\\quad\\text{has }\\det PA=bc-ad=\\bm{-\\det A}\\). The determinant of \\(\\begin{bmatrix} xa+yA &amp; xb+yB \\\\ c &amp; d \\end{bmatrix}\\) is \\(x(ad-bc)+y(Ad-Bc)\\). \\(\\begin{array}{l} \\textbf{Det is linear in} \\ \\textbf{row 1 by itself.} \\end{array}\\) 1 &minus; The determinant of \\(\\begin{bmatrix} xa+yA & xb+yB \\\\ c & d \\end{bmatrix}\\) is \\(x(ad-bc)+y(Ad-Bc)\\). \\(\\begin{array}{l} \\textbf{Det is linear in} \\\\ \\textbf{row 1 by itself.} \\end{array}\\) 2 + The determinant is a linear function of each row separately (all other rows stay fixed), see in example 5.1 A Elimination \\(EA=\\begin{bmatrix} a &amp; b \\\\ 0 &amp; d-\\dfrac{c}{a}b \\end{bmatrix}\\quad\\bm{\\det EA}=a(d-\\dfrac{c}{a}b)=\\textbf{product of pivots}=\\bm{\\det A}\\). If \\(A\\) is \\(n\\) by \\(n\\) then the four statements above remain true: \\(\\bm{\\det=0}\\) when \\(A\\) is singular, det reverses sign when row are exchanged, det is linear in row 1 by itself, \\(\\det=\\textbf{product of the pivots}\\). Always \\(\\bm{\\det BA=(\\det B)(\\det A)}\\) and \\(\\bm{\\det A^\\textbf{\\textrm{T}}=\\det A}\\). This is an amazing number. &dagger; WORKED EXAMPLES &dagger; 5.1 A&emsp;Apply these operations to \\(A\\) and find the determinants of \\(M_1\\), \\(M_2\\), \\(M_3\\), \\(M_4\\): &emsp;In \\(M_1\\), multiplying each \\(a_{ij}\\) by \\((-1)^{i+j}\\) gives a checker board sign pattern. &emsp;In \\(M_2\\), rows 1, 2, 3 of \\(A\\) are subtracted from rows 2, 3, 1. &emsp;In \\(M_3\\), rows 1, 2, 3 of \\(A\\) are added to rows 2, 3, 1. How are the determinants of \\(M_1\\), \\(M_2\\), \\(M_3\\) related to the determinant of \\(A\\)? $$ \\begin{bmatrix*}[r] a_{11} & -a_{12} & a_{13} \\\\ -a_{21} & a_{22} & -a_{23} \\\\ a_{31} & -a_{32} & a_{33} \\end{bmatrix*} \\quad \\begin{bmatrix} \\text{row 1 $-$ row 3} \\\\ \\text{row 2 $-$ row 1} \\\\ \\text{row 3 $-$ row 2} \\end{bmatrix} \\quad \\begin{bmatrix} \\text{row 1 $+$ row 3} \\\\ \\text{row 2 $+$ row 1} \\\\ \\text{row 3 $+$ row 2} \\end{bmatrix} $$ Solution&emsp;The three determinanats are \\(\\det A\\), \\(0\\), and \\(2\\det A\\). Here are reasons: \\(M_1=\\begin{bmatrix} 1 & & \\\\ & -1 & \\\\ & & 1 \\end{bmatrix}\\begin{bmatrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\\\ a_{31} & a_{32} & a_{33} \\end{bmatrix}\\begin{bmatrix} 1 & & \\\\ & -1 & \\\\ & & 1 \\end{bmatrix}\\quad\\text{so $\\det M_1=(-1)(\\det A)(-1)$.}\\) \\(M_2\\) is singular because its rows add to the zero row. Its determinant is zero. \\(M_3\\) can be split into eight matrices by Rule 3 (linearity in each row separately): $$ \\begin{vmatrix} \\text{row 1 $+$ row 3} \\\\ \\text{row 2 $+$ row 1} \\\\ \\text{row 3 $+$ row 2} \\end{vmatrix} = \\begin{vmatrix} \\text{row 1} \\\\ \\text{row 2} \\\\ \\text{row 3} \\end{vmatrix} + \\begin{vmatrix} \\text{row 3} \\\\ \\text{row 2} \\\\ \\text{row 3} \\end{vmatrix} + \\begin{vmatrix} \\text{row 1} \\\\ \\text{row 1} \\\\ \\text{row 3} \\end{vmatrix} +\\cdots+ \\begin{vmatrix} \\text{row 3} \\\\ \\text{row 1} \\\\ \\text{row 2} \\end{vmatrix} . $$ All but the first and last have repeated rows and zero determinant. The first is \\(A\\) and the last has two row exchanges. So \\(\\det M_3=\\det A+\\det A\\). (Try \\(A=I\\).) 5.1 B&emsp;Explain how to reach this determinant by row operations: $$ \\det\\begin{bmatrix} 1-a & 1 & 1 \\\\ 1 & 1-a & 1 \\\\ 1 & 1 & 1-a \\end{bmatrix}=a^2(3-a) . $$ Solution&emsp;Subtract row 3 from row 1 and then from row 2. This leaves $$ \\det\\begin{bmatrix} -a & 0 & a \\\\ 0 & -a & a \\\\ 1 & 1 & 1-a \\end{bmatrix} . $$ Now add column 1 to column 3, and also column 2 to column 3. This leaves a lower triangular matrix with \\(-a\\), \\(-a\\), \\(3-a\\) on the diagonal: \\(\\det=(-a)(-a)(3-a)\\). &emsp;&ensp;The determinant is zero if \\(a=0\\) or \\(a=3\\). For \\(a=0\\) we have the all-ones matrix&mdash;certainly singular. For \\(a=3\\), each row adds to zero&mdash;again singular. Those numbers 0 and 3 are the eigenvalues of the all-ones matrix. This example is revealing and important, leading toward Chapter 6. Permutations and Cofactors 2 by 2: \\(ad-bc\\) has \\(2!\\) terms with \\(\\pm\\) signs. \\(\\bm{n}\\) by \\(\\bm{n}\\): \\(\\bm{\\det A}\\) adds \\(\\bm{n!}\\) with \\(\\bm{\\pm}\\) signs. For \\(n=3\\), \\(\\det A\\) adds \\(3!=6\\) terms. Two terms are \\(+a_{12}a_{23}a_{31}\\) and \\(-a_{13}a_{22}a_{31}\\). That minus sign came because the column order 3, 2, 1 needs one exchange to recover 1, 2, 3. The six terms include \\(+a_{11}a_{22}a_{33}-a_{11}a_{23}a_{32}=a_{11}(\\bm{a_{22}a_{33}-a_{23}a_{32}})=a_{11}(\\textbf{cofactor }\\bm{C_{11}})\\). Always \\(\\det A=a_{11}C_{11}+a_{12}C_{12}+\\cdots+a_{1n}C_{1n}\\). Cofactors are determinants of size \\(n-1\\). 1 + Each cofactor includes its correct sign, the submatrix \\(M_{ij}\\) throws out row \\(i\\) and column \\(j\\): 2 $$ C_{ij}=(-1)^{i+j}\\det M_{ij} $$ &dagger; WORKED EXAMPLES &dagger; 5.2 A&emsp;A Hessenberg matrix is a triangular matrix with one extra diagonal. Use cofactors of row 1 to show that the 4 by 4 determinant satisfies Fibonacci's rule \\(|H_4|=|H_3|+|H_2|\\). The same rule will continue for all sizes, \\(|H_n|=|H_{n-1}|+|H_{n-2}|\\). Which Fibonacci number is \\(|H_n|\\)? $$ H_2=\\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix} \\qquad H_3=\\begin{bmatrix} 2 & 1 & \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{bmatrix} \\qquad H_4= \\begin{bmatrix} 2 & 1 & & \\\\ \\bm{1} & 2 & \\bm{1} & \\\\ \\bm{1} & 1 & \\bm{2} & \\bm{1} \\\\ \\bm{1} & 1 & \\bm{1} & \\bm{2} \\end{bmatrix} $$ Solution&emsp;The cofactor \\(C_{11}\\) for \\(H_4\\) is the determinant \\(|H_3|\\). We also need \\(C_{12}\\) (in boldface): $$ C_{12}=- \\begin{vmatrix} \\bm{1} & \\bm{1} & \\bm{0} \\\\ \\bm{1} & \\bm{2} & \\bm{1} \\\\ \\bm{1} & \\bm{1} & \\bm{2} \\end{vmatrix} =- \\begin{vmatrix} 2 & 1 & 0 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{vmatrix} + \\begin{vmatrix} 1 & 0 & 0 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{vmatrix} $$ Rows 2 and 3 stayed the same and we used linearity in row 1. The two determinants on the right are \\(-|H_3|\\) and \\(+|H_2|\\). Then the 4 by 4 determinant is $$ |H_4|=2C_{11}+1C_{12}=2|H_3|-|H_3|+|H_2|=|H_3|+|H_2|. $$ The actual numbers are \\(|H_2|=3\\) and \\(|H_3|=5\\) (and of course \\(|H_1|=2\\)). Since \\(|H_n|=2,3,5,8,\\ldots\\) follows Fibonacci's rule \\(|H_{n-1}|+|H_{n-2}|\\), it must be \\(|H_n|=F_{n+2}\\). 5.2 B&emsp;These questions use the \\(\\pm\\) signs (even and odd \\(P\\)'s) in the big formula for \\(\\det A\\): &emsp;&ensp;1.&ensp; If \\(A\\) is 10 by 10 all-ones matrix, how does the big formula give \\(\\det A=0\\)? &emsp;&ensp;2.&ensp; If you multiply all \\(n!\\) permutations together into a single \\(P\\), is \\(P\\) odd or even? &emsp;&ensp;3.&ensp; If you multiply each \\(a_{ij}\\) by the fraction \\(i/j\\), why is \\(\\det A\\) unchanged? Solution&emsp;In Question 1, with all \\(a_{ij}=1\\), all the products in the big formula (8) will be 1. Half of them come with a plus sign, and half with minus. So they cancel to leave \\(\\det A=0\\). (Of course the all-ones matrix is singular. I am assuming \\(n\\gt 1\\).) &dagger; BIG FORMULA &dagger; $$ \\tag{8} \\begin{alignedat}{1} \\det A & =\\text{sum over all $\\bm{n}!$ column permutations $P=(\\alpha,\\beta,\\ldots,\\omega)$} \\\\ & = \\sum(\\det P)a_{1\\alpha}a_{2\\beta}\\cdots a_{n\\omega}=\\textbf{BIG FORMULA}. \\end{alignedat} $$ e.g. 3 by 3 matrix \\(A=\\): $$ \\begin{alignedat}{1} \\det A= & a_{11}a_{22}a_{33}\\begin{bmatrix} 1 & & \\\\ & 1 & \\\\ & & 1 \\end{bmatrix} +a_{12}a_{23}a_{31}\\begin{bmatrix} & 1 & \\\\ & & 1 \\\\ 1 & & \\end{bmatrix} +a_{13}a_{21}a_{32}\\begin{bmatrix} & & 1 \\\\ 1 & & \\\\ & 1 & \\end{bmatrix} \\\\ & +a_{11}a_{23}a_{32}\\begin{bmatrix} 1 & & \\\\ & & 1 \\\\ & 1 & \\end{bmatrix} +a_{12}a_{21}a_{33}\\begin{bmatrix} & 1 & \\\\ 1 & & \\\\ & & 1 \\end{bmatrix} +a_{13}a_{22}a_{31}\\begin{bmatrix} & & 1 \\\\ & 1 & \\\\ 1 & & \\end{bmatrix} . \\end{alignedat} $$ &emsp;&ensp;In Question 2, multiplying \\(\\left[\\begin{smallmatrix} 1 & 0 \\\\ 0 & 1 \\end{smallmatrix}\\right]\\left[\\begin{smallmatrix} 0 & 1 \\\\ 1 & 0 \\end{smallmatrix}\\right]\\) gives an odd permutation. Also for 3 by 3, the three odd permutations multiply (in any order) to give odd. But for \\(n\\gt 3\\) the product of all permutations will be even. There are \\(n!/2\\) odd permutations and that is an even number as soon as \\(n!\\) includes the factor 4. &emsp;&ensp;In Question 3, each \\(a_{ij}\\) is multiplied by \\(i/j\\). So each product \\(a_{1\\alpha}a_{2\\beta}\\cdots a_{n\\omega}\\) in the big formula is multiplied by all the row numbers \\(i=1,2,\\ldots,n\\) and divided by all the column numbers \\(j=1,2,\\ldots,n\\). (The columns come in some permuted order!) Then each product is unchanged and \\(\\det A\\) stays the same. &emsp;&ensp;Another approach to Question 3: We are multiplying the matrix \\(A\\) by the diagonal matrix \\(D=\\textbf{\\textsf{diag(1 : n)}}\\) when row \\(i\\) is multiplied by \\(i\\). And we are postmultiplying by \\(D^{-1}\\) when column \\(j\\) is divided by \\(j\\). The determinant of \\(DAD^{-1}\\) is the same as \\(\\det A\\) by the product rule. Cramer’s Rule, Inverses, and Volumes \\(A^{-1}\\) equals \\(C^\\mathrm{T}/\\det A\\). Then \\((A^{-1})_{ij}=\\text{cofactor $\\bm{C_{ji}}$ divided by the determinant of $A$}\\). &dagger; WHY &dagger; By using Cramer's Rule to solve \\(A\\bm{x}=(1,0,0)\\) (to find column 1 of \\(A^{-1}\\)), we will see the determinant of each \\(B_j\\) is a cofactor of \\(A\\) $$ \\begin{array}{l} B_j=\\text{$A$ with column $j$ changed to $\\bm{b}$} \\\\ B_1=\\begin{vmatrix} \\bm{1} & a_{12} & a_{13} \\\\ \\bm{0} & a_{22} & a_{23} \\\\ \\bm{0} & a_{32} & a_{33} \\end{vmatrix}=a_{22}a_{33}-a_{23}a_{32}=C_{11} \\rarr (A^{-1})_{11}=x_1=\\dfrac{C_{11}}{\\det A} \\\\\\\\ B_2=\\begin{vmatrix} a_{11} & \\bm{1} & a_{13} \\\\ a_{21} & \\bm{0} & a_{23} \\\\ a_{31} & \\bm{0} & a_{33} \\end{vmatrix}=a_{23}a_{31}-a_{21}a_{33}=C_{12} \\rarr (A^{-1})_{21}=x_2=\\dfrac{C_{12}}{\\det A} \\\\\\\\ B_3=\\begin{vmatrix} a_{11} & a_{12} & \\bm{1} \\\\ a_{21} & a_{22} & \\bm{0} \\\\ a_{31} & a_{32} & \\bm{0} \\end{vmatrix}=a_{21}a_{32}-a_{22}a_{31}=C_{13} \\rarr (A^{-1})_{31}=x_3=\\dfrac{C_{13}}{\\det A} \\end{array} $$ For \\(A\\bm{y}=(0,1,0)\\) it goes to \\((A^{-1})_{12}=y_1=\\dfrac{C_{21}}{\\det A}\\), \\((A^{-1})_{22}=y_2=\\dfrac{C_{22}}{\\det A}\\), \\((A^{-1})_{32}=y_3=\\dfrac{C_{23}}{\\det A}\\). Then \\((A^{-1})_{ij}=\\dfrac{C_{ji}}{\\det A}\\) Direct proof of the formula \\(A^{-1}=C^\\mathrm{T}/\\det A\\). This means \\(AC^\\mathrm{T}=(\\det A)I\\): $$ \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\\\ a_{31} & a_{32} & a_{33} \\end{bmatrix} \\begin{bmatrix} C_{11} & C_{21} & C_{31} \\\\ C_{12} & C_{22} & C_{32} \\\\ C_{13} & C_{23} & C_{33} \\end{bmatrix} = \\begin{bmatrix} \\det A & 0 & 0 \\\\ 0 & \\det A & 0 \\\\ 0 & 0 & \\det A \\end{bmatrix} . $$ How to explain the zeros off the main diagonal? When the rows of \\(A\\) multiplying cofactors from different rows, restore the equation to its matrix form, you will see two lines of this matrix are same, thus the determinant is zero. For example: $$ \\begin{alignedat}{1} (AC^\\mathrm{T})_{21}=(\\text{Row 2 of $A$})(\\text{Column 1 of $C^\\mathrm{T}$}) & =a_{21}C_{11}+a_{22}C_{12}+a_{23}C_{13} \\\\ & =\\begin{vmatrix} \\bm{a_{21}} & \\bm{a_{22}} & \\bm{a_{23}} \\\\ a_{21} & a_{22} & a_{23} \\\\ a_{31} & a_{32} & a_{33} \\end{vmatrix} =0 \\end{alignedat} $$ Cramer’s Rule computes \\(\\bm{x}=A^{-1}\\bm{b}\\) from \\(x_j=\\det(\\text{$A$ with column $j$ changed to $\\bm{b}$})/\\det A\\). &dagger; WHY &dagger; Replacing the first column of \\(I\\) by \\(\\bm{x}\\) gives a matrix with determinant \\(x_1\\). When multiply it by \\(A\\), the first column becomes \\(A\\bm{x}\\) which is \\(\\bm{b}\\). The other columns of \\(B_1\\) are copied from \\(A\\): $$ \\begin{alignedat}{2} \\textbf{Key idea}\\quad A \\begin{bmatrix} x_1 & 0 & 0 \\\\ x_2 & 1 & 0 \\\\ x_3 & 0 & 1 \\end{bmatrix} = \\begin{bmatrix} & & \\\\ \\bm{b} & \\bm{a}_2 & \\bm{a}_3 \\\\ & & \\end{bmatrix} =B_1 & \\rarr(\\det A)\\det\\begin{bmatrix} x_1 & 0 & 0 \\\\ x_2 & 1 & 0 \\\\ x_3 & 0 & 1 \\end{bmatrix}=\\det B_1 \\\\ & \\rarr(\\det A)x_1=\\det B_1 \\\\ & \\rarr x_1=\\frac{\\det B_1}{\\det A} \\end{alignedat} $$ To find \\(x_2\\) and \\(B_2\\), put the vectors \\(\\bm{x}\\) and \\(\\bm{b}\\) into the second columns of \\(I\\) and \\(A\\): $$ \\begin{alignedat}{2} \\textbf{Same idea}\\quad A \\begin{bmatrix} 1 & x_1 & 0 \\\\ 0 & x_2 & 0 \\\\ 0 & x_3 & 1 \\end{bmatrix} = \\begin{bmatrix} & & \\\\ \\bm{a}_1 & \\bm{b} & \\bm{a}_3 \\\\ & & \\end{bmatrix} =B_2 & \\rarr(\\det A)\\det\\begin{bmatrix} 1 & x_1 & 0 \\\\ 0 & x_2 & 0 \\\\ 0 & x_3 & 1 \\end{bmatrix}=\\det B_2 \\\\ & \\rarr(\\det A)x_2=\\det B_2 \\\\ & \\rarr x_2=\\frac{\\det B_2}{\\det A} \\end{alignedat} $$ Area of parallelogram \\(=|ad-bc|\\) if the four corners are \\((0,0)\\), \\((a,b)\\), \\((c,d)\\), and \\((a+c,b+d)\\). Volume of box \\(=|\\det A|\\) if the rows of \\(A\\) (or the columns of \\(A\\)) give the sides of the box. The cross product \\(\\bm{w}=\\bm{u}\\times\\bm{v}\\) is \\(\\det\\begin{bmatrix} \\bm{i} &amp; \\bm{j} &amp; \\bm{k} \\\\ u_1 &amp; u_2 &amp; u_3 \\\\ v_1 &amp; v_2 &amp; v_3 \\end{bmatrix}\\). \\(\\begin{array}{l} \\text{Notice $\\bm{v}\\times\\bm{u}=-(\\bm{u}\\times\\bm{v})$.} \\\\ \\text{$w_1$, $w_2$, $w_3$ are cofactors of row 1.} \\\\ \\text{Notice $\\bm{w}^\\mathrm{T}\\bm{u}=0$ and $\\bm{w}^\\mathrm{T}\\bm{v}=0$.} \\end{array}\\) &dagger; WORKED EXAMPLES &dagger; 5.3 A&emsp;If \\(A\\) is singular, the equation \\(AC^\\mathrm{T}=(\\det A)I\\) becomes \\(\\bm{AC^\\mathrm{T}}=\\textbf{zero matrix}\\). Then each column of \\(C^\\mathrm{T}\\) is in the nullspace of \\(A\\). Those columns contain cofactors along rows of \\(A\\). So the cofactors quickly find the nullspace for a 3 by 3 matrix of rank 2. My apologies that this comes so late! &emsp;&ensp;Solve \\(A\\bm{x}=\\bm{0}\\) by \\(\\bm{x}=\\text{cofactors along the row}\\), for these singular matrices of rank 2: $$ \\begin{array}{c} \\textbf{Cofactors} \\\\ \\textbf{give} \\\\ \\textbf{nullspace} \\end{array} \\qquad A=\\begin{bmatrix} 1 & 4 & 7 \\\\ 2 & 3 & 9 \\\\ 2 & 2 & 8 \\end{bmatrix} \\qquad A=\\begin{bmatrix} 1 & 1 & 2 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{bmatrix} $$ Solution&emsp;The first matrix has these cofactors along its top row (note each minus sign): $$ \\begin{vmatrix} 3 & 9 \\\\ 2 & 8 \\end{vmatrix}=6\\qquad -\\begin{vmatrix} 2 & 9 \\\\ 2 & 8 \\end{vmatrix}=2\\qquad \\begin{vmatrix} 2 & 3 \\\\ 2 & 2 \\end{vmatrix}=-2 $$ Then \\(\\bm{x}=(6,2,-2\\) solves \\(A\\bm{x}=\\bm{0}\\). The cofactors along the second row are \\((-18,-6,6)\\) which is just \\(-3\\bm{x}\\). This is also in the one-dimensional nullspace of \\(A\\). &emsp;&ensp;The second matrix has zero cofactors along its first row. The nullvector \\(\\bm{x}=(0,0,0)\\) is not interesting. The cofactors of row 2 give \\(\\bm{x}=(1,-1,0)\\) which solves \\(A\\bm{x}=\\bm{0}\\). &emsp;&ensp;Every \\(n\\) by \\(n\\) matrix of rank \\(n-1\\) has at least one nonzero cofactor by Problem 3.3.12. But for rank \\(n-2\\), all cofactors are zero and we only find \\(\\bm{x}=\\bm{0}\\). 5.3 B&emsp;Use Cramer's Rule with ratios \\(\\det B_j/\\det A\\) to solve \\(A\\bm{x}=\\bm{b}\\). Also find the inverse matrix \\(A^{-1}=C^\\mathrm{T}/\\det A\\). For this \\(\\bm{b}=(0,0,1\\) the solution \\(\\bm{x}\\) is column 3 of \\(A^{-1}\\)! Which cofactors are involved in computing that column \\(\\bm{x}=(x,y,z)\\)? $$ \\textbf{Column 3 of $A^{-1}$}\\qquad \\begin{bmatrix} 2 & 6 & 2 \\\\ 1 & 4 & 2 \\\\ 5 & 9 & 0 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix} . $$ Find the volumes of two boxes: edges are columns of \\(A\\) and edges are rows of \\(A^{-1}\\). Solution&emsp;The determinants of the \\(B_j\\) (with right side \\(\\bm{b}\\)) placed in column \\(j\\)) are $$ |B_1|=\\begin{vmatrix} \\bm{0} & 6 & 2 \\\\ \\bm{0} & 4 & 2 \\\\ \\bm{1} & 9 & 0 \\end{vmatrix}=4\\qquad |B_2|=\\begin{vmatrix} 2 & \\bm{0} & 2 \\\\ 1 & \\bm{0} & 2 \\\\ 5 & \\bm{1} & 0 \\end{vmatrix}=-2\\qquad |B_3|=\\begin{vmatrix} 2 & 6 & \\bm{0} \\\\ 1 & 4 & \\bm{0} \\\\ 5 & 9 & \\bm{1} \\end{vmatrix}=2 . $$ Those are cofactors \\(C_{31}\\), \\(C_{32}\\), \\(C_{33}\\) of row 3. Their dot product with row 3 is \\(\\det A=2\\): $$ \\det A=a_{31}C_{31}+a_{32}C_{32}+a_{33}C_{33}=(5,9,0)\\cdot(4,-2,2)=2. $$ The three ratios \\(\\det B_j/\\det A\\) give the three components of \\(\\bm{x}=(2,-1,1)\\). This \\(\\bm{x}\\) is the third column of \\(A^{-1}\\) because \\(\\bm{b}=(0,0,1)\\) is the third column of \\(I\\). The cofactors along the other rows of \\(A\\), divided by \\(\\det A\\), give the other columns of \\(A^{-1}\\): $$ A^{-1}=\\frac{C^\\mathrm{T}}{\\det A}=\\frac{1}{2}\\begin{bmatrix*}[r] -18 & 18 & 4 \\\\ 10 & -10 & -2 \\\\ -11 & 12 & 2 \\end{bmatrix*} \\text{. Multiply to check }AA^{-1}=I $$ The box from the columns of \\(A\\) has \\(\\text{volume}=\\det A=2\\). The box from the rows also has volume 2, since \\(|A^{T}|=|A|\\). The box from the rows of \\(A^{-1}\\) has volume \\(1/|A|=\\frac{1}{2}\\). Chapter 6 Eigenvalues and Eigenvectors Introduction to Eigenvalues An eigenvector \\(\\bm{x}\\) lies along the same line as \\(A\\bm{x}\\): \\(\\boxed{A\\bm{x}=\\lambda\\bm{x}}\\). The eigenvalue is \\(\\lambda\\). If \\(A\\bm{x}=\\lambda\\bm{x}\\) then \\(A^2\\bm{x}=\\lambda^2\\bm{x}\\) and \\(A^{-1}\\bm{x}=\\lambda^{-1}\\bm{x}\\) and \\((A+cI)\\bm{x}=(\\lambda+c)\\bm{x}\\): the same \\(\\bm{x}\\). If \\(A\\bm{x}=\\lambda\\bm{x}\\) then \\((A-\\lambda I)\\bm{x}=\\bm{x}\\) and \\(A-\\lambda I\\) is singular and \\(\\boxed{\\bm{\\det(A-\\lambda I)=0}}\\). \\(n\\) eigenvalues. 1 + Solve \\(\\det(A-\\lambda I)=0\\) to find \\(n\\) eigenvalues. 2 + Then for each eigenvalue \\(\\lambda\\) solve \\((A-\\lambda I)\\bm{x}=\\bm{0}\\) or \\(A\\bm{x}=\\lambda\\bm{x}\\) to find an eigenvector \\(\\bm{x}\\). 2 + All other vector are combinations of the \\(n\\) eigenvectors. Thus \\(A\\bm{y}=A(c_1\\bm{x}_1+c_2\\bm{x}_2+\\cdots+c_n\\bm{x}_n)=c_1\\lambda_1\\bm{x}_1+c_2\\lambda_2\\bm{x}_2+\\cdots+c_n\\lambda_n\\bm{x}_n\\) 2 + We must add a warning. Some 2 by 2 matrices have only one line of eigenvectors. This can only happen when two eigenvalues are equal. (On the other hand \\(A=I\\) has equal eigenvalues and plenty of eigenvectors.) Without a full set of eigenvectors, we don't have a basis to write every \\(\\bm{v}\\) as a combination of eigenvectors. In the language of the next section, we can't diagonalize a matrix without \\(n\\) independent eigenvectors. &dagger; WHY (Independent \\(\\bm{x}\\) from different \\(\\lambda\\)) &dagger; Suppose \\(c_1\\bm{x}_1+\\cdots+c_n\\bm{x}_n=\\bm{0}\\). Multiply by \\(A\\) to find \\(c_1\\lambda_1\\bm{x}_1+\\cdots+c_n\\lambda_n\\bm{x}_n=\\bm{0}\\). Multiply by \\(\\lambda_n\\) to find \\(c_1\\lambda_n\\bm{x}_1+\\cdots+c_n\\lambda_n\\bm{x}_n=\\bm{0}\\). Now subtract one from the other: $$ \\tag{1} \\text{Subtraction leaves }(\\lambda_1-\\lambda_n)c_1\\bm{x}_1+\\cdots+(\\lambda_{n-1}-\\lambda_n)c_{n-1}\\bm{x}_{n-1}=\\bm{0} $$ \\(\\bm{x}_n\\) is gone. Now from (1) multiply by \\(A\\) and by \\(\\lambda_{j-1}\\) and subtract: $$ \\begin{array}{rl} \\text{$A\\cdot$(1)} & (\\lambda_1-\\lambda_n)c_1\\lambda_1\\bm{x}_1+\\cdots+(\\lambda_{n-1}-\\lambda_n)c_{n-1}\\lambda_{n-1}\\bm{x}_{n-1}=\\bm{0} \\\\ \\text{$\\lambda_{n-1}\\cdot$(1)} & (\\lambda_1-\\lambda_n)c_1\\lambda_{n-1}\\bm{x}_1+\\cdots+(\\lambda_{n-1}-\\lambda_n)c_{n-1}\\lambda_{n-1}\\bm{x}_{n-1}=\\bm{0} \\\\ \\text{Subtraction leaves} & (\\lambda_1-\\lambda_{n-1})(\\lambda_1-\\lambda_n)c_1\\bm{x}_1+\\cdots+(\\lambda_{n-2}-\\lambda_{n-1})(\\lambda_{n-2}-\\lambda_n)c_{n-2}\\bm{x}_{n-2}=\\bm{0} \\end{array} $$ This removes \\(\\bm{x}_{n-1}\\). Repeat the steps above and eventually only \\(x_1\\) is left: $$ \\text{We reach $(\\lambda_1-\\lambda_2)\\cdots(\\lambda_1-\\lambda_n)c_1\\bm{x}_1=\\bm{0}$ which forces $c_1=0$.} $$ Since the \\(\\lambda\\)'s are different and \\(\\bm{x}_1\\neq\\bm{0}\\), we are forced to the conclusion that \\(c_1=0\\). Then from \\(c_2\\bm{x}_2+\\cdots+c_n\\bm{x}_n=\\bm{0}\\) we can proof \\(c_2=0\\) and eventually all the \\(c\\)'s equal to zero. When the \\(\\lambda\\)'s are all different, the eigenvectors are independent. Check \\(\\lambda\\)'s by \\(\\det A=(\\lambda_1)(\\lambda_2)\\cdots(\\lambda_n)\\) and diagonal sum \\(a_{11}+a_{22}+\\cdots+a_{nn}=\\text{sum of $\\lambda$'s}\\). Projections have \\(\\lambda=1\\) and \\(0\\). Reflections have \\(1\\) and \\(-1\\). Rotations have \\(e^{i\\theta}\\) and \\(e^{-i\\theta}\\): complex! &dagger; WHY &dagger; For a two-dimensionl rotation matrix \\(R=\\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix}\\), solve \\(\\det(R-\\lambda I)=0\\): $$ \\begin{alignedat}{1} \\det(R-\\lambda I)=0 & \\harr(\\cos\\theta-\\lambda)^2+\\sin^2\\theta=0 \\\\ & \\harr(\\cos\\theta-\\lambda)^2=-\\sin^2\\theta \\\\ & \\harr\\cos\\theta-\\lambda=\\pm(i\\sin\\theta) \\\\ & \\harr\\lambda=\\cos\\theta\\pm i\\sin\\theta=e^{\\pm i\\theta} \\end{alignedat} $$ Last stage comes from Euler's formula \\(e^{ix}=\\cos x+i\\sin x\\) and \\(e^{-ix}=e^{i(-x)}=\\cos(-x)+i\\sin(-x)=\\cos x-i\\sin x\\) &dagger; WORKED EXAMPLES &dagger; 6.1 A&emsp;Find the eigenvalues and eigenvectors of \\(A\\) and \\(A^2\\) and \\(A^{-1}\\) and \\(A+4I\\): $$ A=\\begin{bmatrix*}[r] 2 & -1 \\\\ -1 & 2 \\end{bmatrix*} \\quad\\text{and}\\quad A^2=\\begin{bmatrix*}[r] 5 & -4 \\\\ -4 & 5 \\end{bmatrix*} . $$ Check the trace \\(\\lambda_1+\\lambda_2=4\\) and the determinant \\(\\lambda_1lambda_2=3\\). Solution&emsp;The eigenvalues of \\(A\\) come from \\(\\det(A-\\lambda I=0)\\): $$ A=\\begin{bmatrix} 2 & -1 \\\\ -1 & 2 \\end{bmatrix} \\qquad \\det(A-\\lambda I)=\\begin{vmatrix} \\bm{2-\\lambda} & \\bm{-1} \\\\ \\bm{-1} & \\bm{2-\\lambda} \\end{vmatrix}=\\lambda^2-4\\lambda+3=0 $$ This factors into \\((\\lambda-1)(\\lambda-3)=0\\) so the eigenvalues of \\(A\\) are \\(\\lambda_1=\\bm{1}\\) and \\(\\lambda_2=\\bm{3}\\). For the trace, the sum \\(2+2\\) agrees with \\(1+3\\). The determinant \\(3\\) agrees with the product \\(\\lambda_1\\lambda_2\\). &emsp;&ensp;The eigenvectors come separately by solving \\((A-\\lambda I)\\bm{x}=\\bm{0}\\) which is \\(A\\bm{x}=\\lambda\\bm{x}\\): $$ \\begin{array}{c} \\bm{\\lambda=1}\\text{:}\\quad(A-I)\\bm{x}=\\begin{bmatrix*}[r] 1 & -1 \\\\ -1 & 1 \\end{bmatrix*}\\begin{bmatrix} x \\\\ y \\end{bmatrix}=\\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\\text{ gives the eigenvector }\\bm{x}_1=\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\\\\\\\ \\bm{\\lambda=3}\\text{:}\\quad(A-3I)\\bm{x}=\\begin{bmatrix*}[r] -1 & -1 \\\\ -1 & -1 \\end{bmatrix*}\\begin{bmatrix} x \\\\ y \\end{bmatrix}=\\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\\text{ gives the eigenvector }\\bm{x}_2=\\begin{bmatrix*}[r] 1 \\\\ -1 \\end{bmatrix*} \\end{array} $$ \\(A^2\\) and \\(A^{-1}\\) and \\(A+4I\\) keep the same eigenvectors as \\(A\\). Their eigenvalues are \\(\\lambda^2\\) and \\(\\lambda^{-1}\\) and \\(\\lambda+4\\): $$ \\textcolor{RoyalBlue}{\\text{ $A^2$ has eigenvalues $1^2=1$ and $3^2=9\\quad A^{-1}$ has $\\dfrac{1}{1}$ and $\\dfrac{1}{3}\\quad A+4I$ has $\\begin{array}{l} 1+4=5 \\\\ 3+4=7 \\end{array}$ }} $$ Notes for later sections: \\(A\\) has orthogonal eigenvectors (Section 6.4 on symmetric matrices). \\(A\\) can be diagonalized since \\(\\lambda_1\\neq\\lambda_2\\) (Section 6.2). \\(A\\) is similar to any 2 by 2 matrix with eigenvalues \\(1\\) and \\(3\\) (Section 6.2). \\(A\\) is a positive definite matrix (Section 6.5) since \\(A=A^\\mathrm{T}\\) and the \\(\\lambda\\)'s are positive. 6.1 B&emsp;How can you estimate the eigenvalues of any \\(\\bm{A}\\)? Gershgorin gave this answer. Every eigenvalue of \\(A\\) must be &ldquo;near&rdquo; at least one of the entries \\(a_{ii}\\) on the main diagonal. For \\(\\lambda\\) to be &ldquo;near \\(a_{ii}\\)&rdquo; means that \\(\\|a_{ii}-\\lambda\\|\\) is no more than the sum \\(\\bm{R_i}\\) of all other \\(\\bm{|a_{ij}|}\\) in that row \\(i\\) of the matrix. Then \\(R_i=\\sum_{j\\neq i}|a_{ij}|\\) is the radius of a circle centered at \\(a_{ii}\\). Every \\(\\bm{\\lambda}\\) is in the circle around one or more diagonal entrices \\(\\bm{a_{ii}}\\): \\(\\bm{|a_{ii}-\\lambda|\\leq R_i}\\). &emsp;&ensp;Here is the reasoning. If \\(\\lambda\\) is an eigenvalue, then \\(A-\\lambda I\\) is not invertible. Then \\(A-\\lambda I\\) cannot be diagonally dominant (see Section 2.5). So at least one diagonal entry \\(a_{ii}-\\lambda\\) is not larger than the sum \\(R_i\\) of all other entries \\(|a_{ij}|\\) (we take absolute values!) in row \\(i\\). &dagger; Diagonally dominant &dagger; Diagonally dominant matrices are invertible. Each \\(a_{ii}\\) on the diagonal is larger than the total sum along the rest of row \\(i\\). On every row, $$ |a_{ii}|\\gt\\sum_{j\\neq i}|a_{ij}| \\quad\\text{means that}\\quad |a_{ii}|\\ge|a_{i1}|+\\cdots(\\text{skip }|a_{ii}|)\\cdots+|a_{in}| . $$ Reasoning.&emsp;&ensp;Take any nonzero vector \\(\\bm{x}\\). Suppose its largest component is \\(|x_i|\\). Then \\(A\\bm{x}=\\bm{0}\\) is impossible, because row \\(i\\) of \\(A\\bm{x}=\\bm{0}\\) would need $$ a_{i1}x_1+\\cdots+a_{ii}x_i+\\cdots+a_{in}x_n=0 . $$ Those can't add to zero when \\(A\\) is diagonally dominant! The size of \\(a_{ii}x_{i}\\) (that one particular term) is greater than all the other terms combined: $$ \\textbf{All }\\bm{|x_j|\\leq|x_i|\\quad\\sum_{j\\neq i}|a_{ij}x_j|\\leq\\sum_{j\\neq i}|a_{ij}||x_i|\\lt|a_{ii}||x_i|}\\textbf{ because $\\bm{a_{ii}}$ dominates} $$ Example 1.&emsp;&ensp;Every eigenvalue \\(\\lambda\\) of this \\(A\\) falls into one or both of the Gershgorin circles: The centers are \\(a\\) and \\(d\\), the radii are \\(R_1=|b|\\) and \\(R_2=|c|\\). $$ A=\\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}\\qquad \\begin{array}{ll} \\text{First circle:} & |\\lambda-a|\\leq|b| \\\\ \\text{Second circle:} & |\\lambda-d|\\leq|c| \\end{array} $$ Those are circles in the complex plane, since \\(\\lambda\\) could certaubky be complex. Example 2.&emsp;&ensp;All eigenvalues of this \\(A\\) lie in a circle of radius \\(R=3\\) around one or more of the diagonal entries \\(d_1\\), \\(d_2\\), \\(d_3\\): $$ A=\\begin{bmatrix} d_1 & 1 & 2 \\\\ 2 & d_2 & 1 \\\\ -1 & 2 & d_3 \\end{bmatrix}\\qquad \\begin{array}{l} |\\lambda-d_1|\\leq 1+2=R_1 \\\\ |\\lambda-d_2|\\leq 2+1=R_2 \\\\ |\\lambda-d_3|\\leq 1+2=R_3 \\end{array} $$ You see that &ldquo;near&rdquo; means not more than 3 away from \\(d_1\\) or \\(d_2\\) or \\(d_3\\), for this example. 6.1 C&emsp;Find the eigenvalues and eigenvectors of this symmetric 3 by 3 matrix \\(S\\): $$ \\textcolor{RoyalBlue}{\\begin{array}{l} \\textbf{Symmetric matrix} \\\\ \\textbf{Singular matrix} \\\\ \\textbf{Trace $1+2+1=4$} \\end{array}} \\qquad S=\\begin{bmatrix*}[r] 1 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 1 \\end{bmatrix*} $$ Solution&emsp;Since all rows of \\(S\\) add to zero, the vector \\(\\bm{x}=(1,1,1)\\) gives \\(S\\bm{x}=\\bm{0}\\). This is an eigenvector for \\(\\lambda=0\\). To find \\(\\lambda_2\\) and \\(\\lambda_3\\) I will compute the 3 by 3 determinant: $$ \\det(S-\\lambda I)= \\begin{vmatrix} 1-\\lambda & -1 & 0 \\\\ -1 & 2-\\lambda & -1 \\\\ 0 & -1 & 1-\\lambda \\end{vmatrix} \\begin{array}{l} =(1-\\lambda)(2-\\lambda)(1-\\lambda)-2(1-\\lambda) \\\\ =(1-\\lambda)[(2-\\lambda)(1-\\lambda)-2] \\\\ =(\\bm{1-\\lambda})(\\bm{-\\lambda})(\\bm{3-\\lambda}) \\end{array} $$ Those three factors give \\(\\lambda=0,1,3\\). Each eigenvalue corresponds to an eigenvector (or a line of eigenvectors): $$ \\bm{x}_1=\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\quad S\\bm{x}_1=\\bm{0x}_1\\qquad \\bm{x}_2=\\begin{bmatrix*}[r] 1 \\\\ 0 \\\\ -1 \\end{bmatrix*}\\quad S\\bm{x}_2=\\bm{1x}_2\\qquad \\bm{x}_3=\\begin{bmatrix*}[r] 1 \\\\ -2 \\\\ 1 \\end{bmatrix*}\\quad S\\bm{x}_3=\\bm{3x}_3 . $$ I notice again that eigenvectors are perpendicular when \\(S\\) is symmetric. We were lucky to find \\(\\lambda=0,1,3\\). For a larger matrix I would use \\(\\textbf{\\textsf{eig(A)}}\\), and never touch determinants. &emsp;&ensp;The full command \\([\\bm{X},\\bm{E}]=\\textbf{\\textsf{eig(A)}}\\) will produce unit eigenvectosrs in the columns of \\(X\\). Diagonalizing a Matrix The columns of \\(AX=X\\Lambda\\) are \\(A\\bm{x}_k=\\lambda_k\\bm{x}_k\\). The eigenvalue matrix \\(\\Lambda\\) is diagonal. \\(\\bm{n}\\) independent eigenvectors in \\(X\\) diagonalize \\(A\\): \\(\\boxed{\\bm{A=X\\Lambda X^{-1}}\\text{ and }\\bm{\\Lambda=X^{-1}AX}}\\). The eigenvector matrix \\(X\\) also diagonalizes all powers \\(A^k\\): \\(\\boxed{\\bm{A^k=X\\Lambda^kX^{-1}}}\\). Solve \\(\\bm{u}_{k+1}=A\\bm{u}_k\\) by \\(\\bm{u}_k=A^k\\bm{u}_0=X\\Lambda^kX^{-1}\\bm{u}_0=\\boxed{\\bm{c_1(\\lambda_1)^kx_1+\\cdots+c_n(\\lambda_n)^kx_n}}\\). &dagger; WHY &dagger; Write \\(\\bm{u}_0\\) as a combination \\(c_1\\bm{x}_1+\\cdots+c_n\\bm{x}_n=X\\bm{c}\\), then \\(\\bm{u}_k=A^k\\bm{u}_0=X\\Lambda^kX^{-1}\\bm{u}_0=X\\Lambda^kX^{-1}X\\bm{c}=(X\\Lambda^k)\\bm{c}=c_1(\\lambda_1)^k\\bm{x}_1+\\cdots+c_n(\\lambda_n)^k\\bm{x}_n\\) No equal eigenvalues ⇒ \\(X\\) is invertible and \\(A\\) can be diagonalized. Equal eigenvalues ⇒ \\(A\\) might have too few independent eigenvectors. Then \\(X^{-1}\\) fails. Every matrix \\(C=B^{-1}AB\\) has the same eigenvalues as \\(A\\). These \\(C\\)'s are “similar” to \\(A\\). &dagger; WHY &dagger; Suppose \\(A\\bm{x}=\\lambda\\bm{x}\\). Then \\(C=B^{-1}AB\\) has the same eigenvalue \\(\\lambda\\) with the new eigenvector \\(B^{-1}\\bm{x}\\): $$ \\textbf{Same $\\bm{\\lambda}\\quad C(B^{-1}\\bm{x})=(B^{-1}AB)(B^{-1}\\bm{x})=B^{-1}A\\bm{x}=B^{-1}\\lambda\\bm{x}=\\lambda(B^{-1}\\bm{x})$.} $$ &dagger; WORKED EXAMPLES &dagger; 6.2 A&emsp;The Lucas numbers are like the Fibonacci numbers except they start with \\(L_1=1\\) and \\(L_2=3\\). Using the same rule \\(L_{k+2}=L_{k+1}+L_k\\), the next Lucas numbers are \\(4\\), \\(7\\), \\(11\\) , \\(18\\). Show that the Lucas number \\(L_{100}\\) is \\(\\lambda_1^{100}+\\lambda_2^{100}\\). Solution&emsp;\\(\\bm{u}_{k+1}=\\left[\\begin{smallmatrix} 1 & 1 \\\\ 1 & 0 \\end{smallmatrix}\\right]\\) is the same as for Fibonacci, because \\(L_{k+2}=L_{k+1}+L_k\\) is the same rule (with different starting values). The equation becomes a 2 by 2 system: $$ \\colorbox{e8f1fe}{ Let \\colorbox{ffffff}{$u_k=\\begin{bmatrix} L_{k+1} \\\\ L_k \\end{bmatrix}$}. The rule $\\begin{array}{l} L_{k+2}=L_{k+1}+L_k \\\\ L_{k+1}=L_{k+1} \\end{array}$ is \\colorbox{ffffff}{$\\bm{u}_{k+1}=\\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}\\bm{u}_k$}. } $$ The eigenvalues and eigenvectors of \\(A=\\left[\\begin{smallmatrix} 1 & 1 \\\\ 1 & 0 \\end{smallmatrix}\\right]\\) still come from \\(\\lambda^2=\\lambda+1\\): $$ \\text{ $\\lambda_1=\\dfrac{1+\\sqrt{5}}{2}$\\quad and\\quad$\\bm{x}_1=\\begin{bmatrix} \\lambda_1 \\\\ 1 \\end{bmatrix}$\\qquad\\qquad $\\lambda_2=\\dfrac{1-\\sqrt{5}}{2}$\\quad and\\quad $\\bm{x}_2=\\begin{bmatrix} \\lambda_2 \\\\ 1 \\end{bmatrix}$. } $$ Now solve \\(c_1\\bm{x}_1+c_2\\bm{x}_2=\\bm{u}_1=(3,1)\\). The solution is \\(c_1=\\lambda_1\\) and \\(c_2=\\lambda_2\\). Check: $$ \\lambda_1\\bm{x}_1+\\lambda_2\\bm{x}_2 =\\begin{bmatrix} \\lambda_1^2+\\lambda_2^2 \\\\ \\lambda_1+\\lambda_2 \\end{bmatrix} =\\begin{bmatrix} \\text{trace of }A^2 \\\\ \\text{trace of }A \\end{bmatrix} =\\begin{bmatrix} 3 \\\\ 1 \\end{bmatrix} =\\bm{u}_1 $$ \\(\\bm{u}_{100}=A^{99}\\bm{u}_1\\) tells us the Lucas numbers \\((L_{101}, L_{100})\\). The second components of the eigenvectors \\(\\bm{x}_1\\) and \\(\\bm{x}_2\\) are \\(1\\), so the second component of \\(\\bm{u}_{100}\\) is the answer we want: $$ \\boxed{ \\textbf{Lucas number\\qquad$\\bm{L_{100}}=c_1\\lambda_1^{99}+c_2\\lambda_2^{99}=\\bm{\\lambda_1^{100}}+\\bm{\\lambda_2^{100}}$.} } $$ Lucas starts faster than Fibonacci, and ends up larger by a factor near \\(\\sqrt{5}\\). 6.2 B&emsp;Find the inverse and the eigenvalues and the determinant of this matrix \\(A\\): $$ A=5*\\textbf{\\textsf{eye(4)}}-\\textbf{\\textsf{ones(4)}}= \\begin{bmatrix*}[r] 4 & -1 & -1 & -1 \\\\ -1 & 4 & -1 & -1 \\\\ -1 & -1 & 4 & -1 \\\\ -1 & -1 & -1 & 4 \\end{bmatrix*} . $$ Describe an eigenvector matrix \\(X\\) that gives \\(X^{-1}AX=\\Lambda\\). Solution&emsp;What are the eigenvalues of the all-ones matrix? Its rank is certainly 1, so three eigenvalues are \\(\\lambda=0,0,0\\). Its trace is 4, so the other eigenvalue is \\(\\lambda=4\\). Subtract this all=ones matrix from \\(5I\\) to get our matrix \\(A\\): $$ \\textcolor{RoyalBlue}{\\textbf{Subtract the eigenvalues 4, 0, 0, 0 from 5, 5, 5, 5. The eigenvalues of $A$ are 1, 5, 5, 5.}} $$ The determinant of \\(A\\) is \\(125\\), the product of those four eigenvalues. The eigenvector for \\(\\lambda=1\\) is \\(\\bm{x}=(1,1,1,1)\\) or \\((c,c,c,c)\\). The other eigenvectors are perpendicular to \\(\\bm{x}\\) (since \\(A\\) is symmetric). The nicest eigenvector matrix \\(X\\) is the symmetric orthogonal Hadamard matrix \\(\\bm{H}\\). The factor \\(\\frac{1}{2}\\) produces unit column vectors. $$ \\textbf{Orthonormal eigenvectors}\\quad X=H=\\dfrac{1}{2} \\begin{bmatrix*}[r] 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 \\end{bmatrix*} =H^\\mathrm{T}=H^{-1} . $$ The eigenvalues of \\(A^{-1}\\) are \\(1\\), \\(\\frac{1}{5}\\), \\(\\frac{1}{5}\\), \\(\\frac{1}{5}\\). The eigenvectors are not changed so \\(A^{-1}=H\\Lambda^{-1}H^{-1}\\). The inverse matrix is surprisingly neat: $$ A^{-1}=\\dfrac{1}{5}*(\\textbf{\\textsf{eye}}(4)+\\textbf{\\textsf{ones}}(4))=\\dfrac{1}{5} \\begin{bmatrix} 2 & 1 & 1 & 1 \\\\ 1 & 2 & 1 & 1 \\\\ 1 & 1 & 2 & 1 \\\\ 1 & 1 & 1 & 2 \\end{bmatrix} $$ \\(A\\) is a rank-one change from \\(5I\\). So \\(A^{-1}\\) is a rank-one change from \\(I/5\\). &emsp;&ensp;In a graph with 5 nodes, the determinant \\(125\\) counts the &ldquo;spanning trees&rdquo; (trees that touch all nodes). Trees have no loops (graphs and trees are in Section 10.1). &emsp;&ensp;With 6 nodes, the matrix \\(6*\\textbf{\\textsf{eye(5)}}-\\textbf{\\textsf{ones(5)}}\\) has the five eigenvalues \\(1\\), \\(6\\), \\(6\\), \\(6\\), \\(6\\), \\(6\\). Systems of Differential Equations If \\(A\\bm{x}=\\lambda\\bm{x}\\) then \\(\\bm{u}(t)=e^{\\lambda t}\\bm{x}\\) will solve \\(\\dfrac{\\mathrm{d}\\bm{u}}{\\mathrm{d}t}=A\\bm{u}\\). Each \\(\\lambda\\) and \\(\\bm{x}\\) give a solution \\(e^{\\lambda t}\\bm{x}\\). &dagger; WHY &dagger; \\(\\bm{u}=e^{\\lambda t}\\bm{x}\\) is true in \\(\\dfrac{\\mathrm{d}\\bm{u}}{\\mathrm{d}t}=A\\bm{u}\\) if \\(A\\bm{x}=\\lambda\\bm{x}\\).: $$ \\begin{array}{ll} \\text{Left side: $\\bm{x}$ is a fixed vector so} & \\dfrac{\\mathrm{d}\\bm{u}}{\\mathrm{d}t}=\\bm{u}^\\prime=\\lambda e^{\\lambda t}\\bm{x} \\\\ \\text{Right side: $e^{\\lambda t}$ can be easily move aside} & A\\bm{u}=e^{\\lambda t}A\\bm{x}=\\lambda e^{\\lambda t}\\bm{x} \\end{array} $$ Both side are the same, therefore \\(\\bm{u}=e^{\\lambda t}\\bm{x}\\) satisfies the equation. The constants in complete solution \\(u(t)=c_1e^{\\lambda_1 t}\\bm{x}_1+\\cdots+c_ne^{\\lambda_n t}\\bm{x}_n\\) can be determined by starting vector \\(\\bm{u}(0)\\), as it eliminates the exponents: $$ \\bm{u}(0)=c_1e^{\\lambda_1\\cdot 0}\\bm{x}_1+\\cdots+c_ne^{\\lambda_n\\cdot 0}x_n=c_1\\bm{x}_1+\\cdots+c_n\\bm{x}_n $$ If \\(A=X\\Lambda X^{-1}\\) then \\(\\boxed{\\bm{u}(t)=e^{At}\\bm{u}(0)=Xe^{\\Lambda t}X^{-1}\\bm{u}(0)=c_1e^{\\lambda_1 t}\\bm{x}_1+\\cdots+c_ne^{\\lambda_n t}\\bm{x}_n}\\). &dagger; WHY &dagger; To prove \\(\\bm{u}(t)=e^{At}C\\) (\\(\\bm{u}\\) is \\(n\\) by \\(1\\) and \\(e^{At}\\) is \\(n\\) by \\(n\\) which is same as \\(A\\), \\(C\\) is \\(n\\) by \\(1\\)) satisfies the \\(\\dfrac{\\mathrm{d}\\bm{u}}{\\mathrm{d}t}=A\\bm{u}\\), we need some truth of \\(e^{At}\\): $$ \\begin{array}{ll} \\text{Seris definition:} & e^{At}=I+At+\\frac{1}{2}(At)^2+\\frac{1}{6}(At)^3+\\cdots \\\\ \\text{Its $t$ derivative:} & (e^{At})^\\prime=A+A^2t+\\frac{1}{2}A^3t^2+\\cdots=Ae^{At} \\end{array} $$ On the left \\(\\dfrac{\\mathrm{d}\\bm{u}}{\\mathrm{d}t}=\\bm{u}'=(e^{At}C)^\\prime=Ae^{At}C\\) which is equal to the right side \\(A\\bm{u}=Ae^{At}C\\). Q.E.D. Since \\(\\bm{u}(0)=e^{A\\cdot 0}C=IC=C\\), we can write \\(\\bm{u}(t)\\) as: $$ \\bm{u}(t)=e^{At}\\bm{u}(0) $$ If \\(A\\) is diagonalizable, \\(e^{At}\\) has the same eigenvector matrix \\(X\\) as \\(A\\): $$ \\begin{alignedat}{2} & \\textbf{Use the series} & e^{At} & =I+X\\Lambda X^{-1}t+\\frac{1}{2}(X\\Lambda^2X^{-1}t)+\\cdots \\\\ & \\textbf{Factor out $X$ and $X^{-1}$} & & =X[I+\\Lambda t+\\frac{1}{2}(\\Lambda t)^2+\\cdots]X^{-1} \\\\ & e^{At}\\textbf{ is diagonalized!} & & \\boxed{e^{At}=Xe^{\\Lambda t}X^{-1}} \\end{alignedat} $$ \\(e^{\\Lambda t}\\) is a diagonal matrix with \\(e^{\\lambda_i}t\\) on its diagonal: $$ \\begin{alignedat}{1} e^{\\Lambda t } & =I+\\Lambda t+\\frac{1}{2}(\\Lambda t)^2+\\cdots \\\\ & = \\begin{bmatrix} (1+\\lambda_1 t+\\frac{1}{2}(\\lambda_1 t)^2+\\cdots) & & \\\\ & \\ddots & \\\\ & & (1+\\lambda_n t+\\frac{1}{2}(\\lambda_n t)^2+\\cdots) \\end{bmatrix} \\\\ & = \\begin{bmatrix} e^{\\lambda_1 t} & & \\\\ & \\ddots & \\\\ & & e^{\\lambda_n t} \\end{bmatrix} \\end{alignedat} $$ \\(A\\) is diagonalizable also means we have \\(n\\) independent eigenvectors, then we can written \\(\\bm{u}(0)=c_1\\bm{x}_1+\\cdots+c_n\\bm{x}_n=X\\bm{c}\\). Recognize \\(\\bm{u}(t)\\): $$ \\begin{alignedat}{1} e^{At}\\bm{u}(0)=Xe^{\\Lambda t}X^{-1}X\\bm{c} & = \\begin{bmatrix} & & \\\\ \\bm{x}_1 & \\cdots & \\bm{x}_n \\\\ & & \\end{bmatrix} \\begin{bmatrix} e^{\\lambda_1 t} & & \\\\ & \\ddots & \\\\ & & e^{\\lambda_n t} \\end{bmatrix} \\begin{bmatrix} c_1 \\\\ \\vdots \\\\ c_n \\end{bmatrix} \\\\ & =c_1e^{\\lambda_1 t}\\bm{x}_1+\\cdots+c_ne^{\\lambda_n t}\\bm{x}_n \\end{alignedat} $$ \\(A\\) is stable and \\(\\bm{u}(t)\\rarr\\bm{0}\\) and \\(e^{At}\\rarr 0\\) when all eigenvalues of \\(A\\) have real part \\(\\lt 0\\). Matrix exponential \\(e^{At}=I+At+\\cdots+(At)^n/n!+\\cdots=Xe^{\\Lambda t}X^{-1}\\) if \\(A\\) is diagonalizable. \\(\\begin{array}{l} \\textbf{Second order equation} \\\\ \\textbf{First order system} \\end{array} u^{\\prime\\prime}+Bu^\\prime+Cu=0\\) is equivalent to \\(\\begin{bmatrix} u \\\\ u^\\prime \\end{bmatrix}^\\prime=\\begin{bmatrix*}[r] 0 &amp; 1 \\\\ -C &amp; -B \\end{bmatrix*}\\begin{bmatrix} u \\\\ u^\\prime \\end{bmatrix}\\). &dagger; WORKED EXAMPLES &dagger; 6.3 A&emsp;Solve \\(y^{\\prime\\prime}+4y^\\prime+3y=0\\) by substituting \\(e^{\\lambda t}\\) and also by linear algebra. Solution&emsp;Substituting \\(y=e^{\\lambda t}\\) yields \\((\\lambda^2+4\\lambda+3)e^{\\lambda t}=0\\). That quadratic factors into \\(\\lambda^2+4\\lambda+3=(\\lambda+1)(\\lambda+3)=0\\). Therefore \\(\\bm{\\lambda_1=-1}\\) and \\(\\bm{\\lambda_2=-3}\\). The pure solutions are \\(y_1=e^{-t}\\) and \\(y_2=e^{-3t}\\). The complete solution \\(\\bm{y}=c_1y_1+c_2y_2\\) approaches zero. &emsp;&ensp;To use linear algebra we set \\(\\bm{u}=(y,y^\\prime\\). Then the vector equation is \\(\\bm{u}^\\prime=A\\bm{u}\\): $$ \\begin{array}{l} \\mathrm{d}y/\\mathrm{d}t=y^\\prime \\\\ \\mathrm{d}y^\\prime/\\mathrm{d}t=-3y-4y^\\prime \\end{array} \\quad\\text{converts to}\\quad \\dfrac{\\mathrm{d}\\bm{u}}{\\mathrm{d}t}=\\begin{bmatrix*}[r] 0 & 1 \\\\ -3 & -4 \\end{bmatrix*}\\bm{u} . $$ This \\(A\\) is a &ldquo;companion matrix&rdquo; and its eigenvalues are again \\(-1\\) and \\(-3\\): $$ \\textbf{Same quadratic}\\qquad \\det(A-\\lambda I)=\\begin{vmatrix} -\\lambda & 1 \\\\ -3 & -4-\\lambda \\end{vmatrix}=\\lambda^2+4\\lambda+3=0 . $$ The eigenvectors of \\(A\\) are \\((1,\\lambda_1)\\) and \\((1,\\lambda_2)\\). Either way, the decay in \\(y(t)\\) comes from \\(e^{-t}\\) and \\(e^{-3t}\\). With constant coefficients, calculus leas to linear algebra \\(A\\bm{x}=\\lambda\\bm{x}\\). Note&emsp;In linear algebra the serious danger is a shortage of eigenvectors. Our eigenvectors \\((1,\\lambda_1)\\) and \\((1,\\lambda_2)\\) are the same if \\(\\lambda_1=\\lambda_2\\). Then we can't diagonalize \\(A\\). In this case we don't yet have two independent solutions to \\(\\mathrm{d}\\bm{u}/\\mathrm{d}t=A\\bm{u}\\). &emsp;&ensp;In differential equations the danger is also a repeated \\(\\lambda\\). After \\(y=e^{\\lambda t}\\), a second solution has to be found. It turns out to be \\(y=\\bm{te^{\\lambda t}}\\). This &ldquo;impure&rdquo; solution (with an extra \\(\\bm{t}\\)) appears in the matrix exponential \\(e^{At}\\). Example 4 showed how. &dagger; Example 4 &dagger; When you substitute \\(y=e^{\\lambda t}\\) into \\(y^{\\prime\\prime}-2y^\\prime+y=0\\), you get an equation with repeated roots: \\(\\lambda^2-2\\lambda+1=0\\) is \\((\\lambda-1)^2=0\\) with \\(\\bm{\\lambda=1,1}\\). A differential equations course would propose \\(e^t\\) and \\(te^t\\) as two independent solutions. Here we discover why. &emsp;&ensp;Linear algebra reduces \\(y^{\\prime\\prime}-2y^\\prime+y=0\\) to a vector equation for \\(\\bm{u}=(y,y^\\prime)\\): $$ \\dfrac{\\mathrm{d}}{\\mathrm{d}t}\\begin{bmatrix} y \\\\ y^\\prime \\end{bmatrix}= \\left[\\begin{alignedat}{1} y^\\prime & \\\\ 2y^\\prime & -y \\end{alignedat}\\right] \\quad\\text{is}\\quad \\dfrac{\\mathrm{d}\\bm{u}}{\\mathrm{d}t}=A\\bm{u}=\\begin{bmatrix*}[r] 0 & 1 \\\\ -1 & 2 \\end{bmatrix*}\\bm{u} . $$ \\(A\\) has a repeated eigenvalue \\(\\bm{\\lambda=1,1}\\) (with \\(\\text{trace}=2\\) and \\(\\det A=1\\)). The only eigenvectors are multiples of \\(\\bm{x}=(1,1)\\). Diagonalization is not possible, \\(A\\) has only one line of eigenvectors. So we compute \\(e^{At}\\) from its definition as serire: $$ \\tag{19} \\textbf{Short series}\\qquad \\bm{e^{At}}=e^{It}e^{(A-I)t}=e^t[I+(A-I)t] . $$ That &ldquo;infinite&rdquo; series for \\(e^{(A-I)t}\\) ended quickly because \\((A-I)^2\\) is the zero matrix! You can see \\(\\bm{te^t}\\) in equation (19). The first component of \\(e^{At}\\bm{u}(0)\\) is our answer \\(y(t)\\): $$ \\begin{bmatrix} y \\\\ y^\\prime \\end{bmatrix}=e^t\\left[I+\\begin{bmatrix} -1 & 1 \\\\ -1 & 1\\end{bmatrix}t\\right]\\begin{bmatrix} y(0) \\\\ y^\\prime(0) \\end{bmatrix} \\qquad y(t)=e^ty(0)-\\bm{te^t}y(0)+\\bm{te^t}y^\\prime(0) . $$ 6.3 B&emsp;Find the eigenvalues and eigenvectors of \\(A\\). Then write \\(\\bm{u}(0)=(0,2\\sqrt{2},0)\\) as a combination of the eigenvectors. Solve both equations \\(\\bm{u}^\\prime=A\\bm{u}\\) and \\(\\bm{u}^{\\prime\\prime}=A\\bm{u}\\): $$ \\dfrac{\\mathrm{d}\\bm{u}}{\\mathrm{d}t}=\\begin{bmatrix*}[r] -2 & 1 & 0 \\\\ 1 & -2 & 1 \\\\ 0 & 1 & -2 \\end{bmatrix*}\\bm{u} \\quad\\text{and}\\quad \\dfrac{\\mathrm{d}^2\\bm{u}}{\\mathrm{d}t^2}=\\begin{bmatrix*}[r] -2 & 1 & 0 \\\\ 1 & -2 & 1 \\\\ 0 & 1 & -2 \\end{bmatrix*}\\bm{u} \\quad\\text{with}\\quad \\dfrac{\\mathrm{d}\\bm{u}}{\\mathrm{d}t}(0)=\\bm{0} . $$ &emsp;&ensp;\\(\\textcolor{RoyalBlue}{\\textit{\\textbf{$\\bm{u^\\prime=}A\\bm{u}$ is like the heat equation $\\bm{\\partial u/\\partial t=\\partial^2u/\\partial x^2}$.}}}\\) &emsp;&ensp;Its solution \\(u(t)\\) will decay (\\(A\\) has negative eigenvalues). &emsp;&ensp;\\(\\textcolor{RoyalBlue}{\\textit{\\textbf{$\\bm{u^{\\prime\\prime}=}A\\bm{u}$ is like the wave equation $\\bm{\\partial^2u/\\partial t^2=\\partial^2u/\\partial x^2}$.}}}\\) &emsp;&ensp;Its solution will oscillate (the square roots of \\(\\lambda\\) are imaginary). Solution&emsp;The eigenvalues and eigenvectors come from \\(\\det(A-\\lambda I)=0\\): $$ \\det(A-\\lambda I)= \\begin{vmatrix} -2-\\lambda & 1 & 0 \\\\ 1 & -2-\\lambda & 1 \\\\ 0 & 1 & -2-\\lambda \\end{vmatrix} =(-2-\\lambda)[(-2-\\lambda)^2-2]=0 . $$ One eigenvalue is \\(\\lambda=-2\\), when \\(-2-\\lambda\\) is zero. The other factor is \\(\\lambda^2+4\\lambda+2\\), so the other eigenvalues (also real and negative) are \\(\\lambda=-2\\pm\\sqrt{2}\\). Find the eigenvectors: $$ \\begin{array}{ll} \\bm{\\lambda=-2} & (A+2I)\\bm{x}=\\begin{bmatrix} 0 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 0 & 1 & 0 \\end{bmatrix}\\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}\\quad\\text{for }\\bm{x}_1=\\begin{bmatrix*}[r] 1 \\\\ 0 \\\\ -1 \\end{bmatrix*} \\\\\\\\ \\bm{\\lambda=-2-\\sqrt{2}} & (A-\\lambda I)\\bm{x}=\\begin{bmatrix} \\sqrt{2} & 1 & 0 \\\\ 1 & \\sqrt{2} & 1 \\\\ 0 & 1 & \\sqrt{2} \\end{bmatrix}\\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}\\quad\\text{for }\\bm{x}_2=\\begin{bmatrix} 1 \\\\ -\\sqrt{2} \\\\ 1 \\end{bmatrix} \\\\\\\\ \\bm{\\lambda=-2+\\sqrt{2}} & (A-\\lambda I)\\bm{x}=\\begin{bmatrix} -\\sqrt{2} & 1 & 0 \\\\ 1 & -\\sqrt{2} & 1 \\\\ 0 & 1 & -\\sqrt{2} \\end{bmatrix}\\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}\\quad\\text{for }\\bm{x}_3=\\begin{bmatrix} 1 \\\\ \\sqrt{2} \\\\ 1 \\end{bmatrix} \\end{array} $$ &emsp;&ensp;The eigenvectors are orthogonal (proved in Section 6.4 for all symmetric matrices). All three \\(\\lambda_i\\) are negative. This \\(A\\) is negative definite and \\(e^{At}\\) decays to zero (stability). &emsp;&ensp;The starting \\(\\bm{u}(0)=(0,2\\sqrt{2},0)\\) is \\(\\bm{x}_3-\\bm{x}_2\\). The solution is \\(\\bm{u}(t)=\\bm{e^{\\lambda_3t}x_3-e^{\\lambda_2t}x_2}\\). Heat equation&emsp;In Figure 6.6a, the temperature at the center starts at \\(2\\sqrt{2}\\). Heat diffuses into the neighboring boxes and then to the outside boxes (frozen at 0&deg;). The rate of heat flow between boxes is the temperature difference. From box 2, heat flows left and right at the rate \\(u_1-u_2\\) and \\(u_3-u_2\\). So the flow out is \\(u_1-2u_2+u_3\\) in the second row of \\(A\\bm{u}\\). Wave equation&emsp;\\(\\mathrm{d}^2\\bm{u}/\\mathrm{d}t^2=A\\bm{u}\\) has the same eigenvectors \\(\\bm{x}\\). But now the eigenvalues \\(\\lambda\\) lead to oscillations \\(e^{i\\omega t}\\bm{x}\\) and \\(e^{-i\\omega t}\\bm{x}\\). The frequencies come from \\(\\omega^2=-\\lambda\\): $$ \\dfrac{\\mathrm{d}^2}{\\mathrm{d}t^2}(e^{i\\omega t}\\bm{x})=A(e^{i\\omega t}\\bm{x}) \\quad\\text{becomes}\\quad (i\\omega)^2e^{i\\omega t}\\bm{x}=\\lambda e^{i\\omega t}\\bm{x} \\quad\\text{and}\\quad \\bm{\\omega^2=-\\lambda} . $$ There are two square roots of \\(-\\lambda\\), so we have \\(e^{i\\omega t}\\bm{x}\\) and \\(e^{-i\\omega t}\\bm{x}\\). With three eigenvectors this makes six solutions to \\(\\bm{u}^{\\prime\\prime}=A\\bm{u}\\). A combination will match the six components of \\(\\bm{u}(0)\\) and \\(\\bm{u}^\\prime(0)\\). Since \\(\\bm{u}^\\prime=\\bm{0}\\) in this problem, \\(e^{i\\omega t}\\bm{x}\\) and \\(e^{-i\\omega t}\\bm{x}\\) produce \\(2\\cos(\\omega t)\\bm{x}\\). 6.3 C&emsp;Solve the four equations \\(\\mathrm{d}a/\\mathrm{d}t=0\\), \\(\\mathrm{d}b/\\mathrm{d}t=a\\), \\(\\mathrm{d}c/\\mathrm{d}t=2b\\), \\(\\mathrm{d}z/\\mathrm{d}t=3c\\) in that order starting from \\(\\bm{u}(0)=(a(0),b(0),c(0),z(0))\\). Solve the same equations by the matrix exponential in \\(\\bm{u}(t)=e^{At}\\bm{u}(0)\\). $$ \\begin{array}{l} \\textbf{Four equations} \\\\ \\lambda=\\bm{0,0,0,0} \\\\ \\textbf{Eigenvalues on} \\\\ \\textbf{the diagonal} \\end{array} \\quad \\dfrac{\\mathrm{d}}{\\mathrm{d}t}\\begin{bmatrix} a \\\\ b \\\\ c \\\\ z \\end{bmatrix} = \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ \\bm{1} & 0 & 0 & 0 \\\\ 0 & \\bm{2} & 0 & 0 \\\\ 0 & 0 & \\bm{3} & 0 \\end{bmatrix} \\begin{bmatrix} a \\\\ b \\\\ c \\\\ z \\end{bmatrix} \\quad\\text{is}\\quad \\dfrac{\\mathrm{d}\\bm{u}}{\\mathrm{d}t}=A\\bm{u} . $$ First find \\(A^2\\), \\(A^3\\), \\(A^4\\) and \\(e^{At}=I+At+\\frac{1}{2}(At)^2+\\frac{1}{6}(At)^3\\). Why does the series stop? Why is it true that \\((e^A)(e^A)=(e^{2A})\\)? Always \\(\\bm{e^{As}}\\) times \\(\\bm{e^{At}}\\) is \\(\\bm{e^{A(s+t)}}\\). Solution 1&emsp;Integrate \\(\\mathrm{d}a/\\mathrm{d}t=0\\), then \\(\\mathrm{d}b/\\mathrm{d}t=a\\), then \\(\\mathrm{d}c/\\mathrm{d}t=2b\\) and \\(\\mathrm{d}z/\\mathrm{d}t=3c\\): $$ \\begin{alignedat}{4} a(t)= && a(0) & & & & & \\\\ b(t)= && ta(0) & + & b(0) & & & \\\\ c(t)= && t^2a(0) & + & 2tb(0) & + & c(0) & \\\\ z(t)= && t^3a(0) & + & 3t^2b(0) & + & 3tc(0) & +z(0) \\end{alignedat} \\quad \\begin{array}{l} \\text{The 4 by 4 matrix which is} \\\\ \\text{multiplyting $a(0),b(0),c(0),d(0)$} \\\\ \\text{to produce $a(t),b(t),c(t),d(t)$} \\\\ \\text{must be the same $e^{At}$ as below} \\end{array} $$ Solution 2&emsp;The powers of \\(A\\) (strictly triangular) are all zero after \\(A^3\\). $$ \\bm{A}= \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ \\bm{1} & 0 & 0 & 0 \\\\ 0 & \\bm{2} & 0 & 0 \\\\ 0 & 0 & \\bm{3} & 0 \\end{bmatrix} \\quad \\bm{A^2}= \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ \\bm{2} & 0 & 0 & 0 \\\\ 0 & \\bm{6} & 0 & 0 \\end{bmatrix} \\quad \\bm{A^3}= \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ \\bm{6} & 0 & 0 & 0 \\end{bmatrix} \\quad \\bm{A^4}=\\bm{0} $$ The diagonals move down at each step. So the series for \\(e^{At}\\) stops after four terms: $$ \\textcolor{RoyalBlue}{\\begin{array}{l} \\textbf{Same $\\bm{e^{At}}$ as} \\\\ \\textbf{in Solution 1} \\end{array}} \\qquad e^{At}=I+At+\\dfrac{(At)^2}{2}+\\dfrac{(At)^3}{6}= \\begin{bmatrix} 1 & & & \\\\ t & 1 & & \\\\ t^2 & 2t & 1 & \\\\ t^3 & 3t^2 & 3t & 1 \\end{bmatrix} $$ The square of \\(\\bm{e^A}\\) is \\(\\bm{e^{2A}}\\). But \\(\\bm{e^Ae^B}\\) and \\(\\bm{e^Be^A}\\) and \\(\\bm{e^{A+B}}\\) can be all different. Symmetric Matrices A symmetric matrix \\(S\\) has \\(n\\) real eigenvalues \\(\\lambda_i\\) and \\(n\\) orthonormal eigenvectors \\(\\bm{q}_1,\\ldots,\\bm{q}_n\\). Every real symmetric \\(S\\) can be diagonalized: \\(\\boxed{S=Q\\Lambda Q^{-1}=\\bm{Q\\Lambda Q^\\mathrm{T}}}\\). &dagger; WHY &dagger; Schur's Theorem: If \\(A\\) is a square real matrix with real eigenvalues, then there is an orthogonal matrix \\(Q\\) and an upper triangular matrix \\(T\\) such that \\(A=QTQ^\\mathrm{T}\\). &emsp;&ensp;This theorem allows repeated \\(\\lambda\\)'s, Schur's \\(S=QTQ^{-1}\\) means that \\(T=Q^\\mathrm{T}SQ\\). The transpose is again \\(Q^\\mathrm{T}SQ\\). The triangular \\(T\\) is symmetric when \\(S^\\mathrm{T}=S\\). Then \\(T\\) must be diagonal and \\(T=\\Lambda\\). Real eigenvalues: All the eigenvalues of a real symmetric matrix are real. Proof&emsp;Suppose that \\(S\\bm{x}=\\lambda\\bm{x}\\) and \\(\\lambda\\) might be a complex number \\(a+ib\\). Its complex conjugate is \\(\\overline{\\lambda}=a-ib\\). Similarly the components of \\(\\bm{x}\\) may be complex numbers, and switching the signs of their imaginary parts gives \\(\\overline{\\bm{x}}\\). &emsp;&ensp;The good thing is that \\(\\overline{\\lambda}\\overline{\\bm{x}}\\) is always the conjugate of \\(\\lambda\\bm{x}\\). So we can take conjugates of \\(S\\bm{x}=\\lambda\\bm{x}\\), remembering that \\(S\\) is real: $$ \\text{$S\\bm{x}=\\lambda\\bm{x}$\\quad leads to \\quad $S\\overline{\\bm{x}}=\\overline{\\lambda}\\overline{\\bm{x}}$.} \\qquad \\text{Transpose to\\quad$\\overline{\\bm{x}}^\\mathrm{T}S=\\overline{\\bm{x}}^\\mathrm{T}\\overline{\\lambda}$.} $$ Now take the dot product of the first equation with \\(\\overline{\\bm{x}}\\) and the last equation with \\(\\bm{x}\\): $$ \\overline{\\bm{x}}^\\mathrm{T}S\\bm{x}=\\overline{\\bm{x}}^\\mathrm{T}\\lambda\\bm{x} \\quad\\text{and also}\\quad \\overline{\\bm{x}}^\\mathrm{T}S\\bm{x}=\\overline{\\bm{x}}^\\mathrm{T}\\overline{\\lambda}\\bm{x} . $$ The left sides are the same so the rights side are equal. They multiply \\(\\overline{\\bm{x}}^\\mathrm{T}\\bm{x}=|x_1|^2+|x_2|^2+\\cdots=\\text{length squared}\\) which is not zero. Therefore \\(\\lambda\\) must equal \\(\\overline{\\lambda}\\), and \\(a+ib\\) equals \\(a-ib\\). So \\(b=0\\) and \\(\\lambda=a=\\textit{real}\\). Q.E.D. &dagger; Proof of Schur's Theorem &dagger; Here I referenced the David H. Wagner's version \\(A\\) is a square real matrix with real eigenvalues. Let \\(\\bm{q}_1\\) be an eigenvector of norm 1, with eigenvalue \\(\\lambda_1\\). Let \\(\\bm{q}_2,\\ldots,\\bm{q}_n\\) be any orthonormal vectors orthogonal to \\(\\bm{q}_1\\). Let \\(Q_1=\\begin{bmatrix} \\bm{q}_1 & \\cdots & \\bm{q}_n \\end{bmatrix}\\). Then \\(Q_1^\\mathrm{T}Q_1=I\\), and $$ \\begin{alignedat}{1} Q_1^\\mathrm{T}AQ_1= \\begin{bmatrix} \\bm{q}_1^\\mathrm{T} \\\\ \\vdots \\\\ \\bm{q}_n^\\mathrm{T} \\end{bmatrix} \\begin{bmatrix} A\\bm{q}_1 & \\cdots & A\\bm{q}_n \\end{bmatrix} & = \\begin{bmatrix} \\bm{q}_1^\\mathrm{T} \\\\ \\vdots \\\\ \\bm{q}_n^\\mathrm{T} \\end{bmatrix} \\begin{bmatrix} \\lambda_1\\bm{q}_1 & \\cdots & A\\bm{q}_n \\end{bmatrix} \\\\ & = \\begin{bmatrix} \\lambda_1 & \\bm{q}_1^\\mathrm{T}A\\bm{q}_2 & \\cdots & \\bm{q}_1A\\bm{q}_n \\\\ 0 & \\bm{q}_2^\\mathrm{T}Aq_2 & \\cdots & \\vdots \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & \\cdots & \\cdots & \\bm{q}_n^\\mathrm{T}A\\bm{q}_n \\end{bmatrix} \\\\ & = \\left[\\begin{array}{c|c} \\lambda_1 & \\cdots \\\\ \\hline \\bm{0} & A_2 \\end{array}\\right] \\end{alignedat} $$ Now I claim that \\(A_2\\) has eigenvalues \\(\\lambda_n,\\ldots,\\lambda_n\\). This is true because $$ \\begin{alignedat}{1} \\det(A-\\lambda I) =\\det(Q_1^\\mathrm{T}Q_1)\\det(A-\\lambda I) & =\\det Q_1^\\mathrm{T}\\det(A-\\lambda I)\\det Q_1 \\\\ & =\\det(Q_1^\\mathrm{T}(A-\\lambda I)Q_1) \\\\ & =\\det(Q_1^\\mathrm{T}AQ_1-\\lambda Q_1^\\mathrm{T}Q_1) \\\\ & =\\det \\left[\\begin{array}{c|c} \\lambda_1-\\lambda & \\cdots \\\\ \\hline \\bm{0} & A_2-\\lambda I \\end{array}\\right] \\\\ & =（\\lambda_1-\\lambda)\\det(A_2-\\lambda I) \\end{alignedat} $$ Then we can perform a similar process for \\(A_2\\): $$ Q_2^\\mathrm{T}A_2Q_2= \\left[\\begin{array}{c|c} \\lambda_2 & \\cdots \\\\ \\hline \\bm{0} & A_3 \\end{array}\\right] $$ Back to \\(Q_1^\\mathrm{T}AQ_1\\) we can make \\(Q_2^\\mathrm{T}A_2Q_2\\) appears by multiply two special matrices on both sides: $$ \\begin{alignedat}{1} & \\left[\\begin{array}{c|c} 1 & \\bm{0} \\\\ \\hline \\bm{0} & Q_2^\\mathrm{T} \\end{array}\\right] Q_1^\\mathrm{T}AQ_1 \\left[\\begin{array}{c|c} 1 & \\bm{0} \\\\ \\hline \\bm{0} & Q_2 \\end{array}\\right] \\\\ = & \\left[\\begin{array}{c|c} 1 & \\bm{0} \\\\ \\hline \\bm{0} & Q_2^\\mathrm{T} \\end{array}\\right] \\left[\\begin{array}{c|c} \\lambda_1 & \\cdots \\\\ \\hline \\bm{0} & A_2 \\end{array}\\right] \\left[\\begin{array}{c|c} 1 & \\bm{0} \\\\ \\hline \\bm{0} & Q_2 \\end{array}\\right] \\\\ = & \\left[\\begin{array}{c|c} \\lambda_1 & (\\cdots)Q_2 \\\\ \\hline \\bm{0} & Q_2^\\mathrm{T}AQ_2 \\end{array}\\right] \\\\ = & \\begin{bmatrix} \\lambda_1 & (\\cdots & \\cdots)Q_2 \\\\ 0 & \\lambda_2 & \\cdots \\\\ \\bm{0} & \\bm{0} & A_3 \\end{bmatrix} \\end{alignedat} $$ We can see an upper triangular matrix is in the middle of contruction. You may wonder that the \\(Q_2\\) on the upper right corner will broken something, in fact it doesn't matter since our goal is to produce the upper triangular matrix \\(T\\). We now prove that in this new matrix, the new \\(Q\\)'s are still orthogonal: $$ \\begin{array}{l} \\textbf{Both are transpose of each other} \\end{array} \\qquad \\left( \\left[\\begin{array}{c|c} 1 & \\bm{0} \\\\ \\hline \\bm{0} & Q_2^\\mathrm{T} \\end{array}\\right] Q_1^\\mathrm{T} \\right) \\left( Q_1 \\left[\\begin{array}{c|c} 1 & \\bm{0} \\\\ \\hline \\bm{0} & Q_2 \\end{array}\\right] \\right) =I $$ Continue the process above we will eventually get what we want, the \\(A=QTQ\\). The number of positive eigenvalues of \\(S\\) equals the number of positive pivots. &dagger; WHY &dagger; From this answer. The reason why this works out is due to the Inertia Theorem of Sylvester: briefly put, for a symmetric matrix \\(A\\) and some nonsingular matrix \\(W\\), \\(A\\) and \\(WAW^\\mathrm{T}\\) have the same number of positive, negative, and zero eigenvalues. (\\(A\\) and \\(WAW^\\mathrm{T}\\) are then said to be congruent.) &emsp;&ensp;Since the symmetric matrix \\(S\\) can have decomposition form \\(S=LDL^\\mathrm{T}\\). The diagonal matrix \\(D\\) have the signs of eigenvalues and pivots all same, then from Inertia Theorem of Sylvester we know \\(S\\) has same number of positive eigenvalues as \\(D\\). Furthmore, introducing the conclusion \\(S=Q\\Lambda Q^T\\harr\\Lambda=Q^\\mathrm{T}SQ\\quad(Q^T=Q^{-1})\\), then we get: $$ \\Lambda=(Q^\\mathrm{T}L)D(L^\\mathrm{T}Q)\\quad(\\text{$Q^\\mathrm{T}L$ and $L^\\mathrm{T}Q$ are transpose of each other}) $$ We can see that \\(D\\) share the signs of positive eigenvalues with \\(\\Lambda\\). Antisymmetric matrices \\(A=-A^\\mathrm{T}\\) have imaginary \\(\\lambda\\)'s and orthonormal (complex) \\(\\bm{q}\\)'s. Section 9.2 explains why the test \\(S=S^\\mathrm{T}\\) becomes \\(\\bm{S=\\overline{S}^\\mathrm{T}}\\) for complex matrices. $$ \\text{$S=\\begin{bmatrix} 0 & i \\\\ -i & 0 \\end{bmatrix}=\\overline{S}^\\mathrm{T}$ has real $\\lambda=1,-1$.} \\qquad \\text{$A=\\begin{bmatrix} 0 & i \\\\ i & 0 \\end{bmatrix}=-\\overline{A}^\\mathrm{T}$ has $\\lambda=i,-i$.} $$ &dagger; WORKED EXAMPLES &dagger; 6.4 A&emsp;What matrix \\(A\\) has eigenvalues \\(\\lambda=1,-1\\) and eigenvectors \\(\\bm{x}_1=(\\cos\\theta,\\sin\\theta)\\) and \\(\\bm{x}_2=(-\\sin\\theta,\\cos\\theta)\\)? Which of these properties can be predicted in advance? $$ \\textcolor{RoyalBlue}{ \\text{$A=A^\\mathrm{T}$\\qquad$A^2=I$\\qquad$\\det A=-1$\\qquad pivots are $+$ and $-$\\qquad$A^{-1}=A$} } $$ Solution&emsp;All those properties can be predicted! With real eigenvalues \\(1\\), \\(-1\\) and orthonormal \\(\\bm{x}_1\\) and \\(\\bm{x}_2\\), the matrix \\(A=Q\\Lambda Q^T\\) must be symmetric. The eigenvalues \\(1\\) and \\(-1\\) tell us that \\(A^2=I\\) (since \\(\\lambda^2=1\\)) and \\(A^{-1}=A\\) (same thing) and \\(\\det A=-1\\). The two pivots must be positive and negative like the eigenvalues, since \\(A\\) is symmetric. &emsp;&ensp;The matrix will be a reflection. Vectors in the direction of \\(\\bm{x}_1\\) are unchanged by \\(A\\) (since \\(\\lambda=1\\)). Vectors in the perpendicular direction are reversed (since \\(\\lambda=-1\\)). The reflection \\(A=Q\\Lambda Q^\\mathrm{T}\\) is across the &ldquo;\\(\\theta\\)-line&rdquo;. Write \\(c\\) for \\(\\cos\\theta\\) and \\(s\\) for \\(\\sin\\theta\\): $$ A=\\begin{bmatrix*}[r] c & -s \\\\ s & c \\end{bmatrix*}\\begin{bmatrix*}[r] 1 & 0 \\\\ 0 & -1 \\end{bmatrix*}\\begin{bmatrix*}[r] c & s \\\\ -s & c \\end{bmatrix*} =\\begin{bmatrix} c^2-s^2 & 2cs \\\\ 2cs & s^2-c^2 \\end{bmatrix} =\\begin{bmatrix*}[r] \\cos 2\\theta & \\sin 2\\theta \\\\ \\sin 2\\theta & -\\cos 2\\theta \\end{bmatrix*} . $$ Notice that \\(\\bm{x}=(1,0)\\) goes to \\(A\\bm{x}=(\\cos 2\\theta,\\sin 2\\theta)\\) on the \\(2\\theta\\)-line. And \\((\\cos 2\\theta,\\sin 2\\theta)\\) goes back across the \\(\\theta\\)-line to \\(\\bm{x}=(1,0)\\). 6.4 B&emsp;Find the eigenvalues and eigenvectors (discrete sines and cosines) of \\(A_3\\) and \\(B_4\\). $$ A_3=\\begin{bmatrix*}[r] 2 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 2 \\end{bmatrix*} \\qquad B_4=\\begin{bmatrix*}[r] 1 & -1 & & \\\\ -1 & 2 & -1 & \\\\ & -1 & 2 & -1 \\\\ & & -1 & 1 \\\\ \\end{bmatrix*} $$ The \\(-1,2,-1\\) pattern in both matrices is a &ldquo;second difference&rdquo;. This is like a second derivative. Then \\(A\\bm{x}=\\lambda\\bm{x}\\) and \\(B\\bm{x}=\\lambda\\bm{x}\\) are like \\(\\mathrm{d}^2x/\\mathrm{d}t^2=\\lambda x\\). This has eigenvectors \\(x=\\sin kt\\) and \\(x=\\cos kt\\) that are the bases for Fourier series. &emsp;&ensp;\\(A_n\\) and \\(B_n\\) lead to &ldquo;discrete sines&rdquo; and &ldquo;discrete cosines&rdquo; that are the bases for the Discrete Fourier Transform. This DFT is absolutely central to all areas of digital signal processing. The favorite choice for JPEG in image processing has been \\(B_8\\) of size \\(n=8\\). Solution&emsp;The eigenvalues of \\(A_3\\) are \\(\\lambda=2-\\sqrt{2}\\) and \\(2\\) and \\(2+\\sqrt{2}\\) (see 6.3 B). Their sum is \\(6\\) (the trace of \\(A_3\\)) and their product is \\(4\\) (the determinant). The eigenvector matrix gives the &ldquo;Discrete Sine Transform&rdquo; and the eigenvectors fall onto sine curves. $$ \\begin{array}{lc} \\textbf{Sines}=\\begin{bmatrix} 1 & \\sqrt{2} & 1 \\\\ \\sqrt{2} & 0 & -\\sqrt{2} \\\\ 1 & -\\sqrt{2} & 1 \\end{bmatrix} & \\textbf{Cosines}=\\left[\\begin{array}{ccrc} 1 & 1 & 1 & 1 \\\\ 1 & \\sqrt{2}-1 & -1 & 1-\\sqrt{2} \\\\ 1 & 1-\\sqrt{2} & -1 & \\sqrt{2}-1 \\\\ 1 & -1 & 1 & -1 \\end{array}\\right] \\\\ \\textbf{Sine matrix = Eigenvectors of $\\bm{A_3}$} & \\textbf{Cosine matrix = Eigenvectors of $\\bm{B_4}$} \\end{array} $$ &emsp;&ensp;The eigenvalues of \\(B_4\\) are \\(\\lambda=2-\\sqrt{2}\\) and \\(2\\) and \\(2+\\sqrt{2}\\) and \\(0\\) (the same as for \\(A_3\\), plus the zero eigenvalue). The trace is still \\(6\\), but the determinant is now zero. The eigenvector matrix \\(C\\) gives the 4-point &ldquo;Discrete Cosine Transform&rdquo;. The graph on the Web shows how the first two eigenvectors fall onto cosine curves. (So do all the eigenvectors of \\(B\\).) These eigenvectors match cosines at the halfway points \\(\\pi/8\\), \\(3\\pi/8\\), \\(5\\pi/8\\), \\(7\\pi/8\\). Positive Definite Matrices Symmetric \\(\\bm{S}\\): \\(\\text{all eigenvalues$\\bm{\\gt 0\\space\\hArr}$ all pivots $\\bm{\\gt 0\\space\\hArr}$ all upper left determinants $\\bm{\\gt 0}$}\\). The matrix \\(S\\) is then positive definite. The energy test is \\(\\bm{x}^\\mathrm{T}S\\bm{x}\\gt 0\\) for all vectors \\(\\bm{x}\\neq\\bm{0}\\). &dagger; WHY &dagger; From \\(S\\bm{x}=\\lambda\\bm{x}\\), multiply by \\(\\bm{x}^\\mathrm{T}\\) to get \\(\\bm{x}^\\mathrm{T}S\\bm{x}=\\lambda\\bm{x}^\\mathrm{T}\\bm{x}=\\lambda\\|\\bm{x}\\|^2\\). The right side is positive for all nonzero vectors while the \\(\\lambda\\) is positive. One more test for positive definiteness: \\(S=A^\\mathrm{T}A\\) with independent columns in \\(A\\). &dagger; WHY &dagger; Take energy test we get \\(\\bm{x}^\\mathrm{T}S\\bm{x}=\\bm{x}^\\mathrm{T}A^\\mathrm{T}A\\bm{x}=(A\\bm{x})^\\mathrm{T}(A\\bm{x})=\\|A\\bm{x}\\|^2\\geq 0\\), \\(A\\bm{x}\\) never equal to zero if \\(A\\) has independent columns and \\(x\\neq 0\\). Positive semidefinite \\(S\\) allows \\(\\lambda=0\\), \\(\\text{pivot}=0\\), \\(\\text{determinant}=0\\), \\(\\text{energy }\\bm{x}^\\mathrm{T}S\\bm{x}=0\\). The equation \\(\\bm{x}^\\mathrm{T}S\\bm{x}=1\\) gives an ellipse in \\(\\mathbf{R}^n\\) when \\(S\\) is symmetric positive definite. &dagger; WHY &dagger; The graph of \\(\\bm{x}^\\mathrm{T}S\\bm{x}=1\\) is an ellipse. For example, a 2 by 2 positve definite symmetric matrix \\(S=Q\\Lambda Q^\\mathrm{T}\\): $$ \\bm{x}^\\mathrm{T}S\\bm{x}=1\\harr\\begin{bmatrix} x & y \\end{bmatrix}Q\\Lambda Q^\\mathrm{T}\\begin{bmatrix} x \\\\ y \\end{bmatrix}=\\begin{bmatrix} X & Y \\end{bmatrix}\\Lambda\\begin{bmatrix} X \\\\ Y \\end{bmatrix}=\\lambda_1X^2+\\lambda_2Y^2=1 $$ Which is similar to the ellipse standard equation \\(x^2/a^2+y^2/b^2=1\\). Here it comes with \\(x=X\\) and \\(y=Y\\) and \\(a=1/\\sqrt{\\lambda_1}\\) and \\(b=1/\\sqrt{\\lambda_2}\\) 6.5 A&emsp;The great factorizations of a symmetric matrix are \\(S=LDL^\\mathrm{T}\\) from pivots and multipliers, and \\(S=QAQ^\\mathrm{T}\\) from eigenvalues and eigenvectors. Try these \\(n\\) by \\(n\\) tests on \\(\\textsf{pascal(6)}\\) and \\(\\textsf{ones(6)}\\) and \\(\\textsf{hilb(6)}\\) and other matrices in \\(\\textsf{MATLAB}\\)'s gallery. \\(\\textbf{\\textsf{pascal(6)}}\\) is positive definite because all its pivots are \\(1\\) (Worked Example 2.6 A) \\(\\textbf{\\textsf{ones(6)}}\\) is positive semidefinite because its eigenvalues are \\(0\\), \\(0\\), \\(0\\), \\(0\\), \\(0\\), \\(6\\). \\(\\textbf{\\textsf{H=hlib(6)}}\\) is positive definite even though \\(\\textsf{eig(H)}\\) shows eigenvalues very near zero. Hilbert matrix \\(\\bm{x}^\\mathrm{T}H\\bm{x}=\\int_0^1(x_1+x_2s+\\cdots+x_6s^5)^2\\mathrm{d}s\\gt 0\\), \\(H_{ij}=1/(i+j-1)\\). \\(\\textbf{\\textsf{rand(6)+rand(6)$^\\prime$}} %Using \\prime to make it look clearer\\) can be positive definite or not. Experiments gave only 2 in 20000. 1n=20000;p=0;for k=1:n,A=rand(6);p=p+all(eig(A+A')&gt;0);end,p/n 6.5 B&emsp;\\(\\textcolor{RoyalBlue}{\\text{When is the symmetric block matrix $M=\\begin{bmatrix} A & B \\\\ B^\\mathrm{T} & C \\end{bmatrix}$ positive definite?}}\\) Solution&emsp;Multiply the first row of \\(M\\) by \\(B^\\mathrm{T}A^{-1}\\) and subtract from the second row, to get a block of zeros. The Schur complement \\(S=C-B^\\mathrm{T}A^{-1}B\\) appears in the corner: $$ \\begin{bmatrix} I & 0 \\\\ -B^\\mathrm{T}A^{-1} & I \\end{bmatrix} \\begin{bmatrix} A & B \\\\ B^\\mathrm{T} & C \\end{bmatrix} = \\begin{bmatrix} A & B \\\\ 0 & C-B^\\mathrm{T}A^{-1}B \\end{bmatrix} = \\begin{bmatrix} \\bm{A} & B \\\\ 0 & \\bm{S} \\end{bmatrix} $$ Those two blocks \\(\\bm{A}\\) and \\(S\\) must be positive definite. Their pivots are the pivots of \\(M\\). 6.5 C&emsp;Find the eigenvalues of the \\(-1,2,-1\\) tridiagonal \\(n\\) by \\(n\\) matrix \\(S\\) (my favorite). Solution&emsp;The best way is to guess \\(\\lambda\\) and \\(\\bm{x}\\). Then check \\(S\\bm{x}=\\lambda\\bm{x}\\). Guessing could not work for most matrices, but special cases are a big part of mathematics (pure and applied). &emsp;&ensp;The key is hidden in a differential equation. The second difference matrix \\(S\\) is like a second derivative, and those eigenvalues are much easier to see: $$ \\tag{5} \\colorbox{e8f1fe}{ $\\begin{array}{l} \\textbf{Eigenvalues $\\bm{\\lambda_1,\\lambda_2,\\ldots}$} \\\\ \\textbf{Eigenfunctions $\\bm{y_1,y_2,\\ldots}$} \\end{array}$ \\qquad \\colorbox{ffffff}{$\\dfrac{\\mathrm{d}^2y}{\\mathrm{d}x^2}=\\lambda y(x)$} \\quad\\textbf{with}\\quad $\\begin{array}{l} y(0)=0 \\\\ y(1)=0 \\end{array}$ } $$ Try \\(y=\\sin cx\\). Its second derivative is \\(y^{\\prime\\prime}=-c^2\\sin cx\\). So the eigenvalue in (5) will be \\(\\lambda=-c^2\\), provided \\(y=\\sin cx\\) satisfies the end point conditions \\(y(0)=0=y(1)\\). &emsp;&ensp;Certainly \\(\\sin 0=0\\) (this is where cosines are eliminated). At the other end \\(x=1\\), we need \\(y(1)=\\sin c=0\\). The number \\(c\\) must be \\(k\\pi\\), a multiple of \\(\\pi\\). Then \\(\\lambda\\) is \\(-k^2\\pi^2\\): $$ \\begin{array}{l} \\textbf{Eigenvalues $\\bm{\\lambda=-k^2\\pi^2}$} \\\\ \\textbf{Eigenfunctions $\\bm{y=\\sin k\\pi x}$} \\end{array} \\qquad \\dfrac{\\mathrm{d}^2}{\\mathrm{d}x^2}\\sin k\\pi x=-k^2\\pi^2\\sin k\\pi x . $$ Now we go back to the matrix \\(S\\) and guess its eigenvectors. They come from \\(\\sin k\\pi x\\) at \\(n\\) points \\(x=h,2h,\\ldots,nh\\), equally spaced between \\(0\\) and \\(1\\). The spacing \\(\\Delta x\\) is \\(h=1/(n+1)\\), so the \\((n+1)\\)st point has \\((n+1)h=1\\). Multiply that sine vector \\(\\bm{x}\\) by \\(S\\): $$ \\textcolor{RoyalBlue}{ \\begin{array}{ll} \\textbf{Eigenvalue of $\\bm{S}$ is positive} & S\\bm{x}=\\lambda_k\\bm{x}=(2-2\\cos k\\pi h)\\bm{x} \\\\ \\textbf{Eigenvector of $\\bm{S}$ is sine vector} & \\bm{x}=(\\sin k\\pi h,\\ldots,\\sin nk\\pi h) \\end{array} } $$ LINEAR ALGEBRA IN A NUTSHELL ((The matrix \\(A\\) is \\(n\\) by \\(n\\))) $$ \\begin{array}{ll} \\textcolor{RoyalBlue}{\\textbf{Nonsingular}} & \\textcolor{RoyalBlue}{\\textbf{Singular}} \\\\ A\\text{ is invertible} & A\\text{ is not invertible} \\\\ \\text{The columns are independent} & \\text{The columns are dependent} \\\\ \\text{The rows are independent} & \\text{The rows are dependent} \\\\ \\text{The determinant is not zero} & \\text{The determinant is zero} \\\\ A\\bm{x}=\\bm{0}\\text{ has one solution }\\bm{x}=\\bm{0} & A\\bm{x}=\\bm{0}\\text{ has infinitely many solutions} \\\\ A\\bm{x}=\\bm{b}\\text{ has one solution }\\bm{x}=A^{-1}\\bm{b} & A\\bm{x}=\\bm{b}\\text{ has no solution or infinitely many} \\\\ A\\text{ has $n$ (nonzero) pivots} & A\\text{ has $r\\lt n$ pivots} \\\\ A\\text{ has full rank }r=n & A\\text{ has rank }r\\lt n \\\\ \\text{The reduced row echelon form is }R=I\\qquad & R\\text{ has at least one zero row} \\\\ \\text{The column space is all of }\\mathbf{R}^n & \\text{The column space has dimension }r\\lt n \\\\ \\text{The row space is all of }\\mathbf{R}^n & \\text{The row space has dimension }r\\lt n \\\\ \\text{All eigenvalues are nonzero} & \\text{Zero is an eigenvalue of }A \\\\ A^\\mathrm{T}A\\text{ is symmetric positive definite} & A^\\mathrm{T}A\\text{ is only semidefinite} \\\\ A\\text{ has $n$ (positive) singular values} & A\\text{ has $r\\lt n$ singular values} \\end{array} $$","link":"/zh-cn/learn/mathematics/2021/introduction-to-linear-algebra/"}],"tags":[{"name":"electronic-and-information-engineering","slug":"electronic-and-information-engineering","link":"/tags/electronic-and-information-engineering/"},{"name":"mathematics","slug":"mathematics","link":"/tags/mathematics/"},{"name":"senior-high-schoool","slug":"senior-high-schoool","link":"/tags/senior-high-schoool/"},{"name":"postgraduate","slug":"postgraduate","link":"/tags/postgraduate/"}],"categories":[{"name":"computer","slug":"computer","link":"/categories/computer/"},{"name":"daily-life","slug":"daily-life","link":"/categories/daily-life/"},{"name":"learn","slug":"learn","link":"/categories/learn/"},{"name":"minecraft","slug":"minecraft","link":"/categories/minecraft/"},{"name":"mathematics","slug":"learn/mathematics","link":"/categories/learn/mathematics/"}],"pages":[{"title":"about","text":"123456 _ _ _ _ __ __| | ___ ___| | ___ __ _ __ | || '_ \\ / _` |/ _ \\/ __| |/ / '__| '_ \\| || | | | (_| | (_) \\__ \\ &lt;| | | | | | ||_| |_|\\__,_|\\___/|___/_|\\_\\_| |_| |_|_| 你好, I’m Proteus, 中文昵称暂定为钱桑, 很高兴认识你. 我喜欢捣鼓自己不懂的东西, 请多指教. 目前受到性别焦虑的影响, 属于 MtF 群体. When a child is not insecure, they don’t succumb the danger. If you make her confident who she is that she is amazing the way she is. She will not succumb to other people and that is how she would navigate. Ultimately I believe the biggest miss in the world is people focusing on things don’t matter and underestimating the things matter. Focusing the things that matter most and building up self-esteem around that. And then, suffocating and muting the stuff society values, because in reality long term it doesn’t matters much. Email: lollipop.studio.cn@gmail.com Mastodon: @ndoskrnl@mastodon.social (不活跃) Telegram: @ndoskrnl QQ: 2113952182 (已停用) Zhihu: ndoskrnl (不活跃) Twitter: @ndoskrnl (已停用)","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"Peers","text":"Proteusの友人们 按字母排序, 在我心中不分先后哦 本地磁盘小日记ヾ(≧▽≦*)ゝ clansty(凌莞) 凌莞大可爱! Makito(朵朵) Full-Stack MinatoAster 霜晨月 xtlsoft(徐天乐) 下面是单向友链 Computer Yuuta Liang BGP, Clearnet ASN, DN42 mathor ACM xehoth C++, Computer Graphics hzwer OI Magolor’s Blog OI 柳婼のblog - 我不管, 反之我最萌~ LeetCode, PAT 斐斐のBlog PAT Raptazure Rust miRoox Wolfram Lil’Log Neural Network, Deep Learning Jingjing’s blog Neural Network, Deep Learning, Computer Vision Sebastian Ruder Deepmind 启示录 Java, Critical thinking Jarvis’s Blog IoT, Linux 雪碧 0xroot IoT, Radio 為了可能的聲音 Archlinux Farseerfc 的小窝 Archlinux 约伊兹的萌狼乡手札 Archlinux Sukka’s Blog Web, Archlinux (顺带一提他的博客很快) Leo’s Field AOSC OS Berd’s Playground MOE Fengberd 始终 C++ 星尘独奏曲 Linux Lianm’s Blog Bioinformatics Lan Tian BGP, DN42 Alex Chi CS 木子 Humanities 长征部落格 Patriotism 菜菜博士 - 博士在网络的家 Internet Dreamwings - 继续踏上旅途, 在没有你的春天… program-think 当然我在扯淡 ServalCandle Cat, dOnOTrEADiT LOFT IN THE IMMOBILE LIBRARY Misc 萨摩的部落格 - 掉毛中… It’s me, Kiri! 蝉时雨 Frontend 酷壳 洛灵酱的小窝 冰凌胧月的小窝 FSpark’s Starry Sky 樱花庄的白猫 佳佳酱 Jeffrey Paul Fallenhh Desvl Mathematics 倚窗，听雨 NOIP 一叶知秋 - 秋是悲欢离合，雨是一生错过 Kalorona - Personal Blog NOIP Estela (Promotana) Dialect:Wu, Español, MtF-Wiki septs Frontend TC39 liolok Archlinux PRIN BLOG - 半吊子全栈开发者的日常","link":"/peers/index.html"}]}