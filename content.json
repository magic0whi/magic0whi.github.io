{"pages":[{"title":"about","text":"123456 _ _ _ _ __ __| | ___ ___| | ___ __ _ __ | || '_ \\ / _` |/ _ \\/ __| |/ / '__| '_ \\| || | | | (_| | (_) \\__ \\ &lt;| | | | | | ||_| |_|\\__,_|\\___/|___/_|\\_\\_| |_| |_|_| 你好, 我的 ID 叫 Proteus, 你可以称呼我为钱桑, 很高兴认识你. 我喜欢捣鼓自己不懂的东西, 也(差不多)是个笨蛋, 带专生, 垃圾学校, 垃圾专业. 因此, 请多指教. 目前受到性别焦虑的影响, 属于 MtF 群体, 这些人只是有点特别罢了, Ta 们中的多数都有着不同程度的心理创伤, 生活中要是请尽量好好对待 Ta 们哦. 欢迎交换友链~ Feel free to contact me: Email: lollipop.studio.cn@gmail.com Twitter: @ndoskrnl Telegram: @ndoskrnl QQ: 2113952182 Zhihu: ndoskrnl Features: Retiring Your browser does not support the audio element.","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Peers","text":"Proteusの友人们 按字母排序, 在我心中不分先后哦 本地磁盘小日记ヾ(≧▽≦*)ゝ clansty(凌莞) 凌莞大可爱! Makito(朵朵) Full-Stack MinatoAster 霜晨月 xtlsoft(徐天乐) 下面是单向友链 Computer Yuuta Liang BGP, Clearnet ASN, DN42 mathor ACM xehoth C++, Computer Graphics hzwer OI Magolor’s Blog OI 柳婼のblog - 我不管, 反之我最萌~ LeetCode, PAT 斐斐のBlog PAT Raptazure Rust miRoox Wolfram Lil’Log Neural Network, Deep Learning Jingjing’s blog Neural Network, Deep Learning, Computer Vision Sebastian Ruder Deepmind 启示录 Java, Critical thinking Jarvis’s Blog IoT, Linux 雪碧 0xroot IoT, Radio 為了可能的聲音 Archlinux Farseerfc 的小窝 Archlinux 约伊兹的萌狼乡手札 Archlinux Sukka’s Blog Web, Archlinux (顺带一提他的博客很快) Leo’s Field AOSC OS Berd’s Playground MOE Fengberd 始终 C++ 星尘独奏曲 Linux Lianm’s Blog Bioinformatics Lan Tian BGP, DN42 Alex Chi CS 木子 Humanities 长征部落格 Patriotism 菜菜博士 - 博士在网络的家 Internet Dreamwings - 继续踏上旅途, 在没有你的春天… program-think 当然我在扯淡 ServalCandle Cat, dOnOTrEADiT LOFT IN THE IMMOBILE LIBRARY Misc 萨摩的部落格 - 掉毛中… It’s me, Kiri! 蝉时雨 Frontend 酷壳 洛灵酱的小窝 冰凌胧月的小窝 FSpark’s Starry Sky 樱花庄的白猫 佳佳酱 Jeffrey Paul Fallenhh Desvl Mathematics 倚窗，听雨 NOIP 一叶知秋 - 秋是悲欢离合，雨是一生错过 Kalorona - Personal Blog NOIP Estela (Promotana) Dialect:Wu, Español, MtF-Wiki septs Frontend TC39 liolok Archlinux","link":"/peers/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"a-guide-to-zhuyin","text":"A brief guide to zhuyin input &amp; keyboard 注音键盘 如图是台湾使用最广的大千式键盘, 由于我这里只有美式键盘, 只能靠记忆来在 PC 上使用注音输入法. 注音五十音 ㄅ b ㄉ d ˇ ˋ ㄓ zh ˊ ˙ ㄚ a ㄞ ai ㄢ an ㄦ er ㄆ p ㄊ t ㄍ g ㄐ j ㄔ ch ㄗ z ㄧ y/i ㄛ o ㄟ ei ㄣ en ㄇ m ㄋ n ㄎ k ㄑ q ㄕ sh ㄘ c ㄨ w/u ㄜ e ㄠ ao ㄤ ang ㄈ f ㄌ l ㄏ h ㄒ x ㄖ r ㄙ s ㄩ yu/ü ㄝ ê ㄡ ou ㄥ eng ㄧㄣ in ㄩㄣ ün ㄧㄥ ing ㄨㄥ weng/ong ㄩㄥ yong","link":"/zh-cn/computer/2022/a-guide-to-zhuyin/"},{"title":"Containerize China APPs with systemd-nspawn","text":"A prescription for 国产软件洁癖症. Thanks to liolok’s work[1] Container bringup Here using Tencent Meeting as an example 12345678910$ su# cd /var/lib/machines# container_name=wemeet# btrfs subvolume create ${container_name}# codename=focal# repository_url='https://repo.huaweicloud.com/ubuntu/'# debootstrap --include=systemd-container \\--components=main,universe,multiverse \\${codename} ${container_name} ${repository_url} Get into the container just created: 12345678910# cp /path/to/TencentMeeting_0300000000_2.8.0.3_x86_64_default.publish.deb /var/lib/machines/container_name/root/# systemd-nspawn --machine=${container_name} --bind-ro=/etc/resolv.confroot@wemeet # dpkg -i TencentMeeting_0300000000_2.8.0.3_x86_64_default.publish.debroot@wemeet # apt -f installroot@wemeet # apt install xorg # If needed install xorgroot@wemeet # ln -s /opt/wemeet/wemeetapp.sh /usr/local/bin/wemeetroot@wemeet # useradd -m wemeetroot@wemeet # su --login wemeet --shell /bin/bashwemeet@wemeet $ mkdir --parents ~/.config ~/.local/share Wrap up Desktop shortcut~/.local/share/applications/wemeet.desktop1234567[Desktop Entry]Comment=Tencent Video ConferencingExec=/home/proteus/.local/bin/wemeetIcon=/path/to/wemeetapp.pngName=Tencent MeetingTerminal=falseType=Application Startup script~/.local/bin/wemeet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/bin/bashapp=wemeethome=/home/${app}host_data=/usr/sharedata=${home}/.local/sharehost_conf=${XDG_CONFIG_HOME:-~/.config}conf=${home}/.configoptions=&quot;--as-pid2 --machine=${app} --user=${app} --chdir=${home}&quot;# Trayhost_dbus=${DBUS_SESSION_BUS_ADDRESS#unix:path=}if [ -z &quot;${host_dbus}&quot; ]; then host_dbus=&quot;/run/user/$(id --user)/bus&quot;fidbus=/run/user/host/busoptions=&quot;${options} --bind-ro=${host_dbus}:${dbus} --setenv=DBUS_SESSION_BUS_ADDRESS=unix:path=${dbus}&quot;# Soundhost_pulse=${PULSE_SERVER#unix:}if [ -z &quot;${host_pulse}&quot;]; then host_pulse=&quot;/run/user/$(id --user)/pulse/native&quot;fipulse=/run/user/host/pulseoptions=&quot;${options} --bind-ro=${host_pulse}:${pulse} --setenv=PULSE_SERVER=unix:${pulse}&quot; # Iconsoptions=&quot;${options} --bind-ro=${host_data}/icons:${data}/icons --setenv=XCURSOR_PATH=${data}/icons&quot;# Fontsoptions=&quot;${options} --bind-ro=${host_data}/fonts:${data}/fonts --bind-ro=${host_conf}/fontconfig:${conf}/fontconfig&quot;# Displayoptions=&quot;${options} --bind-ro=/tmp/.X11-unix/ --setenv=DISPLAY=$DISPLAY&quot;xauth_file=&quot;/tmp/xauth-${app}&quot;touch ${xauth_file}xauth nextract - &quot;${DISPLAY}&quot; | sed -e 's/^..../ffff/' | xauth -f &quot;${xauth_file}&quot; nmerge -options=&quot;${options} --bind=${xauth_file} --setenv=XAUTHORITY=${xauth_file}&quot;# Devicesoptions=&quot;${options} --bind=/dev/dri/ --property=DeviceAllow='char-drm rw'&quot; # Graphic cardsoptions=&quot;${options} --bind=/dev/input/ --property=DeviceAllow='char-input r'&quot; # Joysticksecho &quot;List of cmdline options applied to systemd-nspawn:&quot;printf &quot;%s\\n&quot; ${options} | sort# resolv.confoptions=&quot;${options} --bind-ro=/etc/resolv.conf&quot;kdesu bash -c &quot;systemd-nspawn ${options} ${app}&quot; Please be aware that here I use kdesu as an alternative to sudo, which is include in KDE desktop. Don’t forget to give executable permission chmod +x ~/.local/bin/wemeet Reference ^ \"Containerize Steam with systemd-nspawn\". liolok.com. Retrieved 2022-3-10.","link":"/zh-cn/computer/2022/Containerize-China-APPs-with-systemd-nspawn/"},{"title":"altiumdesigner-notes","text":"进度 Pass 1/2, Stage 16/38, 10:41 原件在放置时按 Tab 键可暂停(暂停后调整属性), 按 Enter 键继续 设置格点View-&gt;Grids-&gt;Set Snap Grid… (快捷键VGS) 在Name属性中, 字符后面加上 \\ 可给字符加上Overline, 如 V\\I\\N 会显示为 VIN 自定义快捷键: 按住 Ctrl 点击想要修改快捷键的命令 学到の里技: 在原理图中添加大量管脚时可使用阵列式粘贴 (With .SchLib file focused in Editor, Edit-&gt;Paste Array…), 其中主增量 (Primary Increment) 对应管脚号 (Designator), 次增量 (Secondary Increment) 对应管脚名称 (Name), 记得先 Ctrl+C 复制一个管脚到剪切板. 可以从原理图 (.SchDoc) 反向生成原理图库 (.SchLib): (With .SchDoc file focused in Editor) Design-&gt;Make Schematic Library 弹出的 Component Grouping 可以指定特定参数相同的归类到一起. 原理图 (.SchDoc) 双击边缘可以快速弹出 Properties 菜单. 快捷键: A 调出对齐菜单 (Edit-&gt;Align) M 调出移动菜单 (Edit-&gt;Move) MS 移动选择的元件 (-&gt;Move Selection) Shift+Drag 快速复制元件 在移动过程中, 按 X、Y 可按对应的轴镜像. Ctrl+W 放置导线 (Place-&gt;Wire). 退格键可撤回确定的点, 导线和绘制线都可用. Place-&gt;Net Label 放置网络标签 原理图绘制步骤: 先不连线, 把各个模块对应的元件大致摆放好. 通过绘制工具中的线 (Place-&gt;Drawing Tools-&gt;Line) 跨分模块区域. 绘制时, Shift+Space 可以切换正交模式、钝角模式、任意角模式. 连号导线, 在一些管脚添加需要的 NetLabel 核对元件 Value 值 (如元件位号 R1、R2, 电阻的阻值等) 可通过位号编辑器自动编号编号, 它的位置在 Tools-&gt;Annotation-&gt;Annotate Schematics… 修改了参数后, 已经套用的需要重置 (如点击 Reset All), 然后再应用 (点击 Update Changes List) 最后点击接受变更 (Accept Changes (Create ECO)), 再在弹出的窗口点击执行变更 (Execute Changes) 即可 给元件添加封装 (Footprint), 即 PCB 上元件的 3D 模型. 由于一个一个在元件的属性里添加封装太麻烦且容易出错, 所以需要用到封装管理器 (Tools-&gt;Footprint Manager…) 原理图的编译设置及检查. 在工程选项 (Project-&gt;Project Options…) 可配置错误报告 (Error Reporting) 的类型. 常用设置:123456Violations Associated with Components: Duplicate Part Designators = Fatal Error // 相同的元件位号Violations Associated with Nets: Floating net labels = Fatal Error // 网络标号悬空 (没有连接元件) Floating power objects = Fatal Error // 电源对象悬空 Nets with only one pin = Fatal Error // 单端网络 在原理图中, 可以设置网络颜色 (View-&gt;Set Net Colors), 以便于查找单端网络. 对于没有网络标号的引脚, 如果连接了悬空的导线, 可以加上通用 No ERC 标号 (Place-&gt;Directives-&gt;Generic No ERC) 来禁用这里的 ERC 检查; 也可以直接删除连接的悬空导线. 常见 CHIP 封装的创建 阻焊的作用是防止绿油覆盖 在 .PcbDoc 中按 Ctrl+D 可以调出视图配置, 可以切换 3D (快捷键 3) 等操作, 在 3D 中, 按住 Shift+鼠标右键 可以调整角度. 元件知识 零欧姆电阻=毫欧电阻, 一般为 20Ω-50Ω 作用: 作保险丝, 功能切换, 跳线, 作高频电感、电容, 作磁珠等","link":"/zh-cn/computer/2021/altiumdesigner-notes/"},{"title":"bookmark","text":"互联网上の资源 IDE C/C++ for Visual Studio Code QT Creator QT download Windows Windows,Office 等镜像 TechBench ESD 解密 decrypt-multi UUPDL KMS client setup keys list Intel (CS)ME, CS(TXE), CS(SPS), PMC, PHY &amp; PCHC Firmware Repositories Windows 10 更新补丁汇总合集 最新支持的 Visual C++ 下载 Linux OriginCode 的服务 Clansty’s Archlinux Repository Android Google Camera Ports Android APK 魔改&amp;破解 mobilism Education Tools 跨平台在线数学可视化 GeoGebra , desmos 在线求解微积分/矩阵等 积分(反导数)计算器 - Symbolab 在线获取试卷 考试酷 在线图书信息库 arbookfind 学术论文一站式搜索 GFsoso SCI-Hub 论文下载可用网址链接 - 实时更新 Library Genesis创世纪图书馆 Z-Library 学术相关书籍/论文 类似ChemDraw, 不过是网页版 MolView ChemDoodle WEB drawio 开源的在线图表制作软件 Chemical Equations Chemical Structure Search 画出结构, 找到化学物质, 感谢 @Alice_486 Learn 计算机工程中缺失的一课 CS自救指北 中科院考试大纲 Yifei Xiong 的数学笔记 数学乐 平面设计/音乐音效 doyoudo Crashcourts中文字幕 Crashcourts BioHack Academy BioHack Academy on Vimeo Bio Academany GaudiLabs Wolfram MathWorld chemcollective GeeksforGeeks | A computer science portal for geeks Learn X in Y Minutes Writing an OS in Rust Full stack open 2021 CS自学指南 Paper The mouse Sry locus harbors a cryptic exon that is essential for male sex determination Github This chapter has benn deprecated and now I useing Github star as a substitution. 手撕 leetcode 求是潮技术研发中心 linux 超赞应用 trackerslist Locale-Emulator FontMod DeepCreamPy Find illustration SauceNao Yande.re Sankaku Channel iqdb konachan 版权自由图片 Pixabay BT ACG.RIP Bangumi Moe Rarbg Free Software Movement 开源许可检查 FOSSA Internet 域名价格比对 domcomp 在线传感器数据分析 Grafana 在线查毒 Virustotal 游戏破解状态 CrackWatch Steam 创意工坊在线下载器 Steam Workshop Downloader Goldberg Steam 模拟器 goldberg_emulator Oracle 账户密码 BugMeNot 油猴脚本 Greasy Fork 免费上网账号 存储 SSD/NAS/DAS 技术论坛 教你制作能打印PCB的压印机 Diyyouware 嘉立创SMT贴片 图拉丁之家 查看账号是否遭数据泄露 have i been pwned? 信息安全 Seebug 随机生成美国/加拿大/日本人信息 haoweichi 基站查询 OpenCellid 萌站·次元导航 生物实验用机器人 Opentrons Seebug SJTUG - A Joyful Techie User Group OpenWeather 生信人 DrugBank Online Sketchfab 科创 美卡论坛 DeepL : 比 Google Translate 好用的在线翻译 QuillBot : English rephrase Kemono.party : 心里要知道白嫖不是长久之计, 每个人的劳动都应当尊重. DevDocs API Documentation : 各种编程语言和软件的文档集合(比如 CPP reference) 科学网-博客 Mathpix Snip : 图片转 Tex Softwares OBS 解压 Inno Setup 打包的资源 Innoextrace OpenBuilds Software - FREE Software for CNC Control News medias iYouPort - IYP","link":"/zh-cn/computer/2020/bookmark/"},{"title":"Some Hexo usages","text":"Hexo 的一些命令和概念速记 部署Git仓库 1git@blog ~$ git init --bare blog.git 然后就是Git Hook的配置, 见前面 别忘了 chmod +x post-update 若想使用git-shell: usermod -s /usr/bin/git-shell git Hexo 文章加密 123$ cd blog$ npm install hexo-blog-encrypt$ nano /Hexo/_config.yml 添加如下内容 1234# Security## 文章加密 hexo-blog-encryptencrypt: enable: true 然后在想加密的文章头部添加上对应字段, 如 123456789---title: hello worlddate: 2016-03-30 21:18:02tags:toc: truepassword: 12345abstract: 该博文的摘要message: 密码输入框的描述性文字--- 另见Github项目说明 升级Hexo 12345# npm update -g # 升级npm全局插件# npm install npm-check npm-upgrade -g # 针对package.json的操作, 前者只是检查有更新的插件, 后者应用改动$ cd /path/to/your/blog$ npm-upgrade # 更新package.json中的插件版本$ npm update # 实际更新插件 分类和标签 只有文章支持分类和标签, 您可以在 Front-matter 中设置. 在其他系统中, 分类和标签听起来很接近, 但是在 Hexo 中两者有着明显的差别: 分类具有顺序性和层次性而标签没有顺序和层次 123456categories:- Diarytags:toc: true- PS3- Games 资源引用 设置 post_asset_folder: true 之后会开启 Hexo 的文章资源文件管理功能. Hexo 将会在我们每一次通过 hexo new &lt;title&gt; 命令创建新文章时自动创建一个同名文件夹, 于是我们便可以将文章所引用的相关资源放到这个同名文件夹下, 然后通过相对路径引用. 123{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %} Example: 1{% asset_link unbound.conf.example &quot;/etc/unbound/unbound.conf&quot; %} 具体见: 标签插件 一些技巧示例 单个页面使用赛博朋克主题, 在 Front-matter 加入如下内容:123456---variant: cyberpunkarticle: highlight: theme: qtcreator_dark--- 一些 Bulma 的提示信息(来自Icarus主题)123456789101112131415161718&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-globe-asia mr-2&quot;&gt;&lt;/i&gt;这是一个页面提示&lt;a href=&quot;{% post_path zh-CN/Getting-Started %}&quot;&gt;超链接&lt;/a&gt;.&lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message message-immersive is-warning&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-question-circle mr-2&quot;&gt;&lt;/i&gt;Something wrong with this article? Click &lt;a href=&quot;https://github.com/ppoffice/hexo-theme-icarus/edit/site/source/_posts/en/Getting-Started.md&quot;&gt;here&lt;/a&gt; to submit your revision.&lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message is-primary&quot; style=&quot;font-size:inherit&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;这是一条讯息.&lt;/div&gt;&lt;/article&gt; 如下: 这是一个页面提示 超链接. Something wrong with this article? Click here to submit your revision. 这是一条讯息. Bulma 的带内容标签示范 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div class=&quot;tabs is-boxed my-3&quot;&gt; &lt;ul class=&quot;mx-0 my-0&quot;&gt; &lt;li class=&quot;is-active&quot;&gt; &lt;a href=&quot;#tab1&quot;&gt; &lt;span class=&quot;icon is-small&quot;&gt;&lt;i class=&quot;fas fa-file-code&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;span&gt;标签1&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#tab2&quot;&gt; &lt;span class=&quot;icon is-small&quot;&gt;&lt;i class=&quot;fas fa-cubes&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;span&gt;标签2&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div id=&quot;tab1&quot; class=&quot;tab-content&quot;&gt; foooooooooo!&lt;/div&gt;&lt;div id=&quot;tab2&quot; class=&quot;tab-content is-hidden&quot;&gt; woooooooooo!&lt;/div&gt;&lt;!-- 最好加条横线以和下文内容区分 --&gt;&lt;hr&gt;&lt;!-- 在页面底部添加 JS 脚本 --&gt;&lt;script&gt;window.addEventListener('DOMContentLoaded', () =&gt; { Array .from(document.querySelectorAll('.tabs li')) .forEach((tab) =&gt; { tab.addEventListener('click', (e) =&gt; { e.preventDefault(); const currentTab = document.querySelector('.tabs li.is-active'); currentTab.classList.remove('is-active'); document .getElementById(currentTab.querySelector('a').getAttribute('href').substring(1)) .classList.add('is-hidden'); const newTab = e.currentTarget; newTab.classList.add('is-active'); document .getElementById(e.currentTarget.querySelector('a').getAttribute('href').substring(1)) .classList.remove('is-hidden'); }); });});&lt;/script&gt; 标签1 标签2 foooooooooo! woooooooooo! 使用内联 CSS 管理行首缩进. (虽然我更喜欢用在段落前加 &amp;emsp\\; 这种方式) 123456789&lt;span class=sentence&gt;凌晨 1 时, 大多数人已睡了三小时, 进入易醒的浅睡阶段, 对疼痛特别敏感.&lt;/span&gt;&lt;style type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt;.sentence { /* padding:.3em .5em .1em 2em; */ padding-left: 2em; background: pink; }&lt;/style&gt; KaTeX div 标签中 DisplayMode (用 “\\\\[,\\\\]” 包裹) 的 KaTeX 会莫名地有条滚动条, 通过内联 css 隐藏它:12345&lt;style type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt;.katex-html { overflow-x: hidden;}&lt;/style&gt; 通过内联 JS 脚本实现 KaTex 参数自定义:123456789101112131415161718192021222324&lt;div id=&quot;katex-1&quot;&gt;&lt;/div&gt;&lt;script&gt;window.onload = () =&gt; { var html = katex.renderToString(` \\\\begin{equation} \\\\begin{split} a &amp;=b+c \\\\\\\\ &amp;=e+f \\\\end{split} \\\\end{equation} \\\\\\\\ \\\\htmlStyle{color: red;}{x} \\\\\\\\ \\\\href{https://katex.org/}{\\KaTeX} \\\\\\\\ \\\\includegraphics[height=0.8em, totalheight=0.9em, width=0.9em, alt=KA logo]{https://katex.org/img/khan-academy.png}` , { displayMode: true, trust: (context) =&gt; ['\\\\includegraphics', '\\\\href', '\\\\htmlStyle'].includes(context.command) }); document.getElementById('katex-1').insertAdjacentHTML( 'afterend', html );};&lt;/script&gt;","link":"/zh-cn/computer/2020/hexo-usage/"},{"title":"kvm","text":"This article includes: KVM + Libvirt PCI passthrough via OVMF Intel’s GVT-g TODO: virtio drivers https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso /etc/modules-load.d/kvm.conf123kvmgt#vfio-iommu-type1vfio-mdev /etc/mkinitcpio.conf1MODULES=(vfio_pci vfio vfio_iommu_type1 vfio_virqfd) libvirt iptables-nft dnsmasq dmidecode bridge-utils openbsd-netcat the easiest way to ensure your user has access to libvirt daemon is to add member to libvirt user group. If you want to use polkit as authentication: Arch defaults to consider anybody in the wheel group as an administrator: this is defined in /usr/share/polkit-1/rules.d/50-default.rules (see Polkit#Administrator identities). Therefore there is no need to create a new group and rule file systemctl enable --now libvirtd.service Access virtual machines using their hostnames for tpm support install swtpm Isolating the GPU Setting up IOMMU 设置 kernel parameter , 加上 intel_iommu=on 用这个脚本可以查看IOMMU的分组check-iommu.sh12345678#!/bin/bashshopt -s nullglobfor g in /sys/kernel/iommu_groups/*; do echo &quot;IOMMU Group ${g##*/}:&quot; for d in $g/devices/*; do echo -e &quot;\\t$(lspci -nns ${d##*/})&quot; done;done; 注意, 如果你的PCIe插槽未作隔离(PCIe的IOMMU组中有多个设备, 包括PCIe本身), 如这样1234IOMMU Group 1: 00:01.0 PCI bridge: Intel Corporation Xeon E3-1200 v2/3rd Gen Core processor PCI Express Root Port [8086:0151] (rev 09) 01:00.0 VGA compatible controller: NVIDIA Corporation GM107 [GeForce GTX 750] (rev a2) 01:00.1 Audio device: NVIDIA Corporation Device 0fbc (rev a1) 如果你不想这个 PCI-E 下的 SSD 或其他设备也要透传进虚拟机, 有两种解决方案: 把要透传的显卡换一个PCIe插槽 安装带 ACS override patch 的 linux-vfio, 然后 kernel parameter 加上 pcie_acs_override =id:8086:0151 , 其中 8086:0151 是你的PCI插槽的 VendorID:DeviceID 关于此问题更多详见IOMMU Gotchas Binding vfio-pci via device ID kernel parameter 加上 vfio-pci.ids=10de:13c2,10de:0fbb If, as noted in #Plugging your guest GPU in an unisolated CPU-based PCIe slot, your pci root port is part of your IOMMU group, you must not pass its ID to vfio-pci, as it needs to remain attached to the host to function properly. Any other device within that group, however, should be left for vfio-pci to bind with. Loading vfio-pci early/etc/mkinitcpio.conf123MODULES=(... vfio_pci vfio vfio_iommu_type1 vfio_virqfd ...)...HOOKS=(... modconf ...) 这里注意如果你两张显卡是相同型号(VendorID相同), 不能用这个方法, 请参阅Using identical guest and host GPUs Verifying that the configuration worked1234 $ lspci -nnk -d 10de:13c2 06:00.0 VGA compatible controller: NVIDIA Corporation GM204 [GeForce GTX 970] [10de:13c2] (rev a1)Kernel driver in use: vfio-pciKernel modules: nouveau nvidia 1234 $ lspci -nnk -d 10de:0fbb 06:00.1 Audio device: NVIDIA Corporation GM204 High Definition Audio Controller [10de:0fbb] (rev a1)Kernel driver in use: vfio-pciKernel modules: snd_hda_intel Add GPU device to VM 由于N卡有两个设备,一个是VGA(PCI地址03:00.0), 另一个是 Audio(PCI地址03:00.1) 就要有2个 &lt;hostdev&gt; 执行 virsh -c qemu:///system edit &lt;VM-Name&gt; 添加下列字段: 12345678910111213141516171819202122232425262728293031323334&lt;devices&gt;...&lt;features&gt; ... &lt;hyperv&gt; ... &lt;vendor_id state='on' value='randomid'/&gt; ... &lt;/hyperv&gt; ... &lt;kvm&gt; &lt;hidden state='on'/&gt; &lt;/kvm&gt; ...&lt;/features&gt;...&lt;hostdev mode='subsystem' type='pci' managed='yes'&gt; &lt;driver name='vfio'/&gt; &lt;source&gt; &lt;address domain='0x0000' bus='0x03' slot='0x00' function='0x0'/&gt; &lt;/source&gt; &lt;rom file='/var/lib/libvirt/customroms/gt610_updGOP.rom'/&gt; &lt;address type='pci' domain='0x0000' bus='0x09' slot='0x00' function='0x0' multifunction='on'/&gt;&lt;/hostdev&gt;&lt;hostdev mode='subsystem' type='pci' managed='yes'&gt; &lt;driver name='vfio'/&gt; &lt;source&gt; &lt;address domain='0x0000' bus='0x03' slot='0x00' function='0x1'/&gt; &lt;/source&gt; &lt;rom file='/var/lib/libvirt/customroms/gt610_updGOP.rom'/&gt; &lt;address type='pci' domain='0x0000' bus='0x09' slot='0x00' function='0x1'/&gt;&lt;/hostdev&gt;...&lt;/devices&gt; 如果是笔记本, 注意 “Error 43: Driver failed to load” with mobile (Optimus/max-q) nvidia GPUs 这里我总线地址选了 0x09, 只要没被别的虚拟设备声明的 PCI 总线地址都行 这里我用了经过 GOPupd 升级的自定义的 VBIOS, 因为我的 GT610 固件不支持 EFI GT610不行, PCI PassThrough 下只要从 VGA 模式切换到带 3D 加速的显卡驱动就会 Kernel Freeze, 最终只能充当 boot_vga GVT-g Set i915 module parameter enable_gvt=1 You can look up what types are available in your system (and cat description inside of each type to discover what it’s capable of) like this:12345# ls /sys/devices/pci${GVT_DOM}/$GVT_PCI/mdev_supported_typesi915-GVTg_V5_1 # Video memory: &lt;512MB, 2048MB&gt;, resolution: up to 1920x1200i915-GVTg_V5_2 # Video memory: &lt;256MB, 1024MB&gt;, resolution: up to 1920x1200i915-GVTg_V5_4 # Video memory: &lt;128MB, 512MB&gt;, resolution: up to 1920x1200i915-GVTg_V5_8 # Video memory: &lt;64MB, 384MB&gt;, resolution: up to 1024x768 libvirt qemu hooketc/libvirt/hooks/qemu123456789101112131415#!/bin/bashGVT_PCI=0000:00:02.0GVT_GUID=db10f5f6-0546-4c1c-96c7-1ffe204ae6ce # generated by uuidgen# The XML of the domain is feed to the hook script through stdin.# You can use xmllint and XPath expression to extract GVT_GUID from stdin, e.g.:# GVT_GUID=&quot;$(xmllint --xpath 'string(/domain/devices/hostdev[@type=&quot;mdev&quot;][@display=&quot;on&quot;]/source/address/@uuid)' -)&quot;MDEV_TYPE=i915-GVTg_V5_4DOMAIN=win10 # Your virtual machine nameif [ $# -ge 3 ]; then if [ $1 = &quot;$DOMAIN&quot; -a $2 = &quot;prepare&quot; -a $3 = &quot;begin&quot; ]; then echo &quot;$GVT_GUID&quot; &gt; &quot;/sys/bus/pci/devices/$GVT_PCI/mdev_supported_types/$MDEV_TYPE/create&quot; elif [ $1 = &quot;$DOMAIN&quot; -a $2 = &quot;release&quot; -a $3 = &quot;end&quot; ]; then echo 1 &gt; /sys/bus/pci/devices/$GVT_PCI/$GVT_GUID/remove fifi Configuration for the VM($ virsh -c qemu:///system edit &lt;Your VM Name&gt;):1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'&gt; ... &lt;features&gt; ... &lt;kvm&gt; &lt;hidden state='on'/&gt; &lt;/kvm&gt; ... &lt;/features&gt; ... &lt;devices&gt; ... &lt;graphics type='spice'&gt; &lt;listen type='none'/&gt; &lt;gl enable='yes'/&gt; &lt;/graphics&gt; ... &lt;video&gt; &lt;model type='none'/&gt; &lt;/video&gt; ... &lt;hostdev mode='subsystem' type='mdev' managed='no' model='vfio-pci' display='on'&gt; &lt;source&gt; &lt;address uuid='db10f5f6-0546-4c1c-96c7-1ffe204ae6ce'/&gt; &lt;/source&gt; &lt;address type='pci' domain='0x0000' bus='0x05' slot='0x00' function='0x0'/&gt; &lt;/hostdev&gt; &lt;hostdev mode='subsystem' type='pci' managed='yes'&gt; &lt;driver name='vfio'/&gt; &lt;source&gt; &lt;address domain='0x0000' bus='0x01' slot='0x00' function='0x0'/&gt; &lt;/source&gt; &lt;address type='pci' domain='0x0000' bus='0x09' slot='0x00' function='0x0' multifunction='on'/&gt; &lt;/hostdev&gt; ... &lt;/devices&gt; ... &lt;qemu:commandline&gt; &lt;qemu:arg value='-acpitable'/&gt; &lt;qemu:arg value='file=/home/ndoskrnl/Work/SSDT1.dat'/&gt; &lt;qemu:arg value='-set'/&gt; &lt;qemu:arg value='device.hostdev0.x-igd-opregion=on'/&gt; &lt;qemu:arg value='-set'/&gt; &lt;qemu:arg value='device.hostdev0.ramfb=on'/&gt; &lt;qemu:arg value='-set'/&gt; &lt;qemu:arg value='device.hostdev0.driver=vfio-pci-nohotplug'/&gt; &lt;qemu:arg value='-set'/&gt; &lt;qemu:arg value='device.hostdev0.romfile=/home/ndoskrnl/Work/vbios_gvt_uefi.rom'/&gt; &lt;/qemu:commandline&gt;&lt;/domain&gt;","link":"/zh-cn/computer/2020/kvm/"},{"title":"linux-usage","text":"一份我的 Linux 手扎 A paper of my Linux gists linux命令 sed 从Next的Katex行内式 $...$ 迁移到Icarus的Katex行内式 \\\\(...\\\\) 1$ sed -i 's,\\$\\([^$]*\\)\\$,\\\\\\\\(\\1\\\\\\\\),g' file.md grep 根据文件内容搜索文件 1$ grep -iRl &quot;your-text-to-find&quot; ./ rsync 拷贝文件, 保留所有信息1$ rsync -aXHAv -P $SOURCE_DIR/ $TARGET_DIR/` 仅复制, 不保留权限1$ rsync -rlt -P --no-owner --no-group --no-perms $SOURCE_DIR/ $TARGET_DIR/ 同步文件夹(小心, 有–delete参数, 会删光目标文件夹多余的文件)1$ rsync -aXHAz -v -P --exclude={&quot;filename1&quot;,&quot;path/to/filename2&quot;} --delete $SOURCE_DIR/ $TARGET_DIR/ ss ss is a member of iproute tools set ss has only 22 parameters 列出套接字统计 1$ ss -s 查看端口占用 1# ss -nlptu | grep &lt;端口号&gt; dd 备份GPT分区表 1# dd if=/dev/sda of=gpt-partition.bin bs=512 count=34 恢复GPT分区表 1# dd if=gpt-partition.bin of=/dev/sda bs=512 count=34 生成随机密码 生成20个长度为12的 含大写字母 -c , 数字 -n , 符号 -y , 完全随机 -s 的密码 1$ pwgen -cnys 12 20 Recursively chmod all directories except files To recursively give directories read&amp;execute privileges: 1# find /path/to/base/dir -type d -exec chmod 755 {} + To recursively give files read privileges: 1# find /path/to/base/dir -type f -exec chmod 644 {} + Reference from StackExchange 带排除项删除文件和目录 12# shopt -s extglob #打开extglob模式# rm -fr !(filename) SWAP file 123# truncate -s 0 /swapfile# chattr +C /swapfile# btrfs property set /swapfile compression none ssh-keygen 查看某个 key 的公钥指纹12$ ssh-keygen -l -f &lt;/path/to/ssh/key&gt;$ ssh-keygen -l -E md5 -f &lt;Your key&gt; # MD5 格式 修改某个 key 的 Comment1$ ssh-keygen -c -C &lt;Your comment&gt; -f &lt;Your key&gt; 输出某个 key 的公钥格式1$ ssh-keygen -y -f &lt;Your key&gt; 泛域名证书 1$ certbot certonly --preferred-challenges dns --manual -d *.example.com Kernel interface 获取uuid1$ cat /proc/sys/kernel/random/uuid 查看熵池1cat /proc/sys/kernel/random/entropy_avail 查看电池电量1$ cat /sys/class/power_supply/&lt;Your battery name&gt;/capacity iptables 透明代理(TPROXY) 12345678910111213141516171819202122232425# 设置策略路由ip rule add fwmark 1 table 100ip route add local 0.0.0.0/0 dev lo table 100# 代理局域网设备iptables -t mangle -N V2RAYiptables -t mangle -A V2RAY -d 127.0.0.1/32 -j RETURNiptables -t mangle -A V2RAY -d 224.0.0.0/4 -j RETURNiptables -t mangle -A V2RAY -d 255.255.255.255/32 -j RETURNiptables -t mangle -A V2RAY -d 192.168.0.0/16 -p tcp -j RETURN # 直连局域网，避免 V2Ray 无法启动时无法连网关的 SSH，如果你配置的是其他网段（如 10.x.x.x 等），则修改成自己的iptables -t mangle -A V2RAY -d 192.168.0.0/16 -p udp -j RETURN # 直连局域网iptables -t mangle -A V2RAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 # 给 UDP 打标记 1，转发至 12345 端口iptables -t mangle -A V2RAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 # 给 TCP 打标记 1，转发至 12345 端口iptables -t mangle -A PREROUTING -j V2RAY # 应用规则# 代理网关本机iptables -t mangle -N V2RAY_MASKiptables -t mangle -A V2RAY_MASK -d 224.0.0.0/4 -j RETURNiptables -t mangle -A V2RAY_MASK -d 255.255.255.255/32 -j RETURNiptables -t mangle -A V2RAY_MASK -d 192.168.0.0/16 -p tcp -j RETURN # 直连局域网iptables -t mangle -A V2RAY_MASK -d 192.168.0.0/16 -p udp ! --dport 53 -j RETURN # 直连局域网，53 端口除外（因为要使用 V2Ray 的 DNS）iptables -t mangle -A V2RAY_MASK -j RETURN -m mark --mark 0xff # 直连 SO_MARK 为 0xff 的流量(0xff 是 16 进制数，数值上等同与上面V2Ray 配置的 255)，此规则目的是避免代理本机(网关)流量出现回环问题iptables -t mangle -A V2RAY_MASK -p udp -j MARK --set-mark 1 # 给 UDP 打标记,重路由iptables -t mangle -A V2RAY_MASK -p tcp -j MARK --set-mark 1 # 给 TCP 打标记，重路由iptables -t mangle -A OUTPUT -j V2RAY_MASK # 应用规则 参考来源 IPSET u32 匹配 判断一个包的 TCP Seq 的最后一个值是否等于 41 : 0&gt;&gt;22&amp;0x3C@ 4 &amp;0xFF=0x29 举个例子(可以用 WireShark 抓包): 123456Source IP: 121.41.89.52= 01111001 00101001 01011001 00110100B = 79 29 59 34H = 2032752948DIP Header：45 00 00 3c 00 00 40 00 31 06 ef 34 **79 29 59 34** c0 a8 c7 81TCP Header：00 50 95 3c 8d 7f 52 ac 69 15 33 be a0 12 71 20 cd dc 00 00 02 04 05 14 04 02 08 0a 08 c8 62 fa 00 1c 30 a1 01 03 03 07 0&gt;&gt;22 的含义是从 IP 报头的 0 下标取 4 字节(共 32 位, u32 默认取 4 字节), 然后按位右移 22 位, 从而得到剩余的开头 10 位. 如 45 00 00 3c = 0100 0101 0000 0000 0000 0000 0011 1100 右移 22 位 得到 1 14 = 01 0001 0100 后面的 &amp;0x3C 的含义是和 0x3C = 0011 1100 进行按位与运算(实际上就是过滤) 因此本例中 0&gt;&gt;22&amp;0x3C 即 01 0001 0100 &amp; 00 0011 1100 得到 00 0001 0100, 通过这两个操作我们得到了 IP 头的第 4~7 位的值 记录 IP 头长度的值是 IP 头的第 4~7 位的值值再加两个 0 也就是 01 0100 (十进制的 20) @ 的含义是根据左边的值推进指针, 本例中 0&gt;&gt;22&amp;0x3C@ 即推进 20 个字节 剩下的也没什么好说的了, 从 TCP 头第 4 下标处取 4 字节然后用掩码 0xFF 按位与取得其中的最后一个字节, 然后比较是否等于 0x29 = 41D 等号后可以是单个值也可以是一个区间, 如判断一个包的 TCP Seq 的最后一个值是否在 41~60 之间 0&gt;&gt;22&amp;0x3C@ 4 &amp;0xFF=0x29:0x3C bash if 判断 12345678910111213141516171819202122232425262728293031323334# 用于数字判断-eq 相等-ne 不等-gt 大于-ge 大于等于-lt 小于-le 小于等于# 用于文件判断-r 可读-w 可写-x 可执行-f 是否是标准文件-d 是否是目录-c 是否是字符特殊文件-b 是否是块特殊文件-s 文件大小非0时为真-t 当文件描述符(默认为1)指定的设备为终端时为真# 用于字符串判断string1 = string2 and string1 == string2 - The equality operator returns true if the operands are equal. Use the = operator with the test [ command. Use the == operator with the [[ command for pattern matching.string1 != string2 - The inequality operator returns true if the operands are not equal.string1 =~ regex- The regex operator returns true if the left operand matches the extended regular expression on the right.string1 &gt; string2 - The greater than operator returns true if the left operand is greater than the right sorted by lexicographical (alphabetical) order.string1 &lt; string2 - The less than operator returns true if the right operand is greater than the right sorted by lexicographical (alphabetical) order.-z string - True if the string length is zero.-n string - True if the string length is non-zero.# 逻辑判断-a 与-o 或! 非 字符串变量匹配 12345678910::x 正数时从左往右截取x个, 负数时从右往左截掉x个:x 从x开始截取后面所有内容, 负数时 :(-x) 或者 : -x 从右往左截取所有内容:x:y 从x开始截取y个字符${food:-Cake} 若 $food 不存在则输出 &quot;Cake&quot;STR=&quot;/path/to/foo.cpp&quot;echo ${STR%/*} # /path/to % 是从右向左截去, 单个 % 是非贪婪模式, echo ${STR#*/} # path/to/foo.cpp # 是从左向右截去, 单个 # 是非贪婪模式, echo ${STR%.cpp} # /path/to/foo 两个 %% 是贪婪模式echo ${STR##*.} # cpp 两个 ## 是贪婪模式 ssh-agent 自启动 参考 Archlinux Wiki Windows用户见Github Docs Github SSH 测试 先添加ssh key: 快捷通道 然后: 1$ ssh -T git@github.com GitHub 的 SSH 密钥指纹 以下是 MD5 格式(十六进制格式): 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 (RSA) ad:1c:08:a4:40:e3:6f:9c:f5:66:26:5d:4b:33:5d:8c (DSA) 以下是 SHA256 格式(base64 格式): SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8 (RSA) SHA256:br9IjFspm1vxR3iA35FWE+4VTyz1hYVLIE2t1/CeyWQ (DSA) GIT 常用命令 友好地输出日志:1$ git log --graph --oneline --decorate --all 输出最近一次commit及diff格式的改动:1git log --cc -1 查看commit间的修改12git diff HEAD HEAD~git diff HEAD^! --stat 撤销对某个文件的更改12345# 工作区$ git checkout -- &lt;file&gt; # unstaged changes$ git reset HEAD &lt;file&gt; # staged changes# 缓存区$ git restore --staged &lt;file&gt; 撤销合并 移动HEAD指针(有人在此间隔提交可能会丢失更改) git reset --hard HEAD~&lt;n&gt; 新建一个revert提交(适用于多人合作) git revert &lt;Commit ID&gt; Git SSH 协议代理 ~/.ssh/config1234ProxyCommand nc -v -x 127.0.0.1:1080 %h %p# 或者 socat (http代理)ProxyCommand=socat - PROXY:127.0.0.1:%h:%p,proxyport=1080 更好的Submodule 使用git-subrepo 然后使用git subrepo为开头 还可将子目录变为子仓库: 1$ git subrepo init &lt;subdir&gt; [-r &lt;remote&gt;] [-b &lt;branch&gt;] [--method &lt;merge|rebase&gt;] Git LFS https://zzz.buzz/zh/2016/04/19/the-guide-to-git-lfs/ Git Cherry-pick git cherry-pick用于把另一个本地分支的commit修改应用到当前分支 假设dev分支有一个hash为38361a68的commit 12$ git checkout master$ git cherry-pick 38361a68 Git Format-patch 两个commit间的修改(包含两个commit) 1$ git format-patch &lt;r1&gt;..&lt;r2&gt; 单个commit 1$ git format-patch -1 &lt;r1&gt; 从某commit以来的修改(不包含该commit) 1$ git format-patch &lt;r1&gt; 应用.patch文件 1$ git am 0001-xxxx.patch 限制 git-gc 的内存占用 123$ git config --global pack.windowMemory &quot;100m&quot;$ git config --global pack.packSizeLimit &quot;100m&quot;$ git config --global pack.threads &quot;1&quot; X11vnc startup With SDDM and SSH Tunnel. Please be aware that this command need to be executed on client-side. 1ssh -t -L 5900:localhost:5900 &lt;REMOTE HOST&gt; 'sudo x11vnc -localhost -display :0 -auth $(find /var/run/sddm/ -type f)'","link":"/zh-cn/computer/2020/linux-usage/"},{"title":"make-a-risc-v-cpu","text":"如何造一个RISC-V架构的CPU Bit Extender 和 Splitter 都可以用来扩充地址以使信号兼容高位宽线路, 此外, Splitter 可裁剪数据以使电路兼容低位宽线路, 如程序计数器 二进制 可按4位二进制对应1位16进制, 从右往左转换为16进制数 0对应0V (地线), 1对应5V 逻辑门 MOSFET, 全称 金属-氧化物半导体场效应晶体管, 分为N型和P型, 是组成逻辑门的基本元件 有栅极 G, 漏极 D, 源极 S 三个端口 P型 输入0导通 输入1则断开, (有个小圈圈的是P型) N型 输入1导通 输入0则断开 (在Logisim就叫Transistor) 8种逻辑门实现: 附文件: Logic_gate_implemented_by_mosfet.circ CPU 组成 ALU 全称 Arithmetic &amp; Logic Unit 算术和逻辑单元 CPU中用来计算加减乘除的单元 由加法器, 减法器, 乘法器, 除法器, 多路复用器组合而成 ALUSel: 0000 加法(add) 0001 and 0010 or 0011 xor 0100 shift logical right(srl) 0101 shift arithmetic right(sra) 0110 shift logical left(sll) 0111 compare less than(slt) 1000 除法(div) 1001 求余(rem) 1010 正数乘法(mul) 1011 正数乘法(后32位)(mulh) 1100 减法(sub) 1101 直接输出B(bsel) 1110 我还不知道 1111 我还不知道 加法器 元件符号: 半加法器无法处理前者输出的进位 所以在半加法器基础上再加一个加法器, 以处理上一个加法器输出的进位 即前一个加法器处理 A+B=Sum , 后一个半加法器再处理 Sum+Carry 具体实现: 附文件: Half_adder_and_full_adder.circ 减法器 减法器可由一个加法器加上另一个加法器和一个非门得到 原理: (假设加法器只有4位) 5-4=5+(-4)=1=0B0001 将 -4 视为正数 4 然后按位取反再加一(称为二补数): 4 -&gt; 0100 , 取反得 1011 , 1011+1=1100 将 5 和 0B1100 相加: 0B1100+0B0101=0B0001 (最高位溢出) 此时可以发现, 5+4的二补数 的结果正好等于 5-4 的结果 有符号数的最高位被用来表示符号位. 如4位的系统中, 0000~0111 代表0~7 这8个正数; 1000~1111代表 -8~-1 这8个负数 有符号数(Signed number): 能表示正数和负数 无符号数(Unsigned number): 只能表示负数 乘法器 乘法器的本质是移位加法 举个例子: 5x7=35=0101x0111=0010 0011 从被乘数的最低位开始，如果第 i 位为 1，则乘数左移 i 位后与之前的值相加，若 0 则不动，直至被乘数的最高位 0101x0111=(第0位为1) 0111&lt;&lt;0 + (第1位为0) + (第2为为1) 0111&lt;&lt;2 + (第3位为0) 为什么能成立呢? 可以这样: 5x7=7+7+7+7+7=7+4x7=7x2^0+7x2^2=7&lt;&lt;0+7&lt;&lt;2 除法器 除法器的本质是移位加减(和平时算除法的方式是一样的) 举个例子: 74 / 8 = 9 = 1001010 / 1000 = 1001 0100 1010 将除数移到高位: 1000 0000 然后将被除数减去当前除数: (0100 1010 - 1000 0000) &lt; 0 若减去后小于零, 商左移补0一位, 然后除数右移一位, 此时: 商=0 除数=0100 0000 将被除数减去当前的除数: 0100 1010 - 0100 0000 = 0000 1010 若减去后打于零, 商左移补1一位, 然后除数右移一位, 此时: 商=01 除数=0010 0000 以此往复, 直到被除数变为0(移了8位), 或者被除数减去当前除数结果为0 多路复用器 Multiplexer 多路复用器, 简称 Mux 通过控制 Sel 以输出 A, B, C, D 之中其中一路的值 具体实现: 附文件: Four_way_multiplexer.circ 寄存器 (别去管它一开始的状态是怎样的) 寄存器由 8 个 D 触发器构成 触发器=锁存器+时钟信号的调控 S-R 触发器 S-R 代表 Set-Reset D 触发器 D 代表 Data 将时钟上沿信号直接接到Enable端口上, 数据的更改受到时钟信号调控, 然而不能长期保存数据 寄存器 在时钟信号这边另加一个与门和端口, 这样就可以决定是否放行时钟信号, 从而防止数据被时钟信号刷掉 具体实现: 附文件: Four_way_multiplexer.circ RAM 然后是底层原理: Logisim中无法直接模拟DRAM, SRAM我试过也不行 横着的线称为字线(wordline), 用于启用指定地址下的8个内存单元 竖着的线称为位线(bitline), 负责数据的输入和输出 解码器(Decoder)负责根据输入的内存地址开启对应的字线 附上解码器(Decoder)的具体实现 附文件: 2_bit_Decoder.circ 附上一个RAM的使用示例: 文件: RAM_example.circ 程序计数器 程序计数器用于指向当前指令(IMEN)内存中的地址 时钟每上沿一次, 计数+4(内存中一条字线管理32位数据, 也就是4个字节) 具体实现: Program_Counter.circ RISC-V 架构 指令抓取 -&gt; 指令解码 -&gt; 执行 -&gt; 内存操作 -&gt; 回写 结构 RISC-V架构(按先后顺序排列: PC寄存器: 存储在指令内存中, CPU当前执行的位置 指令内存(IMEM): 储存需要运行的指令, 程序运行时, 数据不能够被更改 32个寄存器(reg0~reg31): 储存程序运行时的一些临时变量 ALU: 逻辑与数学运算 数据内存(DMEM): 负责存储较大的数据, 程序运行时能够被读写 以上模块构成了RICV-V的数据管线(Data Pipeline) 控制单元(Control Unit): 充当&quot;阀门&quot;, 负责协调以上模块 指令集(Instruction Set): 特定架构下CPU实现的一套操作, 如加减法, 指令集 核心指令格式 规定了所有指令集需要参照的格式(见表格): RISC-V中, 单条指令长度固定32位, 有六个基本类型(R I S SB U UJ) opcode: 规定指令内容(类似于编程中的函数符号, 如func(var1, var2) ), 7位. rd: 目标寄存器(Destination reg), 指定指令结果存储到哪个寄存器中, 5位(对应32个寄存器). 而 S, SB 这两种没有规定 rd, 说明这两种指令操作不会产生新的值(类似于编程中没有返回值的函数). rs1 和 rs2: 来源寄存器(source reg), 类似于函数的参数 如 a+b=c 中, rs1 对应 a, rs2 对应 b, rd 对应 c funct3和funct7: 函数(function), 3代表3位, 7代表7位, 作用是定义函数的实现(如规定a?b是加法 a+b 还是减法 a-b) imm: 立即数(immediate value), 类似于常数(如 a+4=c 的 4) RV64I 基础指令 注意: RISC-V 虽然有32个寄存器, 但寄存器 x0 的值恒为 0, 这是因为 0 这个数经常被用到, 如将 x1 初始化为 0 可用 addi x1, x0, 0 图中用的是Verilog, 一种逻辑描述语言, 若你懂些英文, 建议看一看再读下面的内容 Verilog_for_61C.pdf 汇编语言的格式: add x1, x2, x3 , x1 代表 rd, x2 代表 rs1, x3 代表 rs2 addi x1, x2, 5 , 5 是立即数(或者叫常数) 一些指令的解释: add 和 addw 这样的指令实现的是相同的操作, 区别在于带 ‘w’ 后缀表示与32位兼容(只使用64位寄存器的前32位) jal: 将指令指针从当前位置往后跳 imm/2 行(为什么除2而不是4, 因为有短指令, 具体看下面). 从表中看到, 它的定义是 R[rd]=PC+4; PC=PC + {imm,1b’0}, 由分号分隔, 说明这个指令有两个步骤. 第一步是将(本来要执行的)指令地址储存到 rd 中(方便那边的指令执行完毕后跳转回来) 第二步是修改PC寄存器, 同时赋值的 imm 左移补一个 0 (至于为什么要补一个0而不是两个0, 因为RISC-V虽然一般的指令长度是32位(4字节), 但它也支持16位的短指令, 所以跳转的最小值实际上是2. 你会发现, imm每次+1, 因为后面补了一个0, 实际上+1就变成+2了, 补两个0就是+4) 有些时候, 若某个程序比较大, 以至于需要跳转的行数特别大(jal-&gt;属于UJ指令-&gt;imm最大20位-&gt;最大跳转长度 2^20), 无法直接跳转, 就需要组合技 auipc + jalr auipc 后面的 imm 补了12个0(换算成十进制是4096 -&gt; 往后跳 imm * 1024行), 可以表达很大的跳转行数, 但不会实际执行, auipc 只是将计算后的地址储存到 rd 中. jalr 是从寄存器取得指令内存地址, 并加上 imm/4 行(jalr 的 imm 竟然没有补0)后赋值到PC, 同样的, 将(本来要执行的)指令地址储存到 rd 中以方便跳转回来. 示例(我要将PC地址跳1024+5行, 并将回跳地址保存在寄存器 x2): auipc x1, 1 jalr x2, x1, 20 从指令集到机器代码 机器代码是指令实际储存在内存中的样子 举个例子: addi x1, x0, 1 要将他转化为机器码, 需要查表(本章开局那里)得到addi的参数: type: I opcode: 0010011 funct3: 000 因为addi是I型, 根据Core Instruction Formats的定义将这句汇编代码翻译成机器码: 31 20 19 15 14 12 11 7 6 0 000000000001 00000 000 00001 0010011 为了方便可以转成16进制: 0x00100093 CPU实现 附上一个花了我三天的CPU实现, 参考了 T-K-233 的设计, 一些地方略有不同 risv_v_simple.circ","link":"/zh-cn/computer/2020/make-a-risc-v-cpu/"},{"title":"my-software-configuration","text":"配置文件整合 linux SSH:.ssh/config123456789101112131415161718Host * # 每隔 30s 向远端发送 keep-alive 包, 如果发送 5 次无回应断开连接。 ServerAliveInterval 30 ServerAliveCountMax 5 # ssh代理设置, 请使用 openbsd-netcat ProxyCommand nc -v -x 127.0.0.1:1080 %h %p # 压缩流量 Compression yes # 多个 ssh 会话共享同一个连接, 减少重复连线的时间 ControlMaster auto ControlPath /tmp/ssh-%r@%h:%p # 延长连接有效时间 ControlPersist 30m# github的密钥配置Host github.com User git IdentityFile ~/.ssh/id_ed25519.key Bash: ~/.bashrc Zsh: ~/.zshrc Aria2: aria2.conf sysctl/etc/sysctl.d/99-sysctl.conf123456# BBR TCP Congestionnet.core.default_qdisc = cakenet.ipv4.tcp_congestion_control = bbr# Kernel Panic auto reboot after 30 minuteskernel.panic = 3780 Windows 10/11 禁用遥感 组策略:1234Administrative Templates -&gt; Windows Components -&gt; Data Collection and Preview Builds -&gt; Allow Telemetry -&gt; Enabled, Options: 0 - Security [Enterprise Only] 计划任务:12345Task Scheduler Library -&gt; Microsoft -&gt; Windows -&gt; Application Experience -&gt; Microsoft Compatibility Appraiser -&gt; Disable 禁用 Connected User Experiences and Telemetry1Set-Service DiagTrack -StartupType Disabled 启用UTC1reg add &quot;HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_QWORD /f 参考 Archlinux Wiki 禁用英特尔CPU幽灵/熔断/僵尸负载漏洞补丁12reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management&quot; /v FeatureSettingsOverride /t REG_DWORD /d 3 /freg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management&quot; /v FeatureSettingsOverrideMask /t REG_DWORD /d 3 /f 参考 Microsoft Docs 任务栏时间显示秒钟1reg add &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced&quot; /v ShowSecondsInSystemClock /t REG_DWORD /d 1 /f 默认使用半角标点符号(全角/半角切换: Ctrl+.)12345678Time &amp; Language -&gt; Language -&gt; Chinese (Simplified, China) -&gt; Microsoft Pinyin -&gt; Options -&gt; General -&gt; Use English punctuations when in Chinese input mode: On Scoop installed git bash: “Open Git Bash” here context menu git-install-context.reg git-uninstall-context.reg Windows 11 full right-click menu enable: reg add &quot;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32&quot; /f /ve disable: reg delete &quot;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}&quot; /f Don’t forget to reboot. reference: https://gist.github.com/nebula-moe/75c49c261d1fc9e780df8ed9d0baed97 MPV 放入 portable_config/mpv.conf MPV的配置 针对上网本注释了了一些占用高的选项 TODO: 可能的一份更好的配置 为了区别化特意用 #@# 标记出了我做的注释 mpv.conf 额外的文件: 脚本 portable_config\\scripts\\auto-profiles.lua shaders文件 portable_config\\shaders\\, 请自行取消我的注释以启用shaders KrigBilateral.glsl nnedi3-nns32-win8x4.hook nnedi3-nns64-win8x4.hook SSimDownscaler.glsl SSimSuperRes.glsl 此配置fork于@cczzhh的配置 记录小米路由器3G 的 Openwrt 配置 升级Openwrt 使用 sysupgrade 方式升级123# cd /tmp# wget https://downloads.openwrt.org/snapshots/targets/ramips/mt7621/openwrt-ramips-mt7621-mir3g-squashfs-sysupgrade.tar# sysupgrade /tmp/openwrt-ramips-mt7621-mir3g-squashfs-sysupgrade.tar 升级完后最好更新以下新版本系统的软件包123# opkg update# opkg list-upgradable# opkg list-upgradable | sed -e &quot;s/\\s.*//&quot; | while read PKG_NAME; do opkg upgrade &quot;${PKG_NAME}&quot;; done 安装的软件包123456789nanodiffutilshtopopenssh-sftp-server # if default ssh server dropbear cannnot connectluci-sslluci-theme-materialluci-app-upnpluci-app-wolluci-app-mwan3 Hexo Config:hexo/_config.yml12345678910111213141516171819202122232425262728293031323334353637# 标签页标题title: Ndoskrnl's blogdescription: 'There is nothing to say now'author: Ndoskrnl# 多语言支持language:- zh-cn- en# 时区timezone: 'Asia/Shanghai'# Urlurl: http://blog.ndoskrnl.net# 文章永久链接(目录)permalink: :lang/:category/:year/:title/# 永久链接变量默认值配置permalink_defaults: lang: en# 新文章文件目录new_post_name: :lang/:category/:title.md# 资源文件夹post_asset_folder: true# 主题theme: icarus# 解决半角符号渲染成全角的问题marked: smartypants: false# 部署到 Github Pagesdeploy: type: git repo: git@github.com:ndoskrnl/ndoskrnl.github.io.git branch: master Icarus 主题设置 主题设置由于改动较多且时效性不高, 这里不作记录 具体请见主题配置文件 theme/icarus/_config.yml 将主页样式变为归档页形式: 直接将theme/icarus/layout/index.jsx 替换成 theme/icarus/layout/archive.jsx 内的内容 Git Hook/home/git/blog.git/hooks/post-update1234567891011121314151617181920212223242526#!/bin/bash# 首先删除旧文件# 启用extglob才能用!(xx)之类的语法shopt -s extglobrm -rf /srv/git/www/!(node_modules)# git checkoutgit --work-tree=/srv/git/www --git-dir=/srv/git/blog.git checkout -f# 进入网页文件夹目录cd /srv/git/www# 若node_modules文件夹不存在, 安装依赖插件if [ ! -d /srv/git/www/node_modules ]; then npm installfi# 若package.json有改动, 更新插件CHANGED=$(git --git-dir=/srv/git/blog.git diff HEAD^! --stat -- package.json | wc -l)if [ $CHANGED -gt 0 ]; then rm -rf /srv/git/www/node_modules npm installfi# 生成静态网页hexo g 额外安装的插件123hexo-symbols-count-time # 字数统计hexo-filter-plantuml # UML Diagram for hexohexo-deployer-git # Git 部署 (Github Pages)","link":"/zh-cn/computer/2021/my-software-configuration/"},{"title":"vim-usage","text":"一些 vim 的笔记 u to undo U to restore whole line(this action is not undo, and is undoable) Ctrl-R redo :sp[lit] horizontally split current screen into two windows (with same filebuffer) :vs[plit] vertically split current screen into two windows (with same filebuffer) CTRL-W + &lt;h, j, k, l&gt; jump to another window. d$ delete to end x delete one char dw delete one word(and ’ ') de delete one word(without ’ ') d3w delete three words dd delete one line d2d delete two line o open a line BELOW the cursor and start Insert mode. O open a line ABOVE the cursor. a insert text AFTER the cursor. A insert text after the end of the line. y yanks (copies) text p puts (pastes) it(copied or deleted text). r replace one char R Replace mode until &lt;ESC&gt; is pressed. rx to replace one char with “x” ce change until the end of a word c$ change until the end of line ctrl+g to show your location and the file status G to move to the bottom of the file 501G to move to the 501 lines of the file gg to move to the start of the file v (visual) select text, then you can type d to delete text or save to file with :w FILENAME % press “%” on a bracket can fast move the curser to the matching bracket NOTE: This is very useful in debugging a program with unmatched parentheses! / typing / followed by a phrase searches FORWARD for the phrase. ? Typing ? followed by a phrase searches BACKWARD for the phrase.on n to find the next occurrence in the same direction N to search in the opposite direction CTRL-O takes you back to older positions, CTRL-I to newer positions. NOTE: When the search reaches the end of the file it will continue at the start, unless the ‘wrapscan’ option has been reset. Typing “:set xxx” sets the option “xxx”. Some options are: ‘ic’ ‘ignorecase’ ignore upper/lower case when searching ‘is’ ‘incsearch’ show partial matches for a search phrase ‘hls’ ‘hlsearch’ highlight all matching phrases Prepend “no” to switch an option off: :set noic :help or press &lt;F1&gt; to open a help window. :help cmd to find help on cmd :e ~/.vimrc Create a vimrc startup script to keep your preferred settings. Now read the example “vimrc” file contents: :r $VIMRUNTIME/vimrc_example.vim When typing a : command, press CTRL-D to see possible completions. Press &lt;TAB&gt; to use one completion. command: :s/old/new to substitute ‘new’ for ‘old’ :s/old/new/g to substitute ‘new’ for ‘old’ all occurrence of “thee” in the line :#,#s/old/new/g where #,# are the line numbers of the range of lines where the substitution is to be done. :%s/old/new/g to change every occurrence in the whole file. :%s/old/new/gc to find every occurrence in the whole file, with a prompt whether to substitute or not. :!xxxxx executes an external command (such as :!ls) :w FILENAME writes the current Vim file to disk with name FILENAME :r FILENAME retrieves disk file FILENAME and puts it below the cursor position :r !xxx read the output of the command (such as :r !ls) Explain: d is delete operator motion: w - to the start of the next word e - to the end of the current word $ - to the end of the line ** Typing a number before a motion repeats it that many times. ** Move the cursor to the start of the line below marked —&gt;. Type 2w to move the cursor two words forward. Type 3e to move the cursor to the end of the third word forward. Type 0 (zero) to move to the start of the line\\ dd Due to the frequency of whole line deletion, the designers of Vi decided it would be easier to simply type two d’s to delete a line.","link":"/zh-cn/computer/2020/vim-usage/"},{"title":"windows10-usage","text":"记录一些windows的使用技巧 查看哪些进程正在使用我的摄像头 前往微软文档下载Process Explorer 注意要以管理器权限运行procexp64.exe 具体使用方法: 首先在设备管理器找到摄像头的&quot;物理设备对象名称&quot;, 右键复制 打开 Process Explorer 然后 Ctrl + F, 查询句柄. (这里我打开了mumu模拟器的相机应用) 注意事项: 1. 如果只有svchost.exe而查不到其他使用该句柄的程序, 则一般是某个uwp应用在使用该设备 2. 也可以查看其他设备(如麦克风) 启用 Compact 压缩 123compact /compactos:always # 压缩所有系统文件compact /compactos:query # 查询系统的压缩状态。compact /compactos:never # 取消所有系统文件的压缩 清理组件存储(WinSxS ) 12dism.exe /Online /Cleanup-Image /AnalyzeComponentStore # 查看组件存储大小dism.exe /online /Cleanup-Image /StartComponentCleanup # 执行组件存储清理 Intel ME Firmware 查看 ME 信息1&gt; MEInfoWin.exe 备份 ME 固件1FWUpdLcl.exe -SAVE xxxx.bin 刷写 ME 固件1FWUpdLcl64.exe -f ..\\ME8_1.5M_Production.bin Hyper-V Manager Troubleshoot 首先客户机和宿主机都要启用 WinRM12345678910111213141516PS C:\\Users\\ndoskrnl&gt; Enable-PSRemoting -ForceWinRM has been updated to receive requests.WinRM service type changed successfully.WinRM service started.Set-WSManQuickConfig : &lt;f:WSManFault xmlns:f=&quot;http://schemas.microsoft.com/wbem/wsman/1/wsmanfault&quot; Code=&quot;2150859113&quot;Machine=&quot;localhost&quot;&gt;&lt;f:Message&gt;&lt;f:ProviderFault provider=&quot;Config provider&quot;path=&quot;%systemroot%\\system32\\WsmSvc.dll&quot;&gt;&lt;f:WSManFault xmlns:f=&quot;http://schemas.microsoft.com/wbem/wsman/1/wsmanfault&quot;Code=&quot;2150859113&quot; Machine=&quot;DESKTOP-1KNPPCL&quot;&gt;&lt;f:Message&gt;WinRM firewall exception will not work since one of the networkconnection types on this machine is set to Public. Change the network connection type to either Domain or Private andtry again. &lt;/f:Message&gt;&lt;/f:WSManFault&gt;&lt;/f:ProviderFault&gt;&lt;/f:Message&gt;&lt;/f:WSManFault&gt;At line:116 char:17+ Set-WSManQuickConfig -force+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidOperation: (:) [Set-WSManQuickConfig], InvalidOperationException + FullyQualifiedErrorId : WsManError,Microsoft.WSMan.Management.SetWSManQuickConfigCommand 遇到错误, 用 Set-NetConnectionProfile 将所有网络设置为 Private:123456789101112131415PS C:\\Users\\ndoskrnl&gt; Get-NetConnectionProfileName : Network 5InterfaceAlias : ZeroTier One [83048a06326c5a60]InterfaceIndex : 9NetworkCategory : PrivateIPv4Connectivity : LocalNetworkIPv6Connectivity : LocalNetworkName : Xiaomi_XXXX_5GInterfaceAlias : vEthernet (External Network With Adapter)InterfaceIndex : 16NetworkCategory : PrivateIPv4Connectivity : InternetIPv6Connectivity : InternetPS C:\\Users\\ndoskrnl&gt; Set-NetConnectionProfile -InterfaceIndex 9 -NetworkCategory Private 有时候即使设置了还是会报错, 直接上参数 -SkipNetworkProfileCheck 吧:1PS C:\\Users\\ndoskrnl&gt; Enable-PSRemoting -SkipNetworkProfileCheck -Force 然后再在客户端设置 TrustedHosts1Set-Item WSMan:localhost\\client\\trustedhosts -value &quot;DESKTOP-XXXXXXX.lan&quot; -Force 查看一下确保无错:1Get-Item WSMan:localhost\\client\\trustedhosts 多个主机名可用逗号分隔123$curValue = (Get-Item wsman:\\localhost\\Client\\TrustedHosts).valueSet-Item wsman:\\localhost\\Client\\TrustedHosts -Value `&quot;$curValue, Server01.Domain01.Fabrikam.com&quot;","link":"/zh-cn/computer/2020/windows10-usage/"},{"title":"the-hatch","text":"The bathroom is always a good place to spawn wonderful idea… There was a thought suddenly appeared in my mind when I was washing today: What if we thought economic independence as life environment indenpendent? The target was to build an almostly self-sufficient hatch exclusively to someone in order to give more freedom and soothe his work for survive. In technical deatils the most problem I think is not entropy itself but the energy balance in an enclosed system which means there will no longer have energy transfroms required by ecological cycles. So the only solution is to get energy from external source such as solar sussessively. Now I am seeking more knowkedges about these topics, but for the most urgency things, two which currently. One is to accomplish my linear algebra course which was stucking on chapters relevnce to differential equation and eigenvictor from last June. Another is the graduate design, the issue is that most of the skills required by my design is either not in mastering or (almost) totally a placeholder in it as just heard its definition and application so I then though it might be useful in the design.","link":"/zh-cn/daily-life/2022/the-hatch/"},{"title":"心之里技","text":"A brief report of the current encounter. 我的理智 HRT 是为了缓解性别焦虑 因以下三点因素, 在性别焦虑再次成为关乎个人生存的主要矛盾之前, 暂不考虑 SRS: 父母反对, 不信任父母[1], 对国内多数医生持消极态度. 国内社会中传统观念重男轻女, 工作和学业男性更有优势的大环境. 当前 SRS 技术的客观局限性和我对科技发展的乐观态度. 我的价值观认为 (411医院7万人民币左右的) SRS 的费用应该花在更能为自己带来价值的投资上. 除 HRT 和 SRS 的之外, 我对女性化程度的要求: 由于性别焦虑和抑郁暂时得到控制, 以及外貌 (自己主观认知上认为) 能够pass的前提因素下, 心理处于相对稳定下的我其实并不需要更多刻板性别认知中女性的需求(如服装等); 但相反的, 任何在此稳态下向男性化倾斜的尝试, 都有可能促使性别焦虑继续恶化我的心灵, 从而让心理再次回到不稳定的状态. 我无法判断自己是否能够一直保持理智, 有可能在新的技术出现前自己就实行自切, 因此需要备好届时足够用于恢复的医疗费和去暹罗 SRS 的费用. 否定 性兴奋一定程度上受男性睾酮激素调节作用, 而 HRT 对睾酮的压制便于分析真实性取向. 我一直将手冲时看二次元色图而引发性兴奋的现象的原因归结为我作为生理男性(由于激素调节作用而)对女性身体的本能反应, 由于现实情况是男性通常会因为女性的容貌而喜欢上对方, 我曾认为我的性取向是女性. 但经过数天的思考后, 有两点证据表明也许我从未真正以普通男性的爱慕方式喜欢上某个女性(即因貌生情). 第一点是我在青春期的手冲行为中不自觉地将自己带入到女性角色, 第二点是我在 HRT 后对色图的需求降低, HRT 后的我通常会选择幻想与男票爱爱的方法来引起性兴奋. 因此我重新开始思考, 确定了两点结论. 第一认为能够激发性欲的性别特征只是由于性激素的作用, 第二是否定了性欲对象决定性取向的观念, 自己&quot;喜欢&quot;漂亮女性表面上是睾酮的激素作用引起的性兴奋, 更深层则是源自其容貌的羡慕(即我幻想拥有这样理想的女性身体). 在实际生活中, 那种特殊的感觉往往容易在男性为对象产生, 这也许代表着我更偏向于对男性产生爱慕. (我对父母)很道歉, 但我如今已经难以对女性产生爱慕之情, 连色欲都没有…我又怎么能回应父母的期待, 去找女性结婚生子呢. 注: (非 HRT 情况下的) MtF 会因睾酮的作用对女性的美貌产生普通男性一样的性兴奋, 但她们往往会在手冲时将自己带入到这样的女性身体中. 对于我来说, 手冲结束后往往会产生一种非常厌世的感觉, 以及暂时性地出现相当程度的对自己男性身体的厌恶感. 推论: 以前面对女性的紧张可能是由于性别焦虑导致的自卑(面对自己不是生理女性的自卑)和容貌焦虑. 否定之否定 如今翻看 18 年写在 Iphone5s 上的小目标, 幼稚的意义大抵是如此. 15-20年间的我是通过不断否定15岁前的我来获得精神上的成熟, 20年离开&quot;学校&quot;后, 我开始与外面的世界进行交互, 那时候我定了一些目标, 觉得可以通过自己的努力过上相对不错的生活. 只可惜20年12月的那一次性别焦虑的失控造就了数月糟糕的精神状态, 在这种状态下, 我的大脑几乎学不进任何东西. 在孤独与痛苦的间隙, 我通过网络不断了解到这个群体相关的信息, 在这样的内在与外在因素的催化下, 我的观点在数月间迅速变化着, 也许我也能否定半年前的自我了. 如今, 否定我作为男性角色的GD更是再一次否定了我的理智, 我已经快要控制不住那些想要伤害自己的冲动了. 生或是死? 理想? 世界宏观上是复杂而不完美的, 这就有了能动的改造世界的目的, 而实现梦想根本前提是主体的存活及其机体的健康. 世界是离散而不连续的, 也许世界是可知的, 我不相信毫无根据的死后世界描绘, 我要活着看到一切的解释. 我想去宇宙探索, 我梦想成为一名星际探险家. 社交行为准则 在原先我都是通过直接私聊的方式来发送节日(或其他针对个人的)祝福的, 这也许不是最好的办法, 一方面有些人可能会遇到刷屏的困扰甚至是反感, 另一方面这对我也是蛮累的(如果手动一个一个发的话). 因此目前的方案是: 对于节日, 通过公共空间(如推特、QQ空间)广播祝福即可. 对于针对个人的具体事件祝福, 仅限于在想起(有这回事)+有意向(心情愉悦)+对方明确发布了值得祝福的内容(如生日、结婚等)+对方不曾明确表达谢绝此类祝福这四种条件都满足的情况下进行针对性私聊祝福. 在融入环境之前, 尽量少说话 (控制住, 说话前组织好语言, 不要把心里的话直接说出来, 不要在顿悟时突然很大声地发出&quot;啊&quot;). 目前遇到的困境是与他人进行口头交流时, 往往会陷入到自己的思考中自言自语, 而忽视对话环境和他人的感受. 我觉得根本原因是因为自己太急了, 说话前不动脑子直接就脱口而出了. 因此我打算耐住性子, 更多地参与到旁听的角色中, 尝试着找到那种不错的状态(思想上迎合话题, 心理上成熟稳重, 把幼稚的话憋在肚子里). 我的口语表达能力也有待提高, 说实话, 在口头交流中我描述一件事物的能力超级烂… 我觉得IM群组中的闲聊既浪费时间又毫无价值可言. 因此, 我不再在各个群组聊天中活跃. 独立生活和SRS难度的探讨 个人观点: Time is in our side. 只要人还在国内, SRS其实还是晚点做比较好(更别说以后还有可能会出现技术进步, 一步到位总比再做一次SRS2.0省钱省精力还少受罪), 有这时间好好学习积攒实力总比进厂干苦力强. 目前的主要工作是要处理好和家庭的关系, 毕竟能有父母的帮助, 谁会独身一人自力更生呢. 另一方面, 对SRS的渴望几乎完全取决于GD的严重程度, 如果违背其意愿促使其继续恶化我的心里健康, 自己可能什么蠢事都做得出来, 包括离家出走. (举个例子, 在12月中旬之前我从没有这么强烈的要自切的想法. 在这之前SRS也是只是一件可选项, 但现在我感觉到我如果要继续活着的话, SRS也许是必经之路.) 前提: 假设没有任何学历和技能基础, 只能进厂打工, 工作地点限定在苏州地区(其实武汉那边听说还不错). 如果是在外面租房: 苏州最低的平江区租房价格平江区在1150元左右[2], 合租的话就是大约575元每个月. 只用自己交水电费, 非商用每个月水电费大概180元(夏季). 一年下来9060. 如果是在厂里住宿: 只用自己交水电费, 商用电费加上水费算他200元(夏季). 一年下来顶多2400. 好一点的厂还能平均有25cny一个小时, 每天从早上8点干到晚上8点, 10个小时能有250cny. 包三餐. 做6休1, 一周能有1500. 一年工作日251天能有62750cny. (除去节假日三倍工资, 很多厂其实不让你节假日来上班.) 实际可能比这还少, 不过基本上苦干一年半差不多有够在411做SRS的钱. References ^ \"极其失望. 我重大的人生转折有两个, 一次是初三下学期, 他们在专业的心理咨询和山东戒网瘾学校之间选择了后者; 另一次是我选择职业院校, 他们帮我选择了'洛伍德', 在那里我度过了在 Campus 的五年, 毕业后我不觉得我领到了毕业证书.\" Said 2022-02-23. ^ \"苏州租房价格-安居客\". su.zu.anjuke.com. Retrieved 2021-12-24.","link":"/zh-cn/daily-life/2020/tricks-of-heart/"},{"title":"water-purifier","text":"一份 DIY 净水器需要的零件单 TODO: 优化格式 配件单 汇通RO膜 75G, 型号ULP1812-75 45元 GVE冠宇达电源24V电源, 型号GM48-240200-D, 接口为DC圆头5.5mmx2.5mm 29.9元 CNKB科博高压开关, 型号HPS-1 9元 CNKB科博冲洗电磁阀300CC, 型号FPD-360M30 13.8元 GBN逆止阀, 型号LDK2K2 5元 三角洲75G增压泵, 型号EC-103-75 92元 CNKB科博进水电磁阀, 型号FPD-360L30 12.8元 CNKB科博低压开关, 型号LPS-1 9元 乐透3.2G压力桶, 型号NPTK-3.2G 55元 DNT迪恩特2分快接球阀 1.9元 10寸滤瓶扳手 1.2元 2分CCK管x20米 11.8元(0.59元/米) 2分PE管剪刀 2.8元 DNT迪恩特2分快插弯头x15 7.5元(0.5元/件) DNT迪恩特2分T型三通x3 1.8元(0.6元/件) RO五级挂板 15元 乐透后置活性炭滤芯T33 15元 RO反渗透膜壳1812型(送3个2分快接头) 9.8元 10寸2分口滤瓶x3(两白一透明) 54元(18元/件) DNT迪恩特2分外丝转二分管x6 2.4元(0.4元/件) 10寸前三级通用滤芯(PPF棉、UDF颗粒活性炭,CTO压缩活性炭) 19.8元 1812型大单夹x2 0.8元(0.4元/件) RO膜壳扳手 1元 1812型子母夹x2 0.8元(0.4元/件) 家用净水器电脑版电源母插头(2.5mm的头) 1.2元 家用净水器电脑版 29元 2分一体合金三通阀门(送生料带) 5.5元 304不锈钢外六角十字三组合螺丝10只 3.8元 合计456.6元 提示 一般来说, 前置第一级3个月一换, 二三级6个月一换. 陶氏跟杜邦合并了, 国产杜邦用了陶氏的技术, 性价比最高(淘宝搜杜邦陶氏1812-75只要89)","link":"/zh-cn/daily-life/2021/water-purifier/"},{"title":"Introduction-to-the-Basic-Principles-of-Marxism","text":"马克思主义基本原理概论 现实主义者只会在旧的思潮和旧的制度里为将死之人和自己的既得利益哀鸣, 为自己狭隘的世界观和价值观做无用的辩驳. 他们固步自封腐朽僵化, 对曾经发生的事实和未来要发生的变革视而不见, 或者视而不承认见过. 未来是属于理想主义者的, 理想主义者知道曾经发生过的事实, 相信人性和人类的无限可能, 并在前辈的指引下继续前行. 马克思主义是关于无产阶级和人类解放的科学 世界的物质性及发展规律 物质及其存在形态. 哲学基本问题及其内容. 近代哲学的基本问题为存在和思维的关系问题. 包含两个方面: 存在和思维谁是世界的本质, 即物质和精神谁第一谁第二. 思维能否正确认识存在, 即思维和存在有无同一性问题. 唯物主义和唯心主义: 唯物主义把世界本原归结为物质, 主张物质第一, 意识第二, 意识是物质的产物; 唯心主义把世界本原归结为精神, 主张意识第一, 物质第二, 物质是意识的产物. (历史唯物主义认为社会存在决定社会意识; 历史唯心主义认为社会意识决定社会存在) 可知论和不可知论: 可知论认为世界是可被认知的, 思维和存在具有同一性; 不可知论认为世界不能部分或完全认识, 否认思维和存在的同一性. 辩证法和形而上学: 哲学除了解释世界本原, 还要回答世界如何存在, 即世上事物是联系还是孤立, 是发展还是静止. 根据对这些问题的回答, 出现了辩证法和形而上学两种不同观点. 辩证法坚持用联系的、发展的观点看世界, 认为发展的根本原因在于事物内部矛盾. 形而上学坚持用孤立的、静止的观点看问题, 否认事物内部矛盾的存在和作用. 马克思主义选择了唯物主义、可知论、辩证法. 物质与意识的辩证关系. 马克思主义的物质范畴及其理论意义. 古代朴素唯物主义从具体物质形态出发说明世界, 近代形而上学唯物主义认为世界的本源是原子, 现代辩证唯物主义总结出了物质的唯一共同本质: 世界的本源是客观实在性 马克思主义的物质观: 坚持唯物主义一元论. 唯物主义一元论认为世界统一于物质; 唯心主义一元论认为世界统一于精神; 唯物主义二元论否定世界的同一性, 认为世界有两个相互平行、各自独立的本原–物质和精神, 是不彻底的哲学, 必然会导向唯心主义. 坚持反映论和可知论, 批判不可知论. 唯物论和辩证法的统一. 形而上学唯物主义包含某些辩证法因素, 但机械性、形而上学性是它的主要特点, 且在社会历史领域仍然持社会意识决定社会存在的唯心主义观点. 唯物主义自然观与唯物主义历史观的统一, 为彻底的唯物主义奠定了理论基础. 物质的根本属性和物质运动的存在形式 物质的根本属性是运动. 运动是标志一切事物和现象的变化及其过程的哲学范畴. 物质和运动是不可分割的. 一方面, 运动是物质的存在方式和根本属性, 物质是运动着的物质. 世界上没有脱离运动的物质, 设想不运动的物质, 将导致形而上学. 另一方面, 物质是一切运动变化和发展过程的实在基础和承担者. 世界上没有离开物质的运动, 设想无物质的运动, 将导致唯心主义. 物质世界的运动是绝对的, 而物质在运动过程中又有某种暂时的静止, 静止是相对的. 静止是物质运动在一定条件下的稳定状态. 运动的绝对性体现了物质运动的变动性、无条件性. 静止的相对性体现了物质运动的稳定性、有条件性. 运动和静止相互依赖、相互渗透、相互包含, “动中有静, 静中有动”, 无条件的绝对运动和有条件的相对静止构成了事物的矛盾运动. 时间和空间是物质运动的存在方式. 时间指物质运动的持续性、顺序性, 特点是一维性; 空间指物质运动的广泛性、伸张性, 特点是三维性. 物质运动总是在一定的时间和空间中进行的, 具体物质形态的时空是有限的, 而整个物质世界的时空是无限的; 物质运动时间和空间的客观实在性是绝对的, 物质运动时间和空间的具体特征是相对的. 一切以时间、地点、条件为转移, 具体问题具体分析, 是马克思主义的活的灵魂. 实践是自然存在与社会存在区分和统一的基础. 从实践出发理解社会本质, 要把握一下两个大的方面: 一方面, 实践是使物质世界分化为自然界与人类社会的历史前提, 又是使自然界与人类社会统一起来的现实基础. 通过劳动, 人类具有了自己实践的存在方式. 另一方面, 实践是人类社会的基础, 是理解和解释一切社会现象的钥匙. 社会生活的实践性主要表现在: 第一, 实践是社会关系形成的基础. 第二, 实践形成了社会生活的基本领域. 第三, 实践构成了社会发展的动力. 世界物质统一性原理及其意义. 实践与认识及其发展规律 资本主义的本质及规律 资本主义的发展及趋势 社会主义社会的发展及其规律 共产主义崇高理想及其最终实现","link":"/zh-cn/ideology-and-politics/2021/Introduction-to-the-Basic-Principles-of-Marxism/"},{"title":"Grammars-for-English-Majors-Band-4","text":"Believe in Yourself Believe in your dreams. Believe that you are loved. Believe that you make a different. Believe we can build a better world. Believe there’s light at the end of the tunnel. Believe that you may be that light for someone else. Believe that the best is yet to be. Believe in yourself. 记录要记忆的东西 语法 语法基本概念 名词与主谓一致 代词 限定词 形容词、副词及比较结构 介词 情态助动词 非谓语动词 名词性从句 定语从句 状语从句 时态与语态 虚拟语气 反意疑问句 倒装与省略 词汇 英语6种主要构词法 派生法(Derivation): 词根是派生词的基础, 在词根前加前缀或在词根后加后缀, 从而构成一个与原单词意义相近或相反的新词叫派生法. 前缀: 通常前缀并不影响词根的词性, 而仅对词根的意义加以修饰, 表示否定、相反、时间、方位等意义. 英语中有几个前缀, 如: be-(befriend), en-(enslave)/em-(embody), a-(ablaze), 不改变词根的基本意义, 而是引起词性的变化. 后缀: 英语中的后缀具有较强的语法作用, 后缀不改变词根的基本意义, 而是改变词性. 也有一些带后缀的派生词改变词义, 不改变词性, 例如: neighborhood, gangster, machinery 合成法(Compounding): 指由两个或两个以上本身有独立含义的单词合在一起组成一个新词的构词形式. 转化法(Conversion): 把一种词性用作另一种词性而词形不变的方法. 在词类转化上, 数量最多的当属动词和名词的相互转化. 通常表现为一词多义的现象. 截短法(Clipping): 讲一个较长的单词接短用以构成新词的方法, 主要有截除首部、截除尾部、截除首尾等形式. 通常意义不变. 截除首部 earthquake-&gt;quake 截除尾部 laboratory-&gt;lab 截除首尾 influenza-&gt;flu 混合法(Blending): 将两个词的某一部分合并, 或将一个词加上另一个词的一部分, 从而构成新词的方法. 混合法可分为4类: 词头+词尾(head+tail): television+broadcast-&gt;telecast 电视广播 词头+词头(head+head): situation+comedy-&gt;sitcom 情景剧 词头+词(head+word): medical+care-&gt;medicare 医疗保险 词+词尾(word+tail): news+broadcast-&gt;newscast 新闻报道 首字母缩略法(Acronym) Test of English as a Foreign Language-&gt;TOFEL 托福 常用词根词缀 前缀 表示否定、相反的前缀 dis-=not, the opposite of 否定, 相对 discourage vt. 使灰心 disinfect v. 杀菌(消毒) disapprove v. 不同意 il-, im-, in-, ir-=not 不, 非, 无 illiterate adj. 文盲的 n. 文盲 immoral adj. 不道德的 indifferent adj. 不关心的 irrelevant adj. 不相关的 non-=not 不, 非, 无 nonsense n. 废话 non-binding adj. 不具约束力的 un-=not 不, 非, 无 uncover vt. 揭露 unabridged adj. 未删节的, 完整的 anti-=against 反对, 防止 antinuclear adj. 反对使用核能的 anti-terrorist adj. 反恐怖主义的 contra-, counter-=against 反对, 相反 contrary adj. 相反的 n. [the ~] 相反 counterattack v. 反攻, 反击 表示程度的前缀 macro-=great 大的, 大规模的 macroeconomics n. 宏观经济 macrocosm n. 宏观世界, 宇宙 micro-=small 小, 微小 microwave n. 微波 microbiology n. 微生物学 multi-=many 多 multiple adj. 多样的 multimedia adj. 多媒体的 n. 多媒体 poly-=many 多 polysylabic n. 多音节的 表示时间的前缀 ante-, anti-=before 预先, 前 antecedent adj. 先行的 n. 前例 anticipate vt. 预料; 先于…行动 fore-=before 预先, 前 foresee vt. 预见, 预知 forehead n. 前额 pre-=before 预先, 前 preface n. 序言 predecessor n. 前辈; 前身 post-=after 后 postpone vt. 推迟 postwar adj. 战后的 表示数字的前缀 demi-, hemi-, semi-=half 半 demigod n. 半神半人 hemisphere n. 地球的半球; 大脑半球 semiconductor n. 半导体 semifinal n. 半决赛 mono-=one 一, 单 monotonous adj. 单调的 monopoly n. 垄断; 垄断商品 uni-=one 一, 单 unique adj. 唯一的 umilateral adj. 单边的 bi-, di-,=two 二, 双 bilingual adj. 双语的 dilemma n. (进退两难的)窘境 du-, dou-=two 二, 双 dual adj. 双(重)的 duplicate adj. 复制的 vt. 复制 double adj. 成双的 tri-=three 三 triangle n. 三角形 tripod n. 三脚架 quart-, quadr-=four 四 quartet n. 四重奏 quadruped adj. 四足的 pent-=five 五 pentagon n. 五角形; 五角大楼 pentathlon n. 五项全能运动 deca-, deci-=ten 十 decade n. 十年 decimal adj. 十进位的 centi-=hundred; hundredth 百; 百分之一 centigrade adj. 百分度的; 摄氏的 centimeter n. 厘米 kilo-=thousand 千 kilogram n. 千克 kilowatt n. 千瓦 milli-=thousand; thousandth 千; 千分之一 millipede n. 千足虫 millimeter n. 毫米 表示方位的前缀 dia-=between; through 在两者之间; 穿过 dialogue n. 对话, 对白 diameter n. 直径 e-, ef-, ex-=out 出, 出来 emit vt. 发出, 射出 effluent n. 废弃, 污水 exhale v. 呼出 excerpt n. 摘录 extra-=beyond 超出 extraordinary adj. 不平常的 extracurricular adj. 课外的 inter-=between, among 在…之间 interior n. 内部 adj. 内部的 interfere vi. 干涉; 干扰 sub-, suc-, sup-=under 在…之下 subordinate adj. 下级的; 从属的 successor n. 继任者 suppress vt. 镇压; 禁止发表; 抑制 tele-=far off 远的 telecommunication n. 电讯; 长途通信 telescope n. 望远镜 trans-=across 横过, 超过 transcend vt. 超出, 超越 transatlantic adj. 横跨大西洋的 super-=above, over 在…之上 superb adj. 极好的, 高质量的 superficial adj. 肤浅的; 表面的 ultra-=beyond, extremely 超过,极端 ultraviolet adj. 紫外(线)的 ultrasound n. 超声波 其他常见前缀 auto-=self 自己 autonomy n. 自治 autobiography n. 自传 bene-, bon-=good 好 beneficial adj. 有益的 bonus n. 奖金; 额外给予的东西 bio-=concerning living things 生物的, 生命的 biotechnology n. 生物技术 biodegrade v. 生物降解 by-=less important 次要的, 附带的 by-product n. 副产品 bypass n. 旁路 mal-=bad 坏 malfunction n. 失灵, 故障 malnutrition n. 营养不良 miss-=wrong, bad 错, 坏 mislead vt. 使误解; 把…带坏 misfortune n. 不幸, 逆境 co-, col-, com-, con-, cor-=together; intensifier 共同; 加强语气 coexist v. 共存, 并存 collaborate v. 合作; 通敌 combine v. 结合, 联合 consolidate v. 巩固; 合并 corrosive adj. 腐蚀性的; 侵蚀性的 syn-=together; same 一起; 相同 syndrome n. 综合病症 synonym n. 同义词 后缀 名词后缀 常见名词后缀 -ess 表示&quot;女性&quot; actress n. 女演员 waitress n. 女服务生 hostess n. 女主人 lioness n. 母狮 -ism, -asm 表示&quot;主义、学说&quot; Buddhism n. 佛教 communism n. 共产主义 egoism n. 利己主义 enthusiasm n. 热情,热忱 -ic(s) 表示&quot;…学&quot; logic n. 逻辑(学) physics n. 物理学 electronics n. 电子学 linguistics n. 语言学 -(o)logy 表示&quot;学科&quot; biology n. 生物学 sociology n. 社会学 ecology n. 生态; 生态学 ideology n. 思想(体系); 观念学 -©ule; -ie, -y; -let; -ing 表示&quot;小&quot; molecule n. 分子 birdie n. 小鸟儿 kitty n. 小猫, 猫咪 booklet n. 小册子 leaflet n. 传单 duckling n. 雏鸭 -an, -ian, -arian; -ant, -ent; -ist; -ar, -er, -or; -ee 表示&quot;人&quot; musician n. 音乐家 librarian n. 图书管理员 applicant n. 申请者 correspondent n. 记者 violinist n. 小提琴手 scholar n. 学者 painter n. 画家 executor n. 执行者 employee n. 雇员 interviewee n. 受访者 抽象名词后缀 -ability, -ibility ability n. 能力 flexibility n. 弹性 -age leakage n. 泄漏 postage n. 邮资 -al revival n. 苏醒; 复兴 refusal n. 拒绝 -ance, -ence allowance n. 津贴, 零用钱 reference n. 提及 -ancy, -ency expectancy n. 预料 frequency n. 次数, 频率 -cy accuracy n. 精确 privacy n. 隐私 -dom kingdom n. 王国 freedom n. 自由 -ery bravery n. 勇敢, 无畏 slavery n. 奴隶制 -hood childhood n. 童年 neighborhood n. 四邻 -ion, -ation, -ition revision n. 修订 observation n. 观察 transition n. 过渡 -ity, -ty maturity n. 成熟 cruelty n. 残忍 -ment retirement n. 退休 refinement n. 精炼; 优美 -ness darkness n. 黑暗 wilderness n. 荒野 -ship leadership n. 领导(层) scholarship n. 学问 -sion, -ssion precision n. 精确 depression n. 抑郁; 不景气 -ure closure n. 关闭; 终止 exposure n. 暴露; 揭发 形容词后缀 常见形容词后缀 -able, -ible 表示&quot;有能力、易做、适合&quot; suitable adj. 适当的, 合适的 vulnerable adj. 易受伤的; 易受攻击的 compatible adj. 兼容的; 合得来的 -ful 表示&quot;充满的&quot; dreadful adj. 糟透了的; 可怕的 thoughtful adj. 沉思的; 体贴的 -ior 表示&quot;比较级&quot; inferior adj. 劣等的; 下级的 superior adj. 上级的; 较好的 -most 表示&quot;最高级&quot; utmost adj. 极度的 foremost adj. 首要的, 最佳的 -less 表示&quot;否定&quot; restless adj. 焦躁不安的 groundless adj. 无根据的 -like 表示&quot;似的&quot; childlike adj. 孩子般的; 天真的 ladylike adj. 淑女般的; 端庄的 -proof 表示&quot;防…的&quot; waterproof adj. 防水的 bulletproof adj. 防弹的 -ward 表示方向 inward adj. 内心的, 里面的 outward adj. 外表的, 外面的 表示&quot;状态、性质&quot;的形容词后缀 -al natural adj. 自然的, 天然的 structural adj. 结构(上)的 -an, -arian suburban adj. 郊外的 vegetarian adj. 素食的 -ant, -ent pleasant adj. 令人愉快的 different adj. 不同的 -ary, -ory customary adj. 习惯上的 advisory adj. 顾问的; 劝告的 -ate passionate adj. 充满热情的 considerate adj. 体贴的 -en golden adj. 金色的 wooden adj. 木制的 -ic, -ical scenic adj. 景色优美的 psychological adj. 心理(学)的 -ish childish adj. 幼稚的 reddish adj. 略带红色的 -ive adaptive adj. 适应的 persuasive adj. 有说服能力的 -ous, -ious injurious adj. 有害的, 致伤的 harmonious adj. 和谐的 poisonous adj. 有毒的; 有害的 ambitious adj. 有抱负的, 雄心勃勃的 -y, -ly scary adj. 吓人的 manly adj. 男子气概的 副词后缀 ly 表示&quot;状态&quot; barely adv. 仅仅, 几乎不 deadly adv. 非常 readily adv. 乐意地; 容易地 shortly adv. 立刻 -wise 表示&quot;方式&quot; clockwise adv. 顺时针方向地 otherwise adv. 否则; 在其他方面 likewise adv. 同样地 -ward(s) 表示&quot;方向&quot; afterward(s) adv. 以后 backward(s) adv. 向后; 朝反方向 outward(s) adv. 向外 straightforward adv. 坦率地; 直截了当 动词后缀 表示&quot;做&quot;“造成”“使” -ate equate v. 使相等 originate vi. 起源于 vt. 创造 -en tighten v. 使变量; 加固 strengthen v. 加油, 巩固 -(i)fy horrify v. 使恐怖 simplify v. 简化 -ize, -ise maximize v. 增加到最大限度 specialise v. 专门研究 -ish publish v. 出版; 公布 impoverish v. 是穷困 表示反复的声音或动作 -er flicker v. (火焰)忽明忽暗, 闪烁 mutter v. 轻声低语 -le scribble v. 撩草地写 twinkle v. 闪烁 trickle v. 滴, 淌; 慢慢地移动 常见易混词辨析 词汇题6大常用解题技巧","link":"/zh-cn/learn/2021/Grammars-for-English-Majors-Band-4/"},{"title":"How-To-Ask-Questions-The-Smart-Way.tar.gz","text":"一个更简单的&lt;&lt;提问的智慧&gt;&gt;, 缓解 TL; DR 话不在多而在精 表现出你为解决问题做过的努力, 愿意在找答案的过程中做点什么, 越有可能得到帮助 不要在太多的不同群组上重复转贴同样的问题（cross-post）, 别像机关枪似的一次&quot;扫射&quot;所有的帮助渠道, 这就像大喊大叫一样会使人不快 在即时聊天软件(如QQ)寻求帮助，最好不要发布很长的问题描述，有些人称之为频道洪水. 最好通过一句话的问题描述来开始聊天 在邮件列表或论坛中, 大约 50 字以内的标题是抓住资深专家注意力的好机会 选择提问对象 当某个项目提供开发者邮件列表时, 要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题 如果一个项目既有&quot;使用者&quot;也有&quot;开发者&quot;板块, 非代码问题向&quot;使用者&quot;列表或论坛提问. 不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音 张贴前最好先暗地里观察几天以了解那里的行事方式 确定提问内容 别用喋喋不休的&quot;帮帮忙、跪求、急&quot;, 这样让人反感的话(用这种标题会被条件反射式地忽略) 来浪费这个机会. 避免用无意义的额外提问，例如&quot;有人能帮我吗？&quot;. 除非你想得到是或否类型的回答。例如：没错，没有人能帮你 如果在非母语的论坛提问, 你可以犯点拼写和语法上的小错, 但决不能在思考上马虎 (没错，我们通常能弄清两者的分别) 提示潜在回复者你有潜在的语言困难是很好的: English is not my native language; please excuse typing errors. 英文不是我的母语, 请原谅我的错字或语法 描述问题症状而非你的猜测 告诉大佬们你认为问题是怎样造成的并没什么帮助. (如果你的推断如此有效，还用向别人求助吗？) 你应当将你的推测付诸实践(如果这不是不可挽回的), 然后说明你做了什么尝试 描述目标而不是过程 如果你想弄清楚如何做某事(而不是报告一个 Bug), 在开头就描述你的目标, 然后才陈述重现你所卡住的特定步骤 一个好标题范例是 目标 —— 差异式 的描述 提升人际交往能力 彬彬有礼, 多用&quot;请&quot;和&quot;谢谢您的关注&quot;, 或&quot;谢谢你的关照&quot;. 让大家都知道你对他们花时间免费提供帮助心存感激 如果你觉得被冒犯了, 试着平静地反应. 如果有人真的做了出格的事, 邮件列表、群组或论坛中的前辈多半会招呼他. 如果这没有发生而你却发火了, 那么你发火对象的言语可能在社区中看起来是正常的. 而你将被视为有错的一方, 这将伤害到你获取信息或帮助的机会 绝不要自以为够格得到答案, 你没有; 你并没有. 毕竟你没有为这种服务支付任何报酬. 你将会是自己去挣到一个答案, 靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题, 而不仅仅是被动的从他人处索取知识","link":"/zh-cn/learn/2020/How-To-Ask-Questions-The-Smart-Way/"},{"title":"cyberspace-survive-guide","text":"记录一些各处收集到的技巧, 第一人称非本人 网络骚扰 如果你觉得微博上有人肆无忌惮地伤害您, 您又不知道 Ta 是谁、不知怎么告 Ta, 一步一步这样做: 找你居住地的公证处, 要求公证这些令你觉得受到伤害的帖子. 通常大约1000元左右. 注意, 您要亲自去一下公证处. 可以电话预约. 保留好发票!有人最后会报销的. 居住地的含义是你现在居住的地方而不是户籍地只需要有暂住证或居住证. 在你居住地的法院, 提交诉讼. 诉讼费约 50 元. 如果觉得写诉状头疼, 可以延请你信任的任何人, 甚至不一定是执业律师. 诉讼制度改革后, 法院目前对此类诉状基本去了就受理. 律师费高低不等, 不过不会白花钱的, 把发票放好, 最后也会有人报销. 所以强烈建议找个律师并给予全面授权, Ta 会为您办很多事情, 包括并不限于全权代理您出庭, 您自己都可以不去. 我实践的时候, 根本不想看见那些人, 所以我一次都没出庭. (说结果: 赢了) 重点来了. 你要告的第一个人(法人)是新浪微博(微梦创想公司). 你要求他提供侵权人的信息. 依据两高的司法解释(具有法律效力, 附后), 你的诉求会被法院支持. 这时候, 已经非常娴熟的微博律师会提出和解. 你答应就好: 给出涉嫌侵权人的信息, 我就撤销对你的诉讼. 这是庭前和解, 具有法律强制效力. 新浪微博的律师很快会给出你希望找到的那个人的一大堆信息, 包括他最近几年每一个帖子的 IP 地址、发微博的手机号, 如果他带 V, 还有所有认证信息, 包括身份证号码. 你如约撤销对微博的诉讼, 追加那个你终于得到个人信息的、你真正想告的人, 开始进入正常的诉讼环节. 胜诉, 申请强制执行. 细节处理. 如果您请了律师, 律师也会知道这些: 拿到了微博提供的信息, 比如一些 IP 地址、电话号码等等, 你还是无法查出他的身份信息, 导致法院无法进入正常的诉讼程序, 怎么办? 律师可以填写附图的表, 请法庭协助调查. 很快, 你就能知道 Ta 叫什么、身份证号码、身份证上的地址(很重要)了. 不知道他当前的地址怎么送达传票? 要求法院按照身份证上的地址邮递. 如果因为未被签收、拒收等等原因退回, 就更好了. 你这时可以要求进行&quot;公告送达&quot;, 手续费大约几十元到 200 元不等. 发票也存好. 公告会出现在某个法院指定的报纸上: xxx, 某人已向你提起诉讼, 请于什么时间之前与谁联系… Ta 还不理? 最好了. 公告刊登60天后视同送达, 法庭将在公告后择日开庭. Ta 不出现? 最好, 法庭将缺席审理, 并视同对方放弃质证和答辩权. 这时候你只要回答审判员或合议庭的问题就好了. 对方拒不执行怎么办? 你的诉讼请求要包括要求对方公开赔礼道歉(很重要)、删除帖子、负担诉讼费、律师费、公证费、公告费及精神赔偿. 判决生效后, 你可以去执行庭请求强制执行. 删除帖子好办, 法庭出个文, 微博会照办的. 赔偿也好办, 你有他的名字和身份证号码, 执行庭会查出他的银行卡并强制扣除, 不够扣的, 他就是老赖, 上黑名单. 赔礼道歉的部分, 你一定要求: 在微博置顶道歉 N 天(多少天你和律师商量, 一般是 7-15 天)或(很重要!)在微博首页或你所在城市的报纸刊登判决书摘要 N 天. 这样, 如果他拒绝在他的微博道歉, 你可以申请强制执行刊登判决书摘要. 其成本由被告承担, 通常需要几十万到上百万元. 如果不给钱, 当然也是强制执行, 他卡上钱如果不够, 可以列入老赖, 直到给付为止. 在此期间你可以公开征求对方财产线索, 如房产、汽车、股票等, 如果获得, 可报告执行庭实施查封、拍卖. 如果对方是体制内的人士或者党员团员, 不要忘记将此诉讼和执行情况, 整理成文件, 发给 Ta 的主管纪检监察部门. 依据新党规 100 条, 有 Ta 好看的. 附带说一下, 还有被我诉讼、判决生效后的人迄今没有履行. 别忘记, 我在一定的时效内可以随时申请强制执行. 去执行庭填个申请表, 10 分钟的事儿. 我什么时候想起来去填报, 看我高兴. 对方只是转发我可以告 Ta 吗? 可以, 而转发的阅读量越大, 责任越大. 详见附录的第十条. 附录 最高人民法院关于审理利用信息网络侵害人身权益民事纠纷案件适用法律若干问题的规定摘要(最高人民法院审判委员会第 1621 次会议通过). 众所周知, 最高法院的法律解释具有法律效力. 第一条 本规定所称的利用信息网络侵害人身权益民事纠纷案件, 是指利用信息网络侵害他人姓名权、名称权、名誉权、荣誉权、肖像权、隐私权等人身权益引起的纠纷案件. 第二条 利用信息网络侵害人身权益提起的诉讼, 由侵权行为地或者被告住所地人民法院管辖. 侵权行为实施地包括实施被诉侵权行为的计算机等终端设备所在地, 侵权结果发生地包括被侵权人住所地. 第三条 原告依据侵权责任法第三十六条第二款、第三款的规定起诉网络用户或者网络服务提供者的, 人民法院应予受理. 原告仅起诉网络用户, 网络用户请求追加涉嫌侵权的网络服务提供者为共同被告或者第三人的, 人民法院应予准许 原告仅起诉网络服务提供者, 网络服务提供者请求追加可以确定的网络用户为共同被告或者第三人的, 人民法院应予准许. 第四条 原告起诉网络服务提供者, 网络服务提供者以涉嫌侵权的信息系网络用户发布为由抗辩的, 人民法院可以根据原告的请求及案件的具体情况, 责令网络服务提供者向人民法院提供能够确定涉嫌侵权的网络用户的姓名(名称)、联系方式、网络地址等信息. 网络服务提供者无正当理由拒不提供的, 人民法院可以依据民事诉讼法第一百一十四条的规定对网络服务提供者采取处罚等措施. 原告根据网络服务提供者提供的信息请求追加网络用户为被告的, 人民法院应予准许. 第十条 人民法院认定网络用户或者网络服务提供者转载网络信息行为的过错及其程度, 应当综合以下因素: (一) 转载主体所承担的与其性质、影响范围相适应的注意义务; (二)所转载信息侵害他人人身权益的明显程度. 第十五条 雇佣、组织、教唆或者帮助他人发布、转发网络信息侵害他人人身权益, 被侵权人请求行为人承担连带责任的, 人民法院应予支持. 第十六条 人民法院判决侵权人承担赔礼道歉、消除影响或者恢复名誉等责任形式的, 应当与侵权的具体方式和所造成的影响范围相当. 侵权人拒不履行的, 人民法院可以采取在网络上发布公告或者公布裁判文书等合理的方式执行, 由此产生的费用由侵权人承担. 第十八条 被侵权人为制止侵权行为所支付的合理开支, 可以认定为侵权责任法第二十条规定的财产损失. 合理开支包括被侵权人或者委托代理人对侵权行为进行调查、取证的合理费用. 人民法院根据当事人的请求和具体案情, 可以将符合国家有关部门规定的律师费用计算在赔偿范围内. 被侵权人因人身权益受侵害造成的财产损失或者侵权人因此获得的利益无法确定的, 人民法院可以根据具体案情在 50 万元以下的范围内确定赔偿数额. 引战的本质 引战的诀窍: 让人们&quot;意识到&quot;他们属于不同的群体, 再提供一下具有地图炮属性的&quot;帽子&quot;和极端又激烈的&quot;弹药&quot; 渴望证明存在感的人们就会自觉自愿地拿起这些帽子, 抄起弹药向其他人发动攻击 引战的本质是人人都为了虚假的&quot;身份认同&quot;而战 举报维权电话 纪委12388, 组织12380, 环保12369, 检察12309, 社保12333, 物价12358, 食药12331, 商务12335, 税务12366, 司法12348, 外交12308, 文化12318, 文物12359, 互联网12321, 运输12328, 知识产权12330, 质检12365, 海关12369, 国土12336, 公积金12329, 烟草12313, 保监会12378, 快递12305, 铁路12306, 农业信息12316, 国家扶贫办12317, 城市服务12319, 防震减灾12322, 妇联12338, 间谍举报12339, 城管12342, 民政12349, 安全生产12350, 工会12351, 残联12385, 证监会12386 睡眠 先说说睡眠的过程, 睡眠的过程大概是以一个半小时为一个睡眠周期 每个睡眠周期分为四个阶段(每个周期间还会穿插快速眼动时期, 此时人会做梦), 每个阶段人的脑袋脑电波所处的波频不一样. 通常建议每个人的睡眠最好是以周期进行, 常常说人要睡足八个小时的原因, 往往是 5 个周期 + 眼动时期的误差时间. 有些人七个半小时很有可能就已经足够了. 在工作比较紧张的时候, 一周最起码要保证 30 个睡眠周期(这也是经常提给高三高考生的睡眠建议), 以及平日里如果有空，需要保证 35 个睡眠周期的优质睡眠. 蓝光对人的睡眠节律有着毁灭性的破坏, 但即使是在睡眠前半个小时不玩手机, 蓝光对我们的影响还在持续, 最理想的是应该在睡眠的前一个半小时停止接触蓝光设备, 期间整理整理衣服, 看一看书(不建议看情节性太强的小说, 建议看虚幻/科幻类的小说). 人的黄金睡眠时间是 22：00 到 2：00, 最好能够在这期间进入睡眠, 而且尽量固定起床时间, 按照睡眠周期往前推算, 比如果定好 6：00 起床, 那么假设现在已经 23：15, 不妨推到 12：00 左右再入眠 假若你的起床时间能够调整到 6：00 到 8：00 之间的话, 建议在这段时间里在户外的自然光环境下呆上半个小时. 假若你有在户外吃早餐的习惯, 那再好不过了. 人的眼睛和皮肤对自然光极其敏感, 平日里的自然光是室内光的100倍, 即使是在阴天, 也有 10 倍左右, 人就是靠光线来调整自身的昼夜节律的, 这一点非常重要. 其他时间当然也行, 不过所需的时间可能需要更长一点, 你当然可以选择在晚饭后的傍晚沐浴在夕阳温柔的余晖里散步. 以及不要在卧室床上做睡眠以外的任何事情, 人对空间有功能分区, 会潜意识里对每个物件或是空间进行功能归因, 我们在课上经常睡成习惯, 往往是我们对课堂进行了睡眠归因. 大脑其实非常聪明, 比如我们平日里不用英语, 而只是用英语进行应试, 大脑对信息的接受和提取要慢的很多. 如果床的功能被一段时间的行为紊乱了之后(比如玩手机), 那么我们在床上入睡的愿望可能就完全没有那么强烈, 所以请把你的床当成一个神圣的地方. Notes 医保异地需要转院证明 整容的结果都是未知的，找到一个靠谱的医生，然后尽可能只去整一些后遗症小的部位，这样成功率可以大大提升。切记，不要去私立医院，绝大多数都是广告、医托、莆田系。普通的三甲医院也不要去，很多整形科都外包给莆田系了。推荐北京八大处，和上海九院，医生方面可以自己多了解，选一个靠谱的、适合自己的。","link":"/zh-cn/learn/2021/cyberspace-survive-guide/"},{"title":"girls_dressing_skills","text":"怎么穿搭好看得体 如何着装才得体和谐 着装的审美 着装的基本要求 干净整洁, 不能又折又皱, 可学习熨烫技术 衣服轮着穿, 两套衣服穿两周比一套衣服连续穿三天好 过于保守和过于暴露是不自信的表现. 魅力应透过得体的装扮, 优雅的举止, 丰富的见识和谦逊温和的品行展现. 服装的审美 穿衣有三层境界: 第一是和谐, 第二是美感, 第三是个性. 由浅入深. 在选择衣服颜色时, 要依据颜色自身特点, 自己的体型, 肤色, 结合自己的喜好搭配. 不同的衣服有不同的穿搭技巧, 下面列出三点注意: 穿偏短的裙子, 要穿连裤丝股袜, 不能穿半截袜. 即丝袜袜口应被裙子下拜遮掩(国内不适合搞绝对领域hh). 短袜不能配凉鞋. 白色衣服和裤子应穿肉色内衣, 白裤子不能配黑皮鞋等. 衣服的洗涤和收纳 衣服的正确洗涤方法 用洗衣机时, 清洗前将口袋物品取出, 口袋外翻, 拉链拉好, 以免刮到其他衣服. 查看衣服的洗涤标签以确定洗涤和晾干方法, 内衣最好手洗 不要把衣服穿得很脏才洗, 沾上污渍的衣物要及时清洗 外衣/袜子不要与内衣一起洗 衣服的收纳及保护 当季衣服放衣橱里 过季的衣服分门别类放入防潮袋, 有需要可真空压缩. 化纤, 丝质, 棉织品不可用樟脑或香包, 易损害衣物. 空气湿度大不能晒毛衣, 羽绒服之类的衣服. 选对色彩衬肤色 色彩的搭配原则和方法 同类色搭配: 颜色色相相同或相近, 深浅明暗不同的两种同一类颜色相配. 是最简便基本的配色法. 比如绿色配天蓝, 墨绿配浅绿, 咖啡配米色. 但同类色容易显得平庸土气, 可用围巾, 披肩, 皮带, 有颜色的手势, 包包等提升亮点. 对比色搭配: 用强烈的对比撞色或明度差异明显的颜色, 即二种相隔较远的颜色搭配. 如红色与清绿色, 黄色与紫色. 但难以驾驭, 需谨慎, 一般人的肤色难以匹配. 可5:3或3:2配色技巧. 分离色搭配: 具有色彩感的服装与黑白灰搭配的配色法. 适合对色彩不自信的女生. 以黑白色作底, 上半身或下半身颜色鲜艳. 补色搭配: 每一色相与相对色相之间的关系, 即两种相对颜色的配合. 如黑白搭配 冬天宜用暖色, 夏天宜用冷色搭配 色彩与肤色的搭配 一个简单的方法, 找一个日光充足的白天, 找两件衣服, 一件蓝色一件橙色. 蓝色好看, 就适合冷色, 橙色好看, 就适合暖色. 皮肤白皙的女生, 可尝试色彩明度高的颜色, 浅色系也合适, 但不适合紫罗兰色, 亮黄色, 纯白色. 皮肤发黄的女生, 不建议穿着咖色, 褐色, 橘色, 砖红色, 蓝紫色的衣服, 且灰色调容易显得没精神. 不管是那种肤色, 不建议穿和肤色一样颜色的衣服. 基本靠-你衣柜里必备的衣服","link":"/zh-cn/learn/2021/girls-dressing-skills/"},{"title":"markdown","text":"旨在统一文档的符号、Katex 书写格式 规范 正文 使用顿号 “、” 来表示同级. 不需要空格(因为是全角符号) 下一行要留空: html表格标签结尾 图片资源标签 {%img %} Markdown 子列表(若接下来还有文本) 内容尽量用数字列表(1. 2. 3.)包装(比如本文) 若定义需要多行来解释, 第一行留空, 如:12341. 定义内容 xxx xxxx xxxxx 标题避免使用 KaTeX 式子(因为TOC无法解析) LaTeX 所有数学式子、符号必须用 LaTeX 修饰 KaTeX式子两边要留一个空格间距 尽量不在 KaTeX 式子中使用逗号; 两个 Katex 式子之间的逗号 “,” 留一个空格间距 式子后面括号注释(如 \\(y=x \\quad(x\\geqslant 0)\\) 使用的空格间距统一为 \\quad 使源文档中 KaTeX 尽量地短(减少空格的使用) (R) 会变成版权标志, 应该使用 \\(R\\) 提示 下划线 &lt;u&gt;&lt;/u&gt; KaTeX 使用自定义的空格长度可用 \\mskip{1em} Katex 中 省略号 “…” 可以用 \\dots 表示 波浪线 “~” \\sim 星号 “*” 要加斜杠变成 \\* Markdown 语法 标题 123# 最大标题## 第二大标题###### 最小标题 样式文本 样式 语法 键盘快捷键 示例 输出 粗体 ** ** 或 __ __ 命令/控制键 + b **这是粗体文本** 这是粗体文本 斜体 * * 或 _ _ 命令/控制键 + i *这是斜体文本* 这是斜体文本 删除线 ~~ ~~ ~~这是错误文本~~ 这是错误文本 粗体和嵌入的斜体 ** ** 和 _ _ **此文本 _非常_ 重要** 此文本 非常 重要 全部粗体和斜体 *** *** ***所有这些文本都很重要*** 所有这些文本都是斜体 引用文本 您可以使用&gt;来引用文本。 123用 Abraham Lincoln 的话来说：&gt; 原谅我爆粗口 表格 1234| First Header | Second Header || ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell | 有用的链接： Github-MD基础书写和格式 Github-使用表格组织化信息 锚点 12345&lt;!-- 定义锚点 --&gt; &lt;span id=&quot;const_method&quot;&gt;&lt;/span&gt;&lt;!-- 锚点链接 --&gt; [const method](#const_method)","link":"/zh-cn/learn/2020/markdown/"},{"title":"simple-chemistry-experiment","text":"一些安全条例 Principle 长时间的实验进行时必须有人在场且必要时设好闹钟 尽量避免危险&amp;环境有害的化学品的使用&amp;合成 黑名单: 有毒且污染环境: 含铅、含铜、含钡、含砷、含汞的单质及化合物; 氰化物; 白磷(也称黄磷, 化学式 \\(\\ce{P4}\\), 非常危险, 易燃且几乎无法熄灭, 可谓三味真火) 易燃易爆: 硝酸; 乙醚(勿常温久置, 如瓶盖难以打开请小心放置并立即求助专业人员) 尽量避免: 有毒: 含氟化合物(如氟化氢, 萤石(氟化钙)); 硫化氢(高浓度能麻痹嗅觉神经, 因此会闻不到) 易产生爆炸物: 异丙醇(长期放置易产生TATP) 易燃易爆: 乙炔 防呆禁令: 禁明火蒸馏酒精(应使用水浴) 禁止在通风不良的环境中进行会产生有毒气体的实验 Solvent Polarity Table https://sites.google.com/site/miller00828/in/solvent-polarity-table Notes 含聚苯二甲酸酯(如饮料瓶常用的 PET)会和氢氧化钠等强碱反应, 因此不能用作存放强碱的容器. 砂坂孔隙度: (XC/EC) G1 20-30um 滤除粗沉淀即胶状沉淀物 © G2 10-15 滤除粗沉淀即气体洗涤 (M) G3 4.5-9um 滤除系沉淀, 过滤水银 (F) G4 3-4um 滤除系沉淀或极细沉淀物","link":"/zh-cn/learn/2021/simple-chemistry-experiment/"},{"title":"terms","text":"术语记录表 术语 解释 标签 - - - KDF (Key derivation function)密钥派生函数, 属于 hash 函数, 通常用来将短密码变成长密码 Cryptography CoW (Copy-on-write)多个进程共享一个副本, 只有一个进程尝试修改该资源时, 系统才会执行复制 Btrfs RTTI (Run-time Type Information)a feature of the C++ programming language that exposes information about an object’s data type at runtime. C++ TLDR (Too Long; Didn’t read.)太长不看, 等价于 TLDW(Too Long; Didn’t Watch) 贝特里奇头条定律 (Betteridge’s law of headlines)指任何以问号结尾的新闻标题, 都能够用’不’来回答 回音室效应 (Echo Chamber)In news media, echo chamber is a metaphorical description of a situation in which beliefs are amplified or reinforced by communication and repetition inside a closed system. By visiting an “echo chamber”, people are able to seek out information that reinforces their existing views, potentially as an unconscious exercise of confirmation bias. This may increase social and political polarization and extremism… 达克效应 (D-K effect)是一种认知偏差现象, 指能力欠缺的人在自己欠考虑的决定的基础上得出错误结论, 但是无法正确认识到自身的不足, 辨别错误行为. 这些能力欠缺者们沉浸在自我营造的虚幻优势之中, 常常高估自己的能力水平, 却无法客观评价他人的能力. GDP (Gross Domestic Product)国内生产总值 CPI (Consumer Price Index)消费者物价指数(通货膨胀率) PPI (Producer Price Index)生产者价格指数 PMI (Purchasing Managers’ Index)采购经理人指数(以50%作为经济强弱分界点) NFPA 704 (National Fire Protection Association)美国消防协会制定危险品紧急处理系统鉴别标准 Chemistry MTU (Maximum Transmission Unit)最大传输单元, 指位于数据链路层上的数据包所能通过的最大大小 Network LIR (Regional Internet Registry)区域互联网注册管理机构, 是管理世界上某特定地区互联网资源的组织, 包括 IP 地址和 AS 号. 现在(2021年)世界上有五个正在运作的区域互联网注册管理机构 Network 第一性原理(第一原理) 每个系统存在一个不能违背或删除的最基本命题. 寻找解决方案应尝试寻找更本质的需求 能指和所指 索绪尔语言学的一对概念, 能指意为描述实体的抽象语言本身(如词形、词音), 所指指抽象语言描述的实体及其相关的属性 SICP Structure and Interpretation of Computer Programs, 计算机程序的结构与解释, 是一本关于计算机程序设计的总体性观念的基础教科书. 书中使用程序 Lisp 语言的方言 Scheme 来解释计算机科学的核心概念, 包括抽象、递归、解释器以及元语言抽象 洗稿 指通过某些手段掩盖原文章的真实来源, 以争取审查时间差或躲避著作权的行为 HPLC (High-performance liquid chromatography)高效液相色谱法, 常用于生物化学和分析化学, 一种用于混合物分离、识别、量化各成分比例的技术 XRD (X-ray diffraction analysis)X射线衍射分析, 一种在材料科学中用于确定材料晶体结构的技术 DEXA Dual-energy X-ray absorptiometry is a means of measuring bone mineral density.","link":"/zh-cn/learn/2020/terms/"},{"title":"笨蛋の自我修养","text":"正在努(mo)力(yu)… 关于关于出生以来钱桑的若干历史问题的决议 2021 总结: 在性别焦虑失控至初步得到控制的阶段(2020-12-7~至今), 耗费了大量的时间, 技术上的发展受到严重影响. 暑期(2021-6-5~2021-8-31), 结识了更多朋友, 稍微变得开朗了一些. 22岁生日(2021-10-13), 孤独但是开心^=^. 22年的人生总得来说是失败的, 即不符合自己所应达到的发展程度. 人格方面, 至今仍在进行不断地修正, 最近由于与朋友们的交流才克服了一些内心的矛盾, 可以说是晚熟了. 空中楼阁的学术, 理论与实践几乎完全脱轨. (编程? 快多久没敲过代码了? 一年? 写过几个项目? 0个? ACM? 门都没入) 经济上, 完全依靠父母, 无法说服自己放弃宝贵的时间和精力去做兼职, 但反过来, 自己又无法完全解决自己的问题(睡眠障碍)去好好学习. 睡眠障碍的原因可能由以下几个因素共同作用: 学术上发展迟缓带来的心理压力. 感官过于敏感, 需要耳塞眼罩等辅助睡眠. 不合适的睡姿. 睡前吸收过多蓝光影响褪黑素生成. 拖延的态度导致晚睡, 洗完澡就已经很晚了. 家庭矛盾, 心情难以平复. 面临的困难: 睡眠困难, 晚上睡不着. 12月的英语四级. 毕业设计毫无着落. 上的课压根没在认真听. 于是, 钱桑战时摸鱼体制诞生啦~~~ 钱桑战时摸鱼体制(DEFCON 2) 两个必须: 必须早睡早起 状态不好也必须开始 十大要求: SE的课…先拖着吧, 反正看起来难度不大, 到时候临时抱臭脚好了233. 5点40起来洗漱, 来杯咖啡(最晚10点之前喝!!!钱桑咖啡半衰期11小时!) 背单词 TOFEL、GRE. 学习新高中物理选修3的热力学, 英语专4语法. 铺路, 概率论与数理统计, 线性代数的 Problem Set. 补番: 史莱姆, 无职转生. 晚上出去走走(跑图), 找个僻静的有监控的地方练习CQC (总的时间限制在1小时内). 晚上9点之前人要躺床上. 如果睡不着, 那就幻想个男票发发情, 释放一下压力. 遇上母亲发病, 带上耳机听歌转移注意力, 不要去理会那个笨蛋. 心情难以压抑时就尽情的释放悲伤吧. 其他工作 总优先级: MATLAB&gt;GTM&gt;CS61a&gt;ACM入门&gt;有机化学&gt;德语&gt;日语N2 寻找 Mathlab 的 python 替代(numpy, panda, matplotlib), 顺便了解下 R 语言、也许我们还可以试试 Mathematica? Operation Baroque, 尝试阅读以下列表的前五本: Undergraduate Texts in Mathematics An Introduction to Difference Equations - Saber Elaydi Calculus or Several Variables - Serge Lang Introduction to Analytic Number Theory - Tom M. Apostol Ordinary Differential Equations - Vladimir I. Arnold Universitext Partial Differential Equations 1 - Friedrich Sauvigny Partial Differential Equations 2 - Friedrich Sauvigny Representations and Characters of Groups - Gordon James &amp; Martin Liebeck Classics in mathematics Combinatorial Theory - Martin Aigner Graduate Texts in Mathematics A Course in Arithmetic - Jean-Pierre Serre Linear Geometry - K.W. Greenberg &amp; A. J. Weir Matrix Analysis - Rajendra Bhatia The Symmetric Group - Bruce E. Sagan IndyMill 漫画绘画入门 清空数据结构笔记的 TODO, 还有两个我没理解的算法 Operation Canteralla: Organic Chemistry I, II, III cs61a(SICP, 计算机程序构造和解释), cmu15-213(CSAPP, 深入理解计算机程序) 未曾设想的道路(考研) 焦点树: individual-focus-tree.xmind 时间管理技巧 from: Ali Abdaal; Noodlefighter’s Wiki 给要做的事排轻重缓急 二八法则: 优先 20% 的时间能掌握 80% 的东西. 帕金森定律: 给一项计划充裕时间反而会降低效率; 强调应分配刚好够的时间, 只求完成不求完美(类似迭代开发完美是迭代出来的而不是一步到位). 两分钟原则: 耗费两分钟就能完成的事不要拖延马上做. 推论: 不论多难多累的事能快速完成就马上做 成批处理: 同类任务积攒定时成批处理, 这样不用切换思维模式, 减少耗时. 学习观 什么是建模: 建模是从有限的例子中, 找出问题和答案之间的模式 (规律), 其目的是用模式压缩原本无限的知识 如何建模: 知识的描述只是对建模起到指引的作用, 最终一定要通过样本训练理清问题和答案的模式来重塑大脑连接 (构造模型) 建模的误区 错误的输入输出: 知识分为运动类 (如语言、游泳) 和思考类 (如数学、物理), 运动类适合建立直接的输入和输出(即浅层学习, 因此想要建立英语模型不适合中文作为中间体) 以语言为例的输入输出模型: 听: 声音-意思 说: 想法-发声 读: 文字-意思 写: 想法-打字 有效的英语建模方法 (矫正输入输出): 看电影学英语 练听力时不要看字幕 选择一个话题, 不思考中文的情况下自言自语的表达想法 只看英语解释和英语例句, 不思考中文 思考类的问题往往需要联系多个知识点解决, 适合深度学习 (多层的输入输出) 解思考类问题的两个原则: 多学知识 (有招可用), 分而治之 (拆分问题) 错误的模型迁移方式 将适合浅层学习的运动类知识使用深度学习 (如应试教育的英语, 只能教出懂英语语法确不擅长用英语的人) 将适合深度学习的思考类知识使用浅层学习 (如死背公式)","link":"/zh-cn/learn/2020/the-new-plan/"},{"title":"fabric-mod-list","text":"A detailed list of mods in my Minecraft server Launcher HMCL-3.5.2.216.jar Jan 2, 2022 Server Server name Release Date Minecraft Version fabric-installer-0.10.2 Dec 04, 2021 1.18.1 Powered by itzg’s docker image . Mods Common Mod name Download link Last Update Fabric API fabric-api-0.46.4+1.18.jar Feb 3, 2022 Architectury API (Fabric) architectury-3.6.17.jar Feb 6, 2022 Cloth Config API (Fabric) cloth-config-6.1.48-fabric.jar Jan 16, 2022 Fabric Language Kotlin fabric-language-kotlin-1.7.1+kotlin.1.6.10.jar Dec 20, 2021 Patchouli Patchouli-1.18.1-65-FABRIC.jar Jan 31, 2022 Not Enough Crashes (Fabric) notenoughcrashes-4.1.4+1.18.1-fabric.jar Jan 15, 2022 LazyDFU lazydfu-0.1.2.jar Feb 2, 2021 Krypton krypton-0.1.6.jar Dec 11, 2021 Lithium (Fabric) lithium-fabric-mc1.18.1-0.7.7.jar Jan 2, 2022 Starlight (Fabric) starlight-1.0.0+fabric.d0a3220.jar Dec 8, 2021 Alternate Current alternate-current-mc1.18-1.1.0.jar Dec 1, 2021 Concurrent Chunk Management Engine (Fabric) c2me-fabric-mc1.18.1-0.2.0+alpha.6.25-all.jar Jan 20, 2022 FerriteCore (Fabric) ferritecore-4.0.0-fabric.jar Dec 5, 2021 Observable observable-1.2.3-fabric.jar Jan 28, 2022 Roughly Enough Items (REI) RoughlyEnoughItems-7.2.416.jar Jan 29, 2022 Roughly Enough Resources rer-2.3.0.jar Dec 18, 2021 WTHIT wthit-fabric-4.4.1.jar Jan 6, 2022 megane megane-7.0.2.jar Jan 28, 2022 Inventorio (Fabric) inventorio-1.18-fabric-1.6.2.jar Dec 7, 2021 Polymorph (Fabric) polymorph-fabric-0.0.19-1.18.1.jar Jan 14, 2022 FallingTree (Forge&amp;Fabric) FallingTree-1.18.1-3.2.0b2.jar Jan 26, 2022 Universal Graves graves-2.0.0-beta.4.2+1.18.1.jar Jan 26, 2022 AppleSkin appleskin-fabric-mc1.18.1-2.3.0.jar Jan 28, 2022 Applied Energistics 2 appliedenergistics2-10.0.0.jar Jan 17, 2022 Applied Energistics 2 Wireless Terminals AE2WTLib-10.0.1-release.jar Jan 26, 2022 Deep Mob Learning: Refabricated deepmoblearning-refabricated-0.5.0-beta2.jar Dec 12, 2021 Reborn Core RebornCore-5.1.0-beta.8.jar Jan 31, 2022 Tech Reborn TechReborn-5.1.0-beta.8.jar Jan 31, 2022 Minecraft Transit Railway MTR-1.18.1-3.0.0-beta-8.jar Dec 11, 2021 Modern Industrialization Modern-Industrialization-1.0.4.jar Jan 6, 2022 Space Dimensions (Fabric) agape_space_18_1-0.5.0.jar Jan 15, 2022 CC: Restitched cc-restitched-1.100.1.jar Jan 25, 2022 Prefab prefab-fabric-3.0.3.jar Jan 30, 2022 Tax Free Levels TaxFreeLevels-1.3.jar Dec 8, 2021 Chest Cavity chestcavity-2.13.5.jar Dec 17, 2021 Nature’s Compass NaturesCompass-1.18.1-2.0.2-fabric.jar Dec 18, 2021 Milk+ milk_plus-2.0.1.jar Dec 27, 2021 Enhanced Mob Spawners fabric-branders-spawnermod-1.18-1.1.2.jar Dec 6, 2021 GeckoLib geckolib-fabric-1.18-3.0.32.jar Jan 29, 2022 Happiness (is a) Warm Gun HWGMod-1.18.1-1.0.2.jar Jan 26, 2022 Immersive Portals (DISABLED) immersive-portals-1.2.5-mc1.18.1-fabric.jar Jan 25, 2022 Pending Mods: Culinaire, Industrial Revolution, Deep Mob Learning: Simulacrum, BlockTuner, IC2, Mob Buckets (Fabric). Pending Mods (Management): None. Client-Side Mods Mod name Download link Last Update WMITAF wmitaf-fabric-mc1.18.1-2.2.0.jar Dec 15, 2021 cAn i MiNe thIS bLOCk? can-i-mine-this-block-1.1.0.jar Jun 28, 2021 Better Sneak BetterSneak-Fabric-1.18-1.0.0.jar Dec 30, 2021 Mouse Tweaks MouseTweaks-fabric-mc1.18-2.22.jar Jan 13, 2022 Just Enough Keys [JEK] [Fabric] justenoughkeys-0.5.3-fabric.jar Jan 12, 2022 Autofish Autofish-0.9.4-fabric-mc1.18.jar Dec 31, 2021 Xaero’s Minimap Xaeros_Minimap_22.1.1_Fabric_1.18.jar Jan 28, 2022 Better Ping Display BetterPingDisplay-Fabric-1.18.1-1.1.1.jar Dec 14, 2021 Light Overlay (Rift/Forge/Fabric) light-overlay-6.0.4.jar Dec 7, 2021 Trajectory preview [Fabric] Trajectory Preview-1.0-1.18.1.jar Dec 21, 2021 Mod Menu modmenu-3.0.1.jar Dec 18, 2021 Baritone baritone-standalone-fabric-1.8.0.jar Dec 3, 2021 Advanced XRay (Fabric Edition) advanced-xray-fabric-1.18-0.7.0-build.10.jar Dec 3, 2021 ToolTipFix tooltipfix-1.0.4-1.18.jar Dec 1, 2021 Spyglass Zoom spyglass-zoom-fabric-1.0.2.jar Dec 4, 2021 Better Fps - Render Distance[Forge/Fabric] betterfpsdist-fabric-1.18-1.5.jar Jan 9, 2022 Dynamic FPS dynamic-fps-2.1.0.jar Jan 15, 2022 Enhanced Block Entities enhancedblockentities-0.5+1.18.jar Dec 10, 2021 Cull Leaves cullleaves-2.3.2.jar Oct 30, 2021 Entity Culling Fabric/Forge EntityCulling-Fabric-1.3.3.jar Nov 12, 2021 Cull Particles Fabric cullparticles-2.0.jar Jan 4, 2021 Sodium sodium-fabric-mc1.18.1-0.4.0-alpha6+build.14.jar Jan 14, 2022 Sodium Extra sodium-extra-mc1.18.1-0.3.9.jar Jan 28, 2022 Indium (Fix MI broken textures with Sodium) indium-1.0.2-alpha2+mc1.18.1.jar Jan 15, 2022 Canvas Renderer (DISABLED) canvas-fabric-mc118-1.0.2282.jar Jab 11, 2021 WorldEdit CUI (Fabric) (DISABLED) WorldEditCUI-1.18.1+01-SNAPSHOT.jar Fan 7, 2022 Pending mod: Watson Note: Baritone conflicts with Immersive Portals. OptiFabric, Sodium and Canvas are conflict each other. Canvas Renderer recommands 4GiBs to run. If you use Canvas Renderer there is a recommand shader Lumi Lights Pending Mods: Physics Mod, Sodium Extra, Falling Leaves. Server-side Mods Mod name Download link Last Update LuckPerms LuckPerms-Fabric-5.3.98.jar Jan 2, 2022 Minecraft Command Permissions Fabric minecraft-command-permissions-1.5.0.jar Dec 2, 2021 spark spark-fabric.jar Jan 3, 2022 Fireplace Lib Fireplace-Lib-6.2.2+1.18.jar Dec 1, 2021 Unforgiving Void Unforgiving-Void-3.1.1+1.18.jar Dec 1, 2021 Ledger ledger-1.2.0.jar Dec 1, 2021 Dynmap-Forge/Fabric Dynmap-3.3-fabric-1.18.jar Jan 30, 2022 Gunpowder (DISABLED) gunpowder-base-1.1.1.1+1.18.1.jar Dec 29, 2021 Gunpowder Currency (DISABLED) gunpowder-currency-1.0.8+gunpowder.1.1.1.1.mc.1.18.1.jar Dec 30, 2021 Gunpowder Market (DISABLED) gunpowder-market-1.0.7+gunpowder.1.1.1.1.mc.1.18.1.jar Dec 30, 2021 Grand Economy (DISABLED) Grand-Economy-5.1.1+1.18.jar Dec 1, 2021 WorldEdit (DISABLED) worldedit-mod-7.2.8.jar Dec 11, 2021 Pending Mods: Dynamic View[Forge/Fabric], Flan Minecraft IDs Using for mining by baritone :) Minecraft coal_ore iron_ore deepslate_iron_ore redstone_ore deepslate_redstone_ore diamond_ore iron_ore gold_ore lapis_ore The nether: nether_gold_ore nether_quartz_ore ancient_debris techreborn techreborn:tin_ore techreborn:deepslate_tin_ore techreborn:lead_ore techreborn:deepslate_lead_ore techreborn:bauxite_ore techreborn:deepslate_bauxite_ore techreborn:galena_ore techreborn:iridium_ore techreborn:ruby_ore techreborn:sapphire_ore techreborn:silver_ore techreborn:copper_ore The nether: techreborn:pyrite_ore techreborn:cinnabar_ore techreborn:sphalerite_ore The end: techreborn:tungsten_ore techreborn:sheldonite_ore techreborn:peridot_ore techreborn:sodalite_ore appliedenergistics2 appliedenergistics2:quartz_ore appliedenergistics2:charged_quartz_ore Modern Industrialization: modern_industrialization:tin_ore modern_industrialization:deepslate_tin_ore modern_industrialization:nickel_ore modern_industrialization:deepslate_nickel_ore modern_industrialization:lead_ore modern_industrialization:deepslate_lead_ore modern_industrialization:quartz_ore modern_industrialization:bauxite_ore modern_industrialization:deepslate_bauxite_ore modern_industrialization:antimony_ore modern_industrialization:deepslate_antimony_ore modern_industrialization:mozanite_ore modern_industrialization:deepslate_mozanite_ore Dynmap Due to the use of third-party services provided by LittleSkin, Dynmap needs to be configured. fabric-data/dynmap/configuration.txt12345# Control loading of player faces (if set to false, skins are never fetched)fetchskins: true# Customize URL used for fetching player skins (%player% is macro for name)skin-url: &quot;https://littleskin.cn/skin/%player%.png&quot; Worlds cleanup: Remove corresponding items in dynmap/forgeworlds.yml, then /dynmap reload LuckPerms Enable auto-op on fabric server (used as a “pssudo” root wildcard, as many mods support the operator system over permissions): All users will be de-opped unless they have the permission node luckperms.autoopserverroot/config/luckperms/luckperms.conf123456789101112# Enables or disables a special permission based system in LuckPerms for controlling OP status.## - If set to true, any user with the permission &quot;luckperms.autoop&quot; will automatically be granted# server operator status. This permission can be inherited, or set on specific servers/worlds,# temporarily, etc.# - Additionally, setting this to true will force the &quot;enable-ops&quot; option above to false. All users# will be de-opped unless they have the permission node, and the op/deop commands will be# disabled.# - It is recommended that you use this option instead of assigning a single '*' permission.# - However, on Fabric this setting can be used as a &quot;pseudo&quot; root wildcard, as many mods support# the operator system over permissions.auto-op = true C2ME Disable no-tick view distance due to mysterious ae2’s cable disconnect:serverroot/config/c2me.toml12[noTickViewDistance]enabled = false","link":"/zh-cn/minecraft/2020/fabric-mod-list/"},{"title":"mods-changes","text":"Legacy MOD changes Will be merged when the first release IC2 1.18 was published. 工业2 (已移除) 主配置文件改动 config/IC2.ini1234567[balance]; 移动储电箱无电量损耗energyRetainedInStorageBlockDrops = 1; 通过传送器时，玩家的背包重量不会增加能量消耗teleporterUseInventoryWeight = false; 关闭扳手拆机器logwrenchLogging = false 让打粉机可以打AE2的东西 config/ic2/macerator.ini1234567891011121314; certus quartz dustOreDict:crystalCertusQuartz = appliedenergistics2:material@2; nether quartz dustOreDict:gemQuartz = appliedenergistics2:material@3; fluix dustOreDict:crystalFluix = appliedenergistics2:material@8; sky stone dustappliedenergistics2:sky_stone_block = appliedenergistics2:material@45; ender dustminecraft:ender_pearl = appliedenergistics2:material@46 将高炉炼钢时间缩短为一分钟 config/ic2/blast_furnace.ini12345678910; Iron Ingotminecraft:iron_ingot = ic2:ingot#steel ic2:misc_resource#slag @fluid:1 @duration:600; Crushed Iron OreOreDict:crushedIron = ic2:ingot#steel ic2:misc_resource#slag @fluid:1 @duration:600; Iron Oreminecraft:iron_ore = ic2:ingot#steel ic2:misc_resource#slag @fluid:1 @duration:600; Purified Crushed Iron OreOreDict:crushedPurifiedIron = ic2:ingot#steel ic2:misc_resource#slag @fluid:1 @duration:600; Iron DustOreDict:dustIron = ic2:ingot#steel ic2:misc_resource#slag @fluid:1 @duration:600 砍树 与工业2橡胶树的兼容 config/treecapitator.cfg1234ic2_rubber_tree { S:logs=IC2:rubber_wood S:leaves=IC2:leaves} EpicBanItem (检查当工业2的采矿镭射枪nbt数据, 充能大于0时触发ban物品) config/epicbanitem/banitem.conf123456789101112131415161718&quot;ic2:mining_laser&quot;=[ { name=ban-mining-laser-in-ic2 priority=5 query { id=&quot;ic2:mining_laser&quot; &quot;tag.charge&quot; { &quot;$gt&quot;=&quot;0.0d&quot; } } update { &quot;$set&quot; { Damage=0 id=&quot;minecraft:air&quot; } } }]","link":"/zh-cn/minecraft/2020/mods-changes/"},{"title":"archlinux-installation-standard","text":"The standard of archlinux installation &amp; configurations for me For Lenovo user, Enter F12 for Boot Menu when on bootstrap stage Pre-installation Update the system clock 1# timedatectl set-ntp true Preparing the partitions Partition layout: 12345678910+-----------------------+------------------------+| Boot partition | LUKS2 encrypted system || | partition || | || /boot | / || | || | /dev/mapper/cryptroot ||-----------------------|------------------------|| /dev/sda1 | /dev/sda2 |+-----------------------+------------------------+ Preparing non-boot partitions 1234# cryptsetup -y -v --pbkdf-memory=114514 luksFormat /dev/sda2# cryptsetup open /dev/sda2 cryptroot# mkfs.btrfs -L arch_os /dev/mapper/cryptroot# mount /dev/mapper/cryptroot /mnt You can set the filesystem label later by using btrfs filesystem label /dev/mapper/cryptroot &quot;arch_os&quot; Preparing the boot partition 1# mkfs.fat -F32 /dev/sda1 Btrfs subvolumes Create top-level subvolumes1234# btrfs subvolume create /mnt/@# btrfs subvolume create /mnt/@snapshots# btrfs subvolume create /mnt/@home# btrfs subvolume create /mnt/@var_log Mount top-level subvolumes Unmount the system partition at /mnt.1# umount /mnt Now mount the newly created subvolumes by using the subvol= mount option (with enabled compress zstd).123456# mount -o compress=zstd,subvol=@,discard /dev/mapper/cryptroot /mnt# mkdir -p /mnt/{boot,home,.snapshots,var/log}# mount -o discard /dev/sda1 /mnt/boot# mount -o compress=zstd,subvol=@home,discard /dev/mapper/cryptroot /mnt/home# mount -o compress=zstd,subvol=@snapshots,discard /dev/mapper/cryptroot /mnt/.snapshots# mount -o compress=zstd,subvol=@var_log,discard /dev/mapper/cryptroot /mnt/var/log Create nested subvolumes Create any nested subvolumes you do not want to have snapshots of when taking a snapshot of /. Every nested subvolume will be an empty directory inside the snapshot. Since the @ subvolume is mounted at /mnt you will need to create a subvolume at /mnt/var/cache/pacman/pkg as a nested subvolume You may have to create any parent directories first.123# mkdir -p /mnt/var/cache/pacman# btrfs subvolume create /mnt/var/cache/pacman/pkg# btrfs subvolume create /mnt/var/tmp Installation Select the mirrors I will use huaweicloud as main mirror1# sed -i '1aServer = https://mirrors.huaweicloud.com/archlinux/$repo/os/$arch\\n' /etc/pacman.d/mirrorlist Install essential packages1# pacstrap /mnt base base-devel linux linux-firmware btrfs-progs vim rng-tools git tmux openssh bash-completion zram-generator bluez bluez-utils snapper Configure the system Fstab 1# genfstab -U /mnt &gt;&gt; /mnt/etc/fstab Chroot 1# arch-chroot /mnt Time zone 123# ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime# timedatectl set-ntp true# hwclock --systohc Localization 12345# sed -i 's/#en_US.UTF-8 UTF-8/en_US.UTF-8 UTF-8/g' /etc/locale.gen# sed -i 's/#zh_CN.UTF-8 UTF-8/zh_CN.UTF-8 UTF-8/g' /etc/locale.gen# locale-gen# echo &quot;LANG=en_US.UTF-8&quot; &gt;&gt; /etc/locale.conf# echo &quot;KEYMAP=us&quot; &gt;&gt; /etc/vconsole.conf Network configuration Create the /etc/hostname file: 1# echo &quot;myhostname&quot; &gt; /etc/hostname Add matching entries to hosts(5): /etc/hosts123127.0.0.1 localhost::1 localhost127.0.1.1 myhostname.neo myhostname Choose one of the following methods: Using systemd-networkd &amp; systemd-resolved &amp; iwd Install iwd: pacman -S iwd Wireless adapter configuration Use ip link to show network interface names /etc/systemd/network/25-wireless.network12345[Match]Name=&lt;Your wireless interface name&gt;[Network]DHCP=yes Enable daemons and systemd-resolved stub mode:1234# systemctl enable iwd.service# systemctl enable systemd-networkd.service# systemctl enable systemd-resolved.service# ln -rsf /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf Using NetworkManager Install &amp; Enable NetworkManager:12# pacman -S networkmanager# systemctl enable NetworkManager.service Random number generation Enable Rng-tools 1# systemctl enable rngd.service Configuring mkinitcpio Using the sd-encrypt hook with the systemd-base initramfs. (replace hook udev with systemd) /etc/mkinitcpio.conf 1 HOOKS=(base systemd autodetect keyboard sd-vconsole modconf block sd-encrypt filesystems fsck) Configure /etc/crypttab.initramfs (As /etc/crypttab but in initramfs; Here I enabled Discard/TRIM support for SSD): /etc/crypttab.initramfs1cryptroot UUID=&lt;UUID_OF_ROOTFS&gt; - discard Recreate the initramfs image 1# mkinitcpio -P Users and password Create and use an unprivileged(non-root) user account(s) for most tasks 1# useradd -m -s /bin/bash &lt;Username&gt; sudo: add user to sudoers and disable password prompt timeout 12# echo &quot;&lt;Username&gt; ALL=(ALL) ALL&quot; &gt;&gt; /etc/sudoers.d/&lt;Username&gt;# echo &quot;Defaults passwd_timeout=0&quot; &gt; /etc/sudoers.d/notimeout Setting the new user and root user’s password 12# passwd &lt;Username&gt;# passwd root AUR helper Using paru as AUR helper Create makepkg wrapper makepkg-shallow to make makepkg do shallow clone/usr/bin/makepkg-shallow12345678910111213141516#!/bin/bashgit() { if [[ $# -gt 1 &amp;&amp; $1 == 'clone' &amp;&amp; $2 != '-s' ]]; then /bin/git &quot;$@&quot; --depth=1 --no-single-branch elif [[ $# -gt 1 &amp;&amp; $1 == 'fetch' ]]; then /bin/git fetch --depth=3 -p elif [[ $# -gt 1 &amp;&amp; [$1 == 'describe' || $1 == 'rev-list'] ]]; then /bin/git fetch --unshallow -p /bin/git &quot;$@&quot; else /bin/git &quot;$@&quot; fi}source /bin/makepkg &quot;$@&quot; Build &amp; Install paru12345678910# chmod 755 /usr/bin/makepkg-shallow# mkdir /build# chown -R &lt;Username&gt;:&lt;Username&gt; /build# cd /build# sudo -u &lt;Username&gt; git clone --depth=1 https://aur.archlinux.org/paru.git# cd paru# sudo -u &lt;Username&gt; makepkg-shallow --noconfirm -si# pacman -Qtdq | xargs -r pacman --noconfirm -Rcns# rm -rf /home/&lt;Username&gt;/.cache# rm -rf /build Boot loader Installing the EFI boot manager 1# bootctl install Automatic update The package systemd-boot-pacman-hook[AUR] provides a Pacman hook to automate the update process. Please be aware that the description of configure Secure Boot below overrides the hook in this package. Configuring the boot loader /boot/loader/loader.conf1234default arch.conftimeout 4console-mode maxeditor no use lsblk -f to show persistent block device naming /boot/loader/entries/arch.conf1234title Arch Linuxlinux /vmlinuz-linuxinitrd /initramfs-linux.imgoptions root=/dev/mapper/cryptroot rootflags=compress=zstd,subvol=@,discard /boot/loader/entries/arch-fallback.conf1234title Arch Linux (fallback)linux /vmlinuz-linuxinitrd /initramfs-linux-fallback.imgoptions root=/dev/mapper/cryptroot rootflags=compress=zstd,subvol=@,discard (Optional) Enable sshd 1# systemctl enable sshd.service (Optional) Configurate zram-generator Configuration /etc/systemd/zram-generator.conf123[zram0]zram-size = min(min(ram, 4096) + max(ram - 4096, 0) / 2, 32 * 1024)compression-algorithm = zstd Applying config changes 12# systemctl daemon-reload# systemctl restart systemd-zram-setup@zram0 (Optional) Enable bluetooth 1# systemctl enable bluetooth.service Bluetooth auto power-on after boot: /etc/bluetooth/main.conf12[Policy]AutoEnable=true (Optional) Add Archlinuxcn repository 1234[archlinuxcn]Server = https://repo.archlinuxcn.org/$arch## or install archlinuxcn-mirrorlist-git and use the mirrorlist#Include = /etc/pacman.d/archlinuxcn-mirrorlist Install archlinux-keyring 1# pacman -S archlinuxcn-keyring Post-installation Rebooting to installed system to ensure that systemd is running. (Optional) Configuration of snapper Ensure /.snapshots is not mounted and does not exist as folder: 12# umount /.snapshots# rm -r /.snapshots Then create a new configuration for /. Snapper create-config automatically creates a subvolume .snapshots with the root subvolume @ as its parent, that is not needed for current filesystem layout, and can be deleted. 123# snapper -c root create-config /# btrfs subvolume delete /.snapshots# mkdir /.snapshots Now mount @snapshots to /.snapshots: 1# mount -o compress=zstd,subvol=@snapshots,discard /dev/mapper/cryptroot /.snapshots (Optional) Unlocking encrypted root filesystem by using a TPM. list your installed TPMs and the driver in use: 1$ systemd-cryptenroll --tpm2-device=list If you encounter such message “TPM2 support is not installed” then try to install tpm2-tss A key may be enrolled in both the TPM and the LUKS volume using only one command. The following example binds the key to PCRs 0 and 7 (the system firmware and Secure Boot state): 1# systemd-cryptenroll --tpm2-device=/path/to/tpm2_device --tpm2-pcrs=0+7 /dev/sda2 Tip: If your computer has only one TPM installed, which is usually the case, you may instead specify --tpm2-device=auto to automatically select the only available TPM. Specifying the root volume using the /etc/crypttab.initramfs: /etc/crypttab.initramfs1cryptroot UUID=&lt;UUID_OF_ROOTFS&gt; - tpm2-device=auto,discard Regenerate the initramfs: 1# mkinitcpio -P To remove a key enrolled using this method, run: 1# systemd-cryptenroll /dev/sdX --wipe-slot=slot_number where slot_number is the numeric LUKS slot number in which your TPM key is stored. Alternatively, run: 1# systemd-cryptenroll /dev/sdX --wipe-slot=tpm2 to remove all TPM-associated keys from your LUKS volume. Secure Boot by using a signed boot loader (shim) Install shim-signed[AUR], sbsigntools and efibootmgr 1# paru -S shim-signed sbsigntools efibootmgr As shim tries to launch grubx64.efi, rename systemd boot loader to it. 1# cp /boot/EFI/systemd/systemd-bootx64.efi /boot/EFI/BOOT/grubx64.efi Copy shim and MokManager to boot loader directory: 12# cp /usr/share/shim-signed/shimx64.efi /boot/EFI/BOOT/BOOTx64.EFI# cp /usr/share/shim-signed/mmx64.efi /boot/EFI/BOOT/ (Optional) create a new NVRAM entry to boot BOOTx64.EFI: 1# efibootmgr --verbose --disk /dev/sda --part 1 --create --label &quot;Shim&quot; --loader /EFI/BOOT/BOOTx64.EFI Generate a Machine Owner Key: 12$ openssl req -newkey rsa:4096 -nodes -keyout MOK.key -new -x509 -sha256 -days 3650 -subj &quot;/CN=my Machine Owner Key/&quot; -out MOK.crt$ openssl x509 -outform DER -in MOK.crt -out MOK.cer Sign boot loader (named grubx64.efi) and kernel: 12# sbsign --key MOK.key --cert MOK.crt --output /boot/vmlinuz-linux /boot/vmlinuz-linux# sbsign --key MOK.key --cert MOK.crt --output /boot/EFI/BOOT/grubx64.efi /boot/EFI/BOOT/grubx64.efi We can automate the kernel signing with a pacman hook: Create pacman’s default hooks directory if it doesn’s exist: 1# mkdir /etc/pacman.d/hooks /etc/pacman.d/hooks/999-sign_kernel_for_secureboot.hook12345678910111213141516[Trigger]Operation = InstallOperation = UpgradeType = PackageTarget = linuxTarget = linux-ltsTarget = linux-hardenedTarget = linux-zen[Action]Description = Signing kernel with Machine Owner Key for Secure BootWhen = PostTransactionExec = /usr/bin/find /boot/ -maxdepth 1 -name 'vmlinuz-*' -exec /usr/bin/sh -c 'if ! /usr/bin/sbverify --list {} 2&gt;/dev/null | /usr/bin/grep -q &quot;signature certificates&quot;; then /usr/bin/sbsign --key /etc/pacman.d/hooks/MOK.key --cert /etc/pacman.d/hooks/MOK.crt --output {} {}; fi' ;Depends = sbsigntoolsDepends = findutilsDepends = grep Also, there is a pacman hook for systemd-boot upgrades: /etc/pacman.d/hooks/100-systemd-boot.hook1234567891011[Trigger]Type = PackageOperation = UpgradeTarget = systemd[Action]Description = Gracefully upgrading systemd-boot...When = PostTransactionExec = /bin/sh -c '/usr/bin/systemctl restart systemd-boot-update.service &amp;&amp; cp /boot/EFI/systemd/systemd-bootx64.efi /boot/EFI/BOOT/grubx64.efi &amp;&amp; cp /usr/share/shim-signed/shimx64.efi /boot/EFI/BOOT/BOOTx64.EFI &amp;&amp; sbsign --key /etc/pacman.d/hooks/MOK.key --cert /etc/pacman.d/hooks/MOK.crt --output /boot/EFI/BOOT/grubx64.efi /boot/EFI/BOOT/grubx64.efi'Depends = shim-signedDepends = sbsigntools Then copy Mok.key and MOK.crt to the path which is specified above: 1# cp MOK.key MOK.crt /etc/pacman.d/hooks/ Copy MOK.cer to a FAT formatted file system (you can use EFI system partition). 1# cp MOK.cer /boot/ Reboot and enable Secure Boot. If shim does not find the certificate grubx64.efi is signed with in MokList it will launch MokManager (mmx64.efi). In MokManager select Enroll key from disk, find MOK.cer and add it to MokList. When done select Continue boot and your boot loader will launch and it will be capable launching any binary signed with your Machine Owner Key. Desktop Environment Installation KDE12# pacman -S plasma-meta konsole dolphin ark kio-fuse# systemctl enable sddm.service GNOME Some packages require archlinuxcn’s repository 123456$ paru -S gnome-shell gnome-shell-extensions gdm \\nautilus file-roller sushi seahorse eog \\gnome-{control-center,terminal,tweaks,keyring,backgrounds,clocks,logs,screenshot,menus} \\gtk-engine-murrine materia-gtk-theme \\dconf-editor loginized# systemctl enable gdm.service (Optional) Install &amp; Configure input method:12# pacman -S fcitx5-im fcitx5-chinese-addons# cp /usr/share/applications/org.fcitx.Fcitx5.desktop ~/.config/autostart/ ~/.pam_environment123GTK_IM_MODULE DEFAULT=fcitxQT_IM_MODULE DEFAULT=fcitxXMODIFIERS DEFAULT=\\@im=fcitx (Optional|KDE) Turn off screen (DPMS) together with locking session: Go to: System Settings &gt; Notifications &gt; Applications(The button “Configure”) &gt; Search “Screen Saver” &gt; Configure Events: Select Screen locked and check box “Run command”, paste /bin/sleep 2; /usr/bin/xset dpms force off into it. NVIDIA &amp; NVIDIA Optimus I will use the method of PRIME render offload which was official method supported by NVIDIA The nvidia-prime package provides a script that can be used to run programs on the NVIDIA card.1# pacman -S nvidia nvidia-prime To run a program on the NVIDIA card you can use the prime-run command:12$ prime-run glxinfo | grep &quot;OpenGL renderer&quot;$ prime-run vulkaninfo Dynamic power management of the dGPU Enable runtime power management for each PCI function 12# echo auto &gt; /sys/bus/pci/devices/&lt;Domain&gt;:&lt;Bus&gt;:&lt;Device&gt;.&lt;Function&gt;/power/control# modprobe nvidia &quot;NVreg_DynamicPowerManagement=0x02&quot; The automated ways to perform the manual steps mentioned above so that this feature works seamlessly after boot: Create a file named 80-nvidia-pm.rules in /lib/udev/rules.d/ directory/lib/udev/rules.d/80-nvidia-pm.rules12345678# Remove NVIDIA Audio devices, if presentACTION==&quot;add&quot;, SUBSYSTEM==&quot;pci&quot;, ATTR{vendor}==&quot;0x10de&quot;, ATTR{class}==&quot;0x040300&quot;, ATTR{remove}=&quot;1&quot;# Enable runtime PM for NVIDIA VGA/3D controller devices on driver bindACTION==&quot;bind&quot;, SUBSYSTEM==&quot;pci&quot;, ATTR{vendor}==&quot;0x10de&quot;, ATTR{class}==&quot;0x030000&quot;, TEST==&quot;power/control&quot;, ATTR{power/control}=&quot;auto&quot;# Disable runtime PM for NVIDIA VGA/3D controller devices on driver unbindACTION==&quot;unbind&quot;, SUBSYSTEM==&quot;pci&quot;, ATTR{vendor}==&quot;0x10de&quot;, ATTR{class}==&quot;0x030000&quot;, TEST==&quot;power/control&quot;, ATTR{power/control}=&quot;on&quot; You can use udevadm info --attribute-walk --path=/sys/bus/pci/devices/&lt;Domain&gt;\\:&lt;Bus&gt;\\:&lt;Slot&gt;.&lt;Function&gt; to get a PCI device’s attribution Set the driver option via the kernel module configuration files/etc/modprobe.d/nvidia.conf1options nvidia &quot;NVreg_DynamicPowerManagement=0x02&quot; Reboot the system Troubleshot blacklist kernel module/etc/modprobe.d/blacklist.conf12blacklist ideapad_laptopblacklist nouveau Disable media automount in GNOME12$ gsettings set org.gnome.desktop.media-handling automount false$ gsettings set org.gnome.desktop.media-handling automount-open false Video Decode is disabled in Microsoft Edge~/.config/microsoft-edge-dev-flags.conf123--ignore-gpu-blocklist--enable-features=VaapiVideoDecoder--enable-accelerated-video-decode In Surface Devices: I use KDE for more smooth experience Instal linux-surface kernel1234$ curl -s https://raw.githubusercontent.com/linux-surface/linux-surface/master/pkg/keys/surface.asc \\ | sudo pacman-key --add -$ sudo pacman-key --finger 56C464BAAC421453$ sudo pacman-key --lsign-key 56C464BAAC421453 Add the repository:/etc/pacman.conf12[linux-surface]Server = https://pkg.surfacelinux.com/arch/ Then you can install the linux-surface kernel and its dependencies. You should also enable the iptsd service for touchscreen and stylus support:123$ sudo pacman -Syu$ sudo pacman -S linux-surface linux-surface-headers iptsd$ sudo systemctl enable iptsd Don’t forget to change the corresponding loader entries’ config SDDM has problem with NetworkManager &amp; Long loading time: Use GDM as a replace, don’t forget to configure KDE Wallet’s PAM:/etc/pam.d/gdm-password123...auth optional pam_kwallet5.sosession optional pam_kwallet5.so auto_start Auto disable touch screen after login (X11): First install xorg-xinput. Then create a shell script:disable_touch_screen.sh1234#!/bin/bashif [[ ${XDG_SESSION_TYPE} = &quot;x11&quot; ]]; then xinput disable `xinput list | egrep -o &quot;IPTS Touch.+id=[0-9]+&quot; | egrep -o &quot;[0-9]+&quot;`fi Finally go to System Settings &gt; Startup and Shutdown &gt; Autostart: Press Add button and select Add Login Script, choose the script you just created. Additional Packages Additional Packages123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120[AUR] gnome-shell-extension-appindicator[AUR] gnome-shell-extension-kimpanel-git[AUR] gnome-shell-extension-dash-to-dock[AUR] gnome-shell-extension-desktop-icons-ng[AUR] gnome-shell-extension-freon-gitgvfs-mtpgpastesnap-pacnoto-fonts{,-cjk,-emoji}xf86-video-intelvulkan-intelvulkan-toolslibva-utils^[AUR] libva-intel-driver-hybrid^intel-media-driverpulseaudio-bluetooth[AUR] fcitx5-pinyin-zhwikifcitx5-material-colorbpytophtopdockerdocker-composezerotier-onemancmakegdbarch-install-scriptspacman-contribrsynctreenmaptraceroutecompsizewireguard-toolspicocom ($ picocom -b 1500000 /dev/ttyUSB0, Ctrl-a Ctrl-q to quit)[AUR] tealdeerncdu[AUR] cppmanopenbsd-netcatbcp7zipunrarzshzsh-autosuggestionszsh-syntax-highlightingzsh-history-substring-searchnpm[AUR] hexo-clitelegram-desktopthunderbirdankiremmina- libvncserver- freerdpv2raytexlive-most- [AUR] tllocalmgr-gitlibreoffice-stillblenderkrita[AUR] bitwarden[AUR] qv2ray-dev-git[AUR] v2ray-cap-git[AUR] cgproxyobs-studiompv[AUR] visual-studio-code-bin[AUR] microsoft-edge-dev-bin[AUR] xmind-2020[AUR] netease-cloud-music-gtksteam- ttf-liberation- lib32-vulkan-intelpython-pippython-matplotlibpython-pandaspython-seabornlutriswine- lib32-giflib- lib32-gnutls- lib32-mpg123- lib32-openal- lib32-v4l-utils- lib32-libpulse- lib32-libxcomposite- lib32-libxinerama- lib32-libxslt- lib32-gst-plugins-base-libsdebootstrapubuntu-keyringvirt-managerlibvirt- dmidecode- dnsmasq- ebtables- ^qemu ^[AUR] qemu-user-static [AUR] binfmt-qemu-static-all-archedk2-ovmf[AUR] v2raya[Archlinuxcn] fcitx5-pinyin-moegirl[AUR] syncthing-gtkqtcreator","link":"/zh-cn/computer/2020/archlinux-installation-standard/"},{"title":"blender","text":"开始入门 Blender, 契机是我的米家随手吸尘器的配件-前置滤网的 ABS 框架被我烤变形了, 淘宝搜寻一番后发现卖 50+ 实在太贵, 遂自己建模打印一个. 常规软件设置 在状态栏(右下角)显示内存、显存、点线面数量等信息: 启用模拟三键鼠标(Alt+鼠标左键 旋转视角, 类似 MAYA 的操作): 但是注意开启之后会导致选择循环边快捷键变成双击选择, 建议适应鼠标中键旋转视角(这样的优势在于一只手就能旋转视觉了) 启用围绕选择物体旋转和自动深度(解决视角无法继续推近的问题) 启用自动加载 Python 脚本(一些插件需要开启, 不然可能会报错) 启用插件: Node: Node Wrangler (强大的节点工具) Rigging: Rigify (自带的强大绑骨软件) Import-Export: Import Images as Planes (导入图像为平面) Import-Export: Export Autocad DXF Format (.dxf) (导出为 DXF 格式) Import-Export: Import AutoCAD DXF Format (.dxf) (导入为 DXF 格式) Add Curve: Extra Objects (添加额外的曲线物体) Add Mesh: BoltFactory (添加螺栓) Add Mesh: Extra Objects (添加额外的网格物体) Add Mesh: A.N.T.Landscape (简单地形制作) Interface: Modifier Tools (修改器工具) Interface: Copy Attributes Menu (复制属性菜单) Mesh: LoopTools (Loop 工具) Object: Bool Tool (布尔工具) Render: Auto Tile Size (自动 Tile 大小, 能自动帮你设置渲染块数量, 提供硬件利用率) UV: Magic UV (魔法 UV) 最后别忘了保存设置 基础操作 观察物体: ➀ 视角旋转: 鼠标中键 或 Alt+左键 (模拟三键鼠标) ➁ 视角平移: Shift+鼠标中键 或 Shift+Alt+鼠标左键 (模拟三键鼠标) ➂ 摄像机视图切换: 小键盘0 ➃ 透视/正交切换: 小键盘5 提示: 若是87键键盘没有小键盘, 可通过在首选项开启模拟数字键盘, 使普通数字键作为快捷键使用 摄像机相关: 如何让摄像机跟随视角同步? 按 N 键开启 N 面板, 然后点击视图选项卡, 勾选锁定相机到视图 如何更改摄像机取景框的比例和大小? ➀ 见图: ➁ 在关闭锁定相机到视图的情况下, 在相机视图下直接使用鼠标滚轮和视角平移操作就可以改变相机取景框在屏幕上的大小和位置 我找到了一个不错的角度, 如何将当前的视角快速变为摄像机视图? 场景集合列表(Scene Collection)中选中相机物体, 然后 Ctrl+Alt+小键盘0 四视图视角: Ctrl+Alt+Q 顶视图: 小键盘7; 底视图: Ctrl+小键盘7 前视图: 小键盘1; 后视图: Ctrl+小键盘1 右视图: 小键盘3; 左视图: Ctrl+小键盘3 翻转当前视角: 小键盘9 (如当前是顶视图, 翻转变成底视图; 正交视图之外的情况是绕Z轴翻转) 聚焦当前物体: 选中目标物体, 然后在视图中按小键盘的'.'键 聚焦并屏蔽其他物体的显示: 选中目标物体, 然后在视图中按小键盘的'/'键 在四视图界面, 要想同步聚焦, 按 Ctrl+小键盘'.'键 显示整个场景: Home 键 调整物体 开启移动, 旋转, 调整工具的实时显示: Gizmo 可通过 Ctrl+` 来快速开关 移动物体: 快捷键 G, 此时按 X、Y、Z 可使其在对应的轴上移动, 输入数字可以进行精确移动. 若要在对应的平面上移动, 可按 Shift+垂直轴的字母, 如 Shift+Z 为在 X-Y 平面内移动 位置归零: Alt+G 旋转物体: 快捷键 R, 默认是基于当前视角旋转, 此时再按 R 可进入视角深度旋转, 按 X、Y、Z 可使其在对应的轴上旋转, 输入数字可以进行精确旋转(角度制). 旋转归零: Alt+R 缩放物体: 快捷键 S, 按 X、Y、Z 可使其在对应的轴上缩放, 输入数字可以进行精确缩放. 若要在对应的平面上缩放, 可按 Shift+垂直轴的字母 缩放归零: Alt+S 也可利用N面板调整物体: 选择物体 按 W 切换选择工具, 共有四种, 分别为选择移动工具、框选工具、刷选工具、套索选择工具 还可以设置对应工具的属性(如交集选择) 按 A 键全选, 再次按 A 或 Alt+A 取消全选 新建物体 物体添加: Shift+A, 注意物品添加时部分支持使用新建参数, 但这个参数仅在新建时才有效 删除物体 两种方法: Delete 键删除或按 X 删除 坐标系与轴心点 物体变换坐标系: 快捷键 , 局部(Local)坐标系: 基于物体本身方向的坐标系 可在对象属性下的视图显示里开启局部坐标轴显示: 进入变换模式, 二次点击轴字母即可快速切换全局/局部坐标系. 可以在编辑器的顶栏设置默认使用的坐标系: 法向(Normal)坐标系 切换到法向模式, 进入编辑模式中的面选择模式, 点击一个平面, 可以看到Z轴和这个平面平行 (按 Tab 进入编辑模式, 此时按 1、2、3 进入点、线、面选择模式, 注意要使用这个快捷键需关闭模拟数字键盘) 同样的, 进入变换模式后, 二次点击轴字母即可快速切换到全局坐标系 万向(Gimbal)坐标系 对于万向轴来说, 它可通过固定两个轴(旋转轴和转向轴)的方式让第三个绕旋转轴旋转, 如让某个圆球的万向轴设置为旋转轴是它的的局部X轴, 转向轴为它的局部Z轴, 可在 Object Properties-&gt;Transform 选择 Mode 为 “YXZ Eular” (第二个字母为旋转轴, 第三个字母为转向轴): 此时当我们尝试将物体绕着X轴旋转, Y轴会发生变化, 但无论如何旋转, 万向坐标系的Z轴永远保持和全局坐标Z轴一个方向, 且万向Z轴与X轴始终保持正交 视图(View)坐标系 坐标轴XY与视窗锁定, 上下为Y, 左右为X, 垂直平面为Z 创建坐标系功能 使场景中所有的物体的坐标系为某个物体的局部坐标系 (复制物体の两种方法: 选中物体, Ctrl+C + Ctrl+V 或 Shift+D) 选中某个物体, 点击变换坐标系菜单的&quot;+&quot;号: 此时会生成一个与该物体名称相同的坐标系, 其他物体的坐标系变为此物体的局部坐标系: 游标坐标系 和创建坐标系功能相似, 可以选择游标工具或在选择工具下按住 Shift+鼠标右键 拖动, 移动后游标会朝向移动时的视角 物体变换轴心点 原点: 物体中心的橘黄色的小点称为原点, 可在编辑器右上角的选项中启用仅影响原点来对原点进行变换操作: 移动了原点后, 可通过右键菜单中的设置原点子菜单恢复原点位置: (分别是几何中心到原点, 原点到几何中心, 原点到3D游标, 原点到重心(表面), 原点到重心(体积)) 变换轴心点: 选择多个物体后出现的一个变换位置用的轴心点, 可使用句号键 “.” 或在编辑器的顶部选择变换轴心点位置的计算方式(边界框中心、3D游标、各自的原点、质心点、活动元素): 质心点(Median Point): 为变换轴心点计算的默认方式, 是基于原点计算产生的均值, 在只有一个物体选择的情况下, 质心等于原点. 边界框中心(Bounding Box Center) 边界框可在 Object Properties-&gt; Viewport Display 这里勾选 Bounds 来开启显示 如图, 在边界框中心模式下, 两物体的变换轴心点是根据两个边界框来计算的 3D游标(3D Cursor): 顾名思义, 就是变换轴心点的位置是游标的位置. 配合下一章的吸附. 各自的原点(Individual Origins): 比较特别, 此模式下对选中的多个物体进行缩放和旋转都会对以各自的原点进行变换, 而不是一个统一的变换轴心点. 如下图中的旋转操作: 活动元素(Active Element): 变换轴心点的位置是活动元素(最后选择的对象, Scene Collection 中高亮的那个)的原点 当使用句号键 “.” 在弹出的浮动菜单勾选仅位置后, 选择的多个物体的缩放和旋转只会相对于变换轴心点进行相对的距离和角度的变换而不会改变物体本身的缩放和旋转. 如图, 旋转操作不旋转物体本身, 只是相对于变换轴心点的角度进行位置上的&quot;旋转&quot; 吸附与衰减编辑工具 吸附功能全解: 可通过 Shift+Tab 或点击编辑器顶部的磁铁图标来开启或关闭吸附功能, 也可在变换的时候按住 Ctrl 来临时开启或(在吸附模式开启状态下)关闭 旁边的下拉菜单可以调整吸附对象的吸附内容(Snap To)和被吸附对象的吸附基准点(Snap With)和影响的变换(移动 Move、选择 Rotate、缩放 Scale): 为了更好地展示吸附效果, 开启线框模式(快捷键 Shift+Z): 对于吸附基准点, 最近=被吸附对象离吸附目标最近距离的顶点, 中心=变换轴心点约等于质心, 但由变换轴心点的设置决定(参见上章). 可通过 Shift+S 呼出游标吸附相关的浮动菜单, 从而让游标吸附到各种位置上. 如将游标吸附到某个选择的面上: Tab 进入编辑模式, 3 进入点线面的面模式, 然后选中物体的某个平面, Shift+S 呼出游标吸附菜单, 选择 Cursor to Selected, 如图所示. 增量模式(Increment): 物体的变换会吸附到背景网格上, 可利用不同缩放下网络间距不同来达到选择移动 0.1M 或 1.0M 的效果. 默认是相对于网格的移动, 若选中绝对栅格对齐(Absolute Grid Snap), 则物体/多个物体的质心会被严格吸附到网格点上. 如图所示(俯视图), 移动后, 两个方块的质心点被吸附到网格上: 顶点模式(Vertex): 物体的变换会吸附到其他物体的顶点上. 勾选背面剔除(Backface Culling)后, 将不会吸附当前视角下处在物体背面的顶点. 勾选旋转对齐目标(Align Rotation to Target)后, 被吸附物体的局部坐标轴的Z轴会与顶点的法向对齐, 如图: 其他的功能, 自己尝试吧~ 这里说一下面模式的妙用, 可以很方便地实现让一个物体摆放在另一个物体之上: 我们将这个要放置物体的原点置于底面的中心(配合四视图比如正视图+吸附功能) ) 然后选择面吸附模式下并设置吸附基准点为质心(Median), 就可以将这个物体完美地放在另一个物体的平面上啦~ 面模式下, 勾选项目的独立元素(Project Individual Elements)后, 将会使选择多个物体使用各自的原点进行吸附. 此外, 若在编辑模式下进行面吸附, 可以将网格物体贴合到另一个物体的面上, 目前版本贴合似乎有bug, 建议多开一个窗口用正交视图下(四视图)进行贴合. 垂直交线(Edge Perpendicular)模式: 物体会被吸附到吸附基准点与目标吸附物体的边的垂直交线的交点上, 也适用于编辑模式下的顶点模式. 衰减编辑: 快捷键 O. 启用衰减编辑后, 对其中一个物体进行变换会带动周围的物体一起进行变换. 如图, 启用衰减编辑后, 变换物体时会出现一个灰色的圈, 圈内的物体会被带动, 使用鼠标可以改变圈的大小 衰减的模式有许多种, 具体可以自己逐一尝试, 这里略过不讲. 提一下衰减编辑配合网格(Grid)对象在编辑模式下的运用: 配合从视角投影(Projected from View)可以做到根据视角的投影方向进行统一的操作: 常用基础操作集中处理(游标、物体合并分立、操作重复执行、第一人称观察、物体隐藏、物体父子级、物体镜像变换) 游标操作: 游标移动相关浮动菜单 Shift+S 游标快速移动 Shift+右键拖动 游标回到世界坐标 Shift+C 物体合并分离: 合并: 选择物体然后 Ctrl+J 分离: 进入编辑模式选择分离部分(可使用快捷键 L 选择相邻元素)然后 P 或 Alt+M 提示: 合并后原点为活动项原点, 分离后原点位置在分离物体原点上 操作重复执行: 复制/变换等常规操作完成后按 Shift+R 第一人称观察和拍摄: Shift+~ 进入后, WASDEQ 前后左右上下, +Shift 加速, +Alt 减速, 空格 可快速前进到准星对准的物体处 可配合相机的锁定到视图实现相机的自由移动 记录K帧: 在相机的 Object Properties-&gt;Transform 下, 将鼠标指针停留在各项参数上然后按 I 键来启动记录(这里我们记录位置旋转缩放的信息), 最后开启自动记录关键帧. 此时按 空格 启动播放, 然后进入第一人称模式自由进行摄像机的一些移动: 可以选择然后按 X 或 Delete 来删除一些不想要的关键帧 进入到关键帧曲线编辑器(Graph Editor), 可以对关键帧进行一些平滑处理: 在编辑器中按 A 键选择所有曲线, 然后找到 Key-&gt;Smooth Keys (快捷键 Alt+O) 来平滑关键帧. 平衡一次的效果可能不够明显, 可以通过连续按住 Alt+O 来较为彻底地平滑曲线: 物体隐藏、显示、禁用 隐藏: 可通过点击物体然后按 H 或点击场景集合(Scene Collation)中物体旁边的&quot;小眼睛&quot;来实现. 显示: 重新显示所有隐藏对象 Alt+H 禁用: 首先确保在导航面板(Outliner)中, Restriction Toggles 的 Disable in Viewports (显示器图标)和 Disable in Renders (相机图标)为开启状态: 然后就可以对物体设置视图中禁用和渲染中禁用了: 物体父子级: 子物体可以实现与父物体变换操作的同步 建立父子级: 选择多个物体后, 按 Ctrl+P, 活动项会成为父级 清空父级: Alt+P 也可在导航面板(Outliner)按住 Shift 拖动物体来建立或取消父子级关系: 物体镜像变换 如图, 在同一位置通过 Shift+D 然后右键取消位移的方式原位复制一个猴子(这样在镜像后原来的猴子就不会消失) 选中要镜像变换的物体(上图中的 Suzanne.001), 按 Ctrl+M 进入交互式镜像变换模式, 此模式下, 按 XYZ 或者 鼠标中键拖拽 可以选择镜像轴: 建模功能篇 初识编辑模式点线面与统计信息拓展 点线面切换: 主键盘1/2/3 模式加减选: Shift+1/2/3 统计信息除了在首选项里进行信息栏的开启外, 也可在视图编辑器的视图叠加层设置(Viewport Overlays)中进行开启: 物体模式(Object Mode)统计数据计算的所有物体数据总和 编辑模式(Edit Mode)统计数据计算当前进入编辑物体数据总和 三角形(Triangles)为网格等效为三角面之后的预估数量, 面是可以三角化的: 挤出类工具全解(挤出、沿法向挤出、挤出各个面、挤出至游标) 初识T面板 左侧的工具栏可以通过 T 键开启/隐藏 鼠标移动到工具栏位置然后按 小键盘 +/- 可实现UI缩放. 向右拖拽工具栏可以切换显示并排工具栏、名称工具栏(推荐切换到图2的并排工具栏) 挤出并移动 进入编辑模式, T面板会出现 编辑模式下的工具. 选择挤出到选区工具(Extrude Region, 快捷键 E), 单个面默认沿面法向、多个面默认沿质心法向, 可按 X/Y/Z 直接切换轴向移动; 按 Shift+X/Y/Z 可锁定对应轴向方向的移动, 也可以进入对应的正交视图规避未显示轴向的数据干扰 切换到面模式选择一个面, 此时可以看到一个黄色的加号, 拖拽这个加号, 对面的法向方向进行挤出 翻车点: 挤出到选区工具的操作是挤出并移动, 按右键取消的只是移动, 但依旧会进行挤出从而产生一个重叠面. 解决方案是开启投选模式(X-Ray, 快捷键 Alt+Z), 然后框选并按距离合并顶点(快捷键 M). 对于边的法向, 由于不是很直观, 可以在视图叠加层(Viewport Overlays)中进行开启法向线的显示, 图中的按钮分别是点法向/线法向/面法向的显示, 这里我们开启线法向线的显示并将长度设置为0.45 对于面法向, 除了在视图叠加层(Viewport Overlays)中开启法向线的显示外, 还可以启用面朝向(Face Orientation), 蓝色为正面, 红色为反面 沿法向挤出(Extrude Along Normals) 新建两个平面, 将其中一个面翻转. 如图所示, 选中这个面, 然后 Alt+N 在出现的菜单中选择 Flip 来翻转: 可以看到, 选中两个平面后, 挤出并移动工具会默认使用两物体的质心点的法向: 要让选择的平面独立使用自己的法向, 应使用沿法向挤出(Extrude Along Normals)工具, 此时控制柄会变化: 此时拖动平面会沿着各自的法向进行挤出: 挤出各个面(Extrude Individual) 在选取对象为多个相连面的时候, 沿法向挤出是相接的, 而挤出各个面是分开的. 在沿法向挤出模式下, 选择正方形的两个面进行挤出, 会沿着这两个面的夹角作为法向进行挤出: 如果要让挤出变得平均, 需要在挤出操作的历史记录里勾选 Offset Even (均等偏移): 若要让选择的每个面都独自的进行挤出的话, 就需要使用挤出各个面(Extrude Individual)工具了: 挤出至光标(Extrude to Cursor) 把所选挤出到鼠标所在区域, 建议结合正交视图使用. 快捷键 Ctrl+右键 (编辑模式) 挤出流形(Extrude Manifold) 使用其他的挤出工具进行穿插挤压的话, 会出现多余面的问题: 使用挤出流形则可以很好地解决这个问题: 快捷菜单 编辑模式下选中目标然后 Alt+E 即可弹出全部和挤出相关的功能 重复挤出: 除了挤出后按 Shirt+R 进行重复操作外, 在快捷菜单中也可选择 Extrude Reoeat 进行重复挤出, 在弹出的历史操作里进行重复挤出的设置: 绕视图旋转(Spin): 在快捷菜单下还有个旋转功能, 可以让轮廓沿着视图旋转成为一个立体模型: 首先通过顶点挤出创建一个轮廓 然后在俯视图下, Alt+E 然后选择 Spin 使其进行绕Z轴旋转: 当然, 也可以对旋转操作进行参数上的设置 内插面工具全解(激活内插、深度、外插、分离、边界与其他相关参数) 激活内插面 I 激活后: 深度-按住 Ctrl 移动 外插- O 边界- B 分离- I (分离开启会影响到边界和外插属性) 面边界: 只被一个面包含的边 倒角工具全解(全参数解析、额外拓展、解决倒角不均匀) 基础操作 快捷键 Ctrl+B 进入后可根参考状态栏快捷键提示进行操作: 鼠标滚轮或按 S 键拖动切换段数. 按 P 键可控制形状轮廓(内凹还是外凸) 宽度类型 为了更好的演示, 将宽度、段数、形状的值调整至下图所示: 针对宽度类型, 分别有偏移量(Offset), 宽度(Width), 深度(Depth), 百分比(Percent), 绝对值(Absolute) 对于前三个类型, 有如下图可以很好地解释: 偏移量宽度类型(Offset)=平行边 间距=垂线距离 百分比宽度类型(Percent), 会根据倒角原始边的邻边长度决定, 需要注意邻边不同会产生倒角不均匀的问题. 绝对值宽度类型(Absolute), 绝对值=平行线端点连线斜边长度&gt;=垂线距离: 如何测量两点间距离: 举个例子, 将倒角操作的参数设置为宽度类型为宽度(Width), 段数(Segments)为2, 形状为1: 将吸附模式选择为顶点吸附, 选择T面板中的测量工具(Measure), 持续按住 Ctrl (临时启用吸附)拖动连接两个顶点即可: 如何测量深度模式下的距离呢, 这个时候需要做一条辅助线. 选择两个顶点按 J 可在两点间作一条辅助线段, 随后启用吸附的垂直交线模式(按住 Shift 同时开启多个吸附)然后直接测量. 也可继续作一条垂直辅助线: 选中这条线段在右键菜单中选择细分(Subdivide)即可将其一分为二, 此时平分后的线段中间的顶点就是想要用于测量的垂直交线上的点. 其他参数全解 材质编号(Material Index) 为了讲解, 需要给物体上材质: 如图, 在物体的材质属性(Material Properties)下建立三个材质槽, 然后将三个材质更名并设置基础色: 默认情况下物体会使用第一个材质, 可进入编辑模式选择面然后指定该面的材质: 此时进行倒角操作, 会发现默认的 -1 材质编号会自动套用临边的材质. 可通过更改这个参数来选择倒角边的材质 平衡着色与硬化法向 想要让倒角变得平滑, 最笨的方法是给增加段数, 但是面数增加会导致运算量的增加. 更好的方法是使用右键菜单的平滑着色: 默认情况下平滑着色套用到了全局, 可在对象数据属性(Object Data Properties)的法向设置里勾选自动光滑来限制自动平滑角度: 另一种方法是硬化法向, 不影响原始法向, 仅平滑倒角. 为了让效果更为明显, 将试图着色方式改为以下快照材质: 钳制重叠(Clamp Overlap)可以避免宽度增大到一定出现穿插的情况. 外斜接(Miter Outer): 有锐边(Sharp)、补块(Patch)、圆弧(Arc)三种模式. 内斜接(Inner): 有锐边(Sharp)、圆弧(Arc)两种模式 相交类型(Intersection Type): 有栅格填充(Grid Fill)、截止(Cutoff)两种模式. 面强度(Face Strength): 面权重限制法向平滑-结合未来加权法向修改器可以根据条件标记面的权重强弱, 比如面的面积、比如倒角区域, 来限制不同强度区域产生不同程度的平滑效果. 标记(Mark) 缝合边(Seams): 对一个带有缝合边的边进行倒角时会出现缝合边断开的情况, 此时可以勾选标记缝合边来实现自动补全: 什么是缝合边? 有什么用? 进入UV编辑模式, 删除原有的UV映射. 然后想象剪一个纸盒, 选择要剪开的几条边, 将它们设置成缝合边: 按 A 全选, 进行UV展开: 锐边(Sharp)同理, 勾选标记锐边可以自动补全断离的锐边. 什么是锐边? 有什么用? 勾选了锐边后, 90°下的法向自动平滑将不会对标记为锐边的边进行平滑. 自定义倒角轮廓: 选择顶点可进行相关设置、删除: 注意楼梯预设在更改段数后不要忘了点击应用预设的按钮来刷新预设: 倒角不均匀与顶点倒角 倒角不均匀: 注意物体是否进行过变形, 可通过应用菜单(Ctrl+A)的&quot;全部变换(All Transforms)&quot;实现 顶点倒角: 新建一个平面, 在编辑模式下右键菜单选择细分(Subdivide). 然后 Ctrl+Shift+B 进入顶点倒角模式, 参数的设置可参考边线倒角: 环切与偏移环切边工具全解(边线循环原理+全解析环切与偏移环切边工具) 循环边传递原理 环切工具全解 偏移循环边工具全解","link":"/zh-cn/computer/2021/blender/"},{"title":"ffmpeg 常用命令","text":"记一些 ffmpeg 的使用 本页面有些命令过长, 可以使用Shift + 鼠标滚轮的方式左右滚动查看 常用操作 查看文件信息: $ ffprobe -v quiet -print_format json -show_format -show_streams output.mkv 查看文件长度: $ ffprobe -select_streams v:0 -show_entries stream=duration -of default=noprint_wrappers=1:nokey=1 output.mkv 调整视频分辨率: -vf scale=854x480 VCB-Studio x265 压冻鳗常用参数:1$ &lt;stdout&gt; | x265 --y4m -D 10 --preset slower --deblock -1:-1 --ctu 32 --qg-size 8 --crf 15.0 --pbratio 1.2 --cbqpoffs -2 --crqpoffs -2 --no-sao --me 3 --subme 5 --merange 38 --b-intra --limit-tu 4 --no-amp --ref 4 --weightb --keyint 360 --min-keyint 1 --bframes 6 --aq-mode 1 --aq-strength 0.8 --rd 5 --psy-rd 2.0 --psy-rdoq 1.0 --rdoq-level 2 --no-open-gop --rc-lookahead 80 --scenecut 40 --qcomp 0.65 --no-strong-intra-smoothing --output &quot;output.hevc&quot; - 钱桑の常用参数 x26412345678910111213141516171819202122ffmpeg -i example.mp4 \\ -c:v libx264 \\ -preset slow \\ -pix_fmt yuv420p \\ -x264-params \\&quot;crf=28 \\:threads=4 \\:deblock=-1,-1 \\:keyint=600 \\:min-keyint=1 \\:bframes=8 \\:ref=4 \\:qcomp=0.55 \\:rc-lookahead=70 \\:aq-mode=1 \\:aq-strength=0.8 \\:me=umh \\:subme=7 \\:me_range=16 \\:psy-rd=1.3,0.15&quot; \\ -c:a copy \\ output.mp4 钱桑の常用参数 x265123456789101112131415161718192021222324252627282930313233343536ffmpeg -i example.mp4 \\ -c:v libx265 \\ -x265-params \\ &quot;y4m=true \\ :depth=10 \\ :preset=slower \\ :deblock=-1,-1 \\ :ctu=32 \\ :qg-size=8 \\ :crf=28.0 \\ :cbqpoffs=-2 \\ :crqpoffs=-2 \\ :me=3 \\ :subme=3 \\ :merange=20 \\ :limit-tu=4 \\ :no-amp=true \\ :ref=4 \\ :weightb=true \\ :keyint=600 \\ :min-keyint=1 \\ :bframes=6 \\ :aq-mode=1 \\ :aq-strength=0.8 \\ :rd=5 \\ :psy-rd=1.5 \\ :psy-rdoq=1.0 \\ :rdoq-level=1 \\ :rc-lookahead=60 \\ :scenecut=40 \\ :qcomp=0.65&quot; \\ -acodec aac \\ -ac 2 \\ -ab 79k \\ -ar 48000 \\ output.mp4 Windows 平台下 ffmpeg 的 libx265 貌似没有 y4m、depth、preset 等参数, 此时可用 ffmpeg 参数 -pix_fmt yuv420p (10bit 为 yuv420p10le)、-preset slower 来解决. 通过 VA-API 压 HEVC (相比软压缺少很多参数)1$ ffmpeg -hwaccel vaapi -hwaccel_device /dev/dri/renderD128 -vaapi_device /dev/dri/renderD128 -ss 0 -t 4:59 -i example.mkv -vf 'format=nv12,hwupload' -c:v hevc_vaapi -crf 26 -r 24 -acodec aac -strict -2 -ac 2 -ab 192k -ar 44100 -f mp4 -y output.mp4 通过 nvenc 压 H264 (相比软压缺少很多参数, 只有 meduim, slow, fast 三种 present 可选)1$ ffmpeg -hwaccel cuvid -c:v h264_cuvid -i example.mkv -c:v h264_nvenc -preset slow -b:v 2048 -bufsize 4096 -r 30 -profile:v high -level:v 4.1 -acodec aac -strict -2 -ac 2 -ab 192k -ar 44100 -pass 1 -f matroska output.mkv -y 选项解释 主要参考VCB-Studio的文档[2][4]. Encoding Mode (编码模式) --qp Quantization Parameter, 量化参数对应 CQ 模式, 默认值为 23. CQ 模式 (也称 CQP): Const Quantizer, 固定量化模式. 所有 P 帧采用一个固定的 Quantizer. Quantizer, 量化, 是一种衡量图像压缩程度的方法, 用 0-69 的浮点数表示, 0 为无损, 量化值越大, 图像被压缩的越多, 码率越低. 注意量化值不一定代表目视质量, 比如说一个纯色的图像可以以很高的量化值被量化, 占用的体积很小, 而一个很复杂的图像就算量化值不高. 但是压缩后观感也可能很差. 因为 quantizer 不能够较好的体现质量, 所以该模式一般由 Const Quality 模式替代. 就算不用 CQ 模式, Quantizer 这个概念依旧在编码中存在, 只不过编码器可以智能的浮动 QP 值. -crf CRF 模式: Constant Rate Factor 固定质量因子. x264 默认为 23.0, x265 默认为 28.0. x264 用一种结合人心理学估算出来的值, 来衡量视频的目测质量, 即是 RF (Rate Factor), 用浮点数表示, 0 为无损, 越高质量越差. CRF 就是在视频前后采用恒定的 RF 从而使视频前后的目测质量几乎一致. CRF 模式下，码率的时间分配效果是最理想的，也是最常用的模式. x264下, 对于一般视频, CRF 设置在 18-26 左右. 通常采用 19-21.5 就能使得 Rip 看上去很不错. 如需要绝对好的质量可以降低到 16, 但是码率也会很高. x265下, 日常编码建议 23 以上. 对于动漫的高画质编码, 建议至少 8.0 起. 注意, CRF 在搭配不同的参数前提下, 实际造成的目测效果还是有差距的, 甚至可能很大, 因此不能一概的认为 CRF 代表目视质量. 一般 vcb-s 用的 10bit 1080p BDRip，CRF 选择在 16~18 之间. --preset Preset 效率预设, x264 会自动设置很多参数来调节你对速度与效率的取舍. 最快的 ultrafast 速度媲美 GPU 加速, 最慢的 placebo 所需的时间可以是 ultrafast 的近百倍. Preset 越慢，x264 的码率效率越高，意味着单位码率能做到的画质越好. 一般推荐在 slow/slower/veryslow 三档. vcb-s 所用的参数一般基于 --preset &quot;veryslow&quot; --y4m 使用yuv420p颜色空间 -D/--depth 输出精度, 如输出 10bit: --depth 10 --deblock Deblocking 去色块. 现代编码器都是基于 MacroBlock 编码, 把画面划分为一块块的区域, 有损编码后, 区域之间就可能出现可见的 “分界线”. Deblock 的作用就是去除它们, 开启是肯定的. deblock 的两个参数分别是 alpha 和 beta 参数, 这两个参数默认是 0:0. 一般认为合理的范围是-3:-3~3:3 之间. 越是高码率的压片越建议调低; 因为设置高了, deblock 的强度会变大, 对画面有模糊的效果. 通常设置 -1:-1 就行了. 默认 0:0 已经算是比较合理的选择. deblock 的强度和 QP 值有关，所以 deblock 设置不变时, QP 值越低 (码率越高), deblock 的强度就会相应降低. --ctu Code Tree Unit, 指定最大允许 CTU 的尺寸. 虽然 x265 允许 64x64，但是过大的 TU 会增加平面的涂抹，增加运算量, 降低多线程优化可能, 总体来说在&lt;=1080p 的编码下弊大于利, 因此限制为 32 比较好. HEVC divides the picture into CTUs (Coding Tree Unit). In HEVC standard, if something is called xxxUnit, it indicates a coding logical unit which is in turn encoded into an HEVC bit stream. On the other hand, if something is called xxxBlock, it indicates a portion of video frame buffer where a process is target to. Coding Tree Unit is therefore a logical unit. It usually consists of three blocks, namely luma (Y) and two chroma samples (Cb and Cr), and associated syntax elements. Each block is called CTB (Coding Tree Block). CTB can be split into CBs[1] --qg-size 表示用于调整 QP 值的 CU (Coding Unit) 的最小单位, 越低 x265 调整一帧内 QP 值的灵活度越高. 推荐设置为最小值 8. A coding tree unit can be divided into coding units. CU consists of three CBs (Y, Cb, and Cr) and associated syntax elements. [1] --cbqpoffs x264 会根据 Psy 强度自动调整 Chroma 平面的码率分配, x265 无此机制所以经常出现 Chroma 欠码导致的色彩纹理削弱. 给 -2 左右的 offset 可以较好的缓解问题. --crqpoffs 同上, 建议 -2. --no-sao Sample Adatpive Offset, 然而也可称 Smoothing All Objects 可以减少 DCT ringing[3] 等欠码瑕疵, 但代价是极其暴力的涂抹效果, 所以要禁用它 (除非你是极低码率编码). Motion-Estimation (动态分析) --me ME Algorithm 动态搜索算法, 可选: Diamond (--me dia, x265 为 --me 0), 菱形搜索, 不推荐; Hex (--me hex, x265 为 --me 1), 六边形搜索, 默认选项. 只在非常追求速度的时候推荐; Multi Hex (--me umh, x265 为 --me 2), 多重六边形搜索. 非常均衡的算法, 效果非常好, 速度适中. 推荐一般情况下使用; Exhaustive (--me esa, x265 为 --me 4), 全面搜索. 很慢.; SATD Exhaustive(--me tesa) 经过转换的全面搜索. 速度比 esa 稍微慢一点点, 但是效果好一点, 所以一般有时间浪费的都选 tesa 而不是 esa. tesa 比起 umh, 提升在 5%~10%左右. 时间花费上则是 150%~200% 的增加. x265 下增加两个模式 (x265没有 tesa): Star (--me 3), Star is a three-step search adapted from the HM encoder: a star-pattern search followed by an optional radix scan followed by an optional star-search refinement; Full (--me 5), Full is an exhaustive search; an order of magnitude slower than all other searches but not much better than umh or star.[5] Star 综合来说好于 umh，但是不要试图用 Full。因为 x265 目前还没有对 Full 做优化，太慢了. --subme Subpixel Refinement 次像素级别优化. 从 0~11 效果越来越好, 速度也越来越慢. 追求速度推荐用 7, 追求质量推荐用 10, 最低建议 3 (preset = slow 时默认为 3). --merange ME Range, 表示搜索的最大范围. 一般 720p 给 16~24, 1080p 给 24~38. 值越大速度越慢. --me、--subme、--me_range 三个选项共同组成 ME 的参数组合. ME 是以编码时间换效率的另一套参数 (另一个是--ref、--bframes 构成的 Frame). 一般来说, 动态不高的番, 应该是用较强的 Frame 参数, 动态高的番则是用较强的 ME 参数. 一般来说，对于 x264, 下面三个组合是很好的快中慢三种选择: --me umh --subme 7 --me_range 16 --me umh --subme 10 --me_range 24 --me tesa --sumbe 10 --me_range 24 --no-amp、--no-rect amp 和 rect 是 HEVC 规范中对 block 的创新. 一般来说 block 都是正方形, rect 启用 1x2/2x1 类型的; amp 允许 1x4/3x4/4x1/4x3 类型的, 且 amp 是 rect 的充分但不必要条件. 通常来说，&lt;=1080p 下, 两个都没啥作用 (其中 amp 更没作用), 但都很耗时, 所以建议至少关闭 amp. --limit-tu 接上面, 如果 rect 开启, 建议开启 --limit-tu 4 来限制 x265 对分块的（可能）无效尝试. Reference Frames --ref Number of Reference Frames 参考帧数量. 表示某一帧最多允许参照多少其他的帧. ref 对编码所需时间的影响是线性的, ref 能带来的收益则是非线性的. 也即越高的 ReF, 额外收益越低. ref 是一个以编码时间换取编码效率的参数. ref 的数量不仅影响编码效率, 而且影响解码效率, 以及解码时最大缓存帧数. ref 和分辨率与帧率相乘后决定了播放设备需要达到的解码能力, x264 各个 Level 对其 ref 上限的支持有相应的限制. 对于日常的动漫, 一般来说，ref 设置如下: 追求速度的编码可以用 ref=4. 速度会很理想; 日常编码, ref=6, 相对 ref=4 可以节省 2%~4% 左右的体积. 追求压缩比的编码, ref=8, 相对 ref=4 可以节省 4%~8% 的体积. 追求极致压缩比的编码, ref 可以选择 13 左右. 相对 ref=4 可以节省 6%~15% 的体积. 特别静态的场景, 或者特别动态的场景 (比如噪点多的真人电影), ref 开高的意义均不大. 反而是动态程度一般, 场景混杂的, 开高 ref 效果比较好. vcb小组实测 ref 增加在 x265 中作用不明显. 建议不超过 6, 建议值为 4. --scene-cut (x264), --scenecut (x265) Number of Extra I-frames. 这是让 x264 决定是否切换场景的灵敏度. x264 会在场景切换的时候插入 I 帧，这个参数越低, x264 越容易判断场景做了切换, 越鼓励插入 I 帧. 通常保持默认 40 就好. --keyint Maximum GOP Size, 规定了最远两个 IDR 帧之间的距离. 这个值越大, 给编码器灵活度越高, 因为编码器不用被迫在不需要的情况下插入 IDR 帧; 但是也意味着拖动进度条的时候压力越大. 特别是 keyint=inf (x265 为 -1) 的时候, 一些真人访谈场景, 如果不切换场景, 很可能从头到尾只有一个第 0 帧是 IDR. 一般来说设置在 250~900 之间. 对于在线视频 360~480 是不错的选择. 本地视频 480~720 会比较合适. --min-keyint Minimum GOP Size, 规定了最近两个 IDR 帧之间的距离. 一般编码器在检测到场景转换的时候, 会插入 I 帧. 如果新插入的 I 帧距离上个 IDR 帧的距离 &gt;=min-keyint, 编码器就会将它设置为 IDR 帧. 否则会插入非 IDR 的 i 帧. 一般选择将 min-keyint 设置成 1, 所有 I 帧都会变为 IDR 帧. 关于 min-keyint 的设置有一种说法是考虑到画面中出现反复闪烁时, 设置一定大小的 min-keyint 可以避免插入 I 帧，而是插入 i 帧. 但实际上, x264 的 scene change 检测是十分智能的, 如果前后的场景可以有互相参考的价值, 那么即便中间有几个突变帧, 也不会贸然地插入 I 帧. 实际上, 这种情况在闪烁的地方插入 P 帧是完全没问题的, 因为即便是 P 帧, 其中的各个 macro-block 依然可以作为 I Block (独立编码), 所以没有使用 i 帧的必要性. (P 帧和 B 帧都可以有 Intra Block, 表现为某个 macroblock 不借助前后帧进行参考.) 事实上插入 i 帧还会导致兼容性问题, 例如为了 blu-ray compat 就需要设为 1, 所以始终用 --min-keyint 1 是最佳的选择. Bframes --open-gop, --no-open-gop Open GOP. 如果开启, 那么前一个 GOP 的 B 帧将可以参照下一个 GOP 的里面的帧. GOP 规定后面的不允许参照前面的, 但是前面的能否参照后面的, 则是由 OpenGOP 决定的. 如果开启, 那么在特定场景下可以增加编码效率, 但是一些播放设备和播放器不支持. 一般来说开启与否问题都不大. --weightb Weighted Prediction for B frame 允许 B 帧的加权预测, 在一些渐变场景比较有用. 百利无一害的选项, 默认开启. --bframes Number of B-Frames, 最大允许的连续 B 帧数量. 这个值越大, 编码时间稍有提高, 对压缩率也有帮助. B 帧并不是越高越好, 一般认为真人电影设置为 3~8, 动漫设置为 6~12 左右比较合适. --b-adapt Adaptive B-Frames, 采用什么算法来决定是否采用 B 帧. 对于 x264, 0-off 表示永远能用就用, 1-fast 是快速算法, 2-normal 采用的是常规算法. 2 比较优秀, 也会较慢. 一般推荐 --preset slow 及以上时候使用 2. x265 下有似乎有不同的实现[5]: With b-adapt 0, the GOP structure is fixed based on the values of --keyint and --bframes. With b-adapt 1 a light lookahead is used to choose B frame placement. With b-adapt 2 (trellis) a viterbi B path selection is performed. (Default) --b-pyramid B-Pyramid, B 帧参照其他 B 帧的方式. Disable 表示不允许 B 帧参照其他的 B 帧, Strict 为了 BD 原盘播放兼容性而设置, normal 则不加限制. 一般选择 normal 以最大化编码效率. x265 下只有启用和禁用. Rate Control --aq-mode Adaptive Quantizers, 简称 AQ. 没有 AQ, x264 会倾向于在平面和纹理处降低码率. 造成的效果就是线条部分看上去还行, 但是平面大幅度 block, 纹理烂掉. AQ 的作用就是来防止码率在纹理和平面处被过分的降低. AQ Mode, 选择 AQ 的算法. x264 有 Disable (aq-mode=0), Variance AQ (aq-mode=1) 和 Auto-Variance AQ(aq-mode=2). 一般来说, mode=1 效果中等, 比较安全, 不容易出现较烂的帧. mode=2 比较省码率, 但是偶尔容易出现烂帧. x265 有三种 aq 模式. aq-mode 1 是最安全稳定的 AQ, 适合高码率/高画质编码; aq-mode=2 相对来说效率最高, 适合中低码率的编码; aq-mode=3 对暗场进行加强, 适合 8bit 编码防止暗场压烂. 一般 10bit 编码根据 crf 高低决定 AQ 选取, 个人建议在 crf&lt;=16 时候使用 aq-mode=1, 否则使用 aq-mode 2. 注意同 crf 下, 不同 aq-mode 出来的体积是不一样的, 3&gt;1&gt;2. --aq-strength AQ Strength, AQ 强度. 对于 x264, 动漫选 0.6-1.0 左右; 真人选 0.8-1.2 左右. 越是高质量的编码, AQ 的 Strength 应该越高. 对于 x265, 动漫的 aq-strength 不用太高 (太高了码率也会浪费). 通常 aq-mode=1, aq-strength 给 0.8 比较合理; aq-mode=2, aq-strength 给 0.9 左右, aq-mode=3, aq-strength 给 0.7 左右. --qcomp 0.65 Quantizer Compression, 这个参数决定了 QP 的时域变化灵活度. 越低的数值代表灵活度越高, QP 值变动越大, 效果就是高动态场景下烂的比较严重, 因为 x264 会倾向于提高高动态下的 QP 值 (特别是引入 mbtree 之后). 通常认为, 越是倾向于高画质编码的, qcomp 需要给的越高, 反之亦然. qcomp=0 的时候效果接近固定比特率, qcomp=1 的时候效果接近固定 qp 值. qcomp 的作用会受到 mbtree 的影响. 建议设置为略高于默认 0.6 的 0.65, 对时域分配采取略保守的策略，来针对中高画质优化. --mbtree, --no-mbtree MB-tree (Marco-Block Tree) 是 x264 后期引入的一种码率控制和决策的工具, 在时域和空域都有重要的影响. MB-tree 的原理简单点说, 就是在编码过程中, 被大量参照的 block (被前后帧参照, 或者被同一帧其他部分参照) 给的 QP 值降低, 画质更好, 体积更大; 反之, 被参照少的帧 QP 增加, 画质更烂, 体积更小. 其逻辑在于, 被参照多的 block 理应有更好的画质, 这可以让参照它的更多 block 受益. MB-tree 的弊端主要在通常将平面和纹理涂抹的较为过分 (这些 block 通常是直接参照别的 block), MB-tree 也倾向于降低高动态部分的质量. 如果关闭 MB-tree, 通常细节会更好, 但是线条会有些欠码. 普遍认为，在中低码率的编码中 (crf&gt;18), MB-tree 永远是利大于弊的. 在极高码率的编码中 (crf&lt;16), MB-tree 永远是弊大于利的. 在高码率 (crf=16-18), 越是动态多, 噪点多, 线条锐利的片子, MB-tree 的正面作用越强. 开启 MB-tree 体积会减少很多. 所以一般开 MB-tree, crf 可以相比于关 MB-tree 低 1.0 左右. 比如 crf=16.5 mbtree=1、crf=17.5 mbtree=0 是 vcb-s 常用的选择. MB-tree 开启的时候, qcomp 的灵活度会被放大. 所以一般开 MB-tree 需要增加 qcomp (qcomp 数值增加, 灵活度降低). 比如 vcb-s 常用的参数: crf=16.0 mbtree=1 qcomp=0.80, crf=17.0 mbtree=0 qcomp=0.70; crf=16.5 mbtree=1 qcomp=0.75, crf=17.5 mbtree=0 qcomp=0.60; crf=17.0 mbtree=1 qcomp=0.75, crf=18.0 mbtree=0 qcomp=0.60; crf=19.0 mbtree=1 qcomp=0.70 (crf=19 的时候不宜关闭 MB-tree) --pbratio 降低 P 帧和 B 帧间画质差距. 动漫编码 B 帧数量庞大, 且 P、B 之间分工不明显, 因此降低这个参数对全局有利. Psycho-visual --psy-rd Psy 相关是一种 x264 引入的主观优化: 在欠码的时候, 人眼宁愿看到失真, 也不愿看到大范围的模糊. 虽然这种失真对客观的还原度来说不利, 但是它有利于保留画面纹理, 编码前后的图像看上去违和感较低, 细节锐度较好. 在 x264 中, 它有两个参数, 第一个是Psy-rd Strength, 心理学优化强度. 一般压制动漫选择 0.4-1.0，压制真人选择 0.7-1.3.越是高质量的编码, 可以开的越高. 但是在 CRF 模式下, 开高了 psy-rd 也会提高码率. 第二个参数是 Psy Trellis, 在 psy-rd 的基础上, 微调保留的噪点之类的微小细节的保留度. 一般开 MB-tree 时候, psy-trellis 可以给 0.1 左右. 关闭 MB-tree 时建议关闭.psy-trellis 的值越高, 会相应的调低 --chroma-qp-offset 以求让 Chroma 平面的细节得以保留. 所以在关闭 MB-tree 的时候, 一方面将 --psy-trellis 设置为 0，一方面将 --chroma-qp-offset 往下调 1 左右. 对于 x264 推荐设置为 0.6:0.15. 对于 x265, Psy 是目前调节锐利度和细节保留的重要工具, 低了会糊高了会出现动态瑕疵. 默认的 2.0 其实是个不错的数值. 如果中低码率编码，可以考虑降低到 1.5 左右. --psy-rdoq (x265) 作用类似 x264 中的 --psy-trellis, 默认 0.0, 设置为 1.0 有助于保留细节和噪点. Mode decision / Analysis --rd Rate distortion optimization 码率失真优化, 值越高计算度越复杂. 3 是一个比较平衡的选择. 目前 5 是实际最高选择. 根据官方 doc, --rd 3 和 --rd 4 相同, --rd 5 和 --rd 6 相同. --rdoq-level Specify the amount of rate-distortion analysis to use within quantization:[5] At level 0 rate-distortion cost is not considered in quant. At level 1 rate-distortion cost is used to find optimal rounding values for each level (and allows psy-rdoq to be effective). It trades-off the signaling cost of the coefficient vs its post-inverse quant distortion from the pre-quant coefficient. When --psy-rdoq is enabled, this formula is biased in favor of more energy in the residual (larger coefficient absolute levels). At level 2 rate-distortion cost is used to make decimate decisions on each 4x4 coding group, including the cost of signaling the group within the group bitmap. If the total distortion of not signaling the entire coding group is less than the rate cost, the block is decimated. Next, it applies rate-distortion cost analysis to the last non-zero coefficient, which can result in many (or all) of the coding groups being decimated. Psy-rdoq is less effective at preserving energy when RDOQ is at level 2, since it only has influence over the level distortion costs. 注意默认的 --preset medium 下它是 0, 这时候 rdoq 是没有用的. slow 及以上自动开启. --b-intra 允许 B 帧中出现 Intra Block. 动画建议. --rc-lookahead 编码时候往前看多少帧来规划 Coding Unit Tree (CUTree, 相当于 MBTree), 一般设置为 60-80 比较合理; 帧率越高的片源适合给的越高. --strong-intra-smoothing, --no-strong-intra-smoothing Enable strong intra smoothing for 32x32 intra blocks. This flag performs bi-linear interpolation of the corner reference samples for a strong smoothing effect. The purpose is to prevent blocking or banding artifacts in regions with few/zero AC coefficients. Default enabled --output 输出文件名 一些姿势 IPB 相关知识 IBP 帧: 视频压缩的过程中, 对于一段时间内相似的帧, 采用记录第一张, 后续几张只记录和第一张的区别, 这种想法是很自然的. 由此引申出两种帧: I 帧 (Independent Frame), 独立编码的帧. I 帧相当于记录一张 jpg, 一般常见于一个场景开头. 后续的帧就需要依赖 I 帧. P 帧(Predictive Frame), 需要依赖其他帧来编码的类型. P 帧需要参照在它之前的 I 帧或者其他的 P 帧, 因为它只记录差别, 所以对于那种前后差别很小甚至没有的帧, 使用 P 帧编码能极大地减少体积. MPEG2 之后，引入了第三种帧: B 帧 (Bi-directional Frame), 双向预测帧. B 帧跟 P 帧类似, 都是需要参照别的帧, 区别在于 B 帧需要参照它后面的帧, B 帧的记录和预测方式也做了调整, 使得 B 帧的预测方式更灵活, 对付高度静态规律的场景可以更有效的降低体积. 一种典型的排列方式: IPBBPBPIPPB… 视频开头一定是一个 I 帧. IDR 帧与 GOP 区间 I 帧中, 有一类特殊的 I 帧, 叫做 IDR 帧. IDR 帧的性质是, 比如第 1000 帧是 IDR 帧, 那么这一帧相当于一个分水岭, 从 1001 帧开始, 所有的帧都不能再参照 1000 帧之前的帧. 在 closed GOP 规定下 (x264 设置中可以指定, 并且 vcb-s 一直指定), 0~999 帧也不允许参照这个 IDR 帧以及之后的帧. 等于说 IDR 帧将视频分割成两个独立的部分: 前面的不能参照后面的(closed GOP 规定下), 后面的不能参照前面的. 这个性质在播放的时候额外有用: 如果我直接从第 1000 帧开始播放, 我可以毫无问题的播放下去, 因为我不需要参照 1000 帧之前的内容完成解码. 我从开头播放, 直到 999 帧的时候, 我都不需要参照 1000 帧及它后面的东西; 1000 帧之后的数据都损坏了, 0~999 帧也能正常播放. IDR 的全称叫做 Instantaneous Decoder Refresh, 意思是，解码到当前帧, 解码器就可以把缓存全清了, 之前的所有帧信息都没用了, 后续帧不会再去参照它们. 视频开头的 I 帧一定是 IDR 帧. 有时候, 我们用 I 帧表示 IDR 帧, i 帧表示非 IDR 的 I 帧. i 帧和 IDR 帧都只进行 intra prediction (所有参照信息都是帧内, 不借助前后帧). 区别在于 i 帧的前后 P、B 帧可以互相参考, 而 I 帧不允许. 从一个 IDR 帧开始, 到下一个 IDR 前的帧结束, 叫做 IDR 区间, 又叫做 GOP 区间. closed GOP 设定下, GOP 区间可以看做是独立的一段视频: 它里面的所有帧, 都不需要参照任何区间之外的东西, 只要一个 GOP 区间是齐全的, 区间里面所有的帧都能被解码. 我们平时看的视频就是多段 GOP 区间连接起来的. 在我们拖动进度条的时候，为啥有时候会卡顿，或者拖不准呢？其实是播放器干了这些事： 计算你拖动进度条的时间, 找出它应该是哪一帧, 假设为 N; 通过搜索视频索引信息, 找出 N 帧前面最近的一个 IDR 帧, 假设为 M (M&lt;=N). 很显然, M 和 N 同属于一个 GOP 区间, 这个区间开头的帧是 M; 如果你的播放器设置了快速索引, 视频将直接从 M 帧开始播放, 因为 M 帧是 IDR, 它不需要参照任何帧, 所以立刻可以开始播放. 这是为啥你会发现开始的地方总是在之前一点; 否则, 如果你的播放器设置了精确索引, 解码器会从 M 帧一直开始解码, 解码到 N 帧, 然后显示 N 帧的画面, 并继续播放. 当 N-M 比较大的时候, 播放器可能需要先解码几百甚至上千帧, 才能继续播放.如果视频允许很长的 GOP 区间, 这个视频在播放的时候, 拖动进度条就特容易卡顿. 如果设置了 --min-keyint 1, 那么所有 I 帧都是 IDR 帧 (vcb-s 也一直在用). 而 GOP 区间最大的范围则通过 --keyint 指定. 参考文献 ^ \"HEVC – What are CTU, CU, CTB, CB, PB, and TB?\". codesequoia.wordpress.com. Retrieved 2022-2-10. ^ \"VCB-Studio 教程 10 x265 v2.9 参数设置\". vcb-s.nmm-hd.org. Retrieved 2022-2-10. ^ Yu Yuan, David Feng, and Yu-Zhuo Zhong. \"The Causation and Solution of Ringing Effect in DCT-based Video Coding\". World Academy of Science, Engineering and Technology, International Journal of Computer, Electrical, Automation, Control and Information Engineering, vol. 2, no. 1, pp. 231-236, 2008 ^ \"VCB-Studio 教程 09 x264 参数设置\". vcb-s.nmm-hd.org. Retrieved 2022-2-10. ^ \"Command Line Options - x265 documentation\". x265.readthedocs.io. Retrieved 2022-2-10.","link":"/zh-cn/computer/2020/ffmpeg/"},{"title":"english-grammar","text":"英语的语法是一系列的规则, 只要理清和遵循这些规则, 就能写出正确的句子 本文的作用旨在脑中形成一个能够检查英语语法正确性的模型. 主从复合句: 至少包含两个谓语(主句一个从句一个)的句子 句子结构 句子成分 主语: 名词, 动词不定式, 动名词, 名词性从句(主语从句) 谓语: 动词 宾语: 名词, 动词不定式, 动名词 表语: 名词, 形容词, 副词, 动词不定式, 动名词, 分词 补语(主语/宾语补足语): 名词, 形容词, 动词不定式, 分词 定语: 形容词, 动词不定式, 动名词, 分词 状语: 副词, 动词不定式, 分词 [状语]+[前置定语]+主语+[后置定语]+[状语]+谓语+[前置定语]+宾语+[后置定语]+[补语]+[状语] 主语+系动词+[前置定语]+表语+[后置定语]+[补语] 补语修饰谁看具体含义 定语 定语是广义的形容词, 限定主语或宾语对象的范围. 定语和补语区别: 补语强调补充, 定语限定范围 状语 状语是广义的副词. 说明谓语或表语的状态(时间, 地点, 程度, 目的, 结果) 五大句型 主语 + 不及物动词 e.g. He cried. 主语 + 系动词 + 表语 e.g. The dinner smells good. e.g. This is an English-Chinese dictionary. 主语 + 谓语 + 宾语 e.g. He enjoys reading 主语 + 谓语 + 间接宾语 + 直接宾语 e.g. He brought you a dictionary. 主语 + 谓语 + 宾语 + 宾语补足语 e.g. I often find him at work. e.g. They painted the door green. 三大从句 定语从句 something 为先行词, 定语从句不能用 which 定语从句三要素: 先行词、关系词、关系词在从句中充当的成分. 关系代词(who/whom/which/that/whose)引导的定语从句 先行词是人(用 who/whom/that) The man who/that is standing there is my English teacher. (在从句中作主语不可省略) The man (whom/that) I am talking to is from the US. (在从句中作宾语可省略) 先行词是物 (用 which/that) The book which/that is on my desk is the best saller of 2018. (在从句中作主语不可省略) The book (which/that) I am reading is the best seller of 2018. (在从句中作宾语可省略) 先行词是人或物具备的东西(用 whose) The man whose hair is brown is the chairman of the meeting. I am looking for the book whose cover is red. 只用 that 不用 which 的情况 多少: no, little, few, much 不定代词: some-, -thing, any-, all, every-, none, no-, neither… 唯一: the only, the one 恰好: the very/right + 先行词 人和物: 先行词中既有人又有物 They talk about the thing and people that were unforgetable. (在从句中作主语不可省略) 最高级: 形容词最高级 + 先行词 序数词: 序数词 + 先行词 关系副词(when/where/why)引导的定语从句 先行词是事件(用 when) I still remember the day when we had the first class in this hall. 先行词是地点(用 where) I still remember the city where we visited ten years ago. 先行词为原因(用 why) I don’t know the reason why you are absent from the meeting. 关系副词 when, where, why = 介词 + which The house in which(=where) Lu Xun used the live is now a museum. 非限制性定语从句 先行词与定语从句往往有逗号隔开, 不能用 that 引导 起补充说明的作用, 如果去掉, 主句的意思仍然清楚 Jim passed the driving test, which surprised everybody in the office as 引导的定语从句 As is known to all, the earth is round. John, as you know, is a famous writer. He is from the south, as we can see from his accent. 状语从句 状语从句在复合句中修饰主句、主句中的动词等. 由从属连词引导, 与主语连接, 常用逗号与主句分开. 如果位于句末, 其前一般不用逗号. 根据其用途可以分为时间状语从句、原因状语从句、结果状语从句、条件状语从句、让步状语从句、地点状语从句、目的状语从句. 时间状语从句(when, while, as, before, after, since, until/till, as soon as…) when 的用法 表示主句和从句动作同时或先后发生, 动词可以是延续性动词也可以是非延续性动词 I worked for a foreign company when I was in Shanghai. while 的用法 往往表示主句和从句中的动作同时发生, 且常用延续性或表示状态的动词. They rushed in while we were discussing problems. as 的用法 as 引导时间状语从句表示一边…一边…, 随着, 或者正当… Helen heared the story as she washed clothes. before 和 after 的用法 before 表示在…之前, after 表示在…之后. I will always work hard before I enter Peking University. She cooked several delicious dishes for me after I got to her home. until/till 的用法 意思相同, 可以互换, 但 till 不能用于句首 主句谓语是延续性动词时. 主句用肯定形式, 表示这个动作或状态一直持续到 until/till 引导的从句的动作发生为止. I will wait for you untill/till you come to see me. 主句谓语是非延续性动词时, 主句用否定形式, 表示主句的动作直到 until 引导的从句动作发生才发生(构成 not…until 结构), 此时不能用 till. (有时不用 not, 而用其它表示否定的词, 如 never, nothing) I didn’t go to bed until I finished my homework. since 的用法 since 引导的时间状语从句, 一般主句用现在完成时, 从句用一般过去时. I have worked in this company since I graduated from Peking University. as soon as 的用法 as soon as 引导的时间状语从句, 表示从句的动作一发生, 主句的动作也随之发生. 该从句一般用现在时表示将来时. I will tell him the truth as soon as he comes here. 条件状语从句 主句为祈使句、一般将来或含有情态动词时, 条件状语从句一般用现在时. if 引导的条件状语从句 I will visit the Great Wall if it doesn’t rain tomorrow. unless 引导的条件状语从句 We’ll go for an outing tomorrow unless it rains (=if it doesn’t rain). 注意: 为了强调动作的完成, 从句中也能用完成时. You can go out if you have finished your homework 原因状语从句 原因状语从句通常用 because, since 或 as 引导. 这三个词所表示的语气由 because 到 as 逐渐递减. because 的用法 表示因果关系的语气最强, 用来回答 why 的问题, 所引出的原因往往是听话人所不知道或者感兴趣的, because 引导的原因状语从句往往显得比主句更重要. I’m leaving because I am fed up with the lecture. My friends admire me because I can speak English as fluently as the native speakers. since 的用法 表示已知事实, 不需要强调的原因, 因此经常译成既然…, 通常放在句首. since 引导的从句是次要的, 重点强调主句的内容. Since every one is here, let’s get started. as 的用法 as 与 since 用法相似, 所引出的理由在说话人看来已经很明显, 或已为听话人所熟悉而不需要用 because 加以强调. as 引导的从句与主句具有同等的重要性. She didn’t hear us come in as she was asleep. now(that) 的用法 主要用于口语, 表示微弱的原因, 主、从句因果关系不明显, 意为既然. Now(that) you have come, you may as well stay. 目的状语从句 目的状语从句通常由 so that, in order that 等引导. 从句谓语中常含 may, might, can, could, will, would 等情态动词. He must get up early so that he can go to work on time. 当从句主语与主句主语一致时, 可用 so as to 和 in order to. He worked day and night in order that he could succeed. = He worked day and night in order to succeed. 结果状语从句 由 so…that, such…that 引导 so + 形容词或副词 + that so + 形容词 + a/an + 单数名词 + that such + a/an + 形容词 + 名词 + that such + 形容词 + 复数名词/不可数名词 + that She is such a lovely girl that we love her very much. = She is so lovely a girl that we love her very much. 注意: 当名词前面有 many, much, little, few 修饰时, 用 so 不用 such. We have so much time that we can finish the work very well. so…that 句型的否定形式可用简单句 too…to… 或 not…enough to 代替. He is so young that he can’t go to school. = He is too young to go to school. = He is not old enough to go to school. 让步状语从句 though/although 的用法 同义, 一般情况下可互换, 但是 although 语气较重, 大多置于句首. 可与 yet 连用, 不可与 but 连用 They are generous though they are poor. Although he was Japanese, he spent most of his life in China. even though 与 even if 的用法 同义, 表示语气更强的让步. Even though he is 24 new, he’s still like a little child. We’ll make a trip even if/even though the weather is bad. wh-ever 类引导词的用法 在英语中 wh-ever 既可引导名词性从句, 还可引导让步状语从句且可换成 no matter + 相应的 wh- 词, 而在引导名词性从句时只能用 wh-ever. Whenever I am unhappy, it is my friend who cheers me up. = No matter when I am unhappy, it is my friend who cheers me up. 地点状语从句 引导地点状语从句的从属连词有 where 和 wherever. 指具体地点时, 从句可位于主句之前或之后; 表示抽象含义时, 从句需放在主句前面. He lives where the climate is cool. Where there is a will, there is a way. 注意区分 where 引导的状语从句和定语从句. You’d better make a mark where you have questions. (状语从句) You’d better make a mark at the place where you have questions. (有先行词, 定语从句) 注意: 不能同时出现在一个句子中的连词: because (因为) 引导原因状语从句. so (所以) 连接并列句. 不能同时出现在一个句子里, 只能用其一. Because he was tired, he couldn’t walk here. = He was tired, so he couldn’t walk here. although/though (虽然) 引导让步状语从句. but (但是) 连接并列句. 不能同时出现在一个句子里, 只能用其一. 但 although/though 和 yet 可以出现在一个句子里(这里的 yet 不是连词, 而是副词). when, while, as 的区别 when, while, as 引导的从句都可使用持续性动词. when 和 as 都可以与非持续性动词连用, 而 while 不能. when 可表示瞬间, 也可表示时间段, 与主句所陈述的动作、事情可同时发生, 也可有先后. while 常用于连接同时进行的两个持续性动词相伴随而发生的动作. as 不指先后, 尤指两个动作或事件同时发生. The film has been on when we arrived. My mother was cooking while I was doing my homework. As I left the house, I forgot the key. 名词性从句 引导名词性从句的连接词 连接代词: who, whose, whom, what, which. 有词义, 在从句中充当句子成分, 如主语、表语、宾语等 连接副词: when, where, why, how. 有词义, 在从句中充当句子成分, 作状语. 连结词: that, whether, if, as if. that 无词义, 在从句中不充当句子成分, 有时可省略; 而 whether, if, as if 虽有词义, 但在从句中不充当句子成分. 主语从句 主语从句在复合句中作主语. Who will go is not important. 用 it 作为形式主语, 主语从句放在句末, 但 what 引导的主句从句表示…的东西时, 不用 it 做形式主语, whatever, whichever, whoever 一般也不用 it 做形式主语. It doesn’t matter so much whether you will come or not. What he needs is more experience. that 引导主语从句时不能省略 That he suddenly fell ill made us surprised. 表语从句 在句中做表语的从句称为表语从句, 共分三类常考点: 若主句的主语是 advice, suggestion, order, request, requirement 等名词时, 则表语从句的谓语应用虚拟语气, 即 should + 动词原形的形式. His suggestion is that we (should) change our course. 主语为 reason 时, 表语从句的连接词要用 that, 而不用 why 或 because. The reason for such a serious accident is that the driver was too careless and drunk. because, why, as if/as though, as, like 等连接词也可以连接表语从句. He has lung cancer. That is because he has been smoking too much. (应根据句子结构判断是表语从句还是结果状语从句) 宾语从句 在主从复合句起宾语作用 宾语从句分为三类: 动词的宾语从句、介词的宾语从句和形容词的宾语从句. 根据不同的作用, 宾语从句的连结词通常分为以下几类: that: 本身无意义, 只起连接作用, 口语中可以省略. He said (that) Kate was good at swimming. what, which, who, whose, whom 等连接词, 在从句中作一定的成分, 如主语、宾语、表语、定语. I don’t know what they are going to do. (这里的 what 作宾语) He asked me whose book it was. (这里的 whose 作定语) when, where, why, how 等连接副词, 在从句中充当状语. Could you tell me where you live? (地点状语) Do you know how they found the place? (方式状语) If, whether 意为是否, 不作句子成分, 但不能省略. (这里和条件状语的区分关键是宾语从句的事情已经做了, 而条件状语的事情还没做) He asked me if Miss Zhao was a teacher. 同位语从句 区分同位语从句和定语从句: 同位语能替换宾语, 而定语不能 特殊句式 虚拟语气 所有跟要求有关的动词后面宾语都用虚拟语气 if 引导的虚拟语气: if 条件句 + 结果句 对现在虚拟: If were/did (过去式), would + 动词原形 对过去虚拟: If had done (过去完成) , would have done 对将来虚拟: If would do (过去将来时) , would do 情态动词(should, ought to, need; 过去事实推测: can’t/couldn’t, must) + have … as if/as though 表虚拟(描述与事实不符时)/表陈述(描述与事实相符时) 虚拟条件句 在含有虚拟条件句的复合语句中, 主句和从句的谓语都要用虚拟语气 与现在事实相反 从句: 动词过去式(be + were), 主句: would/should/could/might + 动词原形 If my brother were here, everything would be all right. 与过去事实相反 从句: had + 过去分词, 主句: would/should/could/might + have + 过去分词 If you had taken my device, you wouldn’t(couldn’t) have failed in the exam. 与将来事实相反 从句: 动词过去式, should + 动词原形, were to + 动词原形, 主句: would/should/could/might + 动词原形 If it were Sunday tomorrow, I should(would, could, might) go to see my grandma. If it were to snow this evening, they would not go out. 错综时间 有时条件从句中动词和主语中的动作发生时间不一致, 这时动词形式要根据它所表示的时间加以调整 If you had listened to doctor, you would be all right now. (从句动作指过去, 主句动作指现在) 注意: 主句中 should 只用于第一人称(但在美语中 should 常被 would 代替); 从句中 should 可用于各种人称. 虚拟条件句可以转换成下列形式 省略连词 if 在书面中, 如果虚拟条件从句中有 were, had 或 should, 可以把 if 省略, 把这几个词放到主语之前, 构成主谓倒装. Should he come (If he should come), tell him to ring me up. Were I you (If I were you), I would not do it. 用介词短语代替条件状语从句 有时假设的情况并不用条件从句表示出来, 而是通过介词短语来表示. Without air (If there were not air), there would be no living things. But for your help (If it hadn’t been for your help), I couldn’t have done it. 假设的情况有时可以通过上下文或其他方式表达出来. I was busy that day. Otherwise I would have gone with them. (If I hadn’t been busy that day, I would have gone there with them). I would have finished the work, but I have been ill. (If I hadn’t been ill, I would have finished the work.) 省去条件状语从句 表示虚拟从句的主句或从句有时可以省略, 但其含义仍可以推知. 省去条件从句 (If you had wanted to,) You could have washed your clothes yourself. 省去主句(常用于表示愿望) If my grandma were with me! If only she had not left. 虚拟语气的其他用法 虚拟语气在主语从句的用法 在 It is important(strange, natural, necessary)/suggested/desired/proposed…that… 句型中, that 所引导的主语从句的谓语动词常用 should + 动词原形的结构. It is important that every member (should) inform himself of these rules. 虚拟语气在宾语从句的用法 在动词 wish 后的宾语从句中表示与现在或过去的事实相反或对将来的主观愿望, 从句通常省略连词 that 表示对现在情况的虚拟: 从句动词用过去式或过去进行时(be + were) I wish I knew the answer to the question. 表示对过去情况的虚拟: 从句动词常用 had+过去分词. I wish(wished) I hadn’t spent so much money. 表示对将来的主观愿望: 谓语动词为 would+动词原形. 此时要注意, 主句主语与从句主语不能相同, 因为主句主语所期望的从句动作能否实现取决于从句主语的态度和意愿(非动物名称除外). I wish it would stop. I wish you would come soon. 在 suggest, demand, order, propose, insist, command, request, desire 等动词后面的宾语从句中, 谓语动词用 should + 动词原形. I demand that he (should) answer me immediately. 注意: 当 suggest 表示暗示, 表明之意, insist 表示坚持认为之意时, 其后宾语从句不适用虚拟语气形式, 应使用陈述语气形式. The smile on his face suggested that he was satisfied with our work. The man insisted that he had never stolen the money. 在 would rather 后的宾语从句中, 也用虚拟语气, 其谓语为动词过去式(表示现在或将来动作)或过去完成时(表示过去动作) I would rather she came tomorrow. He would rather I had done the work for him. 虚拟语气在状语从句中的用法 在带有 even if/even though 引导的让步状语从句的主从复合句中, 主句和从句都用虚拟语气, 动词形式与含有非真实条件的虚拟语气相同. Even if he had been ill, he would have gone to his office. 由 as if 或 as though 引导的状语从句表示比较或方式时. 从句谓语形式为动词的过去式(be + were)或 had + 过去分词. He treated me as if I were a stranger. She talked about the film as if she had really seen it. 在 in order to 或 so that 引导的目的状语从句中, 谓语动词多用 could 或 might (有时也用 should) + 动词原形. Mr. Green spoke slowly so that His students could(might) hear clearly. 虚拟语气在定语从句中的用法 在 it is time (that)… 句型中, 定语从句的谓语常用虚拟语气表示将来时, 动词原形一般换成过去式, 意思是该做某事的时候了. It’s (high) time we did our homework. 虚拟语气在简单句中的用法 情态动词过去式用于现在时态, 表示说话人的谦虚、客气、有礼貌, 或委婉的语气, 常见于日常会话中. I would be better for you not to stay up too late. 在一些习惯表达中. I would rather not tell you. 用 may + 动词原形, 表示祝愿, 此时 may 必须置于句首(多用于正式文体中). May you be happy! May good luck be yours! 强调句 强调句结构: (that/who 不能省略) 强调名词 It is/was + 强调部分 + that/who + 剩余部分 强调动词: 人称代词 + do/did + 强调部分 + that 剩余部分 祈使句 动词在句首=祈使句 复合谓语 复合谓语的形式: 情态动词 + 动词原形 助动词 + 实意动词或动词短语 助动词 + 动名词/过去分词 系动词 + 表语(主系表可看作主谓) 独立主格 独立主格是没有谓语的特殊句子, 后面需要跟上主句, 不能独立存在. 比如: Her eyes moist and red there be 开头的句子也是独立主格 并列句 定义: 使用并列连词连接起来的两个以上的句子 结构: 简单句 + 并列连词 + 简单句 常见的并列连词 表示转折、并列、递进关系的并列连词 and, both…, and…, as well as, not only…but also…, neither…nor… My father bought me a present and I like it very much He is not only a good basketball player but also can play the plano very skillfully. 表示转折、对比关系的并列连词 but, yet, while Lucy likes playing the plano while Lily likes playing basketball. 表示选择关系的并列连词 either…or… 连接主语时, 动词和靠近它的主语在人称、数上保持一致, 即就近原则. or 或者, 还可以表示否则 Either you or your mother has been invited. Study hard, or you will fail the exam. 表示因果关系的并列连词 so 后面接结果, for 经常用于引出推断性的原因, 不能位于句首. Kate was ill, so she didn’t go to school. It must have rained last night, for the ground is wet. 注意: and 和 for 用于否定句中的用法 当列举成分是主语且在否定词之前时, 用 and 连接; 当列举成分在否定词之后, 用 or 构成全否定(指 or 连接的两个都否定) Lucy and Lily can’t speak Chinese. I can’t sing or dance. 在否定句中, 如果所连接的两部分都有否定词. 那么用 and, 不用 or There is no water and no air on the moon. 在否定句中, without 之后若有列举成分, 则用 and 连接, 构成完全否定; 在肯定句中, without 之后的列举成分要有 or 连接才能构成完全否定. Man can’t live without air and water. = Man will die without air or water. 当连结词 and 连接的并列句前半部分是祈使句, 后半部分是一般将来时的陈述句时, 前半部分相当于(指可转换成) if 引导的条件状语从句. 这种句型还可以用 or 连接, 但转换成的 if 引导的条件状语从句需是否定形式 Think it over, and you will find the answer. = If you think it over, you will find the answer. Hurry up, or you will be late. = If you don’t hurry up, you will be late. 词语 单词前后缀 prefix12345678910111213141516171819202122232425262728anti- : &quot;opposite&quot; antisocialauto- : &quot;by oneself or itself&quot; autobiographybi- : &quot;two&quot; bicyclebio- : &quot;biological&quot; biologyco- : &quot;together&quot; cooperatecounter- : &quot;against&quot; counteraccackde- : &quot;negative, remove&quot; defrostdis- : &quot;negative, opposite&quot; dishonesten- : &quot;make it in...state&quot; enlargeil- : &quot;not, used before the letter 'l'&quot; illegalim- : &quot;not, used before the letter 'm', 'b', 'p'&quot; impossiblein- : &quot;not&quot; inactiveir- : &quot;not, used before the letter 'r'&quot; irregularinter- : &quot;between&quot; internationalmid- : &quot;middle&quot; middaymini- : &quot;small&quot; miniskirtmis- : &quot;wrong&quot; misunderstandnon- : &quot;not&quot; nonstoppost- : &quot;after&quot; postwarpre- : &quot;before&quot; prewarre- : &quot;again&quot; rewritesub- : &quot;below&quot; subwaysuper- : &quot;great&quot; superherotele- : &quot;large distance&quot; telescopetrans- : &quot;across&quot; transpacifictri- : &quot;three&quot; triangleun- : &quot;not&quot; unimportantunder- : &quot;beneath&quot;, &quot;not enough&quot; underestimate suffix 名词后缀12345678910111213-age-ance, -ence-ancy, -ency-er, -or-hood childhood-ion, -tion, -ation-ian-ist-ment-ness-ology biology, psychology-ship friendship, membership-ty, -ity 动词后缀123-en fasten. shorten-fy, -ify satisfy, simplify-ize, -ise modernize 形容词后缀1234567891011-able, -ible, -ble-al environmental-ful-ic, -ical atomic, economical-ish bluish-ive-less-ly-ous-some troublesome-y 副词后缀123-ly-ward(s) backward(s), afterward(s)-wise clockwise 代词 用作形式主语或宾语, 或起从句连接作用 人称/物主代词, 反身代词, 指示代词(单this/that, 复these/those) 不定代词(some-, -thing, any-, all, every-, none, no-, neither…), 相互代词, 疑问代词, 关系代词(用于从句) 连词 whereas 然而; 鉴于 wh-ever 任何… 冠词 (修饰主语, 宾语) 不定冠词 the, 定冠词 a/an 介词 放在宾语/主语前, 视主语/谓语动词而定 TODO: 方位介词 用 for 还是 to 还是 of? 后接动作对象时, to 和 for 差不多 表示事物性质特点或原因或目标或一段时间用 for 形容人性格或品质用 of 常见介词短语(介词+名词, 介词后跟宾语) be relevant to change in // 强调改变的内容 change of // 强调改变本身 change to/into // 强调改变后的状态 confident of have effect on = affect be bound to 一定要 impact on carry out mastery over cross out 删去 matter to 对…很重要 so as to 以便于 be up to 取决于 an integral part of …不可或缺的一部分 multitude of 众多的 through thick and thin 风雨同舟 动词 助动词 助动词: do, have, be, 情态动词 助动词后跟动词原形组成复合谓语 助动词作用: 构成时态、语态, 表达情感 情态动词 情态动词属于助动词 情态动词: can, may, must, need, ought to, dare, shall, will, have to 情态动词没有非谓语动词形式 使役动词 使役动词: have, make, let, help, use 使役动词后跟动词原形组成复合谓语 have作使役动词不能直接跟动词 系动词(也称连系动词) 系动词: be, ramain appear, keep, 感官动词(look, sound, feel, smell, taste, seem, …), 趋势动词(get, go, become, turn, …) 系动词的否定形式为前面加don’t 及物和不及物 不及物动词后不能直接跟名词 await (vt.) = wait (vi.) for 动词短语 动词短语形式为: 动词 + 介词/副词 take into set apart // set us apart as beings compare to // point out resemblances between objects regarded as essentially of a different order compare with // point out different between objects regarded as essentially of the sane order give up 的两种形式 give up sth. 名词 give it up 代词 非谓语动词 动词不定式 (作主语、宾语、表语、补语、定语和状语) 构成: to + 动词原形, to 是不定式的符号, 无意义, 有时可省略. 但是不定式具有动词的特点, 可以有自己的宾语和状语, 但没有三单和复数形式. 句法功能: 作主语: To learn English is not easy for me. 不定式作主语时, 常用 it 作为形式主语, 而把真正的不定式放后面. 其结构为: It + be + adj. (+for/of sb.) + 动词不定式 It is not easy for me to learn English. It is very kind of you to tell me the truth. 作表语: My work is to clean the room everyday. 作宾语: What sport does he like to play? He likes to play football. 不定式只能作某些动词的宾语, 不能作介词的宾语(but, expect 除外). 这些动词常常表示命令、打算或希望. 如: would like, want, wish, hope, decide, plan, expect 等. Would you like to see a film this evening? 如果动词为 find 或者 think 后跟不定式作宾语时, 常用 it 作形式宾语, 而将真正的宾语放在后面. I find it hard to write English articles. 注意: 不定式常和疑问句 what, which, when, where, how 连用作宾语, 相当于一个宾语从句. The kid doesn’t know how to do it himself. (= how he should do it himself.) 作宾语补足语: 不定式作宾补时与宾语有逻辑上的主动关系. Lucy asked him to turn down the radio. 谓语 tell, ask, want, allow, get, would like, encourage 等后面常跟不定式作宾语补足语. 注意: 还有一些使役动词和感官动词也用不定式作宾补. 这时要省略 to. 这些动词有: 这些动词有: 一感(feel), 二听(hear, listen to), 三让(let, make, have), 四看(look at, see, watch, notice), 但是这些动词变被动语态时, 作动词的不定式必须加上 to The boss made them work the whole night. They were made to work the whole night by the boss. 作定语: 不定式作定语应放在名词之后(即只能作后置定语), 它与名词之间有逻辑上的被动关系. We don’t have enough food to eat. 如果是不及物动词, 且与所修饰的词之间有被动的关系, 需要在不定式后面加上适当的介词. There is nothing to worry about. Do you have any ink to write with? It is a very good school to study in. 作状语: 作目的状语 To save the time, we took the plane to Beijing. 注意: 如果强调此目的, 可在不定式前加 in order/so as. 但 so as to 不能用于句首. I will take notes in order not to/so as not to forget these important points. 作结果状语 往往表示出乎意料的结果, 常与 only 连用 He hurried to the station only to find that the train had left. 在某些形容词后面常表示喜怒哀乐的原因. We are pround to be the citizens of China. 在带有 enough 或 too 的句子里作状语 He is old enough to go to school. We found the room too small to hold so many people. 动名词 (作主语、宾语、表语、定语) 构成: 动词原形+ing, 但是有不规则形式. 用法: 作主语: 谓语动词用单数. Eating too much is bad for your health. 作宾语: 表示一般的习惯或抽象行为或经常性的动作. 作动词宾语 I like playing basketball very much. 作介词宾语 英语中有一些动词(短语)后面常跟动名词作宾语. 常用的有 finish, enjoy, mind, miss, be worth, practice, have trouble/problems/difficulty (in), spend some time/money (in), feel like, be/get used to. Stamps are used for sending letters. 分词 (作表语、补语、定语、状语) 构成: 现在分词由动词+ing构成; 过去分词由动词+ed构成, 但是有不规则形式. 现在分词有主动、进行之意; 过去分词有被动、完成之意. 句法功能: 作定语: 现在分词作定语修饰其逻辑主语; 过去分词作定语修饰其逻辑宾语. Do you know the girl standing under the tree? Please hand in your written exercises. 作状语: 现在分词作状语其逻辑主语为句子的主语. The student went out of the classroom, talking and laughing. 当主句和从句主语不一致且要用分词作状语时, 要在分词前面加上动作的逻辑主语 It being a fine day, we decided to go swimming in the lake. 作表语: 现在分词表示主语的性质、特征; 过去分词表示某种状态. The book is so interesting that I will read it again. The boy is too frightened to move. 作补语: 现在分词作补语, 被补足的宾语或主语是它的逻辑主语 过去分词作补语, 被补足的宾语或主语是它的逻辑宾语(因为过去分词有被动含义所以是逻辑宾语) Don’t keep us waiting for a long time. I heard him singing in the classroom. He’ll have his hair cut after school. 易混淆点 动词不定式复合结构用 of 或 for 的区别 在 kind, good, nice, clever 等表示人的品质、特征的形容词后, 不用 for 而用 of; 在表示事物性质特点的形容词后用 for. It’s very clever of you to do it like this. It’s very difficult for me to finish the task in an hour. 不定式符号 to 和介词 to 的区别 to 既可以是不定式的符号, 也可以是介词, 后面跟名词、代词或动名词作宾语. 常用的含有介词 to 的短语: make a contribution to devote…to… prefer…to… get/be used/accustomed to… apply to 动词不定式作宾补和现在分词作宾补的区别 see, watch, hear, feel 等感官动词 后接省略 to 的不定式作宾补时, 表示动作的全过程已经结束; 后接现在分词作宾补, 表示动作正在进行. I saw him cross the street. I saw him crossing the street 某些动词后面接不定式和动名词有区别 stop, forget, remember, try, regret, mean, go on, can’t help need, require, want 后面跟不定式和动名词作宾语的区别 后面接动名词主动式表示被动含义, 也可跟不定式的被动式. The window needs cleaning. The window needs to be cleaned. 用动词不定式还是动名词 TODO: 整理特点 工作内容用不定式 兴趣爱好用动名词 伴随动作用动名词 如 We walked as fast as we could, hoping to catch the 9:30 train like to do 想去做某事 like doing 习惯于 go on/continue to do 停下手上的活做其他的事请 go on/continue doing 一直在做没有停止 remember/forget to do 记得/忘记将要去做 remember/forget doing 记得/忘记做过 try to do 尽力,努力 try doing 尝试 mean to do 打算去做 mean doing 意味着 regret to do 抱歉(为将要发生的事请) regret doing 抱歉(已经发生的事请) begin/start to do 下意识的 begin/start doing 自然发生的 need doing=need to be do: need 为情态动词; need to do: need 为实意 hear sb doing 和 hear sb do: 前者进行时, 后置强调结果 be worthy of being done = worthwhile to do first 和 last 用不定式 the first to do the last to do no good/use 用动名词 please/happy/enough 用不定式 cannot but 用动名词 let alone 用动名词 spend两种形式 spend on sth. spend in doing plan 用不定式 permit 用动名词 miss 用动名词 practice 用动名词 have no … but 用动名词 worth 用动名词 spend (in) doing it takes sb. some time to do sth. 动词形态 时态 Present Past (Predicate/Copule must be v2) Future (+will after Subject) Past Future Simple Subject + Verb(v1)-s/es Subject + Verb(v2) Subject + will/shall + Verb(v1) Subject + would + Verb(v1) Continuous Subject + is/am/are + Verb(+ing) Subject + was/were + Verb(+ing) Subject + will/shall + be + Verb(+ing) Subject + would/should + be + Verb(v1) Perfect Subject + has/have + Verb(v3) Subject + had + Verb(v3) Subject + will + have + Verb(v3) Subject + would/should + have + Verb(v3) Perfect Continuous Subject + has/have + been + Verb(+ing) Subject + had + been + Verb(+ing) Subject + will + have + been + Verb(+ing) Subject + would + have + been + Verb(+ing) 分清句子时态: 过去的过去用过去完成时; 见到一段时间用完成时 时态呼应 主句现在时态, 从句该用什么时态用什么 主句过去时态, 分情况讨论: 从句动作若在主句动作发生之前, 从句用过去完成时态; 若从句有表示具体时间的状语, 从句依然用一般过去时 从句的动作与主句动作同时发生, 用一般过去时或过去完成时. 从句动作发生在主句动作之后, 从句用过去将来时 客观真理, 自然现象, 格言谚语, 从句用一般现在时 被动 被动是针对于主语而言的, 无生命的一般为被动 被动语态 英语中动词的语态有两种: 主动语态和被动语态. 主动语态表示主语是动作的执行者, 被动语态表示宾语是动作的执行者, 主语是动作的承受者. 在被动语态的句子中, 动作的执行者一般由介词 by 引起的短语来表示. We often help them. (主动) They are often helped by us. (被动) 被动语态各时态的形式由助动词 be 的各时态形式加(及物)动词的过去分词构成. 被动语态八种时态的用法: 被动语态常用的八种时态的基本用法和主动语态各时态的基本用法相同, 只是句中的主语不是动作的执行者, 而是动作的承受者. 一般使用被动语态的情况 当不知道动作执行者是谁或没有必要提到动作执行者. Paper was first made in China. 当强调或突出动作承受者的作用时. The new machine was invented by a 20-year-old young worker. 被动语态的各种时态形式: 一般现在时 am/is/are done 一般过去时 was/were done 一般将来时 will/shall be done 现在进行时 am/is/are being done 过去进行时 was/were being done 将来进行时 will/shall be being done 现在完成时 have/has been done 过去完成时 had been done 将来完成时 will/shall have been done 现在完成进行时 have/has been being done 过去完成进行时 had been being done 将来完成进行时 will/shall have been being done 被动语态注意的问题 不及物动词、表状态动词一般用主动语态(即不能作被动) come true, consist of, take place, happen, become, rise, occur, belong, break out, appear, arrive, die, fall, last, exist, fail, succeed 下列动词的主动形态表被动含义 lock, wash, sell, read, wear, blame, ride, write (且常与 well, easily, badly 等副词连用) Glass breaks easily. The car rides smoothly. The case locks easily. The book sells well. 系动词(look, sound, feel, smell, taste, appear, seem, turn, keep, …): The steel feels cold. I don’t want to sound like anyone else, but I’ve had a hard life. 表示开始、结束、运动的动词: begin, finish, start, open, move 等 The shop closes at 6 p.m. every day. 表示事物(或人)客观上&quot;需要&quot;: want, need, require 作谓语 用动名词作宾语一般主动形式表示被动含义. (等价于动词不定式的被动形式) 若动名词是不及物动词, 后面还需跟上相应的介词. 某些作表语的形容词(easy, difficult, light, heavy, fit, good, safe, comfortable, dangerous, pleasant, …)后面(作状语)的动词不定式主动表被动 如 She is easy to approach have sb. do sth. 和 have sb./sth. doing 和 have sth. done 的区别 have sb. do sth. 让某人做某事, have 可用 let, make 代替. 不定式往往表示一次性的动作, 且强调动作已经完成或尚未发生. The police had the boy stand with back to his father. have sb./sth. doing 让某人或某物一直做某事, have 可用 keep 代替, 现在分词往往具有持续、进行、主动的含义. The teacher had the students reading aloud the text for a quarter. The two men had their lights burning all night long. have sth. done 有两层含义: 托某人做(=ask sb. to do sth.) The driver had hist car washed once a week. 遭受某人做. 过去分词的动作由他人完成, 被动含义且强调动作已完成. He had his wallet stolen when he was shopping. 考试特点 考试特点: 七大题型(主观5个+客观2个) 写作套路 写作套路: 三段式写作(观点, 理由说明, 结论) 2-3 min 审题 想出框架结构 中文稿子 5-7 min 十几分钟翻译成英文 杂项 pursue sth.=in pursuit of sth. be + adj. = be + of + n. 如 He is an able man = He is a man of ability hardly Verb(v3) when no sooner Verb(v2) than","link":"/zh-cn/learn/2021/english-grammar/"},{"title":"cpp","text":"Notes on Cherno C++ Tutorial TODO: 重新格式化这篇文章 写在前面: 如果你在看到一半的时候, 若出现还没有讲到过的操作出现在示范代码中(比如new), 知道它基本起什么作用即可, 在后面的episodes肯定会细讲 如果你看到夹杂英文, 那是我直接copy了@Cherno的话并懒得翻译 Notice Always pass your function parameters with const if possible If an object have pointer variable inside, write a copy constructor and use it 节约内存的小技巧 由于内存最小可操作单位是 byte, 而 bool 类型只需要 1 字节即可(0 和 1)，巧妙的方法是使用 1 个 byte 表示 8 个 bool 类型变量 头文件 or inline? （inline实际上就是将函数整个代码复制到调用这个函数的函数那里） 宏使用#if和#endif作为条件判断 #if 1为true 声明为 static 的变量和函数只在它所在的 translation unit 有效 默认的浮点数是double类型的, 如果你只用float的精度, 在数据后加上&quot;f&quot;如 float a = 5.5f @Cherno 写Class的规范: m_LogLevel的&quot;m_&quot;表示变量是类内部(private)变量 public和private可以分离, 如一部分Public修饰变量, 另一部分Public修饰函数: 123456789101112131415161718192021222324252627class Log {public: const int LogLevelError = 0; const int LogLevelWarning = 1; const int LogLevelInfo = 2;private: int m_LogLevel = LogLevelInfo;public: void SetLevel(int level) { m_LogLevel = level; } void Error(const char* message){ if (m_LogLevel &gt;= LogLevelError) std::cout &lt;&lt; &quot;[Error]:&quot; &lt;&lt; message &lt;&lt; std::endl; } void Warn(const char* message){ if (m_LogLevel &gt;= LogLevelWarning) std::cout &lt;&lt; &quot;[WARNING]:&quot; &lt;&lt; message &lt;&lt; std::endl; } void Info(const char* message){ if (m_LogLevel &gt;= LogLevelInfo) std::cout &lt;&lt; &quot;[INFO]:&quot; &lt;&lt; message &lt;&lt; std::endl; }} How C++ Works Concepts: Every .cpp will compile to one .o/.obj file multiple .cpp and .h has #include with each other can compose to a translation unit Compile Process Path: Source-&gt;Compile-&gt;Linker-&gt;Executables Generate Pre-process file Pro-process file is the source code that the macro (such like #include) was parsed by the compiler. VS2015: Project Settings-&gt;Preprocessor-&gt;Preprocess to a File GCC: cpp hello.cpp &gt; hello.i Compile &amp; Assembly VS2015: Compile Only (Ctrl+F7) GCC: g++ -S main.i; as main.s -o main.o Linker Externally defined functions will be integrated in the link phase, and function declarations that never be called will be optimized away. The parameter of ld are platform specific (mainly depend on your gcc version) Use g++ -v -o hello hello.cpp we can get the parameter of the collect2 (which is an alias for ld) 1234$ g++ -v -o hello hello.cpp.../usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/collect2 -plugin /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/lto-wrapper -plugin-opt=-fresolution=/tmp/ccDNo0Hr.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -o main.exe /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/Scrt1.o /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtbeginS.o -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0 -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../.. /tmp/ccs86P3x.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtendS.o /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crtn.o... So the ld command should be 12345678910111213141516171819202122232425262728293031$ ld&gt; -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/lto-wrapper&gt; -plugin-opt=-fresolution=/tmp/ccHyR7Od.res&gt; -plugin-opt=-pass-through=-lgcc_s&gt; -plugin-opt=-pass-through=-lgcc&gt; -plugin-opt=-pass-through=-lc&gt; -plugin-opt=-pass-through=-lgcc_s&gt; -plugin-opt=-pass-through=-lgcc&gt; --build-id&gt; --eh-frame-hdr&gt; --hash-style=gnu&gt; -m elf_x86_64&gt; -dynamic-linker /lib64/ld-linux-x86-64.so.2&gt; -pie&gt; -o main /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/Scrt1.o&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crti.o&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtbeginS.o&gt; -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0&gt; -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib&gt; -L/lib/../lib&gt; -L/usr/lib/../lib&gt; -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../..&gt; main.o&gt; -lstdc++&gt; -lm&gt; -lgcc_s&gt; -lgcc&gt; -lc&gt; -lgcc_s&gt; -lgcc /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtendS.o&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crtn.o You can probably significantly shorten that link line by removing some arguments. Here’s the minimal set I came up with after some experimentation: 1234567891011$ ld&gt; -dynamic-linker /lib64/ld-linux-x86-64.so.2&gt; -o main /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/Scrt1.o&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crti.o&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtbeginS.o&gt; -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0&gt; main.o&gt; -lstdc++&gt; -lc&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtendS.o&gt; /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crtn.o Variables in C++ Main idea: The difference between C++ data types are simply the different allocated memory size and the declaration of the type of data to be stored Different memory allocation size for C++ Data Type: char 1 Byte short 2 Bytes int 4 Bytes long commonly 4 Bytes long long 8 Bytes float 4 Bytes double 8 Bytes You can use sizeof() to see the data type size. Functions in C++ Function means a function that is not in a class. Method means a function in a class. The main purpose of the function is to reduce code duplication. But don’t frequently divide your code into functions, calling a function requires creating an entire stack frame for that function. This means we have to push parameters and so on into the stack, and also, put something called the return address into the stack, so that after the function executed the PC register could return to the address before the function call. TLDR: Jumping around in memory to execute function instructions comsumes additional time. Generally we write function definitions in header files (.h) and function bodies in .cpp files. C++ Header Files #pragma once can prevent include same header file multiple times in a translation unit (e.g. your include header file b.h in a.cpp, but b.h includes andther header file c.h, while you have already include b.h before in a.cpp) The second way do the same thing as #pragma once (In CLion this is the default way): Log.h123456#ifndef _LOG_H#define _LOG_H// some sentence...#endif How to DEBUG C++ in VISUAL STUDIO The watch view in VS2015 allows you to specify the veriables to be monitored, In memory window you can search by keyword &amp;a to show the address of variable a The default value of uninitialized variables is 0xcccccccc Visual Studio Setup for C++ Use Show All Files view under Solution Explorer By default VS2015 put intermediate files in debug directory It’s recommand to set Output Directory into $(SolutionDir)bin\\$(Platform)\\$(Configuration)\\ and set Intermediate Directory into $(SolutionDir)bin\\intermediate\\$(Platform)\\$(Configuration)\\ CONDITIONS and BRANCHES in C++ In C++ 0 means false, any other numbers means true else if is equivalent to else { if(){} } Loops in C++ for can also be written in the form of while: 123456789int i = 0;bool condition = true;for ( ; condition; ){ Log(&quot;Hello World!&quot;); i++; if (!(i&lt;5)) condition = false;} POINTERS in C++ Pointer: the pointer represents a momory address, generally the data type of the pointer is used to represent the data type of the data at the target address. So if we don’t care the pointed data’s data type, just using void* Pointer to Pointer:1234567891011#include &lt;cstring&gt;// ...// Allocate a space with 8 char's and fill it with zero, then finally release the memory space.char* buffer = new char[8];memset(buffer, 0, 8);delete[] buffer;// pointer to pointerchar** ptr = &amp;buffer; In running, ptr 储存的数据为 0x00B6FED4 (即 buffer 作为变量本身的地址), 在 VS2019 自带的 Memory View 中 buffer储存的数据为f0 dd d0 00 (buffer指向8个char长度的空间地址), 由于x86的设计, 我们从 Memory View 看到的是反转的数据, 实际应该是00 d0 dd f0(即 0x00d0ddf0), 这个地址就是那8个char长度空间的所在地. Reference in C++ 函数的形式参数中 使用引用可以使代码相比指针更简洁 因为访问引用变量不使用需要去引用化符号 “*” CLASSES vs STRUCTS in C++ Struct和Class无本质区别 Struct更适合存储多个变量, 侧重于表达数据结构, 而对象侧重于表达对象 Struct中的变量默认是Public修饰. 同时, Class可以继承Struct(但编译器会报警) public: 和 private: 在类中可有多处 Static in C++ Basically just to cut to the chase (切入正题/长话短说), static outside of class means that the linkage of that symbol that you declare to be static is going to be internal meaning. It;s only going to be visible to that translation unit that you’ve defined it in. Whereas a static variable inside a class or struct means that variable is actually going to share memory with all of the instances of the class meaning that basically across all instances that you create of that class or struct, there’s only going to be one instance of that static variable and a similar thing applies to static methods in a class there is no instance of that class being passed into that method. (Cherno讲的是背后的原理) 第一种情况翻译: 由于translation unit中的(不是class中的)全局变量/函数是全局可见的, 所以加上static让全局变量只在它所在的translation unit可见. 否则在不同的translation unit声明相同符号的变量将在链接阶段报重复定义错误. 类似于translation unit的private修饰 @Cherno 的命名规范: s_开头代表变量为静态 static int s_Variable = 5; 尽量在头文件使用static变量, 因为它只是简单将内容复制到cpp文件 Local Static 使变量在局部可见的同时有static的性质 1234567891011121314void Function(){ static int i = 0; i++; std::cout &lt;&lt; i &lt;&lt; std::endl;}int main(){ Function(); Function(); Function(); Function();} Classical Singleton Singleton类在整个程序中只有一个实例 12345678910111213141516// 第一种实现class Singleton{private: static Singleton* s_Instance; Singleton() {}; // 这一行作用阻止类被实例化, 后面构造函数会讲public: static Singleton&amp; Get() { return *s_Instance; }; void Hello() { std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl; };};Singleton* Singleton::s_Instance = nullptr;int main(){ Singleton::Get().Hello(); 12345678910111213141516171819// 或者将对象实例放在局部静态变量中(好处: 相比上一种更少的代码量)class Singleton{private: Singleton() {}; // 这一行作用阻止类被实例化, 后面构造函数会讲public: static Singleton&amp; Get() { static Singleton instance; return instance; }; void Hello() { std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl; };};int main(){ Singleton::Get().Hello();}} Enum in C++ 枚举用来管理标识符, 增强代码可读性, 本质是Integer(可指定which types of integer you want to be) 如 (模式是32位Integer, 这里用unsigned char只有8位可以节约内存) 1234enum Example : unsigned char{ A, B, C}; 使用enum后的Log类 12345678910111213141516171819202122232425262728293031323334353637class Log{public: enum Level { // LevelError = 0代表从零开始递进, 当然默认就是0 LevelError = 0, LevelWarning, LevelInfo };private: Level m_LogLevel = LevelInfo;public: void SetLevel(Level level) { m_LogLevel = level; } void Error(const char* message) { if (m_LogLevel &gt;= LevelError) std::cout &lt;&lt; &quot;[Error]:&quot; &lt;&lt; message &lt;&lt; std::endl; } void Warn(const char* message) { if (m_LogLevel &gt;= LevelWarning) std::cout &lt;&lt; &quot;[WARNING]:&quot; &lt;&lt; message &lt;&lt; std::endl; } void Info(const char* message) { if (m_LogLevel &gt;= LevelInfo) std::cout &lt;&lt; &quot;[INFO]:&quot; &lt;&lt; message &lt;&lt; std::endl; }};int main() { Log log; log.SetLevel(Log::LevelWarning); log.Error(&quot;Hello&quot;); log.Warn(&quot;Hello&quot;); log.Info(&quot;Hello&quot;);} Constructors in C++ You have to manually initialize all of your primitive types otherwise they will be set to whatever was left over in that memory. 禁止实例化类, 只需要把构造函数设为Private, 或者删除构造函数 If you did not want people creating instances… 123456789101112131415161718192021class Log{Private: Log() {} // One waypublic: Log() = delete; // Another way static void Write() { }};int main(){ // Only Write() can be invoke Log::Write(); // Now you cannot access the constructor Log l;} Destructors in C++ 折构函数可以被这样调用, 但是基本上不会用到, It’s weired someClass.~someClass(); Inheritance in C++ 没啥好说的, 唯一要注意的是继承的类的大小将是: 父类所有的变量总和 + 自己声明变量总和 Use colon to inerit a class 1234class Sub_Class : Main_Class{} Virtual Function in C++ 首先我们来看为什么要有Virtual函数 1234567891011121314151617181920212223242526class Entity{public: std::string GetName() { return &quot;Entity&quot;; } };class Player : public Entity{private: std::string m_Name;public: Player(const std::string&amp; name) : m_Name(name) {} std::string GetName() { return m_Name; }};int main(){ Entity* entity = new Entity(); std::cout &lt;&lt; entity-&gt;GetName() &lt;&lt; std::endl; Player* player = new Player(&quot;Cherno&quot;); Eneity* entity2 = player; std::cout &lt;&lt; entity2-&gt;GetName() &lt;&lt; std::endl;} 输出: 12EntityEntity 发现问题了吗, 第二个输出本应是&quot;Cherno&quot; 实际上当指针类型是父类Entity时, 通过该指针调用子类Player类的重载函数GetName()并没有被调用, 而是父类定义的内容, 这会导致许多问题 C++11引入了Override关键字, 它不是必须的, 但能够避免发生拼写错误并能增强代码的可读性 正确示范: 12345678910111213141516171819202122232425262728class Entity{public: // 加上了virtual virtual std::string GetName() { return &quot;Entity&quot;; } };class Player : public Entity{private: std::string m_Name;public: Player(const std::string&amp; name) : m_Name(name) {} // 加上了override std::string GetName() override { return m_Name; }};int main(){ Entity* entity = new Entity(); std::cout &lt;&lt; entity-&gt;GetName() &lt;&lt; std::endl; Player* player = new Player(&quot;Cherno&quot;); Eneity* entity2 = player; std::cout &lt;&lt; entity2-&gt;GetName() &lt;&lt; std::endl;} 总结: If you want to override a function you have to mark the base function in the base class as virtual. 不重要的补充: 使用virtual可以减少dynamic dispatch这种操作的使用 (运行时修改对象的vtable). 很不幸virtual它不属于免费的午餐, 首先使用它会需要额外的Vtable空间以让我们能够dispatch to the correct function that includes a member pointer in the actual base class that points to the Vtable. 第二, 我们每次调用virtual函数我们都要通过那个table来决定which function to actually map to. 但是基本上区别并不明显, 所以能用就用. 除非你的程序要跑在一个性能真的非常非常差的嵌入式设备上. Interface (Pure virtual method) 在Printable中创建一个GetClassName的赋值为0的函数, 它就是一个接口 这个类也不能被直接实例化, 需要实现此方法的子类才能工作 1234class Printable{public: virtual std::string GetClassName() = 0;} 简单的示例 1234567891011121314151617181920class Player : public Entity, Printable // 子类可以继承多个接口类{public: std::string GetClassName() override { return &quot;Player&quot;; }}void Print(Printable* obj) // 通过这样的函数, 我们只需要实现这个方法, 该函数就会调用我们的实现{ std::cout &lt;&lt; obj-&gt;GetClassName() &lt;&lt; std::endl;}void main(){ Player player = new Player(); Print(player); Print(new Player); // 不要这么用, 会导致内存泄漏} Visibility in C++ The default visibility of a Class would actually be private; if its a Struct then it would be public by default. private标记的内容只有本类能访问, 子类也不行, 但是朋友类(friend class)可以, 会在以后视频中讲到. protected标记是在private基础上, 子类可以访问 Arrays in C++ Raw Arrays 举个例子int example[5] 数组名称 example 是一个指针, 指向 example[0] 的所在地址 请注意, 不能使用超出数组下标的操作(如example[-1] = 0), 那意味着访问不在当前数组许可范围内的内存; 在debug模式下它会报错, 但在release下它可能会造成不可预料的后果 还可以用指针的方式访问数组 123456789101112int example[5];int* ptr = example;for (int i = 0; i&lt; 5; i++) example[i] = 2;example[2] = 5;// equals to *(ptr + 2) = 5;// 因为这个指针是int类型, 所以每次+1都向后偏移4字节的内存地址(对指针进行加减操作是不同于普通的);// 所以也可以写成:// *(int*)((char*)ptr + 8) = 6;// 即先以1 byte的char*进行指针加法操作, 然后再转回int*// It is pretty wild line of code. 更多的, 两种不同的创建数组的方式 12345678int example[5];int* another = new int[5];// 前者是创建在stack上的并且会在函数执行完后被摧毁// 后者是创建在heap上的// 建议在类中使用前者, 在函数中使用后者// We need to delete using the square bracketsdelete[] another; 在C++中你无法动态地检查一个普通数组的大小 12345int* another = new int[5];int count = sizeof(another) / sizeof(int);// 使用这样的方式是不靠谱的// 由于another是个指针, 所以最终 count 的结果是1, 这显然不对 一个比较好的办法是管理一些记录数组大小的常量 12static const int exampleSize = 5;int example[size]; C++11 Standard Arrays 好处是能很方便地检查一个数组的大小 12345678#include &lt;array&gt;int main(){ std::array&lt;int, 5&gt; another; for (int i = 0; i &lt; another.size(); i++) eanother[i] = 2;} 两者区别是Standard Arrays 相比 Raw Array s有更多性能的开销(但是值得), 且更安全 @TheCherno 更喜欢用Raw Arrays, Because he like to live dangerously :) How Strings Work in C++ (and how to use them) C风格字符串 1const char* name = &quot;Cherno&quot;; 字符串分配的内存是fixed allocated block, 这表示想要扩充只能通过分配全新的字符串(新的地址)并删除旧的字符串来实现 同时由于这是个char指针所以这个字符串不能用delete(后面会细讲new和delete, rule of thumb is just if you don’t use ‘new’ keyword dont’t use the ‘delete’ keyword) 细节的东西 null termination character: 每个字符串末尾都会有一个null结束符0(int类型, 等价于’\\0’这个char类型) 比如 char name[7] = {'C', 'h', 'e', 'r', 'n', 'o', '\\0'}; 如果没有结束符, 那么当使用cout输出字符串时, 它会一直输出接下来的内存数据直到读到’\\0’. (表现为输出&quot;Cherno&quot;然后跟着一串乱码) 注意: Double quote “” by default it becomes a char pointer; 翻译: “Cherno” 默认表示为类型为 char* 的数据. 为什么是 const char* ? 因为字符串本质是char数组, 而数组变量本质上储存的也就是这个数组的起始地址, 所以用 const char* 没毛病, cout对const char*有特殊对待不不断地读下去直到碰到前文所说的null termination character 同时, 从Memory View看到的十六进制 cc 大概率表示we are right outside of the bounds of our allocation. C++ 标准字符串 本质上是char array 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt; // cout没有输出string类型的overload, 如果不输出可以不用includeint main(){ std::string name = &quot;Cherno&quot; + &quot; hello!&quot;; //这种方式是不对的, 因为&quot;Cherno&quot;是一个 const char* 类型 std::string name = &quot;Cherno&quot;; name += &quot; hello!&quot;; // 这种是对的, a nice easy way, because you are adding it to a string, and &quot;+=&quot; is overloaded in the string class to be able to let you do that. // 或者这样(虽然会有更多的对象拷贝操作, 大多数情况下性能影响不大) std::string name = std::string(&quot;Cherno&quot;) + &quot; hello!&quot;; std::cout &lt;&lt; name &lt;&lt; std::endl;} 简单的使用: 123456789// 判断字符串是否包含指定文字bool const contains = name.find(&quot;no&quot;) != std::string::npos // std::string::npos 代表没有找到返回的值// 因为字符串操作在c++中很普遍, 而每次都进行不必要的对象复制无疑很低效, 使用const xxx&amp;将对象直接以只读形式传入函数void PrintString(const std::string&amp; string){ string += &quot;h&quot;; std::cout &lt;&lt; string &lt;&lt; std::endl;} String literals Terminal character will actuall break the behavior of this string in many cases 1234567#include &lt;stdlib.h&gt;int main(){ const char name[8] = &quot;Che\\0rno&quot;; std::cout &lt;&lt; strlen(name) &lt;&lt; std::endl;} String literals are stored in read-only section of memory This code might not vaild for all CPP compilers. And edit this string is actually didn’t work: 12345678910int main(){ char* name = &quot;Cherno&quot;; // 这种定义是错误的, 字符串类型指针应该永远是const char* // 要想运行时修改字符串, 正确操作应是定义一个字符串数组而不是一个指针 // char name[] = &quot;Cherno&quot;; name[2] = 'a'; std::cout &lt;&lt; name &lt;&lt; std::endl;} 其他类型的字符串 1234567int main(){ const char* name = u8&quot;Cherno&quot;; // utf-8, u8前缀非必要 const char16_t* name2 = u&quot;Cherno&quot;; // two bytes per character (utf-16) const char32_t* name3 = U&quot;Cherno&quot;; // four bytes per character (utf-32) const wchar_t* name4 = L&quot;Cherno&quot;; // 由编译器决定, eitger 2 ir 4 bytes, its 2 bytes on Windows and 4 on Linux and I acpect Mac as well} C++14标准 12345678910111213int main(){ using namespace std::string_literals; std::string name0 = &quot;Cherno&quot;s + &quot; hello&quot;; std::wstring name1 = L&quot;Cherno&quot;s + L&quot; hello&quot;; std::u32string name1 = U&quot;Cherno&quot;s + U&quot; hello&quot;; // raw形式赋值, 对拷贝大篇文章时保留文章格式有用 const char* rawstring = R&quot;(Line1Line2Line3Line4)&quot;;} const in C++ const pointer 在前, you cannot change the data at that memory address 在后, you cannot reassign the actual pointer itself to point something else 1234567891011121314const inst MAX_AGE = 90;// 1. Pointer to const valueconst int* a = new int;*a = 2; // I cannot change the contents of the pointera = (int*) &amp;MAX_AGE; // But I can change the pointer itself// 2. Const pointersint* const b = new int;*b = 2;b = (int*) &amp;MAX_AGE; // but you cannot change the pointer whose value// 3. Const pointer to a const valueconst int* const c = (int*) &amp;MAX_AGE; 注意: const int* 和 int const* 是相等的, 你需要将const 放在 * 号后面 const method const 修饰的方法无法改变类中的变量 Only avaliable in class method 涉及内容: 当const方法返回指针类型时怎么做: 方法数据类型应为 “const int* const” 以 const Object&amp; 实例化的对象只能访问const方法 mutable 变量 1234567891011121314151617181920212223242526272829303132333435class Entity{private: int m_X, *m_Y, *m_Z; // 定义多个变量时指针类型要为每个单独加 '*' 号 mutable int var;public: int GetX() const { // m_X = 2; 你不能修改变量的值 var = 233; // 但我们可以在const方法中修改mutable修饰的变量 return m_X; } const int* const GetY() const // 若const方法要返回指针类型变量, 方法数据类型应为 &quot;const int* const&quot; { return m_Y; } void SetX() { m_X = 2; }}void PrintEntity (const Eneity&amp; e){ // std::cout &lt;&lt; e.SetX() &lt;&lt; endl; 常量型对象无法访问无const修饰的方法 std::cout &lt;&lt; e.GetX() &lt;&lt; endl;}int main(){ Entity e = new Entity(); PrintEneity(e);} Mutable Keyword in C++ mutalbe有两种用法, 第一种用于常量方法中, 见#const method, 第二种用于lambda, 用的不多 123456789int x = 8;auto f = [=]() mutable{ x++; std::cout &lt;&lt; x &lt;&lt; std::endl;}f();// x is still = 8, 因为[=]模式 is just copy this value into this lambda, mutable代表它能更改传递进来的值并且不让编译器报错, 但实际上8本身是个常数所以没有效果. 什么是lambda: a lambda is basically like a little throwaway function that you can write and assign to a variable quickly. Memory Initializer Lists in C++ (Constructor Initializer List) 使用构造初始化列表可以避免使用 “=” 从而实列化两次对象 12345678910111213141516171819202122232425262728293031class Example{public: Example() { std::cout &lt;&lt; &quot;Created Entity!&quot; &lt;&lt; std::endl; } Example(int x) { std::cout &lt;&lt; &quot;Create Entity with &quot; &lt;&lt; x &lt;&lt; &quot;!&quot; &lt;&lt; std::endl; }}class Entity{private: Example m_example; int x, y, z;public: Entity() : m_example(Example(8)), x(0), y(0), z(0) // m_example(Example(8)) 或者m_example(8)都行 { // m_Example = Example(8); 如果在构造函数中实列化内部变量, 该对象会实例化两次 }}int main(){ Entity e0;} Ternary Operators in C++ (Conditional Assignment) 使用三目运算符可以简化if_else语句 12345678910111213141516171819202122232425262728#include &lt;string&gt;static int s_Level = 1;static int s_Speed = 2;int main(){ s_Speed = s_Level &gt; 5 &amp;&amp; s_Level &lt; 100 ? s_Level &gt; 10 ? 15 : 10 : 5; std::cout &lt;&lt; s_Speed &lt;&lt; std::endl; // 以上式子等价于 // if (s_Level &gt; 5 &amp;&amp; s_Level &lt; 100) // { // if(s_Level &gt; 10) // { // s_Speed = 15; // } // else // { // s_Speed = 10; // } // } // else // { // s_Speed = 5; // }} How to CREATE/INSTANTIATE OBJECTS in C++ There are two main section of memory: the stack and heap Stack objects have an automatic lifespan, there lifetime is actually controlled by the scope their declared Heap: once you allocated an object in that heap, it’s gonna sit there unill you explicit delete it 栈空间一般只有1M到几M(取决于平台), 如果你需要创建一个巨大的对象, 你将不得不将他创建在堆内存上 不使用 new 关键字, 对象创建在栈空间上 123Entity entity(&quot;Cherno&quot;);// 或者Entity entity = Entity(&quot;Cherno&quot;); 使用 new 关键字, 对象创建在堆空间上 1234// new 返回的是创建对象的内存地址, 所以用 Entity*Entity* entity = new Entity(&quot;Cherno&quot;);// 你需要手动删除 new 创建的对象来释放内存delete entity; 所以用 new 创建对象很容易导致内存泄漏, 之后会讲的 智能指针 可用很好地解决这个问题 The NEW Keyword in C++ 更多new的细节 How the new keyword find free space on memory? There is something called free list which actually maintain the addresses that have bytes free. It’s obvously written in intelligent but its stll quite slow. 几点事实: new is just an operator, means that you can overload new and change its bahavious Usually calling new will call the underlying C Function malloc() delete also calls the destructor 三种 new 的不同使用方法(normal new, array new, placement new) 12345678910111213141516171819202122232425int main(){ // If we wanted an array of entries (An array which is stored 50 Objects of Entity) Entity* entity = new Entity(); delete entity; // Remember delete object // If using new with square bracket &quot;[&quot; and &quot;]&quot; // The new operator is actually a slightly differ function than normal Entity* entity2 = new Entity()[50]; // Also we need calling delete with square bracket delete[] eneity2; // Placement New is where you actually get to decide kind of where the memory comes from. // You don't really allocating memory wieh new, // you're just calling the constructor and initializing you Object in a specific memory address int* buffer = new int[50]; Entity* entity3 = new(buffer) Entity(); delete entity3; delete[] buffer; // in C there are some kinds of equivalent: // Entity* entity = (Entity*) malloc(sizeof(Entity)); // malloc() will not call the constructor so you need to call it in manual // So it's better don't use this in C++} Implicit Conversion and the Explicit Keyword in C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Entity{private: std::string m_Name; int m_Age;public: Entity(const std::string&amp; name) : m_Name(name), m_Age(-1) P{} // Use explicit keyword to disable implicit conversion explicit Entity(int age) : m_Name(&quot;Unknown&quot;), m_Age(age) {}};void PrintEntity(const Entity&amp; entity){ // Printing Statements}int main(){ // It's weird , you can't do this in other languages(such as C# or Java) // This is called implicit conversion // It implicit converting &quot;Cherno&quot; into Entity's Constructor Method: Entity(const std::string&amp; name) Entity a = std::string(&quot;Cherno&quot;); // 虽然上面是个很好的隐式转换的例子, 但是不建议用这种语法实例化对象 // You cannot do implicit conversion with explicit method anymore // This is not allowed Entity b = 22; // Correct sentence: Entity b = Entity(22); // This is not allowed Entity a = &quot;Cherno&quot;; // and PrintEntity(&quot;Cherno&quot;); // &quot;Cherno&quot; is a const char array // C++ need to do two conversions, one from const char* to std::string, and then call into Entity(const std::string&amp; name) // It's only allowed to do one implicit conversion at same time // Correct sentence: PrintEntity(std::string(&quot;Cherno&quot;); // or as normal: PrintEntity(Entity(&quot;Cherno&quot;));} OPERATORS and OPERATOR OVERLOADING in C++ In the case of operator overloading you’re allowed to define or change the behavior of operator Operators are just functions Here goes some examples: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct Vector2{ float x, y; Vector2(float x, float y) : x(x), y(y) {} // overload the function &quot;operator+()&quot; equals redefine the behavior of operator plus in this Object Vector2 operator+(const Vector2&amp; other) const { return Vector2(x + other.x, y + other.y); } // As same with above Vector2 operator*(const Vector2&amp; other) const { return Vector2(x * other.x, y * other.y); } // As same with above bool operator==(const Vector2&amp; other) const { return x == other.x &amp;&amp; y == other.y; } bool operator!=(const Vector2&amp; other) const { // We have a simple way return !operator==(other); // Or // return !(*this == other); }};// See the use case in main()std::ostream&amp; operator&lt;&lt;(std::string&amp; stream, const Vector2&amp; other){ stream &lt;&lt; other.x &lt;&lt; &quot;, &quot; &lt;&lt; other.y; return stream;}int main(){ Vector2 position(4.0f, 4.0f); Vector2 speed(0.5f, 1.5f); Vector2 powerup(1.1f, 1.1f); Vector2 result1 = position + speed * powerup; // We cannot output the variables in vector directly // We need overload the function &quot;operator&lt;&lt;&quot; std::cout &lt;&lt; result1 &lt;&lt; std::endl; // In programs such like Java we have to use equals() to compare objects // but in C++ we can simply overload the &quot;operator==&quot; if(retult1 == position) std::cout&lt;&lt; &quot;foo&quot; &lt;&lt; std::endl;} Ths “this” keyword in C++ this是一个指向当前方法所在对象的指针 避免形参名字和对象成员变量的名字一样所造成的歧义 12345678910class Entity{public: int x, y; Entity(int x, int y) { // 这里只是示范, 实际有更方便的构造参数列表来赋值 this-&gt;x = x; // or (*this).x = x; }} Object Lifetime in C++ (Stack/Scope Lifetimes) 下面的例子讲了三件事: 编写函数时不要返回在stack内存空间创建的对象 使用 {} 创建局部scope以使stack上的对象更早地被自动清理 Unique Pointer的基本原理展示 1234567891011121314151617181920212223242526272829303132333435int* CreateArray(){ // Don't write code like this // The array gets cleared as soon as we go out of scope int array[50]; return array;}class ScopedPtr{private: Entity* m_Ptr;public: ScopedPtr(Entity* ptr) : m_Ptr(ptr) {} ~ScopedPtr() { delete m_Ptr; // delete Entity when ScopedPtr get deleted }}int main(){ // scope with brace { Entity e; // the object created on stack will gets free when out of the scope // We could use something in the standard library called unique pointer which is a scoped pointer // but here we write our own to explain how it works ScopedPtr e = new Entity(); // It's implicit conversion // because the scoped pointer object gets allocated on the stack which means it will gets deleted when out of the scope and call ~ScopedPtr() // then corresponding the Entity will gets deleted }} SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr) Smart pointers mean that when you call new , you don’t have to call delete In face in many cases with smart pointers we don’t even have to call new This episode introduce: unique pointer shared pointer &amp; weak pointer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;class Entity(){public: Entity() { std::cout &lt;&lt; &quot;Created Entity!&quot; &lt;&lt; std::endl; } ~Entity() { std::cout &lt;&lt; &quot;Destoryed Entity~&quot; &lt;&lt; std::endl; } void Print() {}}int main(){ { // All smart pointer are marked as explicit std::unique_ptr&lt;Entity&gt; uniqueEntity(new Entity()); // The preferred way through to construct this would be to assign it to std::make_unique&lt;Entity&gt; // The primary that is important for unique pointers is due to exception safety std::unique_ptr&lt;Entity&gt; uniqueEntity = std::make_unique&lt;Entity&gt;(); // You can access it like you would normally uniqueEntity-&gt;Print(); // Tou cannot copy unique pointer, you will get a compile error std::unique_ptr&lt;Entity&gt; e0 = entity; // If you go to definition of unique pointer you'll see that the copy constructor // and copy assignment operator are deleted; // shared pointer is use something called reference counting // You create one shread pointer and you define another shared pointer and copy the // previous one, the reference count is now 2, // when the first one dies(out of scope), the reference count goes down 1 // and when the last one dies. the reference count goes back to zero, // and free the memory. // BTW, for shared pointer using make_shared is very recommand because its more efficient // There is something else that you can use with shared pointer is called weak pointer // weak pointer will not increase the reference count std::weak_ptr&lt;Entity&gt; weakEntity; { std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;(); weakEntity = sharedEntity2; } // The sharedEntity will still be free immediately here. } } Copying and Copy Constructors in C++ Ues “=”(called Shallow Copy) to copy an object created on heap(with new) which is without a Copy Constuctors or an object created on stack but with private pointer variables(objects created on heap) will lead to unexpected results. It’s essentially just copy the address data in pointer variable So you need a Copy Constructor which delimit the behavior of the copy operation. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class String{private: char* m_Buffer; unsigned int m_Size;public: String(const char* string) { m_Size = strlen(string); m_Buffer = new char[m_Size + 1]; // +1 for last null termination char // You can also use strcpy() memcpy(m_Buffer, string, m_Size + 1); } // Copy Consturcor String(const String&amp; other) : m_Size(other.m_Size) { m_Buffer = new char[m_Size + 1]; // Or if you want to be more exciting, you can use this instead // memcpy(this, &amp;other, sizeof(String)); } // Or you can just prevent this object to do copy operation //String(const String&amp; other) = delete; ~String() { delete[] m_Buffer; } char&amp; operator[](unsigned int index) { return m_Buffer[index]; } // make &lt;&lt;() to be a fried so it can access private variables in this object friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const String&amp; string);};std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const String&amp; string){ stream &lt;&lt; string.m_Buffer; return stream;}int main(){ String first_String = &quot;Cherno&quot;; String second_string = first_string; second_string[2] = 'a'; std::cout &lt;&lt; first_String &lt;&lt; endl; std::cout &lt;&lt; first_String &lt;&lt; endl;} The Arrow Operator in C++ Normal usage12345int main(){ Entity* entity = new Entity(); entity-&gt;x = 2; // = (*entity).x = 2;} It is actually possible to overload the Arror Operator and use it in specific class such as ScopedPtr (For more see previous chapter: SMART POINTERS in C++).12345678910111213141516171819202122232425262728293031class Entity{public: void Print() const { std::cout &lt;&lt; &quot;Hello!&quot; &lt;&lt; std::endl; }};class ScopedPtr{private: Entity* m_Obj;public: ScopedPtr(Entity* entity) : m_Obj(entity) {} ~ScopedPtr() { delete m_Obj; } Entity* operator-&gt;() { return m_Obj; }};int main(){ ScopedPtr entity = new Entity(); // Do you still remember the Implicit Conversion? entity-&gt;Print();} It can also be used to get the variable’s memory offset in an Object (In some memory hack :)123456789101112struct Vector3{ // I deliberately desrupt the naming order to make it in a different memory layout. float z, y, x;};int main(){ // Get the offset of that 'x' int offset = (int) &amp;((Vector3*)0)-&gt;x; // Or &amp;((Vector3*)nullptr)-&gt;x; std::cout &lt;&lt; offset &lt;&lt; std::endl;} Dynamic Arrays in C++ (std::vector) Vector in C++ is not mathematical vector, it’s kind of like Dynamic Arrays 1234567891011121314151617181920212223242526272829303132333435struct Vertex{ float x, y, z;};std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Vertex&amp; vertex){ stream &lt;&lt; vertex.x &lt;&lt; &quot;, &quot; &lt;&lt; vertex.y &lt;&lt; &quot;, &quot; &lt;&lt; vertex.z; return stream;}int main(){ // the '&lt;Object&gt;' is called template, will show in later chapter // For now, we only need to know this definite the type which the Dynamic Arrarys stores std::vector&lt;Vertex&gt; vertices; // It is hard to decide whether you should be using like vertex pointers // or just vertex object in this case // Which is object stored in line or fragmented in memory // Add object to the end of Dynamic Array vertices.push_back({ 1, 2, 3 }); // Note: Implicit conversion vertices.push_back({ 4, 5, 6 }); // Using range based 'for loop' to iterate the object in Dynamic Array for (const Vertex&amp; v : vertices) std::cout &lt;&lt; v &lt;&lt; sed::endl; // We can remove object in dynamic array individually // This remove the second object in dynamic array vertices.erase(vertices.begin() + 1); // Or we can clean the whole dynamic array vertices.clear();} Optimizing the usage of std::vector in C++ Two ways to reduce memory copy 12345678910111213141516171819202122232425262728293031323334353637383940414243struct Vertex{ float x, y, z; Vertex(float x, float y, float z) : x(x), y(y), z(z) { } // Copy Constructor, used to capture copied times Vertex(const Vertex&amp; v) : x(v.x), y(v.y), z(v.z) { // Output to console to see how many times copied std::cout &lt;&lt; &quot;Copied!&quot; &lt;&lt; std::endl; }};int main(){ std::vector&lt;Vertex&gt; vertices_bad; vertices_bad.push_back(Vertex(1, 2, 3)); // Make it easier to read than previous chapter vertices_bad.push_back(Vertex(4, 5, 6)); vertices_bad.push_back(Vertex(7, 8, 9)); vertices_bad.push_back(Vertex(10, 11, 12)); // Each pass parameter operation in push_back() will cause 1 copy operation // And **each push_back() called will cause memory rearrange**, // which are copy previous objects in dynamic array into new memory area. // So total copied times: 1 + (1 + 1) + (1 + 2) + (1 + 3) = 10 std::cout &lt;&lt; &quot;vertices good&quot; &lt;&lt; std::endl; std::vector&lt;Vertex&gt; vertices_good; // Below is the optimized implementation // 1. Use reserver() to prevent memory rearrange. vertices_good.reserve(4); // 2. Replace push_back() with emplace_back() to prevent parameter copy // it acts as a proxy to process you provided parameter into Constructor. vertices_good.emplace_back(1, 2, 3); vertices_good.emplace_back(4, 5, 6); vertices_good.emplace_back(7, 8, 9); vertices_good.emplace_back(10, 11, 12);} Using Libraries in C++ Preposition work: Visual Studio Setup Using GLFW as example: Create a folder called “Dependencies” under your project directory and then put your libraries into it.C:\\Users\\USERNAME\\source\\repos\\Your_Project_Directory\\12345678910Dependencies\\-&gt; GLFW\\ -&gt; include\\ -&gt; GLFW\\ glfw3.h ... -&gt; lib-vc2015\\ glfw3.dll glfw3.lib glfw3.dll.lib Open your project settings: -&gt; Configuration: All Configuration -&gt; C/C++ -&gt; Additional Include Directories: $(SolutionDir)\\Dependencies\\GLFW\\include -&gt; Linker -&gt; General -&gt; Additional Library Directories: $(SolutionDir)\\Dependencies\\GLFW\\lib-vc2015 Static linking Static linking happens at compile time, the lib intergrate into executable or a dynamic library Open your project setting -&gt; Linker -&gt; Input -&gt; Additional Dependencies: glfw3.lib;xxxxxx;balabala;... Static LinkMain.cpp123456789// quote for header in this project, regular bracket for external library#include &lt;GLFW/glfw3.h&gt;\\\\ Or `extern &quot;C&quot; int glfwInit();`\\\\ Because GLFW is actually a C library so we need `extern &quot;C&quot;`int main(){ int result = glfwInit(); std::cout &lt;&lt; result &lt;&lt; std::endl;} Dynamic linking Dynamic linking happens at runtime Some librarys like GLFW supports both static and dynamic linking in a single header file glfw3.dll.lib is basically a series of pointers into glwfw3.dll Code is basically as same as the Static linking above Open your project settings: -&gt; Linker -&gt; Input -&gt; Additional Dependencies: glfw3.dll.lib;xxxxxx;balabala;... put your dll file(glfw3.dll) to the same folder as your executable file(i.e: $(SolutionDir)\\Debug) In fact, to call a function in dynamic library, it needs a prefix called __declspec(dllimport) If you explore glfw3.h you will see there is a GLFWAPI prefix in every function definition, 123#elif defined(_WIN32) &amp;&amp; defined(GLFW_DLL)/* We are calling GLFW as a Win32 DLL */ #define GLFWAPI __declspec(dllimport) So you need to define a Macro in VS: Open your project setting: -&gt; C/C++ -&gt; Preprocessor -&gt; Preprocessor Definitions: GLFW_DLL;xxxxx;bababa... But why it seems stll work properly without the dllimport prefix? In modern windows, dllimport is not needed for functions, but dllimport is still needed for C++ classes and global variables. Making and Working with Libraries in C++ (Multiple Projects in Visual Studio) Visual Studio Setup: Create one solution with 2 projects “Game” and “Engine”, Project “Game”: -&gt; Ceneral-&gt;Project Defaults-&gt;Configuration Type: Application (.exe) -&gt; C/C++ -&gt; General -&gt; Additional include Directories: $(SolutionDir)\\Engine\\src; Project “Engine”: Ceneral-&gt;Project Defaults-&gt;Configuration Type: Static library (.lib) Right click on projects “Game” -&gt; Add -&gt; Reference -&gt; Select project “Enginx” Code for project “Engine”:Your_Project_Directory\\src\\Engine.h12345#pragma oncenamespace engine { void PrintMessage();} Your_Project_Directory\\src\\Engine.cpp12345678910#include &quot;Engine.h&quot;#include &lt;iostream&gt;namespace engine { void PrintMessage() { std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl; }} Code for project “Game”:Your_Project_Directory\\src\\Application.cpp123456#include &quot;Engine.h&quot;int main(){ engine::PrintMessage();} How to Deal with Multiple Return Values in C++ Example scenario: we have a function called ParseShader() , it needs to return two strings Return a struct cotains two strings (Cherno’s choose):123456789101112struct ShaderProgramSource{ std::string VertexSource; std::string FragmentSource;}ShaderProgramSource ParseShader(){ // Some statements that process result 'vs' and 'fs' // ... return { vs, fs };} Using reference paremeter (Probably one of the most optimal way)1234567891011121314151617181920212223242526void ParseShader(std::string&amp; outVertexSource, std::string&amp; outFragmentSource){ // Some statements that process result 'vs' and 'fs' // ... outVertexSource = vs; outFragmentSource = fs;}main(){ std::string vertexSource, fragmentSource; ParseShader(vertexSource, fragmentSource)}// Or using Pointer parameter if you want to pass nullptr(ignore the output):// void ParseShader(std::string* outVertexSource, std::string* outFragmentSource)// {// if (outVertexSource)// *outVertexSource = vs;// if (outFragmentSource)// *outFragmentSource = fs;// }// main()// {// ParseShader(nullptr, &amp;fragmentSource)// } Return a std::array or std::vector(ignored, too simple) The different is primarly the arrays can be create on the stack where as vectors gonna store its underlying storage on the heap. So technically returning a standard array would be faster.1234567891011#include &lt;array&gt;std::array&lt;std::string, 2&gt; ParseShader(){ // Some statements that process result 'vs' and 'fs' // ... std::array&lt;std::string, 2&gt; result; result[0] = vs; result[1] = fs; return result;} Using std::tuple and std::pair std:tuple (Can return more than two elements)12345678910111213141516171819202122#include &lt;tuple&gt;std::tuple&lt;std::string, int&gt; CreatePerson(){ return { &quot;Cherno&quot;, 24 }; // Implicit conversation // Or use &quot;std::make_pair()&quot;: // return std::make_pair(&quot;Cherno&quot;, 24);}int main(){ // 'auto' means automatically check the return type auto person = CreatePerson(); // Get values in std::tuple std::string&amp; name = std::get&lt;0&gt;(person); int age = std::get&lt;1&gt;(person); // Or using std::tie() std::string name2; int age2; std::tie(name2, age2) = person;} std::pair (A little bit faster than tuple)123456789101112// Show the only difference with 'std::tuple'std::pair&lt;std::string, std::string&gt; ParseShader(){ // ...}int main(){ // ... vertexSource = sources.first; vertexSource = sources.second;} Templates in C++ Template can improve code reuse rate and reduce duplicate code (for example function overload) The essence of template is similar to macros This chapter includes: template type template argument 12345678910111213141516171819// In this case, template specifying how to create methods based on your usage of them.(Automatically generate corresponding overloaded function)// So if nobody call this function, it's code will not exist in compiled file,// even if there is a grammatical error in this function code, it will still compile successfully.template&lt;typename T&gt;// exactly same with: &quot;template&lt;class T&gt;&quot;void Print(T value){ std::cout &lt;&lt; value &lt;&lt; std::endl;}int main(){ Print(5); // I actually specifying the type explicitly // The complete code should be: // Print&lt;int&gt;(5); Print(&quot;Hello&quot;); Print(5.5f);} 1234567891011121314151617181920212223// Yes, multiple template targets can be in one template definitiontemplate&lt;typename T, int N&gt;class Array{private: T m_Arry[N];public: int GetSize() const { return N; }};int main(){ Array&lt;int, 5&gt; array; // Which means its will generate the following code: // class Array // { // private: // int m_Arry[5]; // public: // int GetSize() const { return 5; } // }; std::cout &lt;&lt; array.GetSize() &lt;&lt; std::endl;} Stack vs Heap Memory in C++ Ignore… Macros in C++ Macros do text replace when preprocessor123456#define WAIT std::cin.get()int main(){ WAIT;} Macros function and combine with the environment Environment variables can be defined at: Open your project settings: C/C++ -&gt; Preprocessor -&gt; Preprocessor Definitions12345678910#ifdef PR_DEBUG#define LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl#elif defined(PR_RELEASE)#define LOG(x) // Do nothing#endifint main(){ LOG(&quot;Hello&quot;);} The “auto” keyword in C++ be careful with auto 12345678910111213std::string GetName(){ return &quot;Cherno&quot;;}int main(){ auto name = GetName(); // Call a type specific method // if the return type of GetName() changed to &quot;char*&quot; , this will be broken int a = name.size(); std::cout &lt;&lt; a &lt;&lt; std::endl;} auto’ to reduce type length12345678910111213141516171819202122class DeviceManager{private: std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt; m_Devices;public: const std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;&amp; GetDevices() const { return m_Devices; }}int main(){ DeviceManager dm; // The type is too mass const std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;&amp; devices = dm.GetDevices(); // You can use keyword &quot;using&quot; or &quot;typedef&quot; using DeviceMap = std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;; const DeviceMap&amp; devices2 = dm.GetDevices(); // Or auto const auto&amp; devices3 = dm.GetDevices();} Static Arrays in C++ (std::array) Ignore… Function Pointers in C++ 3 ways to definite a Function Pointers123456789101112131415161718void HelloWorld(int a){ std::cout &lt;&lt; &quot;Hello World! Value: &quot; &lt;&lt; a &lt;&lt; std::endl;}int main(){ auto function = HelloWorld(); // second way: // void(*function)(int) = HelloWorld(); // third way: // typedef void(*Balabala)(int); // Balabala function = HelloWorld; function(233);} A simple usage - the ForEach function:123456789101112131415161718void PrintValue(int value){ std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl;}void ForEach(const std::vector&lt;int&gt;&amp; values, void(*func)(int)){ for(int value : values) func(value);}int main(){ std::vector&lt;int&gt; values = { 1, 5, 4, 2, 3 }; ForEach(values, PrintValue); // We can use lambda to simply the function PrintValue() (see more in next episode) // ForEach(values, [](int value) { std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; })} Lambdas in C++ How to put outside variables into lambda function [=] : Pass everything in by value, the pass in variables is independent of the outside. [&amp;] : Pass everything in by reference. [a] : Pass ‘a’ by value [&amp;a] : Pass ‘a’ by reference. using mutable keyword to allow modify outside variables 12345int main(){ int a = 5; auto lambda = [=]() mutable { a = 5; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; a &lt;&lt; std::endl; };} We need to use std::function instand of raw function pointer if our callback lambda function have pass in variables.123456789101112131415161718#include&lt;functional&gt;// Here is the only difference (Use &quot;const &amp;&quot; because its an object)// &quot;void(*func)(int)&quot; to &quot;const std::function&lt;void(int)&gt;&amp; func&quot;void ForEach(const std::vector&lt;int&gt;* values, const std::function&lt;void(int)&gt;&amp; func){ // ...}int main(){ // ... int a = 5; auto lambda = [=](int value)) {std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; a &lt;&lt; std::endl; ForEach(values, lambda};} Usage of std::find_if (Returns an iterator to the first element for which callback function returns true)123std::vector&lt;int&gt; values = { 1, 5, 4, 2, 3 };auto iterator = std::find_if(values.begin(), values.end(), [](int value) { return value &gt; 3;});std::cout &lt;&lt; *iterator &lt;&lt; std::endl; Why I don’t “using namespace std” Don’t absolutely use using namespace in header files But if you must using using namespace, please use it in a small scope as possible, but NEVER EVER in a header file. For example a serious issue of implicit conversion : 123456789101112131415161718192021222324252627namespace apple{ void print(cout std::string&amp; text) { std::cout &lt;&lt; text &lt;&lt; std::endl; }}namespace orange{ void print(const char* text) { std::string temp = text; std::reverse(temp.begin(), temp.end()); std::cout &lt;&lt; temp &lt;&lt; std::endl; }}using namespace apple;using namespace orange;int main(){ print(&quot;Hello&quot;); // Which one will get called? // Answer: the orange::print() will be called, because the type of &quot;Hello&quot; is &quot;char*&quot;} Namespaces in C++ Use Namespace to avoid naming conflict: apple::print(), orange::print() avoid C library like naming: GLFW_initialize to GLFW::initialize Usage: We can set to use only specific symbol in a namespace12345678910111213141516171819namespcae apple { void print(const char* text) { //... } void print_again() { ///... }}int main(){ using apple::print; print(&quot;Hello&quot;); //We still need &quot;apple::&quot; to call print_again() apple::print_again();} Nested Namespaces can be shorten using Alias123456789101112131415namespace apple { // Or apple::functions (c++17) namespace functions { void print(const char* test) { // ... } }}int main(){ namespace a = apple::functions; a::print(&quot;Hello&quot;);} Threads in C++ If we want to do something else when we called functions that will block the current thread, we can use threads. Here is an example: We created a thread that will do loop on outputting “Working…”, and simultaneously the main() function is waiting for user input. 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;thread&gt;static bool is_Finished = false;void DoWork(){ using namespace std::literals::chrono_literals; // Or use &quot;sleep_for(std::chrono::seconds(1))&quot; below std::cout &lt;&lt; &quot;Started thread id=&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; while (!is_Finished) { std::cout &lt;&lt; &quot;Working...\\n&quot;; std::this_thread::sleep_for(1s); }}int main(){ // As soon as we create instance, it's going to immediately kick off that thread std::thread worker(DoWork); std::cin.get(); is_Finished = true; // Call main thread to wait this thread (block main thread) worker.join(); std::cout &lt;&lt; &quot;Finished.&quot; &lt;&lt; std::endl;} Timing in C++ Make a Timer for statistical time-consuming 123456789101112131415161718192021222324252627282930313233struct Timer{ std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end; std::chrono::duration&lt;float&gt; duration; Timer() { start = std::chrono::high_resolution_clock::now(); } ~Timer() { end = std::chrono::high_resolution_clock::now(); duration = end - start; float ms = duration.count() * 1000.0f; std::&lt;&lt; &quot;Timer took &quot; &lt;&lt; ms &lt;&lt; &quot;ms &quot; &lt;&lt; std::endl; }}void Function(){ // The timer will be auto delete when run out of the scope Timer timer; for (int i = 0; i &lt; 100; i++) std::cout &lt;&lt; &quot;Hello\\n&quot;; // std::endl is quiet slow} int main(){ Function();} Multidimensional Arrays in C++ 12345678910111213141516171819202122232425262728293031323334int main(){ // Allocate a 2D array to store twenty integer pointers int** a2d = new int*[20]; // We can set each of these pointers to point to an array for (int i = 0; i &lt; 20; i++) a2d[i] = new int[50]; // 3D array, you can imagine a cube with size of 20x30x40 int*** a3d = new int**[20]; for (int i = 0 i &lt; 20; i++) { a3d[i] = new int*[30]; for (int j = 0; j &lt; 20; j++) { a3d[i][j] = new int[40]: } } a3d[0][0][0] = 666; // When you want to delete this array, you have to go through inner array and delete all of those arrays from inside to out for(int i = 0; i &lt; 20; i++) { for (int j = 0; j &lt; 30; j++) { delete[] a3d[i][j]; } delete[] a3d[i]; } delete[] a3d;} The most issue is that the Multidimensional Arrays will results memory fragmentation. When iterating the array we have to jump to another location to read or write that data, and that’s results probably a cache miss which means that we’re wasting time fetching data from our actual RAM. One of the most important things you can do is just store them in a single dimensional array: 1234567891011int main(){ int* array =new int[5 * 5]; for (int x = 0; x &lt; 5; y++) { for (int y = 0; y &lt; 5; x++) { array[x * 5 + y] = 2; } }} Sorting in C++ 12345678910111213141516171819202122232425262728293031323334#include &lt;algorithm&gt;int main(){ std::vector&lt;int&gt; values = { 3, 5, 1, 4, 2 }; std::sort(values.begin(), values.end()); // Output the results for (int value : values) std::cout &lt;&lt; value &lt;&lt; std::endl; // We can define how the sorting rule the sort() dose // Such like sorting by big to small std::sort(values.begin(), values.end(), [](int a, int b) { return a &gt; b; }); // Output the results for (int value : values) std::cout &lt;&lt; value &lt;&lt; std::endl; // Or force '1' to the last of array list std::sort(values.begin(), values.end(), [](int a, int b) { // Return true equals do exchange the position of a, b if(a == 1) return false; if(b == 1) return true; return b &lt; a; });} Type Punning in C++ You can Treat an Entity struct as an int array: 12345678910111213141516struct Entity{ int x, y;}int main(){ Entity e = { 5, 8 }; int* position = (int*)&amp;e; std::cout &lt;&lt; position[0] &lt;&lt; &quot;, &quot; &lt;&lt; position[1] &lt;&lt; std::endl; // More crazy usage int y = *(int*)((char*)&amp;e + 4); std::cout &lt;&lt; y &lt;&lt; std::endl;} Unions in C++ Defined member in one Union means same memory location We have Vector2 and Vector2, but there is only one function PrintVector2() can output Vector2, what can we do? 12345678910111213141516171819202122232425262728293031323334353637struct Vector2{ float x, y;};void PrintVector2(const Vector2&amp; vector){ std::cout &lt;&lt; vector.x &lt;&lt; &quot;, &quot; &lt;&lt; vector.y &lt;&lt; std::endl;}struct Vector4{ union { // The benefit of anonymous struct is converting all variables in struct into a single member which is what the Union expects struct { float x, y, z, w; }; struct { // 'zy' will be the same memory as 'x, y', and 'zw' will be the same memory as 'z, w' Vector2 xy, zw; }; };};int main(){ Vector4 vector = { 1.0f, 2.0f, 3.0f, 4.0f }; PrintVector2(vector.xy); PrintVector2(vector.zw); std::cout &lt;&lt; &quot;------------------&quot; &lt;&lt; std::endl; vector.z = 500.0f; PrintVector2(vector.xy); PrintVector2(vector.zw);} Type Punning can do as the same result, but using Union makes it more concise. Virtual Destructors in C++ Virtual Destructors is really important if you are writing a father class, otherwise no one’s going to be able to safely delete the extend class (Because without virtual mark you are just adding a new Destructor instead of overload it) 123456789101112131415161718192021class Base{public: Base() { std::cout &lt;&lt; &quot;Base Constructor\\n&quot;; } virtual ~Base() { std::cout &lt;&lt; &quot;Base Destructor\\n&quot;; }};class Derived : public Base{public: Derived() { std::cout &lt;&lt; &quot;Derived Constructor\\n&quot;; } ~Derived() { std::cout &lt;&lt; &quot;Derived Destructor\\n&quot;; }};int main(){ // Polymorphic kind of type // without `virturl`, the &quot;~Derived()&quot; will not be called Base* poly = new Derived(); delete poly;} Casting in C++ C++ cast not do anything that C-style casts cannot do those casts do make you code more solid and looks better. Static cast (Will do compile time checking) Interpret cast (for Type Punning) Dynamic cast (Will return NULL if casting is failed) Const cast (TODO: Supplement this content) 12345678910111213141516171819202122class Base{public: Base() { } virtual ~Base() { }};class Derived : public Base{ // ...};int main(){ // Static cast double value = 5.5; double s = static_cast&lt;int&gt;(value); Base* base = new Base(); Derived* ac = dynamic_cast&lt;Derived*&gt;(base); if (!ac) { std::cout &lt;&lt; &quot;Converting failed\\n&quot;; }} Conditional and Action Breakpoints in C++ Condition Breakpoints: If I only want the breakpoint to trigger under a certain condition Action Breakpoints: Generally print something to the console when a breakpoint is hit They can prevent recompile and save time For details. please watch the video Safety in modern C++ and how to teach it You should 100% use smart pointers if you are doing serious work Precompiled Headers in C++ Look to 7:07 Dynamic Casting in C++ If we force type casting a Enemy class to Player and access data(funcions, variables) that is unique to player, the program will probablly crash. Dynamic Casting is actually does some validation for us to ensure that cast is valid 12345678910111213141516171819202122232425262728class Entity{};class Player : public Entity{};class Enemy : public Entity{};int main(){ Entity* actuallyPlayer = new Player(); Entity* actuallyEnemy = new Enemy(); // How does it know that actuallyPlayer is actually a Player and not an Enemy? // The way it does that is it stores runtime type information(RTTI) // This does add an overhead but it lets you do things like dynamic casting // Be aware that RTTI can be enabled or disabled Player* p0 = dynamic_cast&lt;Player*&gt;(actuallyPlayer); // Will return null Player* p1 = dynamic_cast&lt;Player*&gt;(actuallyEnemy); // dynamic_cast&lt;xxx*&gt;(xxx); equal to xxx instanceof xxx} BENCHMARKING in C++ (how to measure performance) Always make sure that you profile is actually meaningful in a releases because you’re not gonna be shipping code in debug anyway 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Timer{private: std::chrono::time_point&lt;std::chrono::steady_clock&gt; m_StartTime, m_EndTime;public: Timer() { m_StartTime = std::chrono::high_resolution_clock::now(); } ~Timer() { m_EndTime = std::chrono::high_resolution_clock::now(); auto start = std::chrono::time_point_cast&lt;std::chrono::microseconds&gt;(m_StartTime).time_since_epoch().count(); auto end = std::chrono::time_point_cast&lt;std::chrono::microseconds&gt;(m_EndTime).time_since_epoch().count(); auto duration = end - start; double ms = duration * 0.001; std::cout &lt;&lt; duration &lt;&lt; &quot;us (&quot; &lt;&lt; ms &lt;&lt; &quot;ms)\\n&quot; &lt;&lt; std::endl; }};int main(){ struct Vector2 { float x, y; }; std::cout &lt;&lt; &quot;Make Shared\\n&quot;; { std::array&lt;std::shared_ptr&lt;Vector2&gt;, 1000&gt; sharedPtrs; Timer timer; for (int i = 0; i &lt; sharedPtrs.size(); i++) sharedPtrs[i] = std::make_shared&lt;Vector2&gt;(); } std::cout &lt;&lt; &quot;New Shared\\n&quot;; { std::array&lt;std::shared_ptr&lt;Vector2&gt;, 1000&gt; sharedPtrs; Timer timer; for (int i = 0; i &lt; sharedPtrs.size(); i++) sharedPtrs[i] = std::shared_ptr&lt;Vector2&gt;(new Vector2()); } std::cout &lt;&lt; &quot;Make Unique\\n&quot;; { std::array&lt;std::shared_ptr&lt;Vector2&gt;, 1000&gt; sharedPtrs; Timer timer; for (int i = 0; i &lt; sharedPtrs.size(); i++) sharedPtrs[i] = std::make_shared&lt;Vector2&gt;(); }} STRUCTURED BINDINGS in C++ Only in C++17 and newer a better way compare to How to Deal with Multiple Return Values in C++ 1234567891011std::tuple&lt;std::string, int&gt; CreatePerson(){ return { &quot;Cherno&quot;, 24 };}int main(){ // Structured binding auto[name, age] = CreatePerson(); std::cout &lt;&lt; name;} How to Deal with OPTIONAL Data in C++ Multiple TYPES of Data in a SINGLE VARIABLE in C++? How to store ANY data in C++ How to make C++ run FASTER (with std::async) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;future&gt;std::vector&lt;std::std::future&lt;void&gt;&gt; m_Futures // void is the return type of the function LoadMesh()static std::mutex s_MeshesMutex;// Here we use pointer parameter because reference parameter doesn't work(Cherno not entirely sure why)static void LoadMesh(const std::vector&lt;Ref&lt;Mesh&gt;&gt;* meshes, std::string filepath){ auto mesh = Mesh::Load(filepath); // We need to lock this meshes vector while it been modify // lock the push_back() function std::lock_guard&lt;std::mutex&gt; lock(s_MeshesMutex); meshes-&gt;push_back(mesh);}void EditorLayer::LoadMeshes(){ // Get file context use c++ file stream std::ifstream stream(&quot;src/Models.txt&quot;); std::string line; std::vector&lt;std::string&gt; meshFilepaths; while (std::getLine(stream, line)) meshFilepaths.push_back(line); // m_Meshes is a vector in this class#define ASYNC 1#if ASYNC // Asynchronous for (const auto&amp; file : meshFilepaths) { // std::async() will return std::future and its really important to handle that std::future or its will be destoryed and peform the destructor to make sure the async is actually finished // that basically means it won't be parallel at all m_Futures.push_back(std::async(std::launch::async, LoadMesh, &amp;m_Meshes, file)); }#else // Sequence for (const auto&amp; file : meshFilepaths) { m_Meshes.push_back(Mesh::Load(file)); }#endif} In VS, you can use DEBUG-&gt;Windows-&gt;Parrllel Stacks (Ctrl+Shift+D) to do window parallel debugs How to make your STRINGS FASTER in C++! 1234567```## VISUAL BENCHMARKING in C++ (how to measure performance visually)## SINGLETONS in C++```C++ Small String Optimization in C++ Track MEMORY ALLOCATIONS the Easy Way in C++ 12345678910111213```## lvalues and rvalues in C++In my opinion, any data that is not being attached by a symbol(not being explicitly assigned an address) is an R-value, otherwise it's an L-value.1. L-value reference and R-value reference ```C++ int i = 10; // L-value reference can accept L-value and R-value int&amp; = i; // R-value reference can only accept R-value int&amp;&amp; = 10; const type&amp; is a special rule, realistically what happens is the compiler will probably create like a temporary variable. there are not to kind of avoid creating an L-value but rather to just kind of support both support both L-value and R-values123const int&amp; a = 10;// int temp = 10;// const int&amp; a = temp; Continuous Integration in C++ Static Analysis in C++ Static Analysis is a very important thing that even for an experienced programmer there is still going to be stuff what you miss. It can find logic errors in your code and gives you some tips to fix it clang-tidy is a free tool to do static analysis Argument Evaluation Order in C++ Move Semantics in C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class String{public: String() = default; // equals with String(){} String(const char* string) { printf(&quot;Created!\\n&quot;); m_Size = strlen(string); m_Data = new char[m_Size]; memcpy(m_Data, string, m_Size); } String(const String&amp; other) { printf(&quot;Copied!\\n&quot;); m_Size = other.m_Size; m_Data = new char[m_Size]; memcpy(m_Data, other.m_Data, m_Size); } String(String&amp;&amp; older) noexcept // use noexcept to get rid of compiler warning { printf(&quot;Moved!\\n&quot;); m_Size = older.m_Size; // This immediately presents a problem // because when the old one gets deleted // it's going to delete the m_Data with us m_Data = older.m_Data; // so this is the major thing that we need to do older.m_Size = 0; older.m_Data = nullptr; } ~String() { printf(&quot;Destroyed!\\n&quot;); delete m_Data; } void Print() { for (uint32_t i = 0; i &lt; m_Size; i++) printf(&quot;%c&quot;, m_Data[i]); printf(&quot;\\n&quot;); }private: char* m_Data; uint32_t m_Size;};class Entity{public: Entity(const String&amp; name) : m_Name(name) { } Entity(String&amp;&amp; name) : m_Name(std::move(name)) // equals to m_Name((String&amp;&amp;) name) { } void PrintName() { m_Name.Print(); }private: String m_Name;};int main(){ Entity entity(&quot;Cherno&quot;); entity.PrintName();} std::move and the Move Assignment Operator in C++ std::move actually do force casting but can make your program more search friendly Move Assignment will allow us do move operation on existing objects 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class String{public: String() = default; String(const char* string) { printf(&quot;Created!\\n&quot;); m_Size = strlen(string); m_Data = new char[m_Size]; memcpy(m_Data, string, m_Size); } String(String&amp;&amp; older) noexcept { printf(&quot;Moved!\\n&quot;); m_Size = older.m_Size; m_Data = older.m_Data; older.m_Size = 0; older.m_Data = nullptr; } // define move assignment String&amp; operator=(String&amp;&amp; older) noexcept { if (this != &amp;older) { // Because use move assignment meaning assure there already existing data in currently class // So clean the current class delete[] m_Data; printf(&quot;Moved!\\n&quot;); m_Size = older.m_Size; m_Data = older.m_Data; older.m_Size = 0; older.m_Data = nullptr; } return *this; } ~String() { printf(&quot;Destroyed!\\n&quot;); delete m_Data; } void Print() { for (uint32_t i = 0; i &lt; m_Size; i++) printf(&quot;%c&quot;, m_Data[i]); printf(&quot;\\n&quot;); }private: char* m_Data; uint32_t m_Size;};int main(){ String apple = &quot;Apple&quot;; String dest; std::cout&lt;&lt; &quot;Apple: &quot;; apple.Print(); std::cout&lt;&lt; &quot;Dest: &quot;; dest.Print(); dest = std::move(apple); std::cout&lt;&lt; &quot;Apple: &quot;; apple.Print(); std::cout&lt;&lt; &quot;Dest: &quot;; dest.Print();} ARRAY - Making DATA STRUCTURES in C++","link":"/zh-cn/learn/2020/cpp/"},{"title":"discrete-mathematics","text":"离散数学笔记 非常重要的结论叫定理 普通的结论叫性质 名词解释用需要定义来回答 命题逻辑 中文转折只能用合取来近似地表示 命题: 能判断真假的陈述句(陈述句是命题的必要但不充分条件, 比如&quot;我正在说谎&quot;) 分类: 原子命题和复合命题 原子命题: 不能再分解为更简单的陈述句 复合命题: 由原子命题、联结词和标点符号构成的命题 真值: 命题的判断结果, 真(True, T 或 1), 假(False, F, 或 0) 真值表: 列出命题所有结果的表 联结词: 否定 ┐P &quot;非&quot;运算 P ┐P T F F T 合取 P∧Q &quot;与&quot;运算 P Q P∧Q T T T T F F F T F F F F 析取 P∨Q &quot;或&quot;运算 P Q P∨Q T T T T F T F T T F F F 条件 P→Q (如果前提P为真但此时Q为假说明此条件命题无效, 值为假) P Q P→Q T T T T F F F T T F F T 双条件 P↔Q “当且仅当” 符号iff 可理解为P↔Q=(P→Q)∧(Q→P) P Q P↔Q T T T T F F F T F F F T 联结词的运算优先级: ┐, ∧, ∨, →, ↔ 命题公式(也叫合成公式) 单个命题变元是命题公式 如果 A 是命题公式, 则 ┐A 也是 如果 A, B 是命题公式, 则 A∧B, A∨B, A→B, A↔B 也是 有限次使用上面 1~3 得到的符号串都是命题公式 翻译: 汉语陈述 \\(\\rightleftharpoons\\) 命题公式 方法1: 直接根据逻辑含义 方法2: 真值表法 永真式(重言式): 给定一个命题, 无论对变元做怎样的指派, 其真值总为真 永假式(矛盾式): 给定一个命题, 无论对变元做怎样的指派, 其真值总为假 可满足: 给定一个命题, 其真值有为真的情况 等价: \\(A\\iff B\\) , 当且仅当 \\(A\\harr B\\) 是重言式(其中 A 和 B 可以是多个命题的结合) A, B 给变元任意一组真值指派, A 和 B 真值都相同 十一大等价式: 对合律 \\(\\neg\\neg P\\iff P\\) 幂等律 \\(P\\lor P\\iff P\\) , \\(P\\land P\\iff P\\) 分配律 \\((P\\lor Q)\\land R\\iff (P\\land R)\\lor(Q\\land R)\\) \\(\\mskip{2.5em} (P\\land Q)\\lor R\\iff(P\\lor R)\\land(Q\\lor R)\\) 结合律 \\((P\\lor Q)\\lor R\\iff P\\lor(Q\\lor R)\\) \\(\\mskip{2.5em} (P\\land Q)\\land R\\iff P\\land(Q\\land R)\\) 交换律 \\(P\\lor Q\\iff Q\\lor P\\) , \\(P\\land Q\\iff Q\\land P\\) 吸收律 \\(P\\lor(P\\land Q)\\iff P\\) \\(\\mskip{2.5em} P\\land(P\\lor Q)\\iff P\\) 德摩根律 \\(\\neg(P\\lor Q)\\iff \\neg P\\land\\neg Q\\) \\(\\mskip{3em} \\neg(P\\land Q)\\iff \\neg P \\lor \\neg Q\\) 同一律 \\(P\\lor \\text{F}\\iff P\\) , \\(P\\land \\text{T}\\iff P\\) 零律 \\(P\\lor \\text{T}\\iff \\text{T}\\) , \\(P\\land \\text{F}\\iff \\text{F}\\) 否定律 \\(P\\lor\\neg P\\iff \\text{T}\\) , \\(P\\land\\neg P\\iff \\text{F}\\) 条件命题等价式 \\(A\\to B \\iff \\neg A\\lor B\\) \\(\\mskip{6em} A\\harr B \\iff (A\\to B)\\land(B\\to A)\\) 置换: \\(x\\) 是 \\(A\\) 的子公式, 存在 \\(x\\iff Y\\) , 将 \\(A\\) 中所有的 \\(x\\) 置换为 \\(Y\\) 得到公式 \\(B\\) , 则 \\(B\\iff A\\) 蕴含 当且仅当 \\(P\\to Q\\) 是重言式, 称 \\(P\\) 蕴含 \\(Q\\), 符号 \\(P\\implies Q\\) 蕴含其实就是充分关系, 即左边成立则右边一定成立 反映在真值表就是 \\(P\\) 的真值表中为真的结果 \\(Q\\) 都为真, 但 \\(Q\\) 的真值表中为真的结果 \\(P\\) 不一定都为真 十四大蕴含式 化简律: \\(P\\land Q\\implies P\\) \\(\\mskip{3em}P\\land Q\\implies Q\\) 附加律: \\(P\\implies P\\lor Q\\) 变形附加律: \\(\\neg P\\implies P\\to Q\\) \\(\\mskip{5em}Q\\implies P\\to Q\\) 变形简化律: \\(\\neg(P\\to Q)\\implies P\\) \\(\\mskip{5em}\\neg(P\\to Q)\\implies\\neg Q\\) 假言推理: \\(P\\land(P\\to Q)\\implies Q\\) 拒取式: \\(\\neg Q\\land(P\\to Q)\\implies\\neg P\\) 析取三段论: \\(\\neg P\\land(P\\lor Q)\\implies Q\\) 条件三段论: \\((P\\to Q)\\land(Q\\to R)\\implies P\\to R\\) 等价三段论: \\((P\\harr Q)\\land(Q\\harr R)\\implies P\\harr R\\) 合取构造二难: \\((P\\land R)\\land(P\\to Q)\\land(R\\to S)\\implies Q\\land S\\) 析取构造二难: \\((P\\lor Q)\\land(P\\to R)\\land(Q\\to R)\\implies R\\) 其他联结词 不可兼析取(逻辑异或) \\(P\\triangledown Q\\iff \\neg(P\\harr Q)\\) 条件否定 \\(P\\underrightarrow{c} Q\\iff\\neg(P\\to Q)\\) 与非 \\(P\\uarr Q\\iff\\neg(P\\land Q)\\) 或非 \\(P\\darr Q\\iff\\neg(P\\lor Q)\\) 最小联结词化 结合德摩根律和条件命题等价式, 可以将任何公式化成只含有最小联接词组的形式 最小联接词组 \\(\\{\\neg, \\land\\}\\) , \\(\\{\\neg, \\lor\\}\\) , \\(\\{\\darr\\}\\) , \\(\\{\\uarr\\}\\) 对偶式: 一个命题公式 \\(A\\), 将 \\(\\lor\\) 换成 \\(\\land\\) , \\(\\land\\) 换成 \\(\\lor\\), 若 \\(A\\) 有 F 和 T, 将 F 换成 T, T 换成 F, 得到的 \\(A*\\) 称为 \\(A\\) 的对偶式 例: \\((P\\lor Q)\\land R\\) 的对偶式为 \\((P\\land Q)\\lor R\\) 性质: \\(A\\iff B\\) , \\(A^* \\iff B^*\\) 范式 合取范式 形式为 \\(A_1\\land A_2\\land\\dots A_n\\) , 其中 \\(A_1\\dots A_n\\) 都是由变元及其否定组成的析取式 析取范式 形式为 \\(A_1\\lor A_2\\lor\\dots A_n\\) , 其中 \\(A_1\\dots A_n\\) 都是由变元及其否定组成的合取式 主合/析取范式: 前面的合取范式和析取范式有个缺点, 他是不唯一的 小项(布尔合取): n 个变元的各种合取变换式, 其中每个变元及其否定仅出现一次. (n 个变元的小项有 \\(2^n\\) 个) 小项的编码: 设命题公式有两个变元 P 和 Q, 他有四个小项 P Q P∧Q P∧┐Q ┐P∧Q ┐P∧┐Q T T T F F F T F F T F F F T F F T F F F F F F T 将以上各个小项为真时 P 和 Q 的指派状态用二进制表示可得 11, 10, 01, 00 从而可用 \\(m_{11} , m_{10} , m_{01} , m_{00}\\) 表示以上各个小项 主析取范式 主析取范式由若干小项的析取组成, 见下面定理 定理: 任何一个命题公式, 其真值表中真值为真的指派所对应的小项们的析取就是该公式的主析取范式 大项(布尔析取): n 个变元的各种析取变换式, 其中每个变元及其否定仅出现一次. (n 个变元的小项有 \\(2^n\\) 个) 大项的编码: 设命题公式有两个变元 P 和 Q, 他有四个大项 P Q P∨Q P∨┐Q ┐P∨Q ┐P∨┐Q T T T T T F T F T T F T F T T F T T F F F T T T 将以上各个大项为假时 P 和 Q 的指派状态用二进制表示可得 00, 01, 10, 11 从而可用 \\(M_{00} , M_{01} , M_{10} , M_{11}\\) 表示以上各个大项 主合取范式 主合取范式由若干大项的合取组成, 见下面定理 定理: 任何一个命题公式, 其真值表中真值为假的指派所对应的大项们的合取就是该公式的主合取范式 有效结论: 当且仅当 \\(A\\to C\\) 为重言式, 即 \\(A\\implies C\\) , 就说 \\(C\\) 是 \\(A\\) 的有效结论 推理(也称论证): 若 \\(H_1, H_2,\\dots, H_n\\) 为真, 利用一些公认的规则, 得到一个有效结论的过程. 三种推理方法: 真值表法(万能, 但也是最笨的) 直接证法(重点) P 规则: 引入前提 T 规则: 使用等价式 E, 蕴含式 I 例: 证明 \\((P\\lor Q)\\land(P\\to R)\\land(Q\\to S)\\implies S\\lor R\\)123456789证明: 结论 理由(1) P∨Q P(2) ┐P→Q T(1), E (E代表等价式)(3) Q→S P(4) ┐P→S T(2)(3), I (I代表蕴含式) (使用了条件三段论)(5) ┐S→P T(4), E(6) P→R P(7) ┐S→R T(5)(6), I(8) S∨R T(7), E 间接证明(不要求) 反证法 \\(H_1\\land H_2\\dots H_n\\land\\neg C \\implies \\dots \\implies \\text{F}\\) CP 规则: \\(H_1\\land H_2\\dots H_n\\implies(R\\to C) \\iff H_1\\land H_2\\dots H_n\\land R\\implies C\\) 习题 指出下列语句中哪个不是命题 (C) A. 3+2=5 B. 北京是中国的首都 C. 请勿吸烟 D. 李白是唐朝的诗人 指出下列语句哪个是命题 (D) A. 这本书真好看啊! B. 上课不要迟到! C. 你吃午饭了吗? D. 李白是唐朝诗人 以下语句不是命题的是 (B) A. 明天我要上门去谢你 B. 谢谢你给了我的机会 C. 如果不说我就不谢你 D. 除非你做了我才谢你 下列句子哪些是命题? 她能歌善舞 如果我有时间, 我就来看你 你喜欢看电影吗? 小王今年20岁或21岁 别讲话了! 小王和小李是同学 (解: 1,2,4,6 是命题) 复合命题 由原子命题、联结词和标点符号构成的命题 P、Q 为两个命题, 当且仅当 P和Q都为真时 P∧Q 为真. 命题&quot;如果 1+1=0, 那么太阳从东边落下&quot;的真值为真 设 P、Q 的真值为 0, R、S 的真值为 1, 则下列命题中真值为 1 的是. (D) A. R→P B. Q∧S C. P↔S D. Q∨R 设 P: 天下雨, q: 我去新华书店, 命题&quot;除非天不下雨, 我去新华书店&quot;符号化形式为 (D) A. P→q B. q→P C. ┐q→P D. ┐P→q 若 P: 今天下雪了, Q: 路滑, 则&quot;虽然今天下雪了, 但是路不滑&quot;, 则符号化为 (D) A. (P∧Q) B. P∨┐Q C. (P→┐Q) D. P∧┐Q (中文里转折的意思只能用合取+否定的形式来表示) 设 P, Q, R 的意义如下: P: 李华坐火车, Q: 李华在看书, R: 李华在思考问题 试用日常语言复述下列命题公式. (P∧Q)∧┐R ┐(PVQ)∧R 答: 李华在坐火车和看书, 但是没有思考问题 李华没有做火车也不在看书, 但是在思考问题 (不能写成: 李华没有做火车或看书, 要把 ┐(PVQ) 化为 ┐P∧┐Q) 命题公式 A 与 B 等价是指 (D) A. A 与 B 有相同的原子变元 B. A 与 B 是可满足的 C. 当 A 的真值为真时, B 也为真 D. A 与 B 有相同的真值 \\((P\\to\\neg P)\\to\\neg P\\) 是 永真 式 (填永真, 永假, 可满足) \\((P\\land \\neg P)\\to((Q\\land \\neg Q)\\land\\neg R)\\) 是 永真 式 (填永真, 永假, 可满足) 一个命题公式如果 变元各种指派下, 其真值总为假 , 则称矛盾式 \\((P\\lor\\neg P)\\land\\neg Q\\) 是 可满足 式 (填永真, 永假, 可满足) 重言式: 给定一个命题公式, 它的变元在各种指派下, 其真值总为真 下列集合哪个是最小联结词集? (D) A. \\(\\{\\neg, \\to\\}\\) B. \\(\\{\\neg, \\harr\\}\\) C. \\(\\{\\neg, \\implies\\}\\) D. \\(\\{\\neg, \\land\\}\\) 证明 \\((P\\to R)\\lor(Q\\to R)\\iff(P\\land Q)\\to R\\) (证明思路是将左右两边最终化为由相同的最小联接词组组成的命题) 证明: \\(P\\to R\\lor(Q\\to R)\\) \\(\\iff (\\neg P\\lor R)\\lor(\\neg Q\\lor R)\\) \\(\\iff (\\neg P\\lor\\neg Q)\\lor R\\) (使用了幂等律) \\(\\iff \\neg(P\\land Q)\\lor R\\) (使用了德摩根律) \\(\\iff (P\\land Q)\\to R\\) (使用了条件命题等价式) 证毕 求 \\((P\\lor Q)\\to (P\\harr Q)\\) 的主析取范式 解: P Q P∨Q P↔Q 原式 T T T T T T F T F F F T T F F F F F T T 所以主析取范式: \\(m_0\\lor m_3 \\iff \\sum_{0,3}\\) (小项的编码表示) \\(\\iff (P\\land Q)\\lor(\\neg P\\land\\neg Q)\\) 主合取范式: \\(M_2\\lor M_1 \\iff \\pi_{2,1}\\) (大项的编码表示) \\(\\iff (\\neg P\\lor Q)\\land(P\\land\\neg Q)\\) 命题公式的对偶式: 一个命题公式 A, 将 ∨ 换成 ∧ , ∧ 换成 ∨, 若 A 有 F 和 T, 将 F 换成 T, T 换成 F, 得到的 A* 称为 A 的对偶式 任意两个大项的析取是 永真式 全体大项的合取是 永假式 求 \\(((A\\lor B)\\to C)\\to A\\) 的主析取范式和主合取范式 解: 列真值表 A B C A∨B (A∨B)→C 原式 T T T T T T T T F T F T T F T T T T T F F T F T F T T T T F F T F T F T F F T F T F F F F F T F 主析取范式: \\(\\sum_{2,4,5,6,7}\\) 主合取范式: \\(\\pi_{0,1,3}\\) 谓词逻辑 苏格拉底三段论: A. 所有人都是要死的 B. 苏格拉底是人 C. 苏格拉底是要死的 \\(A\\land B\\implies C\\) 以上命题无法用命题逻辑推理, 由此引出了谓词逻辑 谓词: 描述实体的性质或关系 例子: H() : 是人 x : 苏格拉底 H(x) : 苏格拉底是人 5大于3: L(5, 3) L() : 大于 x 称为客体变元 命题函数: 使用谓词和一些客体变元组成的表达式 个体域(论域): 变元的取值范围 全称量词: \\(\\forall\\) “所有的” “每一个” 存在量词: \\(\\exist\\) “存在一些” “至少有一个” 谓词公式: 原子谓词公式是谓词公式 如果 \\(A\\) 是谓词公式, 则 \\(\\neg A\\) 的否定也是谓词公式 \\(A\\land B\\) , \\(A\\lor B\\) , \\(A\\to B\\) , \\(A\\harr B\\) 是谓词公式 \\(\\forall x A\\) 、\\(\\exist x A\\) 是谓词公式 有限次使用以上 1~4 条得到的式子是谓词公式 翻译: 自然语言 \\(\\rightleftharpoons\\) 谓词公式 指导变元(作用变元): 紧跟量词 \\(\\forall\\) 、\\(\\exist\\) 后面的变元 作用域(辖域): 受指导变元作用的区域, 如无括号即为指导变元后至下一个联结词前的区域(如 ∀xP(x,y,z) 中的 P(x,y,z)) 约束变元: 作用域内出现的该变元叫作该指导变元的约束变元 (如 ∀xP(x,y,z) 中的 x 就是约束变元) 自由变元: 除了约束变元以外的其他变元 (如 ∀xP(x,y,z) 中的 y, z 就是自由变元) 约束变元换名: 对谓词公式中某个指导变元及其作用域内的约束变元替换为一个没有出现过的变元字母 (如 ∀xP(x,y,z) ∨ ∃xP(x) 合取前边的 x 可换名为 ∀aP(a,y,z) ∨ ∃xP(x)) 自由变元代入: 同约束变元换名一样 谓词公式的等价: A, B 对任意一组变元赋值时, 所得的命题真值相同(TLDR: 这两个命题真值表一样), 则 \\(A\\iff B\\) 谓词公式的永真式: 真值总为真 谓词公式的永假式: 真值总为假 谓词公式的可满足: 真值可为真或假 常用的谓词公式等价式: 以下内容利用这两条公式可证明 \\(\\forall x F(x)\\iff F(a_1)\\land F(a_2)\\land\\dots\\land F(a_n)\\) \\(\\exist x F(x)\\iff F(a_1)\\lor F(a_2)\\lor\\dots\\lor F(a_n)\\) 从命题公式中推广而来 注意: 仅有部分可以推广 例: \\(P\\to Q\\iff\\neg P\\lor Q\\) 可变为 \\(\\forall x(P(x)\\to Q(x))\\iff\\forall x(\\neg P(x)\\lor Q(x))\\) 例外 \\(\\exist x(A(x)\\land B(x))\\implies\\exist x A(x)\\land\\exist x B(x)\\) 量词与 \\(\\neg\\) (量词的德摩根律) \\(\\neg\\forall x P(x)\\iff\\exist x\\neg P(x)\\) \\(\\neg\\exist x P(x)\\iff\\forall x\\neg P(x)\\) 量词与 \\(\\land\\) , \\(\\lor\\) , \\(\\to\\) , \\(\\harr\\) \\(\\forall x(A(x)\\land B(x))\\iff\\forall x A(x)\\land\\forall x B(x)\\) \\(\\exist x(A(x)\\lor B(x))\\iff\\exist x A(x)\\lor\\exist x B(x)\\) (对于全称量词的析取, 存在量词的合取, 全称量词和存在量词的条件, 双条件不等价, 而是蕴含) \\(\\forall x(A(x)\\lor B(x))\\implies\\forall x A(x)\\lor\\forall x B(x)\\) \\(\\exist x(A(x)\\land B(x))\\implies\\exist x A(x)\\land\\exist x B(x)\\) \\(\\forall x (A(x)\\to B(x))\\implies\\forall x A(x)\\to\\forall x B(x)\\) \\(\\forall x (A(x)\\harr B(x))\\implies\\forall x A(x)\\harr\\forall x B(x)\\) 量词作用域的扩张与收缩 \\(\\forall x(A(x)\\lor B)\\iff\\forall x A(x)\\lor B\\) \\(\\forall x(A(x)\\land B)\\iff\\forall x A(x)\\land B\\) \\(\\exist x(A(x)\\lor B)\\iff\\exist x A(x)\\lor B\\) \\(\\exist x(A(x)\\land B)\\iff\\exist x A(x)\\land B\\) 注意: \\(\\forall x A(x)\\to B\\iff\\exist x(A(x)\\to B)\\) \\(\\exist x A(x)\\to B\\iff\\forall x(A(x)\\to B)\\) \\(B\\to \\forall x A(x)\\iff\\forall x(B\\to A(x))\\) \\(B\\to \\exist x A(x)\\iff\\exist x(B\\to A(x))\\) 量词的嵌套 对于所有x对于存在y, 和存在y对于所有x不同 (最强) \\(\\forall x\\forall y P(x,y)\\iff\\forall y\\forall x P(x,y)\\) (最弱) \\(\\exist x\\exist y P(x,y)\\iff\\exist y\\exist x P(x,y)\\) (弱) \\(\\forall x\\exist y P(x,y)\\) , \\(\\forall y\\exist x P(x,y)\\) (次强) \\(\\exist x\\forall y P(x,y)\\) , \\(\\exist y\\forall x P(x,y)\\) \\(\\forall x\\forall y\\implies\\exist y\\forall x\\) \\(\\exist y\\forall x\\implies\\forall x\\exist y\\) \\(\\forall x\\exist y\\implies\\exist y\\exist x\\) 谓词公式的推理 US 全称指定规则 \\(\\forall-\\) (比如将 \\(\\forall x P(x)\\) 指定为 \\(P(c)\\) , 其中 c 指任意的数) ES 存在指定规则 \\(\\exist-\\) (比如将 \\(\\exist x P(x)\\) 指定为 \\(P(c)\\) , 其中 c 指能使式子成立的那些数) UG 全称推广规则 \\(\\forall+\\) (比如将 \\(P(c)\\) 推广为 \\(\\forall x P(x)\\)) EG 存在推广规则 \\(\\exist+\\) (比如将 \\(P(c)\\) 推广为 \\(\\exist x P(x)\\) 习题 设 P(x) 为 “x 是大学生”, Q(x) 为 “x 不满 30 岁”, 命题&quot;所有大学生都不满 30 岁&quot;写成谓词公式为 (C) A. \\(\\forall x (P(x)\\land Q(x))\\) B. \\(\\exist x (P(x)\\land Q(x))\\) C. \\(\\forall x P(x)\\to Q(x)\\) D. \\(\\exist x P(x)\\to Q(x)\\) 设 L(x): x 是演员, J(x): x 是老师. A(x,y): x 钦佩 y , 命题 &quot;所有演员都钦佩某些老师&quot;符号化为 (B) A. \\(\\forall x(L(x)\\to A(x,y))\\) B. \\(\\forall x(L(x)\\to \\exist y(J(y)\\land A(x,y)))\\) C. \\(\\forall x\\exist y(L(x)\\land(J(y)\\land A(x,y)))\\) D. \\(\\forall x\\exist y(L(x)\\land(J(y)\\to A(x,y)))\\) D 为什么是错的, D 可化为\\(\\forall x(L(x)\\land\\exist y(J(y)\\to A(x,y)))\\) , 若 \\(x\\) 不是演员结果竟然也为假, 显然不符合命题 翻译时全称量词应和条件搭配(反之, 存在量词应和合取搭配) 已知 \\(\\forall y(R(y)\\lor B(y))\\) , 其中 \\(R(3)=B(4)=T\\) , \\(R(4)=B(3)=F\\) , 且论域是 \\(\\{3,4\\}\\) , 求该式的值 思路: \\(\\forall x F(x)\\iff F(a_1)\\land F(a_2)\\land\\dots\\land F(a_n)\\) \\(\\exist x F(x)\\iff F(a_1)\\lor F(a_2)\\lor\\dots\\lor F(a_n)\\) 解: \\(\\mskip{2.7em}\\forall y(R(y)\\lor B(y))\\) \\(\\iff (R(3)\\lor B(3))\\land(R(4)\\lor B(4))\\) \\(\\iff (T\\lor F)\\land (F\\lor T)\\) \\(\\iff T\\land T\\) \\(\\iff T\\) 谓词公式 \\(\\forall x(P(x)\\lor\\exist y R(y))\\to Q(x)\\) 中变元 \\(x\\) 是 (C) A. 自由变元 B. 约束变元 C. 既是自由变元又是约束变元 D. 既不是自由变元也不是约束变元 公式 \\(\\exist x\\forall y(P(x,y)\\land Q(z))\\) 中 \\(\\forall y\\) 的辖域是 (C) A. \\(P(x,y)\\) B. \\(\\exist x(P(x,y)\\land Q(z))\\) C. \\((P(x,y)\\land Q(z))\\) D. \\(Q(z)\\) 公式 \\(\\forall x\\forall y(P(x,y)\\land Q(x,y))\\land\\exist x P(x,y)\\) 中 \\(\\forall x\\) 的辖域是 (B) A. \\(P(x,y)\\) B. \\(P(x,y)\\land Q(x,y)\\) C. \\(Q(x,y)\\) D. \\(P(x,y)\\land Q(x,y))\\land\\exist x P(x,y)\\) 公式 \\(\\forall x F(x)\\land G(x,y)\\) 中变元 \\(y\\) 是 自由 变元. (填自由或约束) 约束变元的换名: 对谓词公式中某个指导变元及其作用域内的约束变元替换为一个没有出现过的变元字母 下列等价式不正确的是 (D) A. \\(\\neg\\forall x A\\iff \\exist x\\neg A\\) B. \\(\\forall x(B\\to A(x))\\iff B\\to\\forall x A(x)\\) C. \\(\\exist x(A(x)\\lor B(x))\\iff \\exist x A(x)\\lor\\exist x B(x)\\) D. \\(\\forall x\\forall y(A(x)\\to B(y))\\iff\\forall x A(x)\\to\\forall y B(y)\\) 与 \\(\\neg\\exist x M(x)\\) 等价的是 (D) A. \\(\\forall x M(x)\\) B. \\(\\exist x\\neg M(x)\\) C. \\(\\forall x M(x)\\) D. \\(\\forall x\\neg M(x)\\) 量词与否定之间有以下关系: \\(\\neg\\forall x Q(x)\\iff\\) ___\\(\\exist x\\neg Q(x)\\)___ 证明题 符号化并证明: 人总是要死的, 苏格拉底是人, 所以苏格拉底要死的. 翻译: H(x): x 是人; D(x): x 是要死的; s: 苏格拉底 \\(\\mskip{2em}\\forall x(H(x)\\to D(x))\\) , \\(H(s)\\implies D(s)\\) 证明: \\(\\mskip{5em}\\) 结论 \\(\\mskip{5em}\\) 理由 (1) \\(\\forall x(H(x)\\to D(x))\\mskip{3.25em}\\) P (2) \\(H(s)\\mskip{9em}\\) P (3) \\(H(s)\\to D(s)\\mskip{5em}\\) T(1), US (4) \\(D(s)\\mskip{8.7em}\\) T(2)(3), I 形式化并证明 每一个自然数是不是奇数就是偶数, 自然数是偶数当且仅当它被 2 整除, 并不是所有自然数都能被 2 整除, 因此, 有的自然数是奇数 翻译: O(x): x 是奇数; E(x): x 是偶数; D(x): x 能被 2 整除 \\(\\forall x(\\neg O(x)\\to E(x))\\) , \\(\\forall x(E(x)\\harr D(x))\\) , \\(\\neg\\forall x D(x)\\harr\\exist x O(x)\\) 证明: \\(\\mskip{5em}\\) 结论 \\(\\mskip{5em}\\) 理由 (1) \\(\\forall x(\\neg O(x)\\to E(x))\\mskip{3em}\\) P (2) \\(\\forall x(E(x)\\harr D(x))\\mskip{3.5em}\\) P (3) \\(\\neg\\forall x D(x)\\mskip{7.3em}\\) P (4) \\(\\exist x\\neg D(x)\\mskip{6.5em}\\) T(3), E (5) \\(\\neg D(a)\\mskip{7.6em}\\) T(4), ES (6) \\(E(a)\\harr D(a)\\mskip{4.6em}\\) T(2), US (7) \\(\\neg E(a)\\mskip{7.2em}\\) T(5)(6), I (8) \\(\\neg O(a)\\to E(a)\\mskip{4em}\\) T(1), US (9) \\(O(a)\\mskip{8.3em}\\) T(7)(8), I (10) \\(\\exist x O(x)\\mskip{6.6em}\\) T(9), EG 注意: 第5步和第6步不能互换, 存在指定和全称指定的变量 a 需要先经存在指定限定范围 集合论 集合: 把一些元素汇集成一个整体 集合 A, B, C. 元素 a, b, c \\(a\\in A\\) , 读作&quot;属于&quot;, \\(b\\notin\\) 读作&quot;不属于&quot; 分类 \\(\\begin{cases} \\text{有限集} \\\\ \\text{无限集} \\end{cases}\\) 表示: 列举法 \\(A=\\{1,2,3,4,5\\}\\) 描述法 \\(A=\\{x|x\\text{是自然数}\\}\\) 文氏图(venn) 相等: 当且仅当它们有相同的元素 比如: \\(\\{1,3,5,7,\\dots\\}=\\{x|x\\text{是正奇数}\\}\\) \\(\\{1,2,4\\}=\\{1,4,2\\}\\) \\(\\{1,2,4\\}=\\{1,2,2,4\\}\\) 包含于: 若 A 的每一个元素都是 B 的成员, 则称 A 是 B 的子集 记为 \\(A\\subseteq B\\) , 读作&quot;包含于&quot;, 等价于 \\(B\\supseteq A\\) (注意朝向) \\(A\\subseteq B\\iff\\forall x(x\\in A\\to x\\in B)\\) 性质: (自反性) \\(A\\subseteq A\\) (传递性) \\((A\\subseteq B)\\land(B\\subseteq C)\\implies A\\subseteq C\\) (但不满足下式对称性) \\(A\\subseteq B\\nRightarrow B\\subseteq A\\) 互为子集定理: \\(A=B\\iff(A\\subseteq B)\\land(B\\subseteq A)\\) 真包含于: A 中每一个元素都是 B 的成员, 但 B 中至少有一个元素不属于 A, 则称 A 是 B 的真子集, 记作 \\(A\\subset B\\) , 读作&quot;真包含于&quot; 空集 \\(\\varnothing\\) \\(\\varnothing\\neq\\{\\varnothing\\}\\) (前者是空集, 但后者不是. 因为它有一个元素-空集本身) \\(\\varnothing\\in\\{\\varnothing\\}\\) (正确) \\(\\varnothing\\subseteq A\\) (正确) \\(\\varnothing\\subset A\\) (不对, 因为有 \\(A=\\{\\varnothing\\}\\) 的情况) 全集: 在一定范围内, 包含所有元素的集合 \\(E=\\{x|P(x)\\lor\\neg P(x)\\}\\) \\(\\varnothing=\\{x|P(x)\\land\\neg P(x)\\}\\) 幂集: 由 A 的所有子集为元素组成的集合叫 A 的幂集, 记作 P(A) \\(P(A)=\\{B|B\\subseteq A\\}\\) (B 代表 A 的所有子集) 如: \\(A=\\{a,b,c\\}\\) , \\(P(A)=\\{\\{a\\},\\{b\\},\\{c\\},\\{a,b\\},\\{a,c\\},\\{b,c\\},\\{a,b,c\\},\\varnothing\\}\\) 若 \\(A\\) 有 \\(n\\) 个元素, \\(P(A)\\) 有 \\(2^n\\) 个元素 (推导思路, 将所有元素想象成拥有取或不取两种状态, 则能有 \\(2^n\\) 种不同的序列) 交: \\(A\\cap B=\\{x|(x\\in A)\\land(x\\in B)\\}\\) \\(A\\cap A=A\\) \\(A\\cap\\varnothing=\\varnothing\\) \\(A\\cap E=A\\) (对称性/交换律) \\(A\\cap B=B\\cap A\\) (结合律) \\((A\\cap B)\\cap C=A\\cap(B\\cap C)\\) 并: \\(A\\cup B=\\{x|(x\\in A)\\lor(x\\in B)\\}\\) \\(A\\cup A=A\\) \\(A\\cup\\varnothing=A\\) \\(A\\cup E=E\\) \\(A\\cup B=B\\cup A\\) \\((A\\cup B)\\cup C=A\\cup(B\\cup C)\\) 分配律 \\(A\\cap(B\\cup C)=(A\\cap B)\\cup(A\\cap C)\\) \\(A\\cup(B\\cap C)=(A\\cup B)\\cap(A\\cup C)\\) 吸收律 \\(A\\cup(A\\cap B)=A\\) \\(A\\cap(A\\cup B)=A\\) 差: \\(A-B=\\{x|(x\\in A)\\land(x\\notin B)\\}\\) \\(A-B=A\\cup\\sim B\\) 补: \\(\\sim A=E-A=\\{x|(x\\in E)\\land(x\\notin A)\\}\\) \\(\\sim(\\sim A)=A\\) \\(\\sim E=\\varnothing\\) \\(\\sim\\varnothing=E\\) \\(A\\cup\\sim A=E\\) \\(A\\cap\\sim A=\\varnothing\\) \\(A\\cap\\sim B=A-B\\) 定理(集合的德摩根律): \\(\\sim(A\\cup B)=\\sim A\\cap\\sim B\\) \\(\\sim(A\\cap B)=\\sim A\\cup\\sim B\\) 对称差 \\(A\\oplus B=(A-B)\\cup(B-A)=\\{x|(x\\in A)\\triangledown(x\\in B)\\}\\) 序偶: 有固定次序的两个元素 \\(&lt;a,b&gt;\\neq&lt;b,a&gt;\\) \\(&lt;a,b&gt;=&lt;u,v&gt;\\iff(a=u)\\land(b=v)\\) 推广: 三元组, 四元组, … 笛卡尔积(直积): 有序列 A、B, 若序偶的第一个成员属于 A, 序偶的第二个属于 B, 由所有这样的序偶组成的集合称为 A 与 B 的笛卡尔积 符号 \\(A\\times B=\\{&lt;x,y&gt;|(x\\in A)\\land(y\\in B)\\}\\) 例: \\(A=\\{\\alpha,\\beta\\}\\) , \\(B=\\{1,2\\}\\) \\(A\\times B=\\{&lt;\\alpha,1&gt;,&lt;\\alpha,2&gt;,&lt;\\beta,1&gt;,&lt;\\beta,2&gt;\\}\\) 性质: (笛卡尔积 对 并或交运算的分配律) \\(A\\times(B\\cup C)=(A\\times B)\\cup(A\\times C)\\) \\(A\\times(B\\cap C)=(A\\times B)\\cap(A\\times C)\\) \\((A\\cup B)\\times C=(A\\times C)\\cup(B\\times C)\\) \\((A\\cap B)\\times C=(A\\times C)\\cap(B\\times C)\\) \\(A\\times A\\times\\dots\\times A=A^n\\) 但注意, 并或交 对 笛卡尔积 不服从分配律 如 \\(A\\cup(B\\times C)\\neq(A\\cup B)\\times(A\\cup C)\\) (显而易见, 因为左边的 \\(A\\) 不是序偶) 关系\\(^1\\): 任意一个关于序偶的集合, 都是一个二元关系 \\(R\\) , 记作 \\(&lt;x,y&gt;\\in R\\) 例: \\(A=\\{1,2,3,5\\}\\) , \\(B=\\{a,b,c\\}\\) \\(R=\\{&lt;1,b&gt;&lt;2,c&gt;&lt;3,c&gt;\\}\\) 域 由 \\(&lt;x,y&gt;\\in R\\) 中所有 x 组成的集合叫作前域, 记作 \\(\\text{dom R}\\) 由 \\(&lt;x,y&gt;\\in R\\) 中所有 y 组成的集合叫作值域, 记作 \\(\\text{ran R}\\) 前域和值域一起称作域 FLD \\(\\text{FLD}R=\\text{dom R}\\cup\\text{ran R}\\) 例: \\(A=\\{1,2,3,5\\}\\) , \\(B=\\{1,2,4\\}\\) , \\(R=\\{&lt;1,2&gt;,&lt;1,4&gt;,&lt;2,4&gt;,&lt;3,4&gt;\\}\\) 求 \\(\\text{dom R}\\), \\(\\text{ran R}\\), \\(\\text{FLD}R\\) \\(\\text{dom R}=\\{1,2,3\\}\\) \\(\\text{ran R}=\\{2,4\\}\\) \\(\\text{FLD}R=\\{1,2,3,4\\}\\) 关系\\(^2\\) : \\(A\\times B\\) 的子集称作 \\(A\\) 到 \\(B\\) 的关系 恒等关系: \\(I_A=\\{&lt;a,a&gt;|a\\in A\\}\\) 全域关系: \\(A\\times B\\) 空关系: \\(\\varnothing\\) 关系的表示 列举序偶 关系矩阵 \\(R\\) 对应 \\(M_R=[r_{ij}]_{n\\times n}\\) 其中, \\(r_{ij}=\\begin{cases} 1 &amp;\\text{当}&lt;x_i,y_j&gt;\\in R \\\\ 0 &amp;\\text{当}&lt;x_i,y_j&gt;\\notin R \\end{cases}\\) 例: \\(X=\\{x_1,x_2,x_3,x_4\\}\\) , \\(Y=\\{y_1,y_2,y_3\\}\\) , \\(R=\\{&lt;x_1,y_1&gt;,&lt;x_2,y_3&gt;,&lt;x_3,y_2&gt;,&lt;x_2,y_1&gt;\\}\\) \\(M_R=\\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 \\end{bmatrix}_{4\\times 3}\\) 关系图 自反性: 设关于集合 \\(X\\) 的关系 \\(R:X\\) , 如果对于每一个 \\(x\\in X\\) , 都有 \\(xRx\\) (即 \\(&lt;x,x&gt;\\in R\\)) , 则称关系 \\(R\\) 是自反的 例: \\(A=\\{1,2,3\\}\\) , 关系 \\(R=\\{&lt;1,1&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;1,2&gt;\\}\\) 是自反的 关系矩阵主对角线上元素均为 1， 则关系 \\(R\\) 是自反的; 关系图中每个结点都有环, 则关系 \\(R\\) 是自反的. 反自反性: 设关于集合 \\(X\\) 的关系 \\(R:X\\) , 如果对于每一个 \\(x\\in X\\) , 都有 \\(x\\not Rx\\) (即 \\(&lt;x,x&gt;\\notin R\\)), 则称关系 \\(R\\) 是反自反的 例: \\(A=\\{1,2,3\\}\\) , 关系 \\(R=\\{&lt;1,2&gt;,&lt;2,1&gt;,&lt;,3,2&gt;\\}\\) 是反自反的 关系矩阵主对角线上元素均为 0， 则关系 \\(R\\) 是反自反的; 关系图中每个结点都没有环, 则关系 \\(R\\) 是反自反的. 对称性: 设关于集合 \\(X\\) 的关系 \\(R:X\\) , \\(x,y\\in X\\) , 对于每一个 \\(xRy\\) , 都有 \\(yRx\\) , 则称关系 \\(R\\) 是对称的 例: \\(A=\\{1,2,3\\}\\) , 关系 \\(R=\\{&lt;1,2&gt;,&lt;2,1&gt;,&lt;3,3&gt;\\}\\) 是对称的 关系矩阵沿主对角线对称, 则关系 \\(R\\) 是对称的 关系图中若弧是成对出现的, 则关系 \\(R\\) 是对称的 反对称性: 设关于集合 \\(X\\) 的关系 \\(R:X\\) , \\(x,y\\in X\\) , 对于每一个 \\(xRy\\) , 都有 \\(y\\not Rx\\) , 称关系 \\(R\\) 是反对称的 另一个条件: 每当 \\(xRy\\land yRx\\) , 都有 \\(x=y\\) , 也认为是反对称的 例: \\(A=\\{1,2,3\\}\\) , 关系 \\(R=\\{&lt;1,2&gt;,&lt;1,3&gt;,&lt;2,3&gt;\\}\\) 是反对称的 关系矩阵沿主对角线不对称, 则关系 \\(R\\) 是反对称的 关系图中若弧不成对出现, 则关系 \\(R\\) 是反对称的 \\(I_A\\) 是对称的, 又是反对称的 空关系 \\(\\varnothing\\) 是对称的, 又是反对称的 传递性: 设关于集合 \\(X\\) 的关系 \\(R:X\\) , \\(x,y\\in X\\) , 每当 \\(xRy\\) , \\(yRx\\) , 都有 \\(xRz\\) , 则称关系 \\(R\\) 是传递的 例: \\(X=\\{1,2,3\\}\\) , 关系 \\(R=\\{&lt;1,2&gt;,&lt;2,3&gt;,&lt;1,3&gt;,&lt;2,1&gt;\\}\\) 不是传递的 (少了\\(&lt;2,2&gt;\\) 和 \\(&lt;1,1&gt;\\)) 关系图中, 若从 a 到 b 的有向路径(路径是间接的), 存在 a 到 b 的弧(弧是直接的). 则 R 是传递的 关系的运算: 交, 并, 差, 对称差, 补(用 \\(\\tilde{R}\\) , 即 \\(\\text{全域关系}-R\\) 中的序偶) 关系的复合: 设 \\(R: X\\to Y\\) , \\(S: Y\\to Z\\) , 则复合 \\(R\\circ S=\\{&lt;x,z&gt;|x\\in X\\land z\\in Z\\land\\exist y(y\\in Y\\land&lt;x,y&gt;\\in R\\land&lt;y,z&gt;\\in S)\\}\\) 例: \\(R=\\{&lt;1,2&gt;,&lt;3,4&gt;,&lt;2,2&gt;\\}\\) \\(S=\\{&lt;4,2&gt;,&lt;2,5&gt;,&lt;3,1&gt;,&lt;1,3&gt;\\}\\) 实际计算方法就是将 \\(R\\) 中每个序偶的终端 \\(y\\) 去找 \\(S\\) 的序偶中相同的始端 \\(y\\) , 然后跟这个相同始端的序偶结合成 \\(&lt;x,z&gt;\\) \\(R\\circ S=&lt;1,5&gt;,&lt;3,2&gt;,&lt;2,5&gt;\\) \\(S\\circ R=&lt;4,2&gt;,&lt;3,2&gt;,&lt;1,4&gt;\\) 注意: 由上面例子可知复合不满足交换律. 但是复合满足: 结合律 \\(R\\circ(S\\circ P)=(R\\circ S)\\circ P\\) \\(R\\circ I=R\\) \\(R\\circ\\varnothing=\\varnothing\\) \\(R\\circ R=R^{(2)}\\) \\(R\\circ R\\circ R\\circ\\dots\\circ R=R^{(n)}\\) (关系的幂运算) 关系的逆运算: 设 \\(R:X\\to Y\\) , 则 \\(R^c (\\text{或记}R^{-1})=\\{&lt;y,x&gt;|&lt;x,y&gt;\\in R\\}\\) (即把 R 的每一个序偶中元素顺序换一下) \\((R^{-1})^{-1}=R\\) 闭包: 设 \\(R:X\\) , 如果另一个关系 \\(R’\\) 满足: \\(R’\\) 是自反的(对称的, 传递的) \\(R’\\supseteq R\\) 对于任何自反的(对称的, 传递的)关系 \\(R’‘\\) , 如果 \\(R’‘\\supseteq R\\) , 就有 \\(R’‘\\supseteq R’\\) (即 \\(R’\\) 是最小的、包含 \\(R\\) 的自反关系) 则称 \\(R’\\) 为 \\(R\\) 的自反(对称, 传递)闭包 自反闭包表示为 \\(r(R)=R\\cup I_A\\) 对称闭包表示为 \\(s(R)=R\\cup R^{-1}\\) 传递闭包表示为 \\(t(R)=\\underset{i=1}{\\overset{\\infty}{\\cup}}R^{(i)}=\\underset{i=1}{\\overset{|A|}{\\cup}}R^{(i)}\\) (\\(|A|\\) 表示集合 \\(A\\) 的基数) 覆盖: 设 \\(A\\) , \\(S=\\{S_1,S_2,\\dots,S_n\\}\\) , 若 \\(S_i\\subseteq A\\) , \\(S_i\\neq\\varnothing\\) , 且 \\(\\underset{i=1}{\\overset{n}{\\cup}}S_i=A\\) . 则称 \\(S\\) 是 \\(A\\) 的覆盖 划分: 在满足覆盖条件的基础上, 另有 \\(\\forall i\\forall j(S_i\\cap S_j)=\\varnothing\\quad(i\\neq j)\\) , 则称 \\(S\\) 是 \\(A\\) 的划分. 例: \\(A=\\{1,2,3,4,5\\}\\) \\(X=\\{\\{1,2,3\\},\\{3,4,5\\}\\}\\) 是覆盖 \\(Y=\\{\\{1,2,3\\},\\{4\\},\\{5\\}\\}\\) 是划分 \\(Z=\\{\\{1,2,3,4,5\\}\\}\\) 是最小划分(划分数最小) \\(U=\\{\\{1\\},\\{2\\},\\{3\\},\\{4\\},\\{5\\}\\}\\) 是最大划分(划分数最大) 等价关系: 设 \\(R:A\\) , 若 \\(R\\) 是自反的, 对称的, 传递的, 则称 \\(R\\) 是等价关系 等价类: 设 \\(R\\) 是 \\(A\\) 的等价关系, 则对于 \\(\\forall a\\in A\\) , 有元素 \\(a\\) 关于关系 \\(R\\) 的等价类 \\([a]_R=\\{x|xRa,x\\in A\\}\\) (即从等价关系中挑出所有与元素 \\(a\\) 有关系的元素组成的集合就是这个元素 \\(a\\) 的等价类) 例: \\(A=\\{1,2,3,4\\}\\) \\(R=\\{&lt;1,1&gt;,&lt;2,2&gt;,&lt;1,2&gt;,&lt;2,1&gt;,&lt;3,3&gt;,&lt;4,4&gt;,&lt;3,4&gt;,&lt;4,3&gt;\\}\\) 则有 \\([1]_R=\\{1,2\\}=[2]_R\\) \\([3]_R=\\{3,4\\}=[4]_R\\) 定理: 在等价关系中, \\(\\forall a,b\\in A\\) , 有 \\(aRb\\Harr[a]_R=[b]_R\\) 商集: 设 \\(R\\) 是 \\(A\\) 的等价关系, 其等价类的集合 \\(\\{[a]_R|a\\in A\\}\\) 称作 \\(A\\) 关于 R 的商集, 记作 \\(A/R\\) 定理: \\(R\\) 是 \\(A\\) 上的等价关系, 则商集 \\(A/R\\) 是 \\(A\\) 的一种划分(有关系的元素之间等价类完全相同, 所以是划分) 反之, 集合 \\(A\\) 上的任意一种划分 \\(S\\) , 也能确定 \\(A\\) 上的一种等价关系 相容关系: 设 \\(R:A\\) , 若 R 是自反的, 对称的, 则 R 是相容关系 等价关系 \\(\\subset\\) 相容关系 等价类的商集为划分, 相容类的商集为覆盖 偏序关系: \\(R:A\\), 若 R 是自反的, 反对称的, 传递的, 则 R 是偏序关系, 换成用 “\\(\\preccurlyeq\\)” 表示 (或 “\\(\\leqslant\\)” , 因为&quot;小于等于&quot;是一种典型的偏序关系) (\\(a\\preccurlyeq b=\\{&lt;a,a&gt;,&lt;b,b&gt;,&lt;a,b&gt;\\}\\)) 偏序集: 记作 \\(&lt;A,\\preccurlyeq&gt;\\) (用来表示定义在集合 A 上的一种偏序关系) 例: \\(A=\\{2,3,6,8\\}\\) , 设 D 表示整除关系(即每个序偶中后者能整除前者) \\(D=\\{&lt;2,6&gt;,&lt;2,8&gt;,&lt;3,6&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;6,6&gt;,&lt;8,8&gt;\\}\\) D 是偏序关系; 设 M 表示整倍数关系 \\(M=\\{&lt;6,2&gt;,&lt;6,3&gt;,&lt;8,2&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;6,6&gt;,&lt;8,8&gt;\\}\\) M 是偏序关系 盖住: 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\) , 如果 \\(x,y\\in A\\quad(x\\neq y)\\) , 有 \\(x\\preccurlyeq y\\) , 且不存在 \\(z\\in A\\) , 使得 \\(x\\preccurlyeq z\\) 和 \\(z\\preccurlyeq y\\) , 则称 y 盖住 x 盖住关系: \\(\\text{COV}A=\\{&lt;x,y&gt;|\\text{y盖住x}\\}\\) 例: (接着上面的例题) \\(\\text{COV}A=\\{&lt;2,6&gt;,&lt;3,6&gt;,&lt;2,8&gt;\\}\\) 哈斯图(Hasse Diagrams) 作图顺序: 用小圆圈表示元素 若 \\(x\\preccurlyeq y\\) , 将 y 画在 x 上方 若 \\(&lt;x,y&gt;\\in\\text{COV}A\\) , 则 x 和 y 之间用直线连接 例: \\(A=\\{2,3,6,12,24,36\\}\\) , 求 \\(&lt;A,\\text{整除}&gt;\\) 的哈斯图? 解: \\(\\preccurlyeq=\\{&lt;2,2&gt;,&lt;3,3&gt;,&lt;6,6&gt;,&lt;6,2&gt;,&lt;6,3&gt;,&lt;12,12&gt;,&lt;12,6&gt;,&lt;12,3&gt;, \\\\ &lt;12,2&gt;,&lt;24,24&gt;,&lt;24,12&gt;,&lt;24,6&gt;,&lt;24,3&gt;,&lt;24,2&gt;,&lt;36,36&gt;, \\\\ &lt;36,12&gt;,&lt;36,6&gt;,&lt;36,3&gt;,&lt;36,2&gt;\\}\\) \\(\\text{COV}A=\\{&lt;6,2&gt;,&lt;6,3&gt;,&lt;12,6&gt;,&lt;24,12&gt;,&lt;36,12&gt;\\}\\) 哈斯图如下: 链: 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\) , 若集合 \\(A\\) 中任何两个元素都有关系, 称 A 为链, A 的子集也是链 (若任何元素都有关系, 则前者盖住后者, 哈斯图就是链状的) 全序(线序): 设偏序集, \\(&lt;A,\\preccurlyeq&gt;\\) , 如果 \\(A\\) 是链, 则称偏序关系 \\(\\preccurlyeq\\) 为全序 极大元和极小元 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\) , \\(a\\in A\\) 如果 \\(A\\) 中没有元素 \\(x\\) 能够 \\(a\\preccurlyeq x\\) 且 \\(x\\neq a\\) (即没有元素能再盖住 \\(a\\)), 称 \\(a\\) 为 \\(A\\) 的极大元; 如果 \\(A\\) 中没有元素 \\(x\\) 能够 \\(x\\preccurlyeq a\\) 且 \\(x\\neq a\\) (即 \\(a\\) 不能盖住任何元素), 称 \\(a\\) 为 \\(A\\) 的极小元 (极大元/极小元可以有多个) 最大元和最小元 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\) , 如果\\(\\forall a\\in A\\) , 都有 \\(x\\preccurlyeq a\\) , 则称 a 为 \\(&lt;A,\\preccurlyeq&gt;\\) 的最大元; 如果 \\(\\forall a\\in A\\) , 都有 \\(a\\preccurlyeq x\\) , 则称 a 为 \\(&lt;A,\\preccurlyeq&gt;\\) 的最小元. (即最大元只在极大元数量为1的时候存在) (即最小元只在极小元数量为1的时候存在) 上界和下界 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\), 子集 \\(B\\subseteq A\\) , 如果 \\(\\exist a\\in A\\) 且 \\(\\forall x\\in B\\) , 都有 \\(x\\preccurlyeq a\\) , 则 \\(a\\) 为 \\(B\\) 的上界 如果 \\(\\exist a\\in A\\) 且 \\(\\forall x\\in B\\) , 都有 \\(a\\preccurlyeq x\\) , 则 \\(a\\) 为 \\(B\\) 的下界 最小上界(上确界)和最大下界(下确界) 设偏序集 \\(&lt;A, \\preccurlyeq&gt;\\) , \\(B\\subseteq A\\) , 若 \\(a\\) 为 \\(B\\) 的一个上界, 对于 \\(B\\) 的所有上界 \\(x\\), 都有 \\(a\\preccurlyeq x\\) , 称 \\(a\\) 为最小上界(上确界) 若 \\(b\\) 是 \\(B\\) 的一个下界, 对于 \\(B\\) 的所有下界 \\(y\\), 都有 \\(y\\preccurlyeq b\\) , 称 \\(b\\) 为最大下界(下确界) 良序: 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\) , 若对于所有 \\(B\\subseteq A\\) , \\((B\\neq\\varnothing)\\) , \\(B\\) 都存在最小元, 称此偏序为良序 拟序: 反自反且传递的关系是拟序关系 函数: 设集合 X, Y, f 是 X 到 Y 的一个关系, 如果对于 \\(\\forall x\\in X\\) , 都有唯一的 \\(y\\in Y\\) , 使得 \\(&lt;x,y&gt;\\in f\\) , 称关系 \\(f\\) 为函数 记作 \\(f:x\\to y\\) , \\(x\\in X\\) 称作自变元, \\(y\\in Y\\) 称作象 象集 \\(f(x)=\\{f(x)|x\\in X\\}\\subseteq Y\\) 函数=多对一映射 \\(|x|=m\\) , \\(|Y|=n\\) 则从 X 到 Y 的关系有 \\(2^{mn}\\) 种 (可以理解由 \\(nm\\) 个序偶组成的集合, 它的幂集的元素就有 \\(2^{mn}\\) 个) 从 X 到 Y 的函数有 \\(n^m\\) 种 (可以理解为 \\(x\\) 组成的序列, 每个 \\(x\\) 有 \\(n\\) 种可能, 共有 \\(m\\) 个 \\(x\\), 序列就有 \\(n^m\\) 种) 满射(到上映射): 设 \\(f:x\\to y\\) , 如果 \\(Y\\) 中每一个元素都是象, 则称 \\(f\\) 为满射. (即每个 \\(y\\) 都被利用) 入射(单射;一对一映射): 设 \\(f:x\\to y\\) , 如果 \\(X\\) 中没有两个元素有相同的象, 则称 \\(f\\) 为入射. (一个 \\(x\\) 对应一个 \\(y\\)) 双射(对应映射): 既是满射又是入射 逆函数: 设双射函数 \\(f:x\\to y\\) , 则 \\(f\\) 存在逆函数, 记作 \\(f^{-1}\\) 复合函数: 设 \\(f:x\\to y\\) , \\(g:w\\to z\\) , 若 \\(f(x)\\subseteq w\\) , 称 g 在 y 的左边可复合 \\(g\\circ f=g(f(x))=\\{&lt;x,z&gt;|\\exist y, y=f(x)\\land z=g(y)\\}\\) 定理: 设 \\(g\\circ f\\) 是复合函数, 若 \\(g\\) , \\(f\\) 是满射, 则 \\(g\\circ f\\) 是满射 若 \\(g\\) , \\(f\\) 是入射, 则 \\(g\\circ f\\) 是入射 若 \\(g\\) , \\(f\\) 是双射, 则 \\(g\\circ f\\) 是双射 习题 在自然数集上, 下列那种运算是不可交换的? (D) (这里 * 代表任意一种集合的运算) A. \\(a\\text{*}b=\\text{min}(a,b)\\) B. \\(a\\text{*}b=a+b\\) C. \\(a\\text{*}b=\\text{max}(a,b)\\) D. \\(a\\text{*}b=a-b\\) 若集合 A 有 101 个元素, 则 A 的幂集有___ \\(2^{101}\\) ___个元素 下列各项错误的是 (A) A. \\(\\{x\\}\\in\\{x\\}\\) B. \\(\\{x\\}\\subseteq\\{x\\}\\) C. \\(\\{x\\}\\in\\{x,\\{x\\}\\}\\) D. \\(\\{x\\}\\subseteq\\{x,\\{x\\}\\}\\) 设 \\(M=\\{x|(x\\text{是整数})\\land(1\\leqslant x\\leqslant 12)\\land(x\\text{被2整除})\\}\\) \\(N=\\{x|(x\\text{是整数})\\land(1\\leqslant x\\leqslant 12)\\land(x\\text{被3整除})\\}\\) 则 \\(M\\cap N=\\) ___ \\(\\{6,12\\}\\) ___ 证明 \\(A\\cap(B\\oplus C)=(A\\cap B)\\oplus(A\\cap C)\\) 证明: \\(\\begin{aligned} \\text{左边} &amp;=A\\cap((B-C)\\cup(C-B)) \\\\ &amp;=(A\\cap(B-C))\\cup(A\\cap(C-B)) \\end{aligned}\\) \\(\\begin{aligned} \\text{右边} &amp;=((A\\cap B)-(A\\cap C))\\cup((A\\cap C)-(A\\cap B)) \\\\ &amp;=((A\\cap B)\\cap\\sim(A\\cap C))\\cup((A\\cap C)\\cap\\sim(A\\cap B)) \\\\ &amp;=((A\\cap B)\\cap(\\sim A\\cup\\sim C))\\cup((A\\cap C)\\cap(\\sim A\\cup\\sim B)) \\enspace(\\text{分配律拆右边}) \\\\ &amp;=(A\\cap B\\cap\\sim C)\\cup(A\\cap\\sim B\\cap C) \\end{aligned}\\) 所以左边=右边 证毕 下列等式不成立的是 (A) A. \\(A\\cup(B\\times C)=(A\\cup B)\\times(A\\cup C)\\) B. \\(A\\times(B\\cup C)=(A\\times B)\\cup(A\\times C)\\) C. \\((A\\cup B)\\times C=(A\\times C)\\cup(B\\times C)\\) D. \\((A\\cap B)\\times C=(A\\times C)\\cap(B\\times C)\\) 简答: 设 A 和 B 是两个非空集合, \\(A\\times B=B\\times A\\) 吗? 答: 不相等, 除非 A=B, 则成立. 例如 \\(A=\\{1,2\\}\\) , \\(B=\\{3,4\\}\\) \\(A\\times B=\\{&lt;1,3&gt;,&lt;1,4&gt;,&lt;2,3&gt;,&lt;2,4&gt;\\}\\) \\(B\\times A=\\{&lt;3,1&gt;,&lt;3,2&gt;,&lt;4,1&gt;,&lt;4,2&gt;\\}\\) 显然 \\(A\\times B\\neq B\\times A\\) 解释二元关系: 任意集合A、B, A×B 的子集称作 A 到 B 的关系 在一个有 4 个元素的集合上, 可以定义不同的关系个数为 (D) A. \\(2^4\\) B. \\(4^4\\) C. \\(2^{4^4}\\) D. \\(2^{4^2}\\) (序偶有 \\(4^2\\) 种, 把这些序偶视作元素, 能组成 \\(2^{4^2}\\) 种集合) 设 \\(X=\\{0,1,2,3,4,5,6\\}\\) , 其上关系 \\(R=\\{&lt;x,y&gt;|(x&lt;y)\\land (x是质数)\\}\\) , 写出关系 \\(R\\) 中的元素并求出 \\(\\text{dom R}\\) , \\(\\text{ran R}\\) 以及 \\(\\text{FLDR}\\) 解: \\(R=\\{&lt;2,3&gt;,&lt;2,4&gt;,&lt;2,5&gt;,&lt;2,6&gt;,&lt;3,4&gt;,&lt;3,5&gt;,&lt;3,6&gt;,&lt;5,6&gt;\\}\\) \\(\\text{dom R}=\\{2,3,5\\}\\) \\(\\text{ran R}=\\{3,4,5,6\\}\\) \\(\\text{FLDR}=\\{2,3,4,5,6\\}\\) 设 \\(A=\\{1,3,5,7\\}\\) , 定义 A 上的二元关系 \\(R\\) , \\(&lt;a,b&gt;\\in R\\Harr a&lt;b\\) , 称 \\(R\\) 为小于关系, 记为 \\(&lt;\\) , 试求出 \\(R\\) , \\(\\text{dom R}\\) , \\(\\text{ran R}\\) 以及 \\(\\text{FLDR}\\) 解: \\(R=\\{&lt;1,3&gt;&lt;1,5&gt;,&lt;1,7&gt;,&lt;3,5&gt;,&lt;3,7&gt;,&lt;5,7&gt;\\}\\) \\(\\text{dom R}=\\{1,3,5\\}\\) \\(\\text{ran R}=\\{3,5,7\\}\\) \\(\\text{FLDR}=\\{1,3,5,7\\}\\) 设 \\(A=\\{1,2,3\\}\\) , \\(A\\) 的二元关系 \\(R=\\{&lt;2,1&gt;,&lt;2,3&gt;,&lt;1,2&gt;,&lt;3,2&gt;\\}\\) , 则 R 共有的性质是 (B) A. 自反性 B. 对称性 C. 传递性 D. 反对称性 给定 \\(A=\\{1,2,3,4\\}\\) , \\(A\\) 上的二元关系 \\(R=\\{&lt;1,3&gt;,&lt;1,4&gt;,&lt;2,3&gt;,&lt;2,4&gt;,&lt;3,4&gt;\\}\\) , 则 \\(R\\) 满足的性质是 (C) (思路, 一个一个按顺序找, 比如&lt;1,3&gt;, 接下来就找以3开头的序偶看是否满足传递性条件) A. 自反性 B. 对称性 C. 传递性 D. 不可传递性 若关系 \\(R\\) 是反对称的, 当且仅当关系矩阵中主对角线为对称的元素不能同时为1 名词解释: 对称关系 答: 设关于集合 \\(X\\) 的关系 \\(R:X\\) , \\(x,y\\in X\\) , 对于每一个 \\(xRy\\) , 都有 \\(yRx\\) , 则称关系 \\(R\\) 是对称的. 已知集合 \\(A=\\{a,b,c\\}\\) , \\(A\\) 上的二元关系 \\(R_1=\\{&lt;a,b&gt;,&lt;c,b&gt;\\}\\) , \\(R_2=\\{&lt;a,c&gt;,&lt;b,c&gt;\\}\\) , 则 \\(R_1\\circ R_2\\) (A) A. \\(\\{&lt;a,c&gt;,&lt;c,c&gt;\\}\\) B. \\(\\{&lt;a,b&gt;,&lt;b,c&gt;\\}\\) C. \\(\\{&lt;a,c&gt;,&lt;c,a&gt;\\}\\) D. \\(\\{&lt;a,a&gt;,&lt;c,b&gt;\\}\\) 设 \\(A=\\{0,1,2\\}\\) , \\(B=\\{0,2,4\\}\\) , 关系 \\(R=\\{&lt;a,b&gt;|a,b\\in A\\cap B\\}\\) 求 \\(R^{-1}\\) 以及 \\(M_{R^{-1}}\\) 答: (解答题关键步骤要写在答题纸上) \\(A\\cap B=\\{0,2\\}\\) \\(R=\\{&lt;0,0&gt;,&lt;0,2&gt;,&lt;2,0&gt;,&lt;2,2&gt;\\}\\) \\(R^{-1}=\\{&lt;0,0&gt;,&lt;2,0&gt;,&lt;0,2&gt;,&lt;2,2&gt;\\}\\) \\(M_{R^{-1}}=\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\end{bmatrix}\\) 设 \\(A=\\{a,b,c\\}\\) , \\(A\\) 上的二元关系 \\(R=\\{&lt;a,a&gt;&lt;b,b&gt;&lt;a,c&gt;\\}\\) , 则 \\(s(R)\\) 等于 (B) A. \\(R\\cup I_A\\) B. \\(R\\cup\\{&lt;c,a&gt;\\}\\) C. \\(R\\cap I_A\\) D. \\(R\\) 已知集合 \\(A=\\{a,b,c\\}\\) 上关系 \\(R=\\{&lt;a,a&gt;,&lt;a,b&gt;\\}\\) 则 \\(s(R)\\) 等于 (B) A. \\(&lt;a,a&gt;,&lt;b,a&gt;\\) B. \\(&lt;a,a&gt;,&lt;a,b&gt;,&lt;b,a&gt;\\) C. \\(&lt;a,a&gt;,&lt;b,b&gt;,&lt;c,c&gt;\\) D. \\(&lt;a,a&gt;,&lt;a,b&gt;,&lt;b,a&gt;,&lt;b,b&gt;\\) 自反闭包: 设 R:X , 如果另一个关系 R’ 满足: 1. R’ 是自反的; 2. R’⊇R; 3. 对于任何自反的关系 R’‘, 如果 R’‘⊇R , 就有 R’‘⊇R’. 则称 R’ 为 R 的自反闭包. 设 \\(A=\\{1,2,3,4\\}\\) , \\(A\\) 上等价关系 \\(R=\\{&lt;1,2&gt;,&lt;2,1&gt;,&lt;3,4&gt;,&lt;4,3&gt;\\}\\cup I_A\\) 则对应于 \\(R\\) 的 \\(A\\) 的划分是 (D) A. \\(\\{\\{1\\},\\{2,3\\},\\{4\\}\\}\\) B. \\(\\{\\{1,2\\},\\{3\\},\\{4\\}\\}\\) C. \\(\\{\\{1\\},\\{2\\},\\{3\\},\\{4\\}\\}\\) D. \\(\\{\\{1,2\\},\\{3,4\\}\\}\\) 集合 \\(A\\) 上的等价关系 \\(R\\) , 其等价类的集合称为 (C) A. \\(A\\) 与 \\(R\\) 的并集, 记作 \\(A\\cup R\\) B. \\(A\\) 与 \\(R\\) 的交集, 记作 \\(A\\cap R\\) C. \\(A\\) 与 \\(R\\) 的商集, 记作 \\(A/R\\) D. \\(A\\) 与 \\(R\\) 的差集, 记作 \\(A-R\\) 设集合 \\(X=\\{1,2,3,4\\}\\) \\(A_1=\\{\\{1,2,3\\},\\{3,4\\}\\}\\) \\(A_2=\\{\\{1,2\\},\\{3\\}\\}\\) \\(A_3=\\{\\{1\\},\\{2\\},\\{3,4\\}\\}\\) 判断 \\(A_1\\) , \\(A_2\\) , \\(A_3\\) 分别是否是 \\(A\\) 的覆盖? 划分呢? 写出 \\(X\\) 的划分所确立的等价关系 解: \\(A_1\\) , \\(A_3\\) 是覆盖, \\(A_2\\) 既不是覆盖也不是划分, \\(A_3\\) 也是划分 \\(R=\\{&lt;1,1&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;3,4&gt;,&lt;4,3&gt;,&lt;4,4&gt;\\}\\) 给定集合 \\(A\\) 上的关系 \\(R\\) , 若 \\(R\\) 是自反, 对称的, 则称 \\(R\\) 是 \\(A\\) 上的相容关系. 相容关系: 设 R:A , 若 R 是自反的、对称的, 则 R 是相容关系 设 \\(Z\\) 为整数集, 下面哪个序偶不构成偏序集 (A) A. \\(&lt;Z,&lt;&gt;\\) B. \\(&lt;Z,\\leqslant&gt;\\) C. \\(&lt;Z,\\geqslant&gt;\\) D. \\(&lt;Z,/&gt;\\) 已知集合 \\(A=\\{1,2,3,4,5,6\\}\\) , R 是 A 上的整除关系, 则 A 的极小元是 (A) A. 1 B. 2 C. 3 D. 4 设 A 是 18 的 除 1 以外的正因数组成的集合, “/” 为整除关系. 画出 &lt;A, /&gt; (整除), 的哈斯图; 若存在的话, 分别求其最小元, 最大元, 极小元, 极大元, 上界, 下界, 上确界, 下确界 解: \\(A=\\{2,3,6,9,18\\}\\) , \\(\\text{COV}A=\\{&lt;3,2&gt;,&lt;6,3&gt;,&lt;9,6&gt;,&lt;18,9&gt;\\}\\) 哈斯图: 最大元: 18 最小元: 没有 极大元: 18 极小元: 2, 3 上界: 18 下界: 没有 上确界: 18 下确界: 没有 设 \\(X=\\{1,3,4,12,24\\}\\) , R 是 X 的整除关系 求出关系 R 画哈斯图 求子集 \\(\\{3,4,12\\}\\) 的极大元, 最大元, 上界, 上确界 解: \\(R=\\{&lt;1,1&gt;,&lt;1,3&gt;,&lt;1,4&gt;,&lt;1,12&gt;,&lt;1,24&gt;,&lt;3,3&gt;,&lt;3,12&gt;, \\\\ &lt;3,24&gt;,&lt;4,4&gt;,&lt;4,12&gt;,&lt;4,24&gt;,&lt;12,12&gt;,&lt;12,24&gt;,&lt;24,24&gt;\\}\\) 哈斯图: 极大元: 12 最大元: 12 上界: 12, 24 上确界: 12 集合 A 上的拟序关系: 反自反且传递的关系是拟序关系 设 \\(X=\\{1,2,3,4\\}\\) , \\(Y=\\{a,b,c,d\\}\\) (C) (因为 B 中没有 4 的映射) 则下列哪个集合是 \\(X\\to Y\\) 的函数 A. \\(\\{&lt;1,b&gt;,&lt;2,c&gt;,&lt;3,d&gt;,&lt;3,a&gt;\\}\\) B. \\(\\{&lt;1,b&gt;,&lt;2,b&gt;,&lt;3,d&gt;\\}\\) C. \\(\\{&lt;1,b&gt;,&lt;2,d&gt;,&lt;3,a&gt;,&lt;4,d&gt;\\}\\) D. \\(\\{&lt;1,b&gt;,&lt;1,d&gt;,&lt;3,d&gt;,&lt;4,d&gt;,&lt;2,b&gt;\\}\\) 求出从 \\(A=\\{1,2\\}\\) 到 \\(B=\\{x,y\\}\\) 的所有函数, 并列出哪些双射, 哪些满射? 解: \\(f_1=\\{&lt;1,x&gt;,&lt;2,x&gt;\\}\\) \\(f_2=\\{&lt;1,x&gt;,&lt;2,y&gt;\\}\\) \\(f_3=\\{&lt;1,y&gt;,&lt;2,x&gt;\\}\\) \\(f_4=\\{&lt;1,y&gt;,&lt;2,y&gt;\\}\\) 双射: \\(f_2\\) , \\(f_3\\) 满射: \\(f_2\\) , \\(f_3\\) 设 \\(f:\\{1,2\\}\\to\\{1\\}\\) , 则 f 是 (B) A. 入射 B. 满射 C. 双射 D. 非入非满 设 \\(A=\\{0,1\\}\\) , \\(N\\) 是自然数集合, \\(f(x) \\begin{cases} 0 &amp; x\\text{是奇数} \\\\ 1 &amp; x\\text{是偶数} \\end{cases}\\) 若 \\(f:A\\to A\\) . 则 \\(f\\) 是 双射 (填&quot;入&quot;,“满”,“双”) 设 \\(A=\\{1,2,3,4\\}\\) , \\(A\\) 上的关系 \\(R_1=\\{&lt;1,2&gt;,&lt;3,4&gt;,&lt;2,3&gt;,&lt;4,1&gt;\\}\\) , \\(R_2=\\{&lt;1,2&gt;&lt;2,3&gt;,&lt;3,2&gt;\\}\\) 则 \\(R_1\\) , \\(R_2\\) 中是映射的是 (B) A. \\(R_1\\) , \\(R_2\\) B. \\(R_1\\) C. \\(R_2\\) D. 没有 一个映射 \\(f:x\\to y\\) , 如果对于任意 \\(x_i,x_j\\in X\\) . 都有 ___ \\(f(x_i)\\neq f(x_j)\\) ___, 则 \\(f\\) 是入射 设 R 是 A 的等价关系, 在什么条件下, 自然映射 \\(g:A\\to A/R\\) 是双射? 解: 因为 \\(A/R\\) 是等价关系 R 的等价类构成的集合, 即商集 要使映射 \\(g:A\\to A/R\\) 是双射, 则 \\(A/R\\) 与 A 的元素个数必须相等, 因此 R 必须是恒等关系 \\(I_A\\) 若 \\(g\\) , \\(f\\) 是满射, 则 \\(g\\circ f\\) 是满射 代数系统 代数系统: 一个非空集合 A 和定义在该集合上的若干种运算所组成的系统, 记作 \\(&lt;A,f_1,f_2,…,f_k&gt;\\) 例: \\(&lt;N^+,+&gt;\\) 在正整数集合上的加法运算 \\(&lt;P(s),\\cap,\\cup,\\sim&gt;\\) 封闭性: (对于任意的集合中的两个元素, 如果这两元素作某种运算, 运算结果仍在该集合内, 则该运算在这个集合上是封闭的) 设集合 \\(A\\) , 一个从 \\(A^n\\) 到 \\(B\\) 的映射, 称为 \\(A\\) 上的 \\(n\\) 元运算, 如果 \\(B\\subseteq A\\) , 称该 \\(n\\) 元运算是封闭的 另一种定义: 设 * 是集合 A 上的二元运算, 对于 \\(\\forall x,y\\in A\\) , 都有 \\(x*y\\in A\\) , 则称 * 在 A 是封闭的 例: \\(A=\\{2^n|n\\in N\\}\\) \\(2^a\\times2^b\\in A\\) A 是封闭的 \\(2^a+2^b\\notin A\\) A 不是封闭的 交换律: 设 * , \\(\\forall x,y\\in A\\) , 都有 \\(x*y=y*x\\) , 则称 * 是可交换的 结合律: 设 * , \\(\\forall x,y,z\\in A\\) , 都有 \\((x*y)*z=x*(y*z)\\) , 则称 * 是可结合的 分配律: 设 \\(*\\)、\\(\\Delta\\) , \\(\\forall x,y,z\\in A\\) , 都有 \\(x*(y\\Delta z)=(x*y)\\Delta(x*z)\\) , \\((y\\Delta z)*x=(y*x)\\Delta(z*x)\\) 则称 \\(*\\) 对 \\(\\Delta\\) 是可分配的 吸收律: 设 \\(*\\) , \\(\\Delta\\) 是可交换的, 如果 \\(\\forall x,y\\in A\\) , 都有 \\(x*(x\\Delta y)=x\\) \\(x\\Delta(x*y)=x\\) 则称 \\(*\\) , \\(\\Delta\\) 满足吸收律 幺元(单位元): 设 \\(*\\) , \\(\\exist e_l\\) , 对于 \\(\\forall x\\in A\\) , 都有 \\(e_l*x=x\\) , 则称 \\(e_l\\) 为左幺元 都有 \\(x*e_l=x\\) , 则称 \\(e_l\\) 为右幺元 零元: 设 \\(*\\) , 如果他 \\(\\theta_l\\in A\\) , \\(\\forall x\\in A\\) , 都有 \\(\\theta_l*x=\\theta_l\\) 则称 \\(\\theta_l\\) 为左零元 都有 \\(x*\\theta_l=\\theta_l\\) 则称 \\(\\theta_l\\) 为右零元 逆元: 设 \\(*\\) , \\(e\\) 是幺元, 若 \\(b*a=e\\) , 则称 b 是 a 的左逆元, a 是 b 的右逆元 (\\(a\\) 的逆元记作 \\(a^{-1}\\)) 若 b 既是左逆元又是右逆元, 则称 b 是逆元 设 \\(&lt;A,*&gt;\\) , 若 \\(*\\) 是可结合的, 则左逆元等于右逆元且唯一 广群: 设代数系统 \\(&lt;S,*&gt;\\) , 如果 \\(*\\) 是封闭的, 则称 \\(&lt;S,*&gt;\\) 为广群. 半群: 设代数系统 \\(&lt;S,*&gt;\\) , 如果: \\(*\\) 是封闭的 \\(*\\) 是结合的, 即 \\(\\forall a,b,c\\in S\\) , \\((a*b)*c=a*(b*c)\\) 则称 \\(&lt;S,*&gt;\\) 为半群. (半群是一种特殊的广群) 子半群: 设 \\(&lt;S,*&gt;\\) 是半群, \\(B\\subseteq S\\), 若 \\(&lt;B,*&gt;\\) 也是半群, 则 \\(&lt;B,*&gt;\\) 为 \\(&lt;S,*&gt;\\) 的子半群 独异点: 含有幺元的半群 群: 设代数系统 \\(&lt;S,*&gt;\\), 如果: \\(*\\) 是封闭的 \\(*\\) 是结合的 存在幺元 \\(e\\) \\(\\forall x\\in S\\) , 都存在逆元 \\(x^{-1}\\) 则 \\(&lt;S,*&gt;\\) 为群. 群的特性: 设群 \\(&lt;G,*&gt;\\) , 若 \\(G\\) 为有限集, 则有有限解, 若 \\(G\\) 为无限集, 则有无限解. 集合中元素的个数称为基数, 记作 \\(|G|\\) 则 \\(|G|\\) 称为有限群 \\(&lt;G,*&gt;\\) 的阶数 群中不可能有零元. (因为群中每个元素都要有逆元, 但是零元没有逆元) 概念的关系: \\(\\text{广群}\\supset\\text{半群}\\supset\\text{独异点}\\supset\\text{群}\\) 子群: 设群 \\(&lt;G,*&gt;\\) , \\(B\\subseteq G\\) , 如果 \\(&lt;B,*&gt;\\) 也是群, 则 \\(&lt;B,*&gt;\\) 为 \\(&lt;G,*&gt;\\) 的子群 格: 设偏序集 \\(&lt;A,\\preccurlyeq&gt;\\) , 如果 \\(A\\) 中每两个元素组成的子集都有最小上界和最大上界, 则称 \\(&lt;A,\\preccurlyeq&gt;\\) 为格. 例: \\(&lt;I_+,/&gt;\\) 是格, 正整数的整除关系是格 (\\(\\forall a,b\\in I_+\\) , 则 \\(a,b\\) 的最小上界是最小公倍数; 最大下界是最大公约数) \\(&lt;P(S),\\subseteq&gt;\\) (幂集上的包含于关系)也是格 格诱导的代数系统: 例: 设 \\(&lt;A,\\preccurlyeq&gt;\\) 是格, 定义运算 \\(a\\lor b\\) 为 \\(a\\) 与 \\(b\\) 的最小上界, \\(a\\land b\\) 为 \\(a\\) 与 \\(b\\) 的最大下界. 则称 \\(&lt;A,\\land,\\lor&gt;\\) 为格 \\(&lt;A,\\preccurlyeq&gt;\\) 诱导的代数系统. 分配格: 设 \\(&lt;A,\\lor,\\land&gt;\\) 是由 \\(&lt;A,\\preccurlyeq&gt;\\) 格诱导的代数系统. \\(\\forall a,b,c\\in A\\). 若 \\(a\\land(b\\lor c)=(a\\land b)\\lor(a\\land c)\\) \\(a\\lor(b\\land c)=(a\\lor b)\\land(a\\lor c)\\) 则称 \\(&lt;A,\\preccurlyeq&gt;\\) 为分配格 例: \\(A=P(S)\\) , \\(S=\\{a,b,c\\}\\) \\(&lt;A,\\cap,\\cup&gt;\\) 是由格 \\(&lt;A,\\subseteq&gt;\\) 诱导的代数系统, 且 \\(&lt;A,\\subseteq&gt;\\) 是分配的 定理: 小于五个元素的格一定是分配格 定理: 每个链都是分配格 定理: 一个格是分配格当且仅当该格不包含和钻石格或五角格同构的子格 例: 钻石格不是分配格! 图中 \\(a\\land(b\\lor c)\\neq(a\\land b)\\lor(a\\land c)\\) 五角格不是分配格! 习题 在实数域 \\(R\\) 上定义运算 \\(*\\) \\(a*b=a+b+2ab\\) , 则 \\(&lt;R,*&gt;\\) 是代数系统 \\(*\\) 满足结合律? \\(&lt;R,*&gt;\\) 有单位元, 求 \\(e\\) \\(&lt;R,*&gt;\\) 每一个元素都有逆元? 任一个元素 a 的逆元是什么? 解: \\(\\forall a,b,c\\in R\\) , 由于 \\((a*b)*c=(a+b+2ab)+c+2c(a+b+2ab)=a+b+2ab+c+2ac+2bc+4abc\\) \\(a*(b*c)=a+(b+c+2bc)+2a(b+c+2bc)=a+b+c+2bc+2ab+2ac+4abc\\) 上面两式结果相等, 所以 \\(*\\) 满足结合律 设单位元为 \\(e\\) \\(\\forall x\\in R\\) , 都有 \\(x*e=x\\) , 即 \\(x+e+2xe=x\\) , \\(e(1+2x)=0\\) , 则 \\(e=0\\) \\(\\forall a\\in R\\) , 设逆元为 \\(b\\) , 则 \\(a*b=e=0\\) , \\(a+b+2ab=0\\) , \\(b=\\frac{-a}{1+2a}\\) 若 \\(a=-\\frac{1}{2}\\) , 则 a 无逆元, 否则 \\(b=a^{-1}=\\frac{-a}{1+2a}\\) (因为这里涉及到分母为 0 的情况, 所以&quot;若 \\(*\\) 是可结合的, 则左逆元等于右逆元且唯一&quot;不适用) 如果一个独异点 \\(&lt;A,*&gt;\\) 满足 A中每个元素都有逆元. 则 \\(&lt;A,*&gt;\\) 为群. 群 \\(&lt;G,*&gt;\\) , 其中 \\(G\\) 为有限集. 则称 \\(&lt;G,*&gt;\\) 为有限群. \\(G\\) 的阶是 G 中元素的个数 设 \\(&lt;G,*&gt;\\) 是群, \\(H\\) 是 \\(G\\) 的非空子集, \\(H\\) 是 \\(G\\) 的子群当且仅当 ___ \\(&lt;H,*&gt;\\) 也是群 ___ 设 \\(G\\) 为无限群, 则 (C) A. \\(G\\) 是交换群 B. \\(G\\) 是循环群 C. \\(G\\) 中每个元素都有逆元 D. \\(G\\) 中每个元素的阶都是无限的 (交换群: 满足交换律的群; 循环群: 群中任何元素可用某一个元素来表示) 设 \\(&lt;H,*&gt;\\) 是群 \\(&lt;G,*&gt;\\) 的子群, \\(&lt;K,*&gt;\\) 是群 \\(&lt;H,*&gt;\\) 的子群. 求证: \\(&lt;K,*&gt;\\) 是 \\(&lt;G,*&gt;\\) 的子群 证明: \\(\\because &lt;H,*&gt;\\) 是群 \\(&lt;G,*&gt;\\) 的子群 \\(\\therefore H\\subseteq G\\) \\(\\because &lt;K,*&gt;\\) 是群 \\(&lt;H,*&gt;\\) 的子群 \\(\\therefore K\\subseteq H\\) \\(\\therefore K\\subseteq G\\) \\(\\because &lt;K,*&gt;\\) , \\(&lt;G,*&gt;\\) 都是群 \\(\\therefore &lt;K,*&gt;\\) 是 \\(&lt;G,*&gt;\\) 的子群 设 \\(Z_4\\) 为模 4 剩余类的集合 \\(Z_4=\\{[0],[1],[2],[3]\\}\\) \\(+_4\\) 为模 4 加法, 写出 \\(&lt;Z_4,+_4&gt;\\) 的运算表并证明 \\(&lt;Z_4,+_4&gt;\\) 为群 (模 4 剩余类即取模 4 后结果为 0、1、2、3 的那些数) (如结果为 0 的数集用 \\([0]=\\{\\dots, 0,4,8,\\dots\\}\\) 表示) 运算表: \\(+_4\\) \\([0]\\) \\([1]\\) \\([2]\\) \\([3]\\) \\([0]\\) \\([0]\\) \\([1]\\) \\([2]\\) \\([3]\\) \\([1]\\) \\([1]\\) \\([2]\\) \\([3]\\) \\([0]\\) \\([2]\\) \\([2]\\) \\([3]\\) \\([0]\\) \\([1]\\) \\([3]\\) \\([3]\\) \\([0]\\) \\([1]\\) \\([2]\\) 证明: \\(&lt;Z_4,+_4&gt;\\) 是代数系统 \\(+_4\\) 是封闭的 \\(+_4\\) 是可结合的 存在幺元 \\([0]\\) \\([0]^{-1}=[0]\\) \\([1]^{-1}=[3]\\) \\([2]^{-1}=[2]\\) \\([3]^{-1}=[1]\\) \\(\\therefore &lt;Z_4,+_4&gt;\\) 是群 设 \\(&lt;G,*&gt;\\) 为群, 定义关系 \\(R\\) 为 \\(G\\times G\\) 的子集. 其中 \\(R=\\{&lt;a,b&gt;|\\exist c\\in G, \\text{使} b=c*a*c^{-1}\\}\\) 试证 \\(R\\) 是 \\(G\\) 上的等价关系. 证明: 只需证得 \\(R\\) 具有自反性、对称性、传递性即可 \\(\\forall a\\in G\\), 有 \\(a=a*e=a*a*a^{-1}\\) 则有 \\(&lt;a,a&gt;\\in R\\) , \\(R\\) 具有自反性 对于 \\(\\forall &lt;a,b&gt;\\in R\\) , \\(\\exist c\\in G\\) , 使 \\(b=c*a*c^{-1}\\) \\(b*c=c*a*c^{-1}*c=c*a*e=c*a \\Harr c^{-1}*b*c=c^{-1}*c*a=a\\) 即 \\(a=c^{-1}*b*c\\) , 运用换元法设 \\(d=c^{-1}\\) , 则 \\(a=d*b*d^{-1}\\) , 因此 \\(&lt;b,a&gt;\\in R\\) , \\(R\\) 具有对称性 \\(\\forall a,b,c\\in G\\) , \\(&lt;a,b&gt;\\in R\\) , \\(&lt;b,c&gt;\\in R\\) 则 \\(\\exist e,f\\in G\\) , 使得 \\(b=e*a*e^{-1}\\) \\(c=f*b*f^{-1}\\) 则 \\(c=f*e*a*e^{-1}*f^{-1}=(f*e)*a*(f*e)^{-1}\\) 则 \\(&lt;a,c&gt;\\in R\\) \\(R\\) 具有传递性 综上, \\(R\\) 是等价关系. 若 \\(&lt;A,\\preccurlyeq&gt;\\) 是 偏序集, 且 A 中每两个元素都有最小上界和最大下界, 则称 \\(&lt;A,\\preccurlyeq&gt;\\) 为格. 格: 若 &lt;A,≼&gt; 是偏序集, 且 A 中每两个元素都有最小上界和最大下界, 则称 &lt;A,≼&gt; 为格. 以下格是分配格的 (C) A. 钻石格 B. 五角格 C. 少于 5 个元素的格 D. 含有与钻石格同构的格 图论 图: \\(G=(V,E)\\) , 图 \\(G\\) 是由顶点集 \\(V\\) 和边集 \\(E\\) 构成的. 其中 \\(E\\) 的每一条边连接顶点集 \\(V\\) 中的一个或两个顶点. 例如: \\(e_2\\) 与 \\(V_2\\) , \\(V_4\\) 关联的. 环(loop): 关联的边只有一个顶点 度数(deg(V)): 与顶点 V 关联的边数, \\(\\displaystyle\\sum_{v\\in V}deg(v)=2|E|\\) . 用 \\(\\Delta(G)\\) 表示图 \\(G\\) 的最大结点度数 入度(\\(deg_-(V)\\)) 出度(\\(deg_+(V)\\)) 性质 \\(\\displaystyle\\sum_{v\\in V}deg_+(v)=\\displaystyle\\sum_{v\\in V}deg_-(v)=|E|\\) 零图: \\(|E|=0\\) 平凡图: \\(|E|=0\\) , \\(|V|=1\\) 有向图(directed G/digraph): 所有的边有方向 无向图(undirected G): 所有的边没有方向 复杂图: 有的边有方向有的边无方向 简单图(无平行边/无环的图) 多重图(有平行边/有环的图) 完全图(\\(C_n^2=\\frac{n(n-1)}{2}\\) 条边 \\(K_n\\)): 所有顶点两两相连 补图(\\(G=k_n-G\\) 只对边作差): 完全图-原图 同构: 设图 G=(V,E) 和 G’=(V’,E’) 如果存在一一对应的映射 \\(g:v_i\\to v_i’\\) , 而且 \\(e=(v_i,v_j)\\) 是 G 的一条边, 当且仅当 \\(e’=(g(v_i),g(v_j))\\) 也是 \\(G’\\) 的一条边, 则称 \\(G\\) 与 \\(G’\\) 同构, 记 \\(G\\cong G’\\) 子图: 设 \\(G=(V,E)\\) , \\(G’=(V’,E’)\\) , \\(V’\\subseteq V\\) , \\(E’\\subseteq E\\) , 则 \\(G’\\) 为 \\(G\\) 的子图 例: \\(G:k_3\\) , 求子图 需要分类讨论: 1 个顶点: 3 个子图 2 个顶点: 0 条边: 3 个子图 1 条边: 3 给子图 3 个顶点: 0 条边: 1 个子图 1 条边: 3 个子图 2 条边: 3 个子图 3 条边: 1 个子图 共计 17 个子图 路: 设图 \\(G=(V,E)\\), 顶点 \\(v_0,v_1,\\dots,v_n\\in V\\) , 边 \\(e_1,e_2,\\dots,e_n\\in E\\) 从 \\(v_0\\) 出发, 沿着 \\(v_0e_1v_1e_2v_2\\dots e_iv_i\\dots e_nv_n\\) 的交替序列称为路(walk) 若 \\(v_0=v_n\\) 称为回路(closed walk) 若 \\(\\forall i\\forall jE_i\\neq E_j\\) 称为迹(trail) 若 \\(\\forall i\\forall jV_i\\neq V_j\\) 称为通路(path) 既是通路又是回路称为圈(cycle) 顶点连通性: 若顶点 \\(u\\) 和 \\(v\\) 至今存在一条路, 则称 \\(u\\) 和 \\(v\\) 是连通的 图的连通性: 给定图 \\(G=(V,E)\\) , 若 \\(\\forall u,v\\in V\\) , \\(u\\) 和 \\(v\\) 都是连通的, 则称图 \\(G\\) 是连通的 连通分支(connected component): 最大连通子图 顶点之间的距离(distance): 两个顶点之间的最短路的长度 图的直径(diameter): 图中顶点间最大距离 \\(D=\\text{max}d(u,v)\\) , \\(u,v\\in V\\) 有向图中: 可达: 从 \\(u\\) 到 \\(v\\) 存在一条路, 则称 \\(u\\) 可达 \\(v\\) 强连通图: 若简单有向图中, 任何一对顶点之间都是相互可达(能去能回)的, 则称该图为强连通图. 弱连通图: 若简单有向图不是强连通的, 但是省略边的方向得到的无向图是连通的, 称该简单有向图是弱连通的. 图的表示: 列举法 画图 矩阵 邻接矩阵 关联矩阵(不考) 可达性矩阵(不考) 邻接矩阵: 设简单图 \\(G=(V,E)\\) , \\(|V|=n\\) , 则构造 \\(A(G)=(a_{ij})_{n\\times m}\\) 为 \\(G\\) 的邻接矩阵, 其中 \\(\\begin{cases} 1 &amp; \\text{当} v_i \\text{邻接} v_j \\\\ 0 &amp; \\text{当} v_i \\text{不邻接} v_j \\end{cases}\\) 计算 \\(v_i\\) 到 \\(v_j\\) 长度为 2 的路有几条? 路的数目 \\(=a_{i0}\\cdot a_{0j}+a_{i1}\\cdot a_{1j}+\\cdots+a_{in}a_{nj}=\\displaystyle\\sum_{k=0}^{n-1} a_{ik}\\cdot a_{kj}\\) 正好可以利用矩阵乘法来算 (矩阵乘法: \\(a_{ij}=\\displaystyle\\sum_{k=0}^{n-1} a_{ik}\\cdot a_{kj}\\) ， 即矩阵中 \\(a_{ij}\\) 元素的值为前者第 i 行的每项分别乘后者第 j 列的对应项再相加) 则 \\(v_i\\) 到 \\(v_j\\) 长度为 \\(n\\) 条边的路有几条可通过 \\(A^n(G)\\) (矩阵的 n 次幂)得到 欧拉路(欧拉通路): 给定一个无向图, 经过图中每条边一次且仅一次的路称为欧拉路. 欧拉回路: 经过每条边一次且仅一次的回路称为欧拉回路. 欧拉路充要条件: 无向图 \\(G\\) 具有欧拉路当且仅当 \\(G\\) 是连通的且有零个或两个奇数度数的顶点(若存在则必须从奇数度数顶点出发). 欧拉回路充要条件: 无向图 \\(G\\) 具有欧拉回路当且仅当 \\(G\\) 是连通的且所有顶点度数都是偶数. (可从任意顶点出发) 欧拉图: 具有欧拉回路的图 平面图(Plane Graph): 设无向图 \\(G=(V,E)\\) , 如果能够把图中所有边画在一个平面上, 使任意两条边都不相交, 则称 \\(G\\) 为平面图. 例子: \\(k_{3,3}\\) (二分图)和 \\(k_5\\) 都不是平面图 库拉托夫斯基定理: 是平面图当且仅当图不包含 \\(k_{3,3}\\) 和 \\(k_5\\) 面: 设连通平面图 \\(G\\) , 若由边包围的区域不包含任何顶点和边, 则该区域称为面. 注意别忘了最外面的面包围的是外面所有区域(不是向里包围), 称为无限面 面的次数 \\(deg(r)\\) : 组成面的边数 定理: 设连通平面图 \\(G\\) , \\(|E|=e\\) , \\(\\sum deg(r)=2e\\) (所有面的次数之和等于边数的 2 倍) 欧拉定理 设 \\(G\\) 是连通平面图， 有 \\(v\\) 个顶点 , \\(e\\) 条边, \\(r\\) 个面. 则 \\(v-e+r=2\\) 定理: 设 \\(G\\) 是一个连通平面图, 有 \\(v\\) 个顶点, \\(e\\) 条边, 若 \\(v\\geqslant 3\\) , 则 \\(e\\leqslant 3v-6\\) 树: 一个连通且无回路的无向图 树叶: \\(deg(v)=1\\) 的结点 内点: \\(deg(v)&gt;1\\) 的结点 森林: 由多棵树组成的图 树的性质: \\(v=e+1\\) 无回路的树增加一条新边, 则得一个且仅一个回路 连通的树删除一条边则不连通 任何两个结点之间仅有一条路 至少有两片树叶 生成树(spanning tree): 包含图 \\(G\\) 全部结点的子图如果是树, 则称该子图为生成树. 在有权重的图中, 若它在所有的生成树中总权重最小, 则称为最小生成树. 有向树: 给树的每一条边加个方向 根树: 如果一颗有向树只有一个顶点入度为 0 其余结点入度均为 1 根: \\(deg_-(v)=0\\) 的结点 叶子: \\(deg_+(v)=0\\) 的结点 内点: \\(deg_+(v)&gt;0\\) 且 \\(deg_-(v)\\neq 0\\) 的结点 \\(n\\) 叉树(\\(m\\) 叉树): 若根树中每个结点的出度小于等于 \\(n\\), 称这颗树为 \\(n\\) 叉树. 若所有结点出度等于 \\(n\\) 或 0, 则称为完全 \\(n\\) 叉树. 习题 图: 图由顶点集 V 和边集 E 构成, 其中 E 中的边连接 V 中的一个或两个顶点 给定下列序列, 哪一个不能构成无向简单图的结点度数序列 (D) (无向简单图度数之和必为偶数) A. (1,1,2,2,4) B. (1,1,2,2,2) C. (2,1,3,3,3) D. (1,3,4,4,5) 设简单图的最大结点度数为 \\(\\Delta(G)\\) , 图中结点数为 \\(n\\) , 则 \\(\\Delta(G)\\) 与 \\(n\\) 的关系 (B) A. \\(\\Delta(G)&gt;n\\) B. \\(\\Delta(G)&lt;n\\) C. \\(\\Delta(G)=n\\) D. \\(\\Delta(G)\\) 与 \\(n\\) 没关系 由 \\(n\\) 个点 0 条边组成的图为 (A) A. 零图 B. 完全图 C. 平凡图 D. 多重图 \\(n\\) 个结点的完全无向图 \\(k_n\\) 的边数为 ___ \\(C_n^2=\\frac{n(n-1)}{2}\\) ___ 在有 3 个结点的图中, 度数是奇数的结点个数为 (D) (度数是奇数的结点个数必为偶数) A. 1 B. 3 C. 1 或 3 D. 0 或 2 不含多重边和环的图, 称为简单图 \\(n\\) 个结点的无向完全图的边数为 (D) A. \\(n(n+1)\\) B. \\(\\frac{n(n+1)}{2}\\) C. \\(n(n-1)\\) D. \\(\\frac{n(n-1)}{2}\\) 含 5 个结点, 4 条边的无向简单图(不同构)的个数为 (B) A. 1 B. 3 C. 6 D. 7 (建议画图) 在 5 阶图 G 中, 若从结点 \\(v_1\\) 到 \\(v_4\\) 存在路, 则从 \\(v_1\\) 到 \\(v_4\\) 必存在通路, 且长度小于等于 (D) (5 阶图就是顶点个数为 5) A. 1 B. 2 C. 3 D. 4 名词解释: 强连通性 有向图中任意两个顶点相互可达 给定有向图 \\(G=(V,E)\\) 如下 试求: 各顶点的出入度 写出 \\(G\\) 的邻接矩阵 利用矩阵计算从点 1 到 4 长度分别是 1,2,3 的路各有几条. 解: 顶点 1 2 3 4 出度 2 2 2 1 入度 0 3 1 3 \\(A(G)=\\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\end{bmatrix}\\) \\(A^2(G)=\\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\end{bmatrix}\\times\\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\end{bmatrix}=\\begin{bmatrix} 0 &amp; 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 2 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\end{bmatrix}\\) \\(A^3(G)=A^2(G)\\times A(G)=\\begin{bmatrix} 0 &amp; 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 2 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\end{bmatrix}\\times\\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\end{bmatrix}=\\begin{bmatrix} 0 &amp; 2 &amp; 1 &amp; 2 \\\\ 0 &amp; 1 &amp; 2 &amp; 2 \\\\ 0 &amp; 2 &amp; 1 &amp; 2 \\\\ 0 &amp; 2 &amp; 0 &amp; 1 \\end{bmatrix}\\) \\(\\therefore\\) 从顶点 1 到 4 长度是 1, 2, 3 的路分别有 1, 1, 2 条. 无向简单图的邻接矩阵: ___ \\(G=(V,E)\\) , \\(|V|=n\\), \\(A(G)=(a_{ij})_{n\\times n}\\) 其中 \\(a_{ij}=\\begin{cases} 1 &amp; v_i \\text{邻接} v_j \\\\ 0 &amp; v_i \\text{不邻接} v_j \\end{cases}\\) ___ 设 \\(M=(a_{ij})\\) 是无向图 \\(G=(V,E)\\) 的邻接矩阵, \\(M^k\\) 中第 \\(i\\) 行 第 \\(j\\) 列的元素值表示, 从 \\(v_i\\) 到 \\(v_j\\) 长度是 \\(k\\) 的路的数目 设无向图 \\(G=(V,E)\\) , 其中 \\(V=\\{1,2,3,4,5\\}\\) , \\(E=\\{(1,2),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)\\}\\) 画出 \\(G\\) 对应的图 求各顶点的度 \\(G\\) 是否具有欧拉回路, 是否具有欧拉通路, 为什么? 如有请写出. 解: 顶点 1 2 3 4 5 度 2 4 3 3 4 没有欧拉回路, 因为有两个奇数度数的顶点. 有欧拉通路. 如 3-4-2-3-5-2-1-5-4 (这里随便举一条欧拉回路即可) 存在欧拉回路的图称为欧拉图 设 \\(G\\) 是连通平面图, \\(G\\) 有 6 个顶点 8 条边, 则 \\(G\\) 的面数 (C) A. 2 B. 3 C. 4 D. 5 连通平面图 \\(G\\) 中, 所有面的次数之和 (C) A. 边数 B. 边数的一半 C. 边数的两倍 D. 边数的已被 若某连通平面图有 4 个顶点, 3 个区域, 则有5条边. 设 \\(G\\) 为一个至少三个结点的连通平面图, 试证: \\(G\\) 中至少有一个结点的度数小于等于 5 证明: (反证法) 设 \\(G=(V,E)\\) , \\(|V|=v\\) , \\(|E|=e\\) 假设 \\(G\\) 中所有结点度数大于等于 6 则 \\(\\displaystyle\\sum_{i=1}^v deg(v_i)=2e\\) (度数之和等于边数两倍) 则 \\(2e\\geqslant 6v\\) 则 \\(e\\geqslant 3v\\) 则 \\(e\\geqslant 3v-6\\) 这与连通平面图应该具有的性质 \\(e\\leqslant 3v-6\\) 矛盾. 所以假设错误 在根树中, 若每个结点的出度小于等于 m, 则称为 \\(m\\) 叉树. 设 \\(T\\) 为根树, 若每个结点的出度都小于等于 m, 则称 T 为 m 叉树. 在根树中, 如果每个结点的出度恰好等于m或零, 则称这棵树为完全 m 叉树.","link":"/zh-cn/learn/mathematics/2020/discrete-mathematics/"},{"title":"Introduction to Linear Algebra","text":".content { font-family: KaTeX_Main, 'FZYaSongS-R-GB'; } article.article .content { font-size: 1.3em; } .katex .base { font-size: 0.8em; } /* .katex-display { overflow-x: hidden; } */ .content ol.worked-examples { list-style-type: none; margin-left: 0em; } .content ol.worked-examples > li { margin-bottom: 1.5em; } .content ol.worked-examples > li > span.list-head { font-family: Ubuntu, Roboto, 'Open Sans'; font-weight: bold; } .content details summary span.list-summary { font-family: Ubuntu, Roboto, 'Open Sans'; font-weight: bold; color: RoyalBlue; } This is a copy of both brief summary and worked examples of each section in the Introduction to Linear Algebra (Fifth Edition) by Gilbert Strang https://github.com/mitmath/1806/ TODO: draw svg format figure by using tikz Chapter 1 Introduction to Vectors Vectors and Linear Combinations \\(3\\bm{v}+5\\bm{w}\\) is a typical linear combination \\(c\\bm{v}+d\\bm{w}\\) of the vectors \\(\\bm{v}\\) and \\(\\bm{w}\\) For \\(\\bm{v}=\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\) and \\(\\bm{w}=\\begin{bmatrix} 2 \\\\ 3 \\end{bmatrix}\\) The vector \\(\\begin{bmatrix} 2 \\\\ 3 \\end{bmatrix}=\\begin{bmatrix} 2 \\\\ 0 \\end{bmatrix}+\\begin{bmatrix} 0 \\\\ 3 \\end{bmatrix}\\) goes across to \\(x=2\\) and up to \\(y=3\\) in the \\(xy\\) plane. The combinations \\(c\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}+d\\begin{bmatrix} 2 \\\\ 3 \\end{bmatrix}\\) fill the whole \\(xy\\) place. They produce every \\(\\begin{bmatrix} x \\\\ y \\end{bmatrix}\\) The combinations \\(c\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}+d\\begin{bmatrix} 2 \\\\ 3 \\\\ 4 \\end{bmatrix}\\) fill a plane in \\(xyz\\) space. Same plane for \\(\\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}\\), \\(\\begin{bmatrix} 3 \\\\ 4 \\\\ 5 \\end{bmatrix}\\). But \\(\\begin{array}{l} c+2d=1 \\\\ c+3d=0 \\\\ c+4d=0 \\end{array}\\) has no solution because its right side \\(\\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}\\) is not on that plane. &dagger; WORKED EXAMPLES &dagger; 1.1 A&emsp;The linear combinations of \\(\\bm{v}=(1,1,0)\\) and \\(\\bm{w}=(0,1,1)\\) fill a plane in \\(\\mathbf{R}^3\\). Describe that plane. Find a vector that is not a combination of \\(\\bm{v}\\) and \\(\\bm{w}\\)&mdash;not on the plane. Solution&emsp;The plane of \\(\\bm{v}\\) and \\(\\bm{w}\\) contains all combinations \\(c\\bm{v}+d\\bm{w}\\). The vectors in that plane allow any \\(c\\) and \\(d\\). The plane of Figure 1.3 fills in between the two lines. &dagger; Figure 1.3 &dagger; $$ \\text{Combinations}\\qquad c\\bm{v}+d\\bm{w}=c\\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix}+d\\begin{bmatrix} 0 \\\\ 1 \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} c \\\\ c+d \\\\ d \\end{bmatrix}\\text{fill a plane.} $$ Four vectors in that plane are \\((0,0,0)\\) and \\((2,3,1)\\) and \\((5,7,2)\\) and \\((\\pi,2\\pi,\\pi)\\). The second component \\(c+d\\) is always the sum of the first and third components. Like most vectors, \\((1,2,3)\\) is not in the plane, because \\(2\\neq 1+3\\). &emsp;&ensp;Another description of this plane through \\((0,0,0)\\) is to know that \\(\\bm{n}=(1,-1,1)\\) is perpendicular to the plane. Section 1.2 will confirm that \\(90\\degree\\) angle by testing dot products: \\(\\bm{v}\\cdot\\bm{m}=0\\) and \\(\\bm{w}\\cdot\\bm{n}=0\\). Perpendicular vectors have zero dot products. 1.1 B&emsp;For \\(\\bm{v}=(1,0)\\) and \\(\\bm{w}=(0,1)\\), describe all points \\(c\\bm{v}\\) with (1) whole numbers \\(c\\) (2) nonnegative numbers \\(c\\geq 0\\). Then add all vectors \\(d\\bm{w}\\) and describe all \\(c\\bm{v}+d\\bm{w}\\) Solution &ensp;(1)&ensp;The vectors \\(c\\bm{v}=(c,0)\\) with whole numbers \\(c\\) are equally spaced points along the \\(x\\) axis (the direction of \\(\\bm{v}\\)). They include \\((-2,0)\\), \\((-1,0)\\), \\((0,0)\\), \\((1,0)\\), \\((2,0)\\). &ensp;(2)&ensp;The vectors \\(c\\bm{v}\\) with \\(c\\geq 0\\) fill a half-line. It is the positive \\(x\\) axis. This half-line starts at \\((0,0)\\) where \\(c=0\\). It includes \\((100,0)\\) and \\((\\pi,0)\\) but not \\((-100,0)\\). &ensp;(1ʹ)&ensp;Adding all vectors \\(d\\bm{w}=(0,d)\\) puts a vertical line through those equally spaced \\(c\\bm{v}\\). We have infinitely many parallel lines from (whole number \\(c\\), any number \\(d\\)). &ensp;(2ʹ)&ensp;Adding all vectors \\(d\\bm{w}\\) puts a vertical line through every \\(c\\bm{v}\\) on the half-line. Now we have half-plane. The right half of the \\(xy\\) plane has any \\(x\\geq 0\\) and any \\(y\\). 1.1 C&emsp;Find two equations for \\(c\\) and \\(d\\) so that the linear combination \\(c\\bm{v}+d\\bm{w}\\) equals \\(\\bm{b}\\): $$ \\bm{v}=\\begin{bmatrix} 2 \\\\ -1 \\end{bmatrix}\\qquad\\bm{w}=\\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix}\\qquad\\bm{b}=\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} $$ Solution&emsp;In applying mathematics, many problems have two parts: &emsp;1&ensp;Modeling part&emsp;Express the problem by a set of equations. &emsp;2&ensp;Computational part&emsp;Solve those equations by a fast and accurate algorithm. Here we are only asked for the first part (the equations). Chapter 2 is devoted to the second part (the solution). Our example fits into fundamental model for linear algebra: $$ \\text{Find $n$ numbers }c_1,\\ldots,c_n\\text{ so that }c_1\\bm{v}_1+\\cdots+c_n\\bm{v}_n=\\bm{b} $$ For \\(n=2\\) we will find a formula for the \\(c\\)'s. The &ldquo;elimination method&rdquo; in Chapter 2 succeeds far beyond \\(n=1000\\). For \\(n\\) greater than 1 billion, see Chapter 11. Here \\(n=2\\): $$ \\colorbox{e8f1fe}{$\\begin{array}{l} \\textbf{Vector equation} \\\\ c\\bm{v}+d\\bm{w}=\\bm{b} \\end{array}\\qquad c\\begin{bmatrix*}[r] 2 \\\\ -1 \\end{bmatrix*}+d\\begin{bmatrix*}[r] -1 \\\\ 2 \\end{bmatrix*}=\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$} $$ The required equations for \\(c\\) and \\(d\\) just come from the two components separately: $$ \\textcolor{RoyalBlue}{\\textbf{Two ordinary equations}} \\qquad \\begin{alignedat}{2.5} % Using alignedat for no space between columns. For parameter there is +0.5 per column (pair of rl columns), columms align are col1=right, col2=left, col3=right... && 2c- && d=1 \\\\ - && c+ && 2d=0 \\end{alignedat} $$ Each equation produces a line. The two lines cross at the solution \\(c=\\dfrac{2}{3}\\), \\(d=\\dfrac{1}{3}\\). Why not see this also as a matrix equation, since that is where we are going: $$ \\textbf{2 by 2 matrix} \\qquad \\begin{bmatrix*}[r] \\bm{2} & \\bm{-1} \\\\ \\bm{-1} & \\bm{2} \\end{bmatrix*} \\begin{bmatrix} c \\\\ d \\end{bmatrix}=\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} $$ Lengths and Dot Products The “dot product” of \\(\\bm{v}=\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}\\) and \\(\\bm{w}=\\begin{bmatrix} 4 \\\\ 5 \\end{bmatrix}\\) is \\(\\bm{v}\\cdot\\bm{w}=(1)(4)+(2)(5)=4+10=\\bm{14}\\) \\(\\bm{v}=\\begin{bmatrix} 1 \\\\ 3 \\\\ 2 \\end{bmatrix}\\) and \\(\\bm{w}=\\begin{bmatrix*}[r] 4 \\\\ -4 \\\\ 4 \\end{bmatrix*}\\) are perpendicular because \\(\\bm{v}\\cdot\\bm{w}\\) is zero: \\((1)(4)+(3)(-4)+(2)(4)=\\bm{0}\\) The length squared of \\(\\bm{v}=\\begin{bmatrix} 1 \\\\ 3 \\\\ 2 \\end{bmatrix}\\) is \\(\\bm{v}\\cdot\\bm{v}=1+9+4=14\\). The length is \\(\\|\\bm{v}\\|=\\sqrt{\\bm{14}}\\). Then \\(\\bm{u}=\\dfrac{\\bm{v}}{\\|\\bm{v}\\|}=\\dfrac{\\bm{v}}{\\sqrt{14}}=\\dfrac{1}{\\sqrt{14}}\\begin{bmatrix} 1 \\\\ 3 \\\\ 2 \\end{bmatrix}\\) has length \\(\\|\\bm{u}\\|=\\bm{1}\\). Check \\(\\dfrac{1}{\\underline{14}}+\\dfrac{9}{\\underline{14}}+\\dfrac{4}{\\underline{14}}=1\\). The angle \\(\\theta\\) between \\(\\bm{v}\\) and \\(\\bm{w}\\) has \\(\\cos\\theta=\\dfrac{\\bm{v}\\cdot\\bm{w}}{\\|\\bm{v}\\|\\|\\bm{w}\\|}\\) The angle between \\(\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\) and \\(\\begin{bmatrix} 1 \\\\ 1\\end{bmatrix}\\) has \\(\\cos\\theta=\\dfrac{1}{(1)(\\sqrt{2})}\\). That angle is \\(\\theta=45\\degree\\) All angles have \\(|\\cos\\theta|\\leq 1\\). So all vectors have \\(\\boxed{|\\bm{v}\\cdot\\bm{w}|\\leq\\|\\bm{v}\\|\\|\\bm{w}\\|}\\). &dagger; WORKED EXAMPLES &dagger; 1.2 A&emsp;For the vectors \\(\\bm{v}=(3,4)\\) and \\(\\bm{w}=(4,3)\\) test the Schwarz inqeuality on \\(\\bm{v}\\cdot\\bm{w}\\) and the triangle inqeuality on \\(\\|\\bm{v}+\\bm{w}\\|\\). Find \\(\\cos\\theta\\) for the angle between \\(\\bm{v}\\) and \\(\\bm{w}\\). Which \\(\\bm{v}\\) and \\(\\bm{w}\\) give equality \\(\\|\\bm{v}\\cdot\\bm{w}\\|=\\|\\bm{v}\\|\\|\\bm{w}\\|\\) and \\(\\|\\bm{v}+\\bm{w}\\|=\\|\\bm{w}\\|+\\|\\bm{w}\\|\\)? Solution&emsp;The dot product is \\(\\bm{v}\\cdot\\bm{w}=(3)(4)+(4)(3)=24\\). The length of \\(\\bm{v}\\) is \\(\\|\\bm{v}\\|=\\sqrt{9+16}=5\\) and also \\(\\|\\bm{w}\\|=5\\). The sum \\(\\bm{v}+\\bm{w}=(7,7)\\) has length \\(7\\sqrt{2}","link":"/zh-cn/learn/mathematics/2021/introduction-to-linear-algebra/"},{"title":"senior-high-schoool-mathematics","text":"高中数学的内容 省略了不重要的东西(比如集合、函数奇偶性, 弧度制(曲边三角形)等一些谁都懂的概念) 基于 基础版数学笔记 常见集合 自然数: \\(N\\) , 正整数 \\(N^+\\) , 整数 \\(Z\\) , 有理数 \\(Q\\) , 非零有理数 \\(Q^*\\), 实数 \\(R\\) , 复数 \\(C\\) 函数 基本初等函数 指数函数 (Exponential function) 形如: \\(y=a^x\\enspace\\) (\\(a&gt;0\\) 且 \\(a\\neq 1\\)) 性质: 指数函数恒过定点 (0, 1) \\(\\begin{cases} 0 &lt; a &lt; 1 &amp; \\text{为减函数} \\\\ a &gt; 1 &amp; \\text{为增函数} \\end{cases}\\) 注意: 比较两个数(带有次数)可利用 \\(a^0=1\\) 的特殊性 例: \\(1.7^{0.3}\\) , \\(0.9^{3.1}\\) \\(\\because 1.7^{0.3}&gt;1.7^0=1, 0.9^{3.1} &lt; 0.9^0 = 1 \\\\ \\therefore 1.7^{0.3} &gt; 0.9^{3.1}\\) 对数函数 (Logarithmic function) 形如 \\(y=\\log_ax\\enspace\\) (\\(a &gt; 0\\) , 且 \\(a\\neq 1\\)) 其中 \\(y\\) 叫做以 \\(a\\) 为底的对数, \\(x\\) 叫做真数 性质: 对数函数横过定点 (1, 0) 对数函数公式: (\\(a &gt; 0\\) 且 \\(a \\neq 1\\) , \\(M &gt; 0\\) , \\(N &gt; 0\\)) TODO: 补充这些公式的证明过程 \\(a^{\\log_ab}=b\\) \\(\\log_ab\\cdot\\log_ba=1\\) \\(log_{a^n}b^n=\\log_ab\\) \\(\\log_a(M\\cdot N)=\\log_aM+\\log_aN\\) \\(\\log_a(\\frac M N)=\\log_aM-\\log_aN\\) \\(\\log_aM^n=n\\log_aM\\enspace\\) (\\(n\\in R\\)) \\(\\log_ab=\\frac{\\log_cb}{\\log_ca}\\enspace\\) (\\(c &gt; 0\\) 且 \\(c\\neq 1\\)) (换底公式, 是重点) \\(\\log_{a^N}b^M=\\frac{M}{N}\\log_ab\\) \\(\\begin{cases} 0 &lt; a &lt; 1 &amp; \\text{为减函数} \\\\ a &gt; 1 &amp; \\text{为增函数} \\end{cases}\\) 反函数: 关于直线 \\(y=x\\) 对称的两个函数 求一个函数的反函数, 将该函数的 \\(y\\) 和 \\(x\\) 互换并整理 反函数的定义域为原函数的值域, 反函数的值域为原函数的定义域. 对数函数 \\(y=\\log_ax\\enspace\\) (\\(a&gt;0\\) 且 \\(a\\neq 1\\)) 和指数函数 \\(y=a^x\\enspace\\) (\\(a&gt;0\\) 且 \\(a\\neq 1\\)) 互为反函数 幂函数 (Power function) 幂函数: \\(y=x^a\\enspace\\) (\\(a\\) 为常数) (一般只讨论 \\(a=1,2,3,4,\\frac{1}{2},-1\\) 时的情形) 性质: 在第一象限内: 当 \\(a&gt;0\\) 时, 单调增 当 \\(a&lt;0\\) 时, 单调减 函数单调性判断, 取 \\(x_1&lt;x_2\\) , 判断 \\(f(x_2)-f(x_1)\\) 符号, 大于零为增函数, 小于零为减函数; 也可通过求导判断 函数对称性: \\(f(x)\\) 关于直线 \\(x=a\\) 对称, 则 \\(f(x)=f(2a-x)\\) \\(f(x)\\) 关于点 \\((a,b)\\) 对称, 则 \\(f(x)+f(2a-x)=2b\\) 函数与方程 二次函数 (Quadratic function) 形如 \\(y=ax^2+bx+c\\enspace\\) (\\(a \\neq 0\\)) 性质: 顶点坐标: \\((-\\frac{b}{2a},\\frac{4ac-b^2}{4a})\\) 方程根: \\((\\frac{-b - \\sqrt{\\Delta}}{2a}, 0)和(\\frac{-b + \\sqrt{\\Delta}}{2a}, 0)\\) \\(\\Delta=b^2-4ac\\) 若 \\(\\Delta&gt;0\\) , 函数与 \\(x\\) 轴交于两点 若 \\(\\Delta=0\\) , 函数与 \\(x\\) 轴交于一点 若 \\(\\Delta&lt;0\\) , 函数与 \\(x\\) 轴无公共点 零点: \\(f(x)=0\\) 的时候 \\(x\\) 的值 二分法 (Dichotomy) 对于区间 \\([a,b]\\) 上连续不断且 \\(f(a)\\cdot f(b)&lt;0\\) 的函数 \\(y=f(x)\\) , 通过不断地把函数 \\(f(x)\\) 的零点所在的区间一分为二, 使区间的两个端点逐步逼近零点, 进而得到零点近似值的方法叫二分法 零点存在性质定理: 若 \\(f(x)\\) 在 \\([a,b]\\) 上连续不断, 且 \\(f(x)\\cdot f(b)&lt;0\\) , 则在区间 \\([a,b]\\) 存在变号零点 零点与方程根的关系 (Realtionship between zero point and equation root) 函数 \\(y＝f(x)\\) 有零点说明方程 \\(f(x)＝0\\) 有实数根(几何意义为函数 \\(y＝f(x)\\) 的图象与 \\(x\\) 轴有交点) 三角函数 诱导公式 (Induction formula) “奇变偶不变, 符号看象限” \\(\\begin{cases} \\sin(2k\\pi+\\alpha)=\\sin\\alpha &amp; (k\\in Z) \\\\ \\cos(2k\\pi+\\alpha)=\\cos\\alpha &amp; (k\\in Z) \\\\ \\tan(2k\\pi+\\alpha)=\\tan\\alpha &amp; (k\\in Z) \\end{cases}\\) \\(\\begin{cases} \\sin(\\pi+\\alpha)=-\\sin\\alpha \\\\ \\cos(\\pi+\\alpha)=-\\cos\\alpha \\\\ \\tan(\\pi+\\alpha)=\\tan\\alpha \\end{cases}\\) \\(\\begin{cases} \\sin(-\\alpha)=-\\sin\\alpha \\\\ \\cos(-\\alpha)=\\cos\\alpha \\\\ \\tan(-\\alpha)=-\\tan\\alpha \\end{cases}\\) \\(\\begin{cases} \\sin(\\pi-\\alpha)=\\sin\\alpha \\\\ \\cos(\\pi-\\alpha) =-\\cos\\alpha \\\\ \\tan(\\pi-\\alpha)=-\\tan\\alpha \\end{cases}\\) \\(\\begin{cases} \\sin(\\frac{\\pi}{2}-\\alpha)=\\cos\\alpha \\\\ \\cos(\\frac{\\pi}{2}-\\alpha)=\\sin\\alpha \\\\ \\tan(\\frac{\\pi}{2}-\\alpha)=\\cot\\alpha \\end{cases}\\) \\(\\begin{cases} \\sin(\\frac{\\pi}{2}+\\alpha)=\\cos\\alpha \\\\ \\cos(\\frac{\\pi}{2}+\\alpha)=-\\sin\\alpha \\\\ \\tan(\\frac{\\pi}{2}+\\alpha)=-\\cot\\alpha \\end{cases}\\) 周期性和单调性 (Periodic and monotonic) 周期函数: 对于函数 \\(f(x)\\), 如果 \\(\\exist T\\enspace\\) (\\(T\\neq 0\\)), 使得 \\(\\forall x\\in\\) 定义域, 都有 \\(f(x+T)=f(x)\\) , 那么函数 \\(f(x)\\) 就是一个周期函数 最小正周期: \\(f(x)\\) 的所有周期长度(\\(T,2T,3T,\\dots\\)) 中的最小正数 \\(T\\) 叫做函数 \\(f(x)\\) 的最小正周期 简谐运动 (Simple harmonic motion) 形如 \\(y=A\\sin(wx+\\varphi)+k\\) 的函数 (画这类函数的图像可用五点法) \\(A\\) 为这个简谐运动的振幅(影响函数的值域), \\(k\\) 为基准(影响函数初始高度) (\\(w\\) 影响函数的周期长度)这个简谐运动的周期为 \\(T=\\frac{2\\pi}{w}\\) , 所以频率 \\(f=\\frac{1}{T}=\\frac{w}{2\\pi}\\) \\(wx+\\varphi\\) 称为相位, \\(x=0\\) 时的相位 \\(\\varphi\\) 称为初相(影响函数左右平移) 性质 \\(A=\\frac{y(\\text{max}-\\text{min})}{2}\\) (函数值域长度的一半就是波动的幅度) \\(k=\\frac{y(\\text{max}+\\text{min})}{2}\\) (函数值域的中点就是基准点) 同角三角函数基本关系式 平方关系: \\(\\sin^2\\alpha+\\cos^2\\alpha=1\\) 商关系: \\(\\frac{\\sin\\alpha}{\\cos\\alpha}=\\tan\\alpha\\enspace\\) (\\(\\alpha\\neq k\\pi+\\frac{\\pi}{2}\\) , \\(k \\in Z\\)) 三角恒等变换 和差角公式: \\(\\sin(\\alpha\\pm\\beta)=\\sin\\alpha\\cos\\beta\\pm\\cos\\alpha\\sin\\beta\\) \\(\\cos(\\alpha\\pm\\beta)=\\cos\\alpha\\cos\\beta\\mp\\sin\\alpha\\sin\\beta\\) \\(\\tan(\\alpha\\pm\\beta)=\\frac{\\tan\\alpha\\pm\\tan\\beta}{1\\mp\\tan\\alpha\\cdot\\tan\\beta}\\) 二倍角公式: \\(\\sin2\\alpha=2\\sin\\alpha\\cos\\alpha\\) \\(\\cos2\\alpha=\\cos^2\\alpha-\\sin^2\\alpha=1-2\\sin^2\\alpha=2\\cos^2\\alpha-1\\) 辅助角公式: \\(a\\sin{x}+b\\cos{x}=\\sqrt{a^2+b^2}\\sin(x+\\varphi)=\\sqrt{a^2+b^2}\\cos(x-\\varphi)\\) \\(\\tan\\varphi=\\frac{b}{a}\\) , \\(\\varphi\\) 为辅助角 解三角形 正弦定理: \\(2R=\\frac{a}{\\sin A}=\\frac{b}{\\sin B}=\\frac{c}{\\sin C}\\) 正弦定理推论: \\(2R=\\frac{a+b+c}{\\sin A+\\sin B+\\sin C}\\) , \\((\\frac{a}{\\sin A})^2=\\frac{bc}{\\sin B\\sin C}\\) , \\((\\frac{a}{\\sin A})^3=\\frac{abc}{\\sin A\\sin B\\sin C}\\) 余弦定理: \\(\\begin{cases} a^2=b^2+c^2-2bc\\cos A \\\\ b^2=a^2+c^2-2ac\\cos B \\\\ c^2=a^2+b^2-2ab\\cos C \\end{cases}\\) 余弦定理推论: \\(\\cos{A} = \\frac{b^2 + c^2 - a^2}{2bc}\\) , \\(\\cos{B} = \\frac{a^2 + c^2 - b^2}{2ac}\\) , \\(\\cos{C} = \\frac{a^2 + b^2 - c^2}{2ab}\\) 三角形面积公式: \\(S_\\triangle=\\frac{1}{2}bc\\sin A=\\frac{1}{2}ac\\sin B=\\frac{1}{2}ab\\sin C\\) 解三角形记得判断求出的该角能否为钝(锐)角 (大角对大边, 小角对小边) 导数及其应用 导数的概念及其几何意义 平均变化率: 函数 \\(y=f(x)\\) 从 \\(x_1\\) 到 \\(x_2\\) 的平均变化率为 \\(\\frac{f(x_2)-f(x_1)}{x_2-x_1}=\\frac{\\vartriangle{y}}{\\vartriangle{x}}\\) 瞬时变化率: 函数 \\(y=f(x)\\) 在 \\(x=x_0\\) 处的瞬时变化率是 \\(f^\\prime(x_0)=\\lim\\limits_{x\\to x_0}\\frac{f(x)-f(x_0)}{x-x_0}\\) 几何意义: 导数是函数曲线随 \\(x\\) 轴变化的速度 导数的计算 导数公式: \\((c)^\\prime=0\\enspace\\) (\\(c\\) 为常数) \\((x^a)^\\prime=ax^{a-1}\\enspace\\) (\\(a\\in Q^*\\)) \\((\\sin x)^\\prime=\\cos x\\) \\((\\cos x)^\\prime=-\\sin x\\) \\((a^x)^\\prime=a^x\\ln a\\) \\((\\log_a x)^\\prime=\\frac{1}{x\\ln a}=\\frac{1}{x}\\log_a e\\) \\((e^x)^\\prime=e^x\\) \\(\\ln x=\\frac{1}{x}\\) 导数运算法则: \\([f(x)\\pm g(x)]^\\prime=f^\\prime(x)\\pm g^\\prime(x)\\) \\([f(x)g(x)]^\\prime=f^\\prime(x)g(x)+f(x)g^\\prime(x)\\) \\([\\frac{f(x)}{g(x)}]^\\prime=\\frac{f^\\prime(x)g(x)-f(x)g^\\prime(x)}{[g(x)]^2}\\enspace\\) (\\(g(x)\\neq 0\\)) 复合函数: 对于两个函数 \\(y=f(u)\\) 和 \\(u=g(x)\\) . 如果通过变量 \\(u\\)、\\(y\\)可以表示成一个关于 \\(x\\) 的函数, 那么称这个函数 \\(f(g(x))\\) 为 \\(y=f(u)\\) 和 \\(u=g(x)\\) 的复合函数. 记作\\(y=f(g(x))\\) 复合函数求导: \\(f^\\prime(g(x))=f^\\prime(u)\\cdot g^\\prime(x)\\) 导数在研究函数中的作用 函数的单调性与其导函数的正负有如下关系: 存在函数 \\(y=f(x)\\) , 在某个区间 \\((a,b)\\) 内, 如果 \\(f^\\prime(x)&gt;0\\) , 则该函数在这个区间内单调递增 如果 \\(f^\\prime(x)&lt;0\\) , 则该函数在这个区间内单调递减 利用导数找函数极值点和极值: 首先得 \\(\\exist f^\\prime(a)=0\\) 极小值点: 若在点 \\(x=a\\) 附近, 左侧 \\(f^\\prime(x)&lt;0\\) , 右侧 \\(f^\\prime(x)&gt;0\\) . 则点 \\(a\\) 叫做函数的极小值点 极大值点: 若在点 \\(x=a\\) 附近, 左侧 \\(f^\\prime(x)&gt;0\\) , 右侧 \\(f^\\prime(x)&lt;0\\) . 则点 \\(a\\) 叫做函数的极大值点 求函数 \\(y=f(x)\\) 在区间 \\([a,b]\\) 的最大值与最小值的步骤如下 求函数 \\(y=f(x)\\) 在 \\((a,b)\\) 内的极值 将求到的各极值连同端点处的函数值 \\(f(a)\\)、\\(f(b)\\) 比较. 其中最大的是最大值; 最小的是最小值 定积分与微积分基本定理 微分 先来看看微分的概念 \\(\\mathrm{d}x=\\lim\\limits_{\\varDelta x\\to 0}\\varDelta x\\) 结合导数的定义, 有 \\(f^\\prime(x)=\\dfrac{\\mathrm{d}y}{\\mathrm{d}x}\\rArr\\mathrm{d}y=f^\\prime(x)\\mathrm{d}x\\) 关于微分的公式: \\(\\mathrm{d}f(x)=f^\\prime(x)\\mathrm{d}x\\) \\(\\mathrm{d}(ax+b)=a\\mathrm{d}x\\) 定积分 定积分四部曲: 分割-&gt;近似代替-&gt;求和-&gt;取极限 定积分概念: \\(\\int_a^b f(x)\\mathrm{d}x=\\lim\\limits_{n\\to\\infty}\\displaystyle\\sum_{i=1}^n\\textstyle\\frac{b-a}{n}f(\\xi_i)\\) \\(a\\) 与 \\(b\\) 分别叫做积分下限和积分上限, 组成的区间 \\([a,b]\\) 叫做积分区间 函数 \\(f(x)\\) 叫做被积函数, \\(x\\) 叫做积分变量, \\(f(x)\\mathrm{d}x\\) 叫做被积式 上式中 \\(\\mathrm{d}x\\) 与 \\(\\frac{b-a}{n}\\) 对应, 几何意义为被无穷分割的区间 \\([a,b]\\) 中的一小段, \\(\\xi_i\\) 表示这一小段对应的位置 定积分性质: (线性性质) \\(\\int_a^b kf(x)\\mathrm{d}x=k\\int_a^b f(x)\\mathrm{d}x\\) \\(\\int_a^b[f_1(x)\\pm f_2(x)]\\mathrm{d}x=\\int_a^b f_1(x)\\mathrm{d}x\\pm\\int_a^b f_2(x)\\mathrm{d}x\\) (积分区间的可加性) \\(\\int_a^b f(x)\\mathrm{d}x=\\int_a^c f(x)\\mathrm{d}x+\\int_c^b f(x)\\mathrm{d}x\\enspace\\) (\\(a&lt;c&lt;b\\)) \\(\\int_a^b f(x)\\mathrm{d}x=-\\int_b^a f(x)\\mathrm{d}x\\) 函数值大于等于零时, 积分大于零; 函数值小于等于零时, 积分小于零 \\(f(x)\\geqslant 0\\rArr\\int_a^bf(x)\\mathrm{d}x&gt;0\\) , \\(f(x)\\leqslant 0\\rArr\\int_a^b f(x)\\mathrm{d}x&lt;0\\) 若 \\(f(x)\\) 是奇函数, 则 \\(\\int_{-a}^a f(x)\\mathrm{d}x=0\\) (奇函数沿原点对称, 正好抵消) 若 \\(f(x)\\) 是偶函数, 则 \\(\\int_{-a}^a f(x)\\mathrm{d}x=2\\int_0^a f(x)\\mathrm{d}x\\) (偶函数沿 \\(y\\) 轴对称) 微积分基本定理 一般地, 如果 \\(f(x)\\) 是区间 \\([a, b]\\) 上的连续函数. 并且 \\(\\exist F^\\prime(x)=f(x)\\), 那么 \\(\\int_a^b f(x)\\mathrm{d}x=F(b)-F(a)=F(x)|_a^b=[F(x)+c]|_a^b\\) 这个结论叫做微积分基本定理, 也称牛顿⋅莱布尼茨公式. 数列 等差数列 (Arithmetic progression) 通项公式: \\(a_n=a_1+(n-1)d\\) 前 \\(n\\) 项和: \\(S_n=na_1+\\frac{(n-1)n}{2}d=\\frac{(a_1+a_n)n}{2}\\) 性质: 设等差数列 \\(A,B,C\\) , 若 \\(B\\) 为等差中项, 则有 \\(B=\\frac{A+C}{2}\\) \\(m+n=p+q\\rArr a_m+a_n=a_p+a_q\\enspace\\) (\\(m,n,p,q\\in N^+\\)) 数列的前 \\(n\\) 项和 \\(S_n\\) 和 \\(a_n\\) 的关系 \\(a_n=\\begin{cases} S_1 &amp; n=1 \\\\ S_n-S_{n-1} &amp; n\\geqslant 2 \\end{cases}\\) 等差数列前 \\(n\\) 项和性质: 等差数列 \\(\\{a_n\\}\\) 中, 连续的 \\(n\\) 项之和构成的数列(\\(S_n,S_{2n}-S_n,S_{3n}-S_{2n},S_{4n}-S_{3n},\\dots\\))构成等差为 \\(n^d\\) 的等差数列 等比数列 (Geometric progression) 通项公式: \\(a_n=a_1q^{n-1}\\) 前 \\(n\\) 项和: \\(S_n=\\frac{a_1(1-q^n)}{1-q}=\\frac{a_1-a_nq}{1-q}\\enspace\\) (\\(q\\neq 1\\)) 性质: 设等比数列 \\(A,B,C\\) , 若 \\(B\\) 为等比中项, 则有 \\(B^2=AC\\) \\(k+l=m+n\\rArr a_k\\cdot a_l=a_m\\cdot a_n\\enspace\\) (\\(k,l,m,n\\in N^+\\)) 若 \\(\\{a_n\\} , \\{b_n\\}\\) 是项数相同的等比数列, 且公比分别是 \\(p\\) 和 \\(q\\) 则 \\(\\{\\lambda a_n\\}\\) 的公比为 \\(p\\) , \\(\\{\\frac{1}{a_n}\\}\\) 的公比为 \\(\\frac{1}{p}\\) \\(\\{a_n^2\\}\\) 的公比为 \\(p^2\\) , \\(\\{a_nb_n\\}\\) 的公比为 \\(pq\\) \\(\\{\\frac{a_n}{b_n}\\}\\) 的公比为 \\(\\frac{p}{q}\\) 等比数列前 \\(n\\) 项和性质: 在公比不等于 \\(-1\\) 的等比数列 \\(\\{a_n\\}\\) 中, 连续的 \\(n\\) 项之和构成的数列(\\(S_n,S_{2n}-S_n,S_{3n}-S_{2n},S_{4n}-S_{3n},\\dots\\))构成公比为 \\(q^n\\) 的等比数列 在等比数列中, 当项数为偶数时, 比时有 \\(\\dfrac{S_偶}{S_奇}=q\\) (全部偶数项除以全部奇数项) 其他 求数列(非等差和等比数列)的前 \\(n\\) 项和一般采用错位相减法和裂项相消法. 同时还有分组求和, 并项求和, 倒序相加求和 并项求和: 如 \\(S=-1+2-3+4-5+6+(-1)^n\\) 当 \\(n\\) 为偶 \\(S_n=\\frac{n}{2}\\) 当 \\(n\\) 为奇 \\(S_n=S_{n-1}-n=\\frac{n-1}{2}-n\\) 裂项求和公式: \\(\\frac{1}{n(n+k)}=\\frac{1}{k}(\\frac{1}{n}-\\frac{1}{n+k})\\) (基本裂项式) \\(\\frac{1}{n(n+1)}=\\frac{1}{n}-\\frac{1}{n+1}\\) \\(\\frac{1}{(2n-1)(2n+1)}=\\frac{1}{2}(\\frac{1}{2n-1}-\\frac{1}{2n+1})\\) \\(\\frac{1}{n(n+1)(n+2)}=\\frac{1}{2}(\\frac{1}{n(n+1)}-\\frac{1}{(n+1)(n+2)})\\) \\(\\frac{1}{\\sqrt{a}+\\sqrt{b}}=\\frac{1}{a-b}(\\sqrt{a}-\\sqrt{b})\\) 复数 复数的概念 \\(复数域\\begin{cases} 实数 \\begin{cases} 有理数 \\\\ 无理数 \\end{cases} \\\\ 虚数 \\begin{cases} 纯虚数 \\\\ 非纯虚数 \\end{cases} \\end{cases}\\) 形如 \\(a+bi\\enspace\\) (\\(a,b\\in R\\)) 的数叫做复数, \\(i\\) 叫做复数单位 当 \\(a=0\\) 且 \\(b\\neq0\\) 时. 叫做纯虚数. 虚数 \\(i\\) 的周期性(虚数的周期为 4): \\(i^{4n+1}=i\\) \\(i^{4n+2}=-1\\) \\(i^{4n+3}=-i\\) \\(i^{4n}=1\\) 共轭复数: 一般地, 当两个复数的实部相等, 虚部互为相反数时, 这两个复数互为共轭复数(虚部不等于 0 的两个共轭复数也叫做共轭虚数) 复数的四则运算 复数的乘法运算 \\((a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i\\) 复数的除法运算 \\((a+bi)\\div(c+di)=\\frac{a+bi}{c+di}=\\frac{(a+bi)(c-di)}{(c+di)(c-di)}=\\frac{ac+bd}{c^2-d^2}+\\frac{bc-ad}{c^2-d^2}i\\) 复数的模: 设复数 \\(Z=a+bi\\enspace\\) (\\(a,b\\in R\\)) 对应复平面上的点 \\(Z\\) , 则\\(Z\\) 的模 \\(|Z|=\\|\\vec{OZ}\\|=\\sqrt{a^2+b^2}\\) (即点 \\(Z(a, b)\\) 到原点的距离) 逻辑 常用逻辑用语 命题及其关系 四种命题: 原命题: 若 \\(a\\) , 则 \\(b\\) 逆命题: 若 \\(b\\) , 则 \\(a\\) 否命题: 若非 \\(a\\) , 则非 \\(b\\) 逆否命题: 若非 \\(b\\) , 则非 \\(a\\) 原命题和逆否命题同真同假, 否命题和逆命题同真同假 命题关系: 互逆, 互否, 互为逆否 充分条件: 若 \\(p\\) 能推出 \\(q\\), 则 \\(p\\) 是 \\(q\\) 的充分但不必要条件; 表达式 \\(p\\rArr q\\) , 且 \\(p\\nLeftarrow p\\) 必要条件: 若 \\(q\\) 的结果必定有 \\(p\\) , 则 \\(p\\) 是 \\(q\\) 的必要但不充分条件; 表达式 \\(p\\lArr q\\) , 且 \\(p\\nRightarrow p\\) 逻辑连结词或\\且\\非 或: 符号 \\(p \\lor q\\) , \\(p\\) 或 \\(q\\) 其中任意一个成立, 结果为真 且: 符号 \\(p \\land q\\) , \\(p\\) 和 \\(q\\) 全部成立, 结果才为真 非: 符号 \\(\\lnot p\\), 若 \\(p\\) 不成立, 结果为真 全称量词与存在量词 全称量词: 符号 \\(\\forall\\) . 如 \\(\\forall x\\in M\\) , \\(f(x)\\) 表示&quot;对于函数的任意值(都满足某种条件)&quot; 存在量词: 符号 \\(\\exist\\) . 如 \\(\\exist x\\in M\\) , \\(f(x)\\) 表示&quot;函数存在某个值(满足某种条件)&quot; 推理与证明 合情推理与演绎推理 合情推理(结论不一定可靠) 归纳推理: 由某类事物的部分对象具有某些特征, 推出该类事物的全部对象都具有这些特征的推理, 或者由个别事实概括出一般结论的推理 (部分到整体, 个别到一致) 类比推理: 由两类对象具有某些类似特征和其中一类对象的某些已知特征, 推出另一类对象也具有这些特征的推理(特殊到特殊) 演绎推理 从一般到特殊 在大, 小前提及推理形式都正确的情况下, 结论必正确 &quot;三段论&quot;是演绎推理的一般模式, 包括 大前提(已知的一般原理) 小前提(所研究的特殊情况) 结论(根据一般原理, 对特殊情况做出的判断) 例子: 123大前提: M是P小前提: S是M结论: S是P 直接证明与间接证明 直接证明 综合法 利用已知条件和某些数学定义、公理、定理等, 经过一系列的推理论证, 最后推导出所要证明的结论成立. 特点: 由因导果(顺推) 用 \\(P\\) 表示已知条件、已有的定义、公理、定理等, \\(Q\\) 表示所要证明的结论: \\(P\\rArr Q_1\\rarr Q_1\\rArr Q_2\\rarr Q_2\\rArr Q_3\\rarr\\dots\\rarr Q_n\\rArr Q\\) 分析法 从要证明的结论出发, 逐步寻求使它成立的充分条件, 直至最后, 把要证明的结论归结为判定一个明显成立的条件(已知条件、定义、公理、定理等)为止. 特点: 由果导因(逆推) 用 \\(Q\\) 表示要证明的结论: \\(Q\\lArr P_1\\rarr P_1\\lArr P_2\\rarr P_2\\lArr P_3\\rarr\\dots\\rarr\\) [一个明显成立的条件] 间接证明 反证法 假设原命题不成立(即在原命题条件下, 结论不成立), 经过正确的推理, 最后得出矛盾. 因此说明假设错误, 从而证明了原命题成立. 三个步骤: 反设-&gt;归谬-&gt;存真 数学归纳法 用于证明一个与正整数 \\(n\\) 有关的命题 (归纳奠基)证明当 \\(n\\) 取第一个值 \\(n_0\\enspace\\) (\\(n_0\\in N^+\\)) 时命题成立 (归纳递推)假设 \\(n=k\\enspace\\) (\\(k\\geqslant n_0\\) , \\(k\\in N^+\\)) 时命题成立. 证明当 \\(n=k+1\\) 时命题也成立 算法初步 辗转相除法(求最大公约数) 例: 求 8251 与 6105 的最大公约数 \\(8251=6105\\times 1+2146\\) (6105 与 2146 的公约数也是 8251 与 6105 的公约数) \\(6105=2146\\times 2+1813\\) \\(2146=1813\\times 1+333\\) \\(1813=333\\times 5+148\\) \\(333=148\\times 2+37\\) \\(148=37\\times 4\\) \\(\\therefore\\) 37 是 148 与 37 的最大公约数, 也是 8251 与 6105 的最大公约数 更相减损术(求最大公约数) 方法: 任意给定两个正整数, 判断它们是否都是偶数. 若是, 用 2 约简; 若不是, 执行第二步 以较大的数减去较小的数, 接着把所得的差与较小的数比较, 并以大数减小数. 继续这个操作, 直到所得的数相等为止. 例: 求 98 与 63 的最大公约数 因为 63 不是偶数, 执行第二步 \\(98-63=35\\) \\(63-35=28\\) \\(35-28=7\\) \\(28-7=21\\) \\(21-7=14\\) \\(14-7=7\\) \\(\\therefore\\) 98 和 63 的最大公约数为 7 秦九韶算法 把 \\(f(x)=a_nx^n+a_{n-1}x^{n-1}+\\dots+a_1x+a_0\\) 改写成如下形式 \\(\\begin{aligned} f(x) &amp; =a_nx^n+a_{n-1}x^{n-1}+\\dots+a_1x+a_0 \\\\ &amp; =(a_nx^{n-1}+a_{n-1}x^{n-2}+\\dots+a_1)x+a_0 \\\\ &amp; =((a_nx^{n-2}+a_{n-1}x^{n-3}+\\dots+a_2)x+a_1)x+a_0 \\\\ &amp; =\\dots \\\\ &amp; =(\\dots((a_nx+a_{n-1})x+a_{n-2})x+\\dots+a_1)x+a_0 \\end{aligned}\\) 求多项式的值时, 首先计算内层内一次多项式的值 \\(v_1=a_nx+a_{n-1}\\) \\(v_2=v_1x+a_{n-2}\\) \\(v_3=v_2x+a_{n-3}\\) \\(\\dots\\) \\(v_n=v_{n-1}x+a_0\\) \\(v_n\\) 即为该式的值, 这种算法可以减少大量的幂计算 进位制: 约定满二进一, 就是二进制. 二转十通过按位权展开 十转二通过除二取余法 不等式 分式不等式解法 \\(\\frac{f(x)}{g(x)}&gt;0(\\text{或}&lt;0)\\hArr f(x)\\cdot g(x)&gt;0(\\text{或}&lt;0)\\) \\(\\frac{f(x)}{g(x)}\\geqslant 0(\\text{或}\\leqslant 0)\\hArr\\begin{cases} g(x)\\neq 0 \\\\ f(x)\\cdot g(x)\\geqslant 0(\\text{或}\\leqslant 0) \\end{cases}\\) 二元一次不等式与简单线性规划 二元一次不等式表示平面区域 一般地, 直线 \\(y=kx+b\\) 把平面分成两个部分 \\(y&gt;kx+b\\) 表示直线上方的平面区域; \\(y&lt;kx+b\\) 表示直线下方的平面区域 线性规划 把要求最值的函数称为目标函数 在线性约束条件下求线性目标函数的最值统称为线性规划(即给出一堆限定范围的不等式让你在范围内找出最值) 使目标函数取得最值的可行解叫作这个问题的最优解. “选点法”: 任选一个不在直线上的点. 若满足不等式, 则该点所在的一侧为不等式所表示的平面区域; 否则, 直线另一侧为不等式表示的平面区域 (若直线不过原点, 通常选择原点带入) 简单的线性规划问题 解题思路: 根据题目列出约束条件 (那一堆不等式) 作出目标函数 画出可行域图 (画出约束条件对应的直线, 然后确定每条线规划的平面区域, 它们的重合部分即是满足所有线性要求的区域) 一般来说目标函数的最值在该区域的顶点或边界上取到 基本不等式 定理: 若 \\(a,b\\in R\\) , 则有 \\(a^2+b^2\\geqslant 2ab\\hArr\\frac{a^2+b^2}{2}\\geqslant ab\\) (当且仅当 \\(a=b\\) 时等号成立) 若 \\(a,b&gt;0\\) , 则有 \\(a+b\\geqslant 2\\sqrt{ab}\\hArr\\frac{a+b}{2}\\geqslant\\sqrt{ab}\\) (当且仅当 \\(a=b\\) 时等号成立) 若 \\(a,b,c\\in R\\) , 则有 \\(\\frac{a+b+c}{3}\\geqslant\\sqrt[3]{abc}\\) (当且仅当 \\(a=b\\) 时等号成立) 推论: 若 \\(a,b&gt;0\\) , 则有 \\(\\sqrt{\\frac{a^2+b^2}{2}}\\geqslant\\frac{a+b}{2}\\geqslant\\sqrt{ab}\\geqslant\\frac{2}{\\frac{1}{a}+\\frac{1}{b}}(=\\frac{2ab}{a+b})\\) 基本不等式应用: “一正, 二定, 三相等” 一正 (\\(a,b\\geqslant 0\\)) 二定 (\\(\\sqrt{ab}\\) 定, \\(\\frac{a+b}{2}\\) 有最小值; 反之若 \\(\\frac{a+b}{2}\\) 定, \\(\\sqrt{ab}\\) 有最大值) 三相等 (即 \\(a=b\\)) 不等式大题一般在导数题第二问求恒成立 常用方法: TODO: 补充解法 分离参数法 变换主元法(已知参数的范围求因变量的范围) 不等式选讲 绝对值不等式 绝对值不等式解法: (\\(c&gt;0\\)) \\(|ax+b|\\leqslant c\\hArr -c\\leqslant ax+b\\leqslant c\\) \\(|ax+b|\\geqslant c\\hArr ax+b\\leqslant -c\\) 或 \\(ax+b\\geqslant c\\) 三角不等式: \\(|(|a|-|b|)|\\leqslant|a\\pm b|\\leqslant|a|+|b|\\) 柯西不等式 (Cauchy–Schwarz inequality) 代数形式: 设 \\(a,b,c\\in R\\) , 则 \\((a^2+b^2)(c^2+d^2)\\geqslant(ac+bd)^2\\enspace\\) (当且仅当 \\(ad=bc\\) 时等号成立) 向量形式: 设 \\(\\alpha\\)、\\(\\beta\\) 为平面上的两个向量, 则 \\(\\|\\alpha\\|\\cdot\\|\\beta\\|\\geqslant|\\alpha\\cdot\\beta|\\enspace\\) (当且仅当 \\(\\alpha\\)、\\(\\beta\\) 共线时等号成立) 三角形不等式: 设 \\(x_1,y_2;x_2,y_2;x_3,y_3\\in R\\) , 则 \\(\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}+\\sqrt{(x_2-x_3)^2-(y_2-y_3)^2}\\geqslant\\sqrt{(x_1-x_3)^2+(y_1-y_3)^2}\\) (几何意义为两边之长大于第三边) 柯西不等式可推广为如下一般形式: 设 \\(n\\) 为大于 \\(1\\) 的自然数, \\(a_i\\)、\\(b_i\\enspace\\) (\\(i=1,2,\\dots,n\\)) 为实数, 则 \\(a_1^2+a_2^2+\\dots+a_n^2)(b_1^2+b_2^2+\\dots+b_n^2)\\geqslant(a_1b_1+a_2b_2+\\dots+a_nb_n)^2\\) \\(\\displaystyle\\hArr\\sum_{i=1}^n a_i^2\\cdot\\sum_{i=1}^n b_i^2\\geqslant(\\sum_{i=1}^n a_ib_i)^2\\) 排序不等式 TODO: 向量递归法 设两组实数 \\(a_1,a_2,\\dots,a_n\\) 与 \\(b_1,b_2,\\dots,b_n\\) , 其中 \\(a_1\\leqslant a_2\\leqslant\\dots\\leqslant a_n\\) , \\(b_1\\leqslant b_2\\leqslant\\dots\\leqslant b_n\\) 设 \\(c_1,c_2,\\dots,c_n\\) 为 \\(b_1,b_2,\\dots,b_n\\) 的任意一个排列, 则和数 \\(a_1b_1+a_2b_2+\\dots+a_nb_n\\) 在 \\(a_1,a_2,\\dots,a_n\\) 与 \\(b_1,b_2,\\dots,b_n\\) 同序时最大, 反序时最小 即 \\(a_1b_1+a_2b_2+\\dots+a_nb_n\\geqslant a_1c_1+a_2c_2+\\dots+a_nc_n\\geqslant a_1b_n+a_2b_{n-1}+\\dots+a_nb_1\\) (当且仅当 \\(a_1=a_2=\\dots=a_n\\) 或 \\(b_1=b_2=\\dots=b_n\\) 时等号成立) 伯努利不等式 有 \\(x&gt;-1\\) 当 \\(n\\geqslant 1\\) , 则 \\((1+x)^n\\geqslant 1+nx\\) 当 \\(0\\leqslant n\\leqslant 1\\) , 则 \\((1+x)^n\\leqslant 1+nx\\) 当且仅当 \\(n=0,1\\) 或 \\(x=0\\) 时等号成立 用数学归纳法证明伯努利不等式: (只考虑 \\(n\\geqslant 1\\) 的情况) 当 \\(n=1\\) 时, 代入得 \\(1+x\\geqslant 1+x\\) 显然成立 假设 \\(n=k\\) 时 \\((1+x)^k\\geqslant 1+kx\\) 成立, 那么当 \\(n=k+1\\) 时, 有假设 \\((1+x)^{k+1}\\geqslant 1+(k+1)x\\) 将 \\((1+x)^k\\geqslant 1+kx\\) 两边乘以 \\((1+x)\\) 得到 \\((1+x)^k(1+x)\\geqslant(1+kx)(1+x)\\) 可化为 \\((1+x)^{k+1}\\geqslant kx^2 + 1 + (k+1)x\\) 显然 \\(kx^2 + 1 + (k+1)x\\geqslant 1 + (k+1)x\\) 所以假设 \\((1+x)^{k+1}\\geqslant 1+(k+1)x\\) 成立 平均值不等式 基本不等式可推广到 \\(\\frac{a_1+a_2+\\dots+a_n}{n}\\geqslant\\sqrt[n]{a_1a_2\\dots a_n}\\) (当且仅当 \\(a_1=a_2=\\dots=a_n\\) 时等号成立) \\(\\frac{a_1+a_2+\\dots+a_n}{n}\\) 称为算术平均数 \\(\\sqrt[n]{a_1a_2\\dots a_n}\\) 称为几何平均数 证明不等式的基本方法 比较法 比较法分比差法和比商法, 比差法利用基本事实 \\(a-b&gt;0\\hArr a&gt;b\\) 比商法利用基本事实 \\(\\frac{a}{b}&gt;1\\hArr a&gt;b\\enspace\\) (\\(a,b&gt;0\\)) 综合法 从已知条件出发, 利用不等式的有关性质或定理, 经过推理论证, 最终推导出所要证明的不等式成立. 分析法 从待证不等式出发, 逐步寻求使它成立的充分条件, 直到将待证不等式归结为一个已成立的不等式(已知条件、定理等). 反证法 运用反证法证明不等式, 主要有以下两个步骤: 作出与所证不等式相反的假设; 从条件和假设出发, 应用正确的推理方法, 推出矛盾的结论, 否定假设, 从而证明原不等式成立 放缩法 在证明不等式时, 有时要把所证不等式的一边适当放大或缩小以利于化简, 并使它与不等式的另一边的不等关系更为明显, 从而得出原不等式成立. 这种方法称为放缩法. 证明 \\(A&lt;B\\) , 放大 \\(A\\) , 有 \\(A\\leqslant C\\) , 使得容易证明 \\(C&lt;B\\) 或缩小 \\(B\\) , 有 \\(B\\geqslant C\\) , 使得容易证明 \\(C&gt;A\\) 统计与概率 统计 随机抽样 简单随机抽样: 设一个总体含有N个个体, 从中逐个不放回地抽取n个个体为样本, 如果每次抽取时总体上各个个体被抽到的机会相等. 就把这种抽样方法叫做简单随机抽样. 常用的简单随机抽样法有两种: 抽签法和随机数法 抽签法: 把总体中的N个个体编号, 把号码写在号签上, 将号签放在一个不透明容器中, 搅拌均匀后, 每次从中抽取一个号签. 连续抽取n次, 就得到一个容量为n的样本. 分层抽样: 在抽样时, 将总体分成互不相交的层, 然后按照一定的比例, 从各层独立地抽取一定数量的个体, 将各层取出的个体合在一起作为样本, 这种抽样方法称为分层抽样. 系统抽样: 又叫做等距抽样法. 先分段(分组), 起始段用简单随机抽样再在各段相同位置取得样本. 极差: 一组数据最大值与最小值 组数: \\(\\frac{极差}{组距}\\) 样本分析 频率分布直方图(以面积的形式反映数据落在各小组的频率情况) 小矩形的面积 \\(=\\) 组距 \\(\\times\\frac{\\text{频率}}{\\text{组距}}=\\) 频率 频率分布直方图中, 各小矩形面积之和等于 \\(1\\) 众数: 最高的矩形底边中点的横坐标 中位数: 中位数左边和右边的直方图的面积应该相等 平均数: 每个小矩形面积乘以小矩形底边中点的横坐标之和 频率分布折线图: 将频率分布直方图中各个矩形的上底边的中点连结起来, 就成了频率分布折线图 总体密度曲线: 随着样本容量的增加, 作图时所分的组数增加, 组距减小, 相应的频率折线图会越来越接近一条光滑的曲线, 统计中称这条光滑的曲线为总体密度曲线 茎叶图: 不仅能够保留原始数据, 而且能够展示数据的分布情况 “茎”: 中间的一列数, 从上到下由小到大, 一般用于存放数据中高位上的数 “叶”: 两边分别记录两个组的数据, 由外到内数越来越小, 一般用于存放数据中低位上的数 标准差 \\(S=\\sqrt{\\frac{1}{n}\\sum_{i=1}^n (x_i-\\bar{x})^2}\\enspace\\) (\\(n\\) 为样本中数据个数) 方差 \\(=S^2\\) 计数原理 分类加法和分布乘法计数 分类加法计数原理: 完成一件事可以有两类不同的方法, 方案一有 \\(m\\) 种不同的方法; 方案二有 \\(n\\) 种不同的方法. 那么完成这件事有 \\(N=m+n\\) 种不同方法. 分步乘法计数原理: 完成一件事需要两个步骤, 做第一步有 \\(m\\) 种不同的方法, 做第二步有 \\(n\\) 种不同的方法. 那么完成这件事有 \\(N=mn\\) 种不同方法. 排列与组合 排列: 从\\(n\\) 个不同元素中取出 \\(m\\enspace\\) (\\(m\\leqslant n\\)) , 按照一定的顺序排成一列 (存在互异性、有序性) 排列数: \\(A_n^m=n(n-1)(n-2)\\dots(n-m+1)=\\frac{n!}{(n-m)!}\\enspace\\) (\\(m\\leqslant n\\) ; \\(m,n\\in N^+\\)) 将 \\(n\\) 个不同元素全部取出的一个排列, 记作 \\(A_n^n=n!\\enspace\\) (规定 \\(0! = 1\\)) 组合: 从 \\(n\\) 个不同的元素中取出 \\(m\\enspace\\) (\\(m\\leqslant n\\)) 个元素合成一组(与顺序无关, 只取不排) 组合数: \\(C_n^m=\\frac{A_n^m}{A_m^m}=\\frac{n(n-1)(n-2)\\dots(n-m+1)}{m!}=\\frac{n!}{m!(n-m)!}\\enspace\\) (\\(m\\leqslant n\\) , \\(m,n\\in N^+\\)) 组合式性质公式: \\(\\begin{cases} C_n^m=C_n^{n-m} \\\\ C_{n+1}^m=C_n^m+C_n^{m-1} \\end{cases}\\) 二项式定理 二项式定理: \\((a+b)^n=C_n^0 a^n+C_n^1 a^{n-1}b+C_n^2 a^{n-2}b^2+\\dots+C_n^n b^n\\) 二项式系数的性质(结合&quot;杨辉三角&quot;研究推出) 二项式系数: \\(C_n^k\\enspace\\) (\\(k\\in 1,2,3,\\dots,n\\)) (共有 \\(n+1\\) 项) 对称性: 与首末两端&quot;等距离&quot;的两个二项式系式相等. 直线 \\(r=\\frac{n}{2}\\) 为对称轴将二项式系数所表示出的图像分成对称的两部分 增减性与最大值: \\(k&lt;\\frac{n+1}{2}\\rArr\\) 二项式系数大小递增 \\(k&gt;\\frac{n+1}{2}\\rArr\\) 二项式系数大小递减 \\(n\\) 为偶数时, 其最大的二项式系数为 \\(C_n^{\\frac{n}{2}}\\) \\(n\\) 为奇数时, 其最大的二项式系数为 \\(C_n^{\\frac{n-1}{n}}\\) 和 \\(C_n^{\\frac{n+1}{2}}\\) 各二项式系数的和 \\(C_n^0+C_n^1+C_n^2+\\dots+C_n^n=2^n\\) 统计案例 独立性检验的基本方法: 一般地, 对于两个研究对象 I 和 II, I 有两类取值, 即类 A 和类 B; II 也有两类取值, 即类 1 和类 2. 得到如下列联表所示的抽样数据: II 类1 类2 合计 I 类A a b a+b 类B c d c+d 合计 a+c b+d a+b+c+d 要推断 I 和 II 没有关系, 可按下面步骤进行 第一步提出假设 \\(H_0\\) : “I 和 II 没有关系” 第二步根据 2x2 列联表计算统计量 \\(X^2=\\frac{n(ad-bc)^2}{(a+b)(c+d)(a+c)(b+d)}\\enspace\\) (\\(n=a+b+c+d\\)) 第三步对照下面的临界值表, 作出判断: \\(P(X^2)\\) 0.50 0.40 0.25 0.15 0.10 0.05 0.025 0.010 0.005 0.001 \\(X^2\\) 0.455 0.708 1.323 2.072 2.706 3.841 5.024 6.635 7.879 10.828 若 \\(X^2&gt;10.828\\), 则有 99.9% 的把握认为&quot;I 与 II 有关系&quot;(表中表示有 0.1% 的独立性) 若 \\(X^2&gt;6.635\\), 则有 99% 的把握认为&quot;I 与 II 有关系&quot; 若 \\(X^2&gt;2.706\\), 则有 90% 的把握认为&quot;I 与 II 有关系&quot; 若 \\(X^2\\leqslant 2.706\\), 则认为没有充分的证据显示&quot;I 与 II 有关系&quot;, 但也不能作出结论 \\(H_0\\) 成立, 即 I 与 II 没有关系, 只能说证据不足 变量相关性 散点图: 将变量所对应的点在直角坐标系中标出 正相关和负相关: 依据点的散步方式, 若点排列呈现正比例直线则是正相关, 呈现反比例直线是负相关 回归直线方程 最小平方法(最小二乘法): 如果有 \\(n\\) 个样本点 \\((x_1,y_1),(x_2,y_2),\\dots,(x_n,y_n)\\) , 若要求一条最能拟合这些点的直线 \\(\\hat{y}=bx+a\\) , 可通过下面的表达式: \\([y_1-(a+bx_1)]^2+[y_2-(a+bx_2)]^2+\\dots+[y_n-(a+bx_n)]^2\\) 若上述表达式能取得最小值, 将得到的 \\(a\\)、\\(b\\) 的值带入 \\(\\hat{y}=bx+a\\) 就是所要找的最拟合直线. 线性回归方程: 将上面那条表达式使用配方法化简, 就得到了 \\(\\begin{cases} \\hat{b}=\\frac{\\sum_{i=1}^n (x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n (x_i-\\bar{x})^2}=\\frac{\\sum_{i=1}^n x_iy_i-n\\bar{x}\\bar{y}}{\\sum_{i=1}^n x_i^2-n\\bar{x}^2} \\\\ \\hat{a}=\\bar{y}-\\hat{b}\\bar{x} \\end{cases}\\) 带入即可得目标式 \\(\\hat{y}=\\hat{b}x+\\hat{a}\\) 此方程恒经过样本的 \\((\\bar{x},\\bar{y})\\) , 即样本中心点 TODO: 补充最小二乘法细节 回归分析 相关指数 \\(r\\) \\(r=\\frac{\\sum_{i=1}^n (x_i-\\bar{x})(y_i-\\bar{y})}{\\sqrt{\\sum_{i=1}^n (x_i-\\bar{x})^2\\sum_{i=1}^n (y_i-\\bar{y})^2}}=\\frac{\\sum_{i=1}^n x_iy_i-n\\bar{x}\\bar{y}}{\\sqrt{(\\sum_{i=1}^n x_i^2-n(\\bar{x}^2)(\\sum_{i=1}^n y_i^2-n(\\bar{y})^2)}}\\) \\(r\\) 的性质: \\(|r|\\leqslant 1\\) \\(|r|\\) 越接近 \\(1\\) , \\(x\\)、\\(y\\) 的线性相关程度越强 \\(|r|\\) 越接近 \\(0\\) , \\(x\\)、\\(y\\) 的线性相关程度越弱 概率I 事件与概率 随机事件: 在条件 \\(S\\) 下可能发生也可能不发生的事件 互斥事件 互斥: 若 \\(A\\cap B\\) 为不可能事件(\\(A\\cap B=\\varnothing\\)), 则称事件 \\(A\\) 与事件 \\(B\\) 互斥. (即事件 \\(A\\) 与事件\\(B\\) 不会同时发生) 对立: 若 \\(A\\cap B\\) 为不可能事件但 \\(A\\cup B\\) 为必然事件, 则称事件 \\(A\\) 与事件 \\(B\\) 互为对立事件. (事件 \\(A\\) 与事件 \\(B\\) 在任何一次试验中有且仅有一个发生) 古典概型 基本事件: 在一次实验中可能出现的每一个基本结果 基本事件的特点: 任何两个事件是互斥的 任何事件(除不可能事件)都可以表示成某个或某些基本事件的和 古典概型的两个特点: 所有的基本事件只有有限个 每个基本事件出现的可能性相等 古典概型公式: \\(P(A)=\\frac{事件 A 包含的基本事件的个数}{基本事件的总数}\\) 几何概型 几何概型公式: \\(P(A)=\\frac{构成事件 A 的区域长度}{试验的全部结果所构成的区域长度}\\) 概率II 独立性 条件概率 事件 \\(A\\) 发生的前提下 \\(B\\) 发生的概率: \\(P(B|A)=\\frac{P(AB)}{P(B)}\\) 事件独立性 若\\(P(B|A)=P(B)\\) , 则称事件 \\(A\\)、\\(B\\) 独立 事件独立性性质: 事件 \\(A\\)、\\(B\\) 相互独立, 则 \\(\\bar{A}\\) 与 \\(B\\) , \\(A\\) 与 \\(\\bar{B}\\) , \\(\\bar{A}\\) 与 \\(\\bar{B}\\) 也都相互独立 独立事件一定不互斥, 互斥事件一定不独立 离散型随机变量 随机变量: 如果随机试验的结果可以用一个变量来表示, 那么这样的变量叫做随机变量. 常用字母 \\(X,Y,\\xi,\\eta\\) 表示 离散型随机变量: 所有取值可以一一列出的随机变量 \\(n\\) 次重复试验(伯努利试验) 由 \\(n\\) 次试验构成, 且试验之间相互独立, 每次试验的结果仅有两种对立的状态. 二项分布 在 \\(n\\) 次独立重复试验中, 用 \\(X\\) 表示事件 \\(A\\) 发生的次数, 用 \\(p\\) 表示每次试验中事件 \\(A\\) 发生的概率, 则 \\(A\\) 恰好发生 \\(k\\) 次的概率为: \\(P(X=k)=C_n^k p^k(1-p)^{n-k}\\enspace\\) (\\(k=0,1,2,\\dots,n)\\) 可以理解为一个(发生 \\(k\\) 次同时不发生 \\(k-1\\) 的)事件, 再抽象理解为是一个从 \\(n\\) 个样本中抓取 \\(k\\) 的组合 此时称随机变量 \\(X\\) 服从参数为 \\(n\\)、\\(p\\) 的二项分布; 记作 \\(X\\sim B(n,p)\\) 离散均值和离散方差 一般地若离散型随机变量X的概率分布为 \\(X\\) \\(x_1\\) \\(x_2\\) \\(\\dots\\) \\(x_n\\) \\(P(X)\\) \\(p_1\\) \\(p_2\\) \\(\\dots\\) \\(p_n\\) 期望(离散均值): \\(\\displaystyle\\mu=E(X)=\\sum_{i=1}^n x_ip_i\\) 期望的性质: \\(E(aX+b)=aE(X)+b\\) \\(E(X_1+X_2)=E(X_1)+E(X_2)\\) 若 \\(X_1\\)、\\(X_2\\) 相互独立, 则 \\(E(X_1\\cdot X_2)=E(X_1)\\cdot E(X_2)\\) 两点分布期望 \\(E(X)=p\\) 超几何分布期望 \\(E(X)=\\frac{nM}{N}\\) 二项分布期望 \\(E(X)=np\\) 离散方差: \\(\\displaystyle\\sigma^2=V(X)=\\sum_{i=1}^n (x_i-\\mu)^2p_i\\) 离散方差的性质: \\(V(aX+b)=a^2V(X)\\) \\(V(X)=E(X^2)-[E(X)]^2\\) 两点分布方差 \\(V(X)=p(1-p)\\) 超几何分布 \\(V(X)=\\frac{nM(N-M)(N-n)}{N^2(N-1)}\\) 二项分布 \\(V(X)=np(1-p)\\) 超几何分布 一般地, 在含有 \\(M\\) 件次品的 \\(N\\) 件产品中, 任取 \\(n\\) 件, 其中恰有 \\(x\\) 件次品. \\(P(x=l)=\\frac{C_M^k C_{N-M}^{n-k}}{C_N^n}\\enspace\\) (\\(l=1,2,3,\\dots,n\\) ; \\(n\\leqslant N\\) , \\(M\\leqslant N\\)) 不合格数量恰有 \\(l\\) 件的概率分布表如下表所示: 其中 \\(l=\\text{min}(M,n)\\) \\(X\\) \\(0\\) \\(1\\) \\(2\\) \\(\\dots\\) \\(l\\) \\(P\\) \\(\\frac{C_M^0 C_{N-M}^n}{C_N^n}\\) \\(\\frac{C_M^1 C_{N-M}^{n-1}}{C_N^n}\\) \\(\\frac{C_M^2 C_{N-M}^{n-2}}{C_N^n}\\) \\(\\dots\\) \\(\\frac{C_M^l C_{N-M}^{n-l}}{C_N^n}\\) 此时称随机变量 \\(X\\) 服从参数为 \\(n\\)、\\(M\\)、\\(N\\) 的二项分布, 记作 \\(X\\sim H(n, M, N)\\) 正态分布 正态分布密度曲线: \\(\\varphi_{\\mu,\\sigma}(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}\\enspace\\) (\\(x\\in R\\) , \\(\\sigma&gt;0\\)) 其中实数 \\(\\mu\\) 和 \\(\\sigma\\) 为参数, 如果随机变量 \\(X\\) 服从正态分布记作 \\(X\\sim N(\\mu,\\sigma^2)\\) 正态分布的特点: 曲线位于 \\(x\\) 轴上方, 与 \\(x\\) 轴不相交. 曲线是单峰的, 关于 \\(x=\\mu\\) 对称且在 \\(x=\\mu\\) 达到峰值 \\(\\frac{1}{\\sqrt{2\\pi}\\sigma}\\) 曲线与 \\(x\\) 轴之间的面积为 1 当 \\(\\sigma\\) 一定时, 曲线的位置由 \\(\\mu\\) 确定(左右平移), \\(\\mu\\) 称为位置参数 当 \\(\\mu\\) 一定时, 曲线的形状由 \\(\\sigma\\) 确定, \\(\\sigma\\) 称为形状参数 (\\(\\sigma\\) 越小曲线越瘦高, 意味着总体分布越集中; \\(\\sigma\\) 越大曲线越矮胖, 表示总体的分布越分散) \\(P(\\mu-\\sigma&lt;x\\leqslant\\mu+\\sigma)=0.6826\\) \\(P(\\mu-2\\sigma&lt;x\\leqslant\\mu+2\\sigma)=0.9544\\) \\(P(\\mu-3\\sigma&lt;x\\leqslant\\mu+3\\sigma)=0.9974\\) 因此在实际应用中, 通常认为服从正态分布 \\(N(\\mu,\\sigma^2)\\) 的随机变量只取 \\((\\mu-3\\sigma,\\mu+3\\sigma)\\) 之间, 并简称之 \\(3\\sigma\\) 原则 标准正态分布: \\(\\mu=0,\\sigma=1\\rArr f(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}\\enspace\\) (\\(x\\in R\\)) 几何 立体几何初步 空间几何体 圆柱: \\(S=2\\pi r^2+2\\pi rl=2\\pi r(r+l)\\) , \\(V=\\pi r^2h=S_\\text{底}h\\) 圆锥: \\(S=\\pi r^2+\\pi rl=\\pi r(r+l)\\) , \\(V=\\frac{1}{3}\\pi r^2h=\\frac{1}{3}S_\\text{底}h\\) 圆台: \\(S=\\pi r^2+\\pi r^{\\prime 2}+\\frac{1}{2}(2\\pi r+2\\pi r^\\prime)l=\\pi(r^2+r^{^\\prime 2}+rl+r^\\prime l)\\) , \\(V=\\frac{1}{3}\\pi h(R^2+r^2+Rr)=\\frac{1}{3}h(S_{\\text{下底}}+S^\\prime_{\\text{上底}}+\\sqrt{S_{\\text{下底}}S^\\prime_{\\text{上底}}})\\) 球体: \\(S=4\\pi R^2\\) , \\(V=\\frac{4}{3}\\pi R^2\\) 柱体: \\(S_\\text{侧}=ch\\enspace\\) (\\(c\\) 为底面周长) 正棱锥: \\(S_\\text{侧}=\\frac{1}{2}ch^\\prime\\enspace\\) (\\(h^\\prime\\) 为斜高) 台体: \\(S_\\text{侧}=\\frac{1}{2}(c^\\prime+c)h^\\prime\\enspace\\) (\\(h^\\prime\\) 为斜高) 点线面的位置关系 四大公理 公理1: 如果一直线上两点在一个平面内, 那么这条直线在此平面内 推论: 可用于判定一条直线是否在平面内 可用于判定点是否在平面内 可用于检验平面 公理2: 过不在一直线上的三点, 有且只有一个平面 推论: 经过一条直线和这条直线上一点, 有且只有一个平面 经过两天相交直线, 有且只有一个平面 经过两条平行直线, 有且只有一个平面 公理3: 如果两个不重合的平面有一个公共点, 那么它们有且只有一条过该点的公共直线 推论: 可用于判断两个平面是否相交 可用于判断点是否在直线上: \\(A\\in\\alpha\\) , \\(A\\in\\beta\\) , \\(\\alpha\\cap\\beta=l\\) , 则 \\(A\\in l\\) 公理4 平行与同一条直线的两条直线互相平行 线面平行和垂直 定理1 空间中如果两个角的两边分别对应平行, 那么这两个角相等或互补 (直线、平面平行的判定和性质) 定理2 判定定理(直线与平面): 平面外一条直线与此平面内的一条直线平行, 则该直线与此平面平行 符号语言: \\(a\\nsubseteq\\alpha\\) , \\(b\\subset\\alpha\\) , \\(a\\parallel b\\rArr a\\parallel\\alpha\\) 定理3 判定定理(平面与平面): 一个平面内的两条相交直线与另一个平面平行, 则这两个平面平行 符号语言: \\(a\\subset\\alpha\\) , \\(b\\subset\\alpha\\) , \\(a\\cap b=p\\) , \\(a\\parallel\\beta\\)、\\(b\\parallel\\beta\\rArr\\beta\\parallel\\alpha\\) 定理4 性质定理(直线与平面): 一条直线与一个平面平行, 则过这条直线的任一平面与此平面的交线与该直线平行 符号语言: \\(a\\parallel\\alpha\\) , \\(a\\subset\\beta\\) , \\(\\alpha\\cap\\beta=b\\rArr a\\parallel b\\) 定理5 性质定理(平面与平面): 如果两个平行平面同时与第三个平面相交, 那么它们的交线平行 符号语言: \\(\\alpha\\parallel\\beta\\) , \\(\\alpha\\cap\\gamma=a\\) , \\(\\beta\\cap\\gamma=b\\rArr a\\parallel b\\) (直线、平面垂直的判定) 定理6 判定定理(直线与平面): 一条直线与另一个平面内的两条相交直线垂直, 则该直线与此平面垂直 符号语言: \\(a\\perp b\\) , \\(a\\perp c\\) , \\(b\\subset\\alpha\\) , \\(c\\subset\\alpha\\) , \\(b\\cap c=p\\rArr a\\perp\\alpha\\) 定理7 判定定理(平面与平面): 一个平面过另一个平面的垂线, 则这两个平面垂直 符号语言: \\(a\\perp\\alpha\\) , \\(a\\subset\\beta\\rArr\\alpha\\perp\\beta\\) 定理8 性质定理(直线与平面): 垂直于同一平面的两条直线平行 符号语言: \\(a\\perp\\alpha\\) , \\(b\\perp\\alpha\\rArr a\\parallel b\\) 定理9 性质定理(平面与平面): 两个平面垂直, 则一条平面内垂直于交线的直线与另一个平面垂直 符号语言: \\(\\alpha\\perp\\beta\\) , \\(a\\subset\\alpha\\) , \\(\\alpha\\cap\\beta=b\\) , \\(a\\perp b\\rArr a\\perp\\beta\\) 平面解析几何初步 直线与方程 斜率: 若 \\(A(x_1,y_1)\\) , \\(B(x_2, y_2)\\) 则 \\(AB\\) 所在直线斜率 \\(k_{AB}=\\frac{y_2-y_1}{x_2-x_1}\\) 直线方程的几种形式: 点斜式方程(适用于斜率存在的直线): \\(y-y_0=k(x-x_0)\\) 斜截式方程(适用于斜率存在的直线): \\(y=kx+b\\) 两点式方程(适用于斜率存在的直线): \\(\\frac{y-y_2}{y_1-y_2}=\\frac{x-x_2}{x_1-x_2}\\enspace\\) (\\(x_1\\neq x_2\\) , \\(y_1\\neq y_2\\)) 截距式方程(适用于不平行于坐标系和不过原点的直线): \\(\\frac{x}{a}+\\frac{y}{b}=1\\enspace\\) (\\(a\\neq 0\\) , \\(b\\neq 0\\)) 一般式方程(适用于所有直线): \\(Ax+By+C=0\\) 两点间距离公式 \\(|AB|=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}\\) 点到直线距离公式 \\(d=\\frac{|Ax_0+By_0+C|}{\\sqrt{A^2+B^2}}\\) 平行线间距离公式 设: \\(l_1:Ax+By+C_1=0\\) \\(l_2:Ax+By+C_2=0\\) 则两线距离公式为: \\(\\frac{|C_1-C_2|}{\\sqrt{(A+B)}}\\) 根据斜率判定两条直线平行或垂直 \\(l_1\\parallel l_2\\hArr k_1=k_2\\) 或斜率不存在(此时两直线倾斜角都为 90°) \\(l_1\\perp l_2\\hArr k_1\\cdot k_2=-1\\) 或其中一个斜率为 \\(1\\) , 另一个不存在(其中一条直线倾斜角为 90°) 求已知点 \\(x_1,y_1\\) 关于斜率为 \\(k_1\\) 直线的对称点: 得出与该直线垂直且过点 \\(x_1,y_1\\) 的直线然后代入即可 圆与方程 圆的标准方程: \\((x-a)^2+(y-b)^2=r^2\\rArr\\) 圆心 \\((a,b)\\) 圆的一般方程: \\(x^2+y^2+Dx+Ey+F=0\\enspace\\) (\\(D^2+E^2-4F&gt;0\\)) 半径长: \\(\\frac{1}{2}\\sqrt{D^2+E^2-4F}\\) 圆心: \\((-\\frac{D}{2},-\\frac{E}{2})\\) 直线与圆的位置关系 设有直线 \\(y=kx+b\\) , 圆 \\(x^2+y^2+Dx+Ey+F=0\\) , 点 \\(A(x_1,y_1)\\)、\\(B(x_2,y_2)\\) 为直线与圆的交点, \\((x_0,y_0)\\) 为圆上一点 则 弦长公式 \\(|AB|=\\sqrt{1+k^2}\\sqrt{(x_1+x_2)^2-4x_1x_2}=\\sqrt{1+(\\frac{1}{k})^2}\\sqrt{(y_1+y_2)^2-4y_1y_2}\\) 切线方程 \\(x_0x+y_0y=r^2\\) (圆心在原点上适用) 两圆的位置关系 设 \\(C_1:x^2+y^2+D_1x+E_1y+F_1=0\\) , \\(C_2:x^2+y^2+D_2x+E_2y+F_2=0\\) 且两圆相交于 \\(A\\)、\\(B\\) 两点 则点 \\(A\\)、\\(B\\) 所在的直线方程为: \\((D_1-D_2)x+(E_1-E_2)y+F_1-F_2=0\\) 经过两圆公共点的圆为: \\(x^2+y^2+D_1x+E_1y+F_1-\\lambda(x^2+y^2+D_2x+E_2y+F_2)=0\\enspace\\) (\\(\\lambda\\neq -1\\)) 圆锥曲线与方程 椭圆: 椭圆第二定义: 平面内到定点(焦点)的距离与到定直线(准线)距离之比为常数(离心率)的点的轨叫椭圆. 椭圆的标准方程: \\(\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1\\enspace\\) (\\(a&gt;b&gt;0\\)) , 此时焦点在 \\(x\\) 轴 (哪边分母大焦点就在哪个轴) \\(\\frac{y^2}{a^2}+\\frac{x^2}{b^2}=1\\enspace\\) (\\(a&gt;b&gt;0\\)) , 此时焦点在 \\(y\\) 轴 性质: 焦点在 \\(x\\) 轴, 定点为 \\((-c,0)\\)、\\((c,0)\\) , 顶点为 \\((-a,0)\\)、\\((a,0)\\)、\\((0,-b)\\)、\\((0,b)\\) 焦点在 \\(y\\) 轴, 定点为 \\((0,-c)\\)、\\((0,c)\\) , 顶点为 \\((0,-a)\\)、\\((0,a)\\)、\\((-b,0)\\)、\\((b,0)\\) 存在关系 \\(a^2=b^2+c^2\\) 椭圆准线方程: \\(x=\\pm\\frac{a^2}{c}\\) 或 \\(y=\\pm\\frac{a^2}{c}\\) 离心率 \\(e=\\frac{c}{a}\\enspace\\) (\\(0&lt;e&lt;1\\)) \\(e\\) 越大, 椭圆越扁; \\(e\\) 越小, 椭圆越接近于圆 当椭圆焦点不确定在哪个轴上时可设该方程为 \\(mx^2+ny^2=1\\enspace\\) (\\(m&gt;0,n&gt;0,m\\neq n)\\) 若已知椭圆上一点为 \\(P\\) , \\(\\angle{F_1PF_2}=\\theta\\) , 则有 \\(S_{\\triangle F_1PF_2}=b^2\\tan\\frac{\\theta}{2}\\) 双曲线 (这里讨论的双曲线关于 \\(x\\) 轴、\\(y\\) 轴、原点对称) 双曲线第二定义: 平面内到定点(焦点)的距离到定直线(准线)的距离之比为常数(离心率)的点的迹叫双曲线. 双曲线的标准方程: \\(\\frac{x^2}{a^2}-\\frac{y^2}{b^2}=1\\enspace\\) (\\(a&gt;0\\) , \\(b&gt;0\\)) , 此时焦点在 \\(x\\) 轴 , 渐近线方程为 \\(y=\\pm\\frac{b}{a}x\\enspace\\) (被减数是哪个焦点就在哪个上) \\(\\frac{y^2}{a^2}-\\frac{x^2}{b^2}=1\\enspace\\) (\\(a&gt;0\\) , \\(b&gt;0\\)) , 此时焦点在 \\(y\\) 轴 , 渐近线方程为 \\(y=\\pm\\frac{a}{b}x\\) 性质: 存在关系 \\(c^2=a^2+b^2\\) 离心率 \\(e=\\frac{c}{a}\\enspace\\) (\\(e&gt;1\\)) \\(e\\) 越大, 开口越大; \\(e\\) 越小, 开口越小 等轴双曲线: 实虚轴相等. 此时 \\(e=\\sqrt{2}\\) , 渐近线方程为 \\(y=\\pm x\\) 当双曲线的焦点不确定在哪个轴上时可设方程为 \\(mx^2+ny^2=1\\enspace\\) (\\(mn&lt;0\\)) 若已知双曲线的渐近线方程为 \\(\\frac{x}{a}\\pm\\frac{y}{b}=0\\) , 要求双曲线方程, 可设该双曲线方程为 \\(\\frac{x^2}{a^2}-\\frac{y^2}{b^2}=\\lambda\\enspace\\) (\\(\\lambda\\neq0\\)) 再根据题意求 \\(\\lambda\\) 的值 若已知双曲线上一点为 \\(P\\) , \\(\\angle F_1PF_2=\\theta\\) , 则有 \\(S_{\\triangle F_1PF_2}=b^2\\cot\\frac{\\theta}{2}\\) 双曲线的左(右)焦点到左(右)顶点的距离为该焦点到双曲线的最短距离 直线与双曲线位置关系的处理方法: 联立两方程, 消去 \\(y\\) (或 \\(x\\)) , 得到一元二次方程. 在二次项系数不为 \\(0\\) 的情况下考察方程的判别式 \\(\\varDelta&gt;0\\) 时, 直线与双曲线有两个交点 \\(\\varDelta=0\\) 时, 直线与双曲线有一个交点 \\(\\varDelta&lt;0\\) 时, 直线与双曲线没有交点 抛物线 定义: 抛物线上的点到焦点的距离等于该点到准线的距离 标准方程 焦点 准线 \\(y^2=2px\\enspace\\) (\\(p&gt;0\\)) \\((\\frac{p}{2},0)\\) \\(x=-\\frac{p}{2}\\) \\(y^2=-2px\\enspace\\) (\\(p&gt;0\\)) \\((-\\frac{p}{2},0)\\) \\(x=\\frac{p}{2}\\) \\(x^2=2py\\enspace\\) (\\(p&gt;0\\)) \\((0,\\frac{p}{2})\\) \\(y=-\\frac{p}{2}\\) \\(x^2=-2py\\enspace\\) (\\(p&gt;0\\)) \\((0,-\\frac{p}{2})\\) \\(y=\\frac{p}{2}\\) 性质: (设 \\(y=2px\\enspace\\) (\\(p&gt;0\\)), \\(F\\) 为其焦点, 点 \\(A(x_1,y_1)\\)、\\(B(x_2,y_2)\\) 且\\(AB\\) 为其焦点弦, 弦的倾斜角为 \\(\\theta\\)) 离心率 \\(e=1\\) 以抛物线的焦点弦为直径的圆与抛物线的准线相切 \\(x_1x_2=\\frac{p^2}{4}\\) , \\(y_1y_2=-p^2\\) \\(\\frac{1}{|AF|}+\\frac{1}{|BF|}=\\frac{2}{p}\\) \\(|AB|=x_1+x_2+p\\) \\(|AB|=\\frac{2p}{\\sin{^2\\theta}}\\) \\(S_{\\triangle ABO}=\\frac{p^2}{2\\sin{^2\\theta}}\\) 过 \\(A\\)、\\(B\\) 分别作准线的垂线, 垂足分别为 \\(A_1\\)、\\(B_1\\) 则 \\(A_1F\\perp B_1F\\) 此时 \\(A_1\\)、\\(O\\)、\\(B_1\\) 三点共线 焦点弦中, 通经最短 (指垂直于对称轴的焦点弦, 长为\\(2p\\)) 当题中只有给一个点时, 不知对称性. 可设 \\(x^2=2my\\enspace\\) (\\(m\\neq 0)\\) 或 \\(y^2=2mx\\enspace\\) (\\(m\\neq 0\\)) 向量 平面向量 向量的线性运算 加减: 有三角形法则及平行四边形法则、其满足的运算规律有交换率和结合率 数乘: 规定实数 \\(\\lambda\\) 与 \\(\\vec{a}\\) 的积是一个向量, 这种运算叫做向量的数乘. 记作 \\(\\lambda\\vec{a}\\) 性质: (设实数 \\(\\lambda\\) , 向量 \\(\\vec{a}\\)) 结合律: \\(\\lambda(\\mu\\vec{a})=(\\lambda\\mu)\\vec{a}\\) 分配律: \\((\\lambda+\\mu)\\vec{a}=\\lambda\\vec{a}+\\mu\\vec{a}\\) \\(\\lambda(\\vec{a}+\\vec{b})=\\lambda\\vec{a}+\\lambda\\vec{b}\\) \\(\\lambda(\\vec{a}-\\vec{b})=\\lambda\\vec{a}-\\lambda\\vec{b}\\) \\((-\\lambda)\\vec{a}=-(\\lambda\\vec{a})=\\lambda(-\\vec{a})\\) 向量的坐标表示和基本定理 向量的坐标表示 一个向量的坐标表示一条从原点到此坐标的有向线段(若始点坐标非零则是终点坐标减去始点坐标) 设 \\(\\vec{a}=(x_1,y_1)\\) , \\(\\vec{b}=(x_2,y_2)\\) , 则 \\(\\vec{a}+\\vec{b}=(x_1+x_2,y_1+y_2)\\) \\(\\vec{a}-\\vec{b}=(x_1-x_2,y_1-y_2)\\) \\(\\lambda\\vec{a}=(\\lambda x_1,\\lambda y_1)\\) 正交分解 把一个向量分解成两个相互垂直的向量, 叫做把向量正交分解 \\((x_i,y_i)\\hArr(x_i,0)\\) , \\((0,y_i)\\) 向量共线基本定理 \\(\\vec{a}\\) 与 \\(\\vec{b}\\) 共线(\\(\\vec{a}\\parallel\\vec{b}\\) , \\(\\vec{b}\\neq 0\\)) 当且仅当有唯一实数 \\(\\lambda\\) 使 \\(\\vec{b}=\\lambda\\vec{a}\\) 两向量平行或垂直的判定 设 \\(\\vec{a}=(x_1,y_1)\\) , \\(\\vec{b}=(x_2,y_2)\\) 若 \\(\\vec{a}\\parallel\\vec{b}\\enspace\\) (\\(\\vec{b}\\neq\\vec{0}\\)) \\(\\hArr\\frac{x_1}{x_2}=\\frac{y_1}{y_2}\\hArr x_1y_2-x_2y_1=0\\) (内项积等于外项积) 若 \\(\\vec{a}\\perp\\vec{b}\\hArr\\vec{a}\\cdot\\vec{b}=0\\hArr x_1x_2+y_1y_2=0\\) 数量积 (向量点乘) \\(\\vec{a}\\cdot\\vec{b}=\\|\\vec{a}\\|\\|\\vec{b}\\|\\cos{\\theta}\\) , 其中 \\(\\theta\\) 是 \\(\\vec{a}\\) 与 \\(\\vec{b}\\) 的夹角 性质: 交换律 \\(\\vec{a}\\cdot\\vec{b}=\\vec{b}\\cdot\\vec{a}\\) 当 \\(\\vec{a}\\) 与 \\(\\vec{b}\\) 同向时, \\(\\vec{a}\\cdot\\vec{b}=\\|\\vec{a}\\|\\|\\vec{b}\\|\\) 当 \\(\\vec{a}\\) 与 \\(\\vec{b}\\) 反向时, \\(\\vec{a}\\cdot\\vec{b}=-\\|\\vec{a}\\|\\|\\vec{b}\\|\\) 向量模长的平方 \\(\\|\\vec{a}\\|^2=\\vec{a}\\cdot\\vec{a}\\hArr\\|\\vec{a}\\|=\\sqrt{\\vec{a}\\cdot\\vec{a}}\\) \\(|\\vec{a}\\cdot\\vec{b}|\\leqslant\\|\\vec{a}\\|\\cdot\\|\\vec{b}\\|\\) 若 \\(\\vec{a}=(x_1,y_1)\\) , \\(\\vec{b}=(x_2,y_2)\\) , 则 \\(\\vec{a}\\cdot\\vec{b}=x_1x_2+y_1y_2\\) \\(\\cos\\theta=\\frac{\\vec{a}\\cdot\\vec{b}}{\\|\\vec{a}\\|\\|\\vec{b}\\|}=\\frac{x_1x_2+y_1y_2}{\\sqrt{x_1^2+y_1^2}\\sqrt{x_2^2+y_2^2}}\\) 空间向量 空间向量及其运算 向量共线定理推论: 若 \\(A\\)、\\(B\\)、\\(C\\) 三点共线. 对空间任意一点 \\(P\\) , 都有 \\(\\vec{PC}=\\vec{PA}+\\lambda\\vec{AB}=\\lambda\\vec{PB}+(1-\\lambda)\\vec{PA}\\) 向量共面定理: 若两个向量 \\(\\vec{a}\\)、\\(\\vec{b}\\) 不共线, 则向量 \\(\\vec{p}\\) 与向量 \\(\\vec{a}\\)、\\(\\vec{b}\\) 共面的充要条件是存在 \\((x,y)\\) 使 \\(\\vec{p}=x\\vec{a}+y\\vec{b}\\) 推论: 若 \\(A\\)、\\(B\\)、\\(C\\)、\\(D\\) 四点共面, \\(P\\) 为空间中任意一点 存在有序实数对 \\((x,y)\\) , 使 \\(\\vec{BA}=x\\vec{BC}+y\\vec{BD}\\) 存在有序实数对 \\((x,y)\\) , 使 \\(\\vec{PA}=\\vec{PB}+x\\vec{BC}+y\\vec{BD}\\) 存在 \\(x\\)、\\(y\\)、\\(z\\in R\\) , 使 \\(\\vec{PA}=x\\vec{PB}+y\\vec{PC}+z\\vec{PD}\\enspace\\) (\\(x+y+z=1\\)) 定理: 如果三个变量不共面, 那么对空间任一向量 \\(\\vec{p}\\) , 存在有序实数组 \\(\\{x,y,z\\}\\) 使得 \\(\\vec{p}=x\\vec{a}+y\\vec{b}+z\\vec{c}\\) . 其中集合 \\(\\{\\vec{a},\\vec{b},\\vec{c}\\}\\) 称为空间的一个基底, \\(\\vec{a},\\vec{b},\\vec{c}\\) 称为基向量 空间向量的模长: 若 \\(\\vec{a}=(x,y,z)\\) , 则 \\(\\|\\vec{a}\\|=\\sqrt{x^2+y^2+z^2}\\) 空间向量的数量积: 若 \\(\\vec{a}=(x_1,y_1,z_1)\\)、\\(\\vec{b}=(x_2,y_2,z_2)\\) , 则 \\(\\cos\\text{\\textless}\\vec{a},\\vec{b}\\text{\\textgreater}=\\frac{\\vec{a}\\cdot\\vec{b}}{\\|\\vec{a}\\|\\|\\vec{b}\\|}=\\frac{x_1x_2+y_1y_2+z_1z_2}{\\sqrt{x_1^2+y_1^2+z_1^2}+\\sqrt{x_2^2+y_2^2+z_2^2}}\\) 空间向量的应用 直线的方向向量 设 \\(\\vec{a}\\)、\\(\\vec{b}\\) 分别是直线 \\(l\\)、\\(m\\) 的方向向量 \\(\\vec{a}=\\lambda\\vec{b}\\hArr\\vec{a}\\parallel\\vec{b}\\hArr l\\parallel m\\) \\(\\vec{a}\\cdot\\vec{b}=0\\hArr\\vec{a}\\perp\\vec{b}\\hArr l\\perp m\\) 平面的法向量 如果向量 \\(\\vec{n}\\) 垂直于平面 \\(\\alpha\\), 则向量 \\(\\vec{n}\\) 叫做平面 \\(\\alpha\\) 的法向量 应用: 点面距离向量公式 \\(\\vec{n}\\) 是平面 \\(\\alpha\\) 的法向量, \\(PA\\) 是 \\(\\alpha\\) 的斜线, 则点 \\(P\\) 到 \\(\\alpha\\) 的距离 \\(d=\\frac{|\\vec{n}\\cdot\\vec{PA}|}{\\|\\vec{n}\\|}\\) 直线与平面 设 \\(\\vec{a}\\) 是 \\(l\\) 的方向向量, \\(\\vec{n}\\) 是 \\(\\alpha\\) 的法向量 \\(\\vec{a}=\\lambda\\vec{n}\\hArr\\vec{a}\\parallel\\vec{n}\\hArr l\\perp\\alpha\\) \\(\\vec{a}\\cdot\\vec{n}=0\\hArr\\vec{a}\\perp\\vec{n}\\hArr l\\parallel\\alpha\\) 平面与平面 设 \\(\\vec{u}\\)、\\(\\vec{n}\\) 分别为 \\(\\alpha\\)、\\(\\beta\\) 的法向量 \\(\\vec{u}=\\lambda\\vec{n}\\hArr\\vec{u}\\parallel\\vec{n}\\hArr\\alpha\\parallel\\beta\\) \\(\\vec{u}\\cdot\\vec{n}=0\\hArr\\vec{u}\\perp\\vec{n}\\hArr\\alpha\\perp\\beta\\) 三垂线定理 在平面内的一条直线, 如果和这个平面的一条斜线的射影垂直, 那么它也和这条斜线垂直 符号语言: \\(PO\\perp\\alpha\\) , \\(l\\subset\\alpha\\) , \\(OA\\) 是 \\(PA\\) 在 \\(\\alpha\\) 内的射影. 则 \\(l\\perp OA\\rArr l\\perp PA\\) 三垂线定理的逆定理: 在平面内的一条直线, 如果和这个平面的一条斜线垂直, 那么它也和这条直线在平面内的摄影垂直. 符号语言: \\(PO\\perp\\alpha\\) , \\(l&lt;\\alpha\\) , \\(OA\\) 是 \\(PA\\) 在 \\(\\alpha\\) 内的摄影. 则 \\(l\\perp PA\\rArr l\\perp OA\\) 空间角的求法: 异面直线所成的角 \\((0\\degree,90\\degree]\\) 异面直线 \\(a\\) 与 \\(b\\) 所成角为 \\(\\theta\\) . 且 \\(\\vec{a}\\)、\\(\\vec{b}\\) 分别 \\(a\\)、\\(b\\) 的方向向量 则 \\(\\cos\\theta=|\\cos\\text{\\textless}\\vec{a},\\vec{b}\\text{\\textgreater}|=\\frac{|\\vec{a}\\cdot\\vec{b}|}{\\|\\vec{a}\\|\\|\\vec{b}\\|}\\) 二面角 \\((0\\degree,180\\degree)\\) 二面角 \\(\\theta\\) , \\(\\vec{u}\\)、\\(\\vec{v}\\) 分别是平面 \\(\\alpha\\)、\\(\\beta\\) 的法向量 则 \\(\\cos\\theta=\\cos\\text{\\textless}\\vec{a},\\vec{b}\\text{\\textgreater}=\\frac{\\vec{u}\\cdot\\vec{v}}{\\|\\vec{u}\\|\\|\\vec{v}\\|}\\) (锐二面角) 或 \\(\\cos\\theta=-\\cos\\text{\\textless}\\vec{u},\\vec{v}\\text{\\textgreater}=-\\frac{\\vec{u}\\cdot\\vec{v}}{\\|\\vec{u}\\|\\|\\vec{v}\\|}\\) (钝二面角) 直线与平面所成角 \\((0\\degree,90\\degree]\\) 斜线 \\(PA\\) 与平面 \\(\\alpha\\) 所成角为 \\(\\theta\\) , \\(\\vec{n}\\) 为 \\(\\alpha\\) 的法向量, \\(\\vec{PA}\\) 是斜线 \\(PA\\) 的方向向量 则 \\(\\sin\\theta=|\\cos\\text{\\textless}\\vec{PA},\\vec{n}\\text{\\textgreater}|=\\frac{|\\vec{PA}\\cdot\\vec{n}|}{\\|\\vec{PA}\\|\\|\\vec{n}\\|}\\) 点到直线距离(向量法): 例: 已知直线 \\(l\\) 过点 \\(P(0,0,0)\\) , 其方向向量 \\(\\vec{a}=(1,1,1)\\) , 则点 \\(Q(3,4,5)\\) 到直线的距离为? 解: 点 \\(Q\\) 到直线 \\(l\\) 的距离为 \\(\\sqrt{PQ^2-(\\frac{\\vec{a}\\cdot\\vec{PQ}}{\\|\\vec{a}\\|})^2}=\\sqrt{2}\\) (勾股定理) 坐标系与参数方程 坐标系 伸缩变换: 设点 \\(P(x,y)\\) 是平面直角坐标系中的任意一点, 在变换 \\(\\varphi\\begin{cases} x^\\prime=\\lambda\\cdot x &amp; (\\lambda&lt;0) \\\\ y^\\prime=\\mu\\cdot y &amp; (\\mu&gt;0) \\end{cases}\\) 的作用下, 点 \\(P(x,y)\\) 对应到点 \\(P^\\prime(x^\\prime,y^\\prime)\\) 称 \\(\\varphi\\) 为平面直角坐标系中的坐标伸缩变换, 简称伸缩变换 经过伸缩变换后得到一条关于 \\(x^\\prime,y^\\prime\\) 的曲线方程, 最后要将 \\(x^\\prime,y^\\prime\\) 分别转化为具有普遍意义的 \\(x,y\\), 得到一条关于 \\(x,y\\) 的全新的曲线方程. 极坐标: 在平面内取一个定点 \\(O\\), 叫做极点, 自极点 \\(O\\) 引一条射线 \\(OX\\) , 叫做极轴, 再确定单位长度、角度单位、正方向, 就建立了一个极坐标系. 一般地, 极坐标 \\((P,\\theta)\\) 与 \\((P,\\theta+2k\\pi)\\enspace\\) (\\(k\\in Z\\)) 表示同一个点 特别地, 极点 \\(O\\) 的坐标为 \\((0,\\theta)\\enspace\\) (\\(\\theta\\in R\\)) 和直角坐标系不同, 平面内一个点的极坐标有无数种表示 极坐标与直角坐标的互允公式 互化公式的应用条件: 极点与直角坐标系的原点重合 极轴与直角坐标系的 \\(x\\) 轴正半轴重合 两个坐标系的单位长度相同 极坐标化为直角坐标 \\(\\begin{cases} x=\\rho\\cos\\theta \\\\ y=\\rho\\sin\\theta \\end{cases}\\) 直角坐标化为极坐标: \\(\\begin{cases} \\rho^2=x^2+y^2 \\\\ \\tan\\theta=\\frac{y}{x} \\end{cases}\\) 极坐标内两点的距离公式: 若 \\(A(\\rho_1,\\theta_1)\\) , \\(B(\\rho_2,\\theta_2)\\), 则 \\(|AB|=\\sqrt{\\rho_1^2+\\rho_2^2-2\\rho_1\\rho_2\\cos(\\theta_1-\\theta_2)}\\) 某些题目给出相关信息求极坐标方程可用三角函数进行求解. 取要求的曲线上任一点设为 \\(M(\\rho,\\theta)\\). 结合题意表示出关于变量 \\(\\rho,\\theta\\) 的极坐标方程, 即为题目所求的极坐标方程. 可用此方法推导得出: 设圆心为 \\((\\rho_0,\\theta_0)\\) , 半径为 \\(r\\). 则圆的极坐标方程为 \\(\\rho^2+\\rho_0^2-2\\rho_0\\rho\\cos(\\theta-\\theta_0)=r^2\\) 过点 \\(P(\\rho_1,\\theta_1)\\) 且与极轴所成的角为 \\(\\alpha\\) 的直线的极坐标方程为 \\(\\rho\\sin(\\alpha-\\theta)=\\rho_1\\sin(\\alpha-\\theta_1)\\) 参数方程 参数方程的求法: 建系, 设点 \\((x,y)\\) 选取参数 求出 \\(x,y\\) 与参数之间的表达式 结论 参数方程化为普通方程: 要把参数消去, 还要注意 \\(x,y\\) 的取值范围, 即在消去参数的过程中一定要注意普通方程与参数方程的等价性. 常用的消参技巧: 带入消元, 加减消元, 平方和(差)消元, 三角恒等式消元等 常用消参公式: \\(\\sin^2\\alpha+\\cos^2\\alpha=1\\) , \\((t+\\frac{1}{t})^2-(t-\\frac{1}{t})^2=4\\) 直线的参数方程 经过点 \\(P_0(\\rho_0,\\theta_0)\\) , 且倾斜角为 \\(\\alpha\\) 的直线的标准参数方程为 \\(\\begin{cases} x=x_0+t\\cos\\alpha \\\\ y=y_0+t\\sin\\alpha \\end{cases}\\) (\\(t\\) 为参数) 参数 \\(t\\) 的几何意义是有向线段 \\(P_0P\\) 的位置下标. 即 \\(|t|=P_0P\\) 另一种: 直线的方向向量为 \\(\\vec{P_0P}=(x_0,y_0)\\) , \\(\\begin{cases} x=x_0+at \\\\ y=y_0+bt \\end{cases}\\) (\\(t\\) 为参数) 且\\(|P_0P|=\\sqrt{a^2+b^2}|t|\\) 当 \\(a^2+b^2=1\\) , \\(t=|P_0P|\\) 当 \\(a^2+b^2\\neq 1\\) , \\(t\\) 无明确意义 圆的参数方程 圆心坐标为 \\(M(a,b)\\), 半径 \\(r_0\\) 以圆心为顶点且与 \\(x\\) 轴同向的射线按逆时针方向旋转至角 \\(\\alpha\\) 为参数的圆的参数方程为: \\(\\begin{cases} x=a+r\\cos\\alpha \\\\ y=b+r\\sin\\alpha \\end{cases}\\) (\\(\\alpha\\in[0,2\\pi)\\)) 圆锥曲线的参数方程 椭圆(\\(\\varphi\\) 为离心角) \\(\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1\\enspace\\) (\\(a&gt;b&gt;0\\)) 的一个参数方程为 \\(\\begin{cases} x=a\\cos\\varphi \\\\ y=b\\sin\\varphi \\end{cases}\\) (\\(\\varphi\\) 为参数, \\(a&gt;b&gt;0\\)) \\(\\frac{x^2}{b^2}+\\frac{y^2}{a^2}=1\\enspace\\) (\\(a&gt;b&gt;0\\)) 的一个参数方程为 \\(\\begin{cases} x=b\\cos\\varphi \\\\ y=a\\sin\\varphi \\end{cases}\\) (\\(\\varphi\\) 为参数, \\(a&gt;b&gt;0\\)) 双曲线 \\(\\frac{x^2}{a^2}-\\frac{y^2}{b^2}=1\\enspace\\) (\\(a,b&gt;0\\)) 的一个参数方程为 \\(\\begin{cases} x=a\\sec\\varphi=\\frac{a}{\\cos\\varphi} \\\\ y=b\\tan\\varphi \\end{cases}\\) (\\(\\varphi\\) 为参数, \\(a,b&gt;0\\)) \\(\\frac{y^2}{a^2}-\\frac{x^2}{b^2}=1\\enspace\\) (\\(a,b&gt;0\\)) 的一个参数方程为 \\(\\begin{cases} x=b\\tan\\varphi \\\\ y=a\\sec\\varphi=\\frac{a}{\\cos\\varphi} \\end{cases}\\) (\\(\\varphi\\) 为参数, \\(a,b&gt;0\\)) 抛物线 \\(y^2=2px\\) 的一个参数方程 \\(\\begin{cases} x=2pt^2 \\\\ y=2pt \\end{cases}\\) (\\(t\\) 为参数) 平摆线和渐开线 平摆线: 某一个车轮上的一点 \\(P\\) 因车轮滚动而绘制的轨迹(或称旋轮线) 半径为 \\(r\\) 的车轮周上一点 \\(P\\) 的轨迹的参数方程是 \\(\\begin{cases} x=r(\\theta-\\sin\\theta) \\\\ y=r(1-\\cos\\theta) \\end{cases}\\) (\\(\\theta\\) 为参数) 渐开线: 一条动直线(发生线)沿着一个固定的圆(基圆)作纯滚动时，此动直线上一点的轨迹 参数方程为 \\(\\begin{cases} x=r(\\cos\\theta+\\theta\\sin\\theta) \\\\ y=r(\\sin\\theta-\\theta\\cos\\theta) \\end{cases}\\) (\\(\\theta\\) 为参数)","link":"/zh-cn/learn/mathematics/2020/senior-high-schoool-mathematics/"},{"title":"postgraduate-advanced-mathematics-2","text":"同济高等数学笔记整合(下) 考研用 基于 wmathor/Postgraduate-Advanced-Mathematics 建议先看一看 Introduction to Linear Algebra - Determinant 补充了级数部分的内容 向量代数与空间解析几何 向量及其线性运算 定义 向量: 有大小, 有方向. 向量由大小(长度)及方向唯一确定, 与位置无关的向量称为自由向量 向量相等: 若 \\(\\vec{a}\\)、\\(\\vec{b}\\) 方向相同且长度相同, 称 \\(\\vec{a}\\)、\\(\\vec{b}\\) 相等, 记 \\(\\vec{a}\\)、\\(\\vec{b}\\) 向量的模: 设 \\(\\vec{a}\\) 为一个向量, 其长度记为 \\(|\\vec{a}|\\) 若 \\(|\\vec{a}|=0\\) , 称 \\(\\vec{a}\\) 为零向量, 记 \\(\\vec{a}=\\vec{0}\\) (零向量的方向不确定) 若 \\(|\\vec{a}|=1\\) , 称 \\(\\vec{a}\\) 为单位向量 向量的夹角: 设 \\(\\vec{a}\\)、\\(\\vec{b}\\) , 如图 \\(\\vec{a}\\)、\\(\\vec{b}\\) 夹角为 \\(\\theta\\) , 记 \\((\\widehat{\\vec{a},\\vec{b}})=\\theta\\enspace\\) (\\(0\\leqslant\\theta\\leqslant\\pi\\)) 向量的线性运算 加法: \\(\\vec{a}+\\vec{b}=\\vec{b}+\\vec{a}\\) \\(\\vec{a}+(\\vec{b}+\\vec{c})=(\\vec{a}+\\vec{b})+\\vec{c}\\) 平行四边形法则和三角形法则: 减法: \\(\\vec{a}-\\vec{b}=\\vec{a}+(-\\vec{b})\\) 空间直角坐标系 \\(x\\)、\\(y\\)、\\(z\\) 顺序无所谓, 但必须逆时针排列 \\(z&gt;0\\) \\(z&lt;0\\) \\(x-y\\) 平面 第一卦限 第五卦限 \\(x&gt;0\\) , \\(y&gt;0\\) 第二卦限 第六卦限 \\(x&lt;0\\) , \\(y&gt;0\\) 第三卦限 第七卦限 \\(x&lt;0\\) , \\(y&lt;0\\) 第四卦限 第八卦限 \\(x&gt;0\\) , \\(y&lt;0\\) 空间向量的正交分解: 则有 \\(\\overrightarrow{OM}=\\{a,b,c\\}=a\\vec{i}+b\\vec{j}+c\\vec{k}\\) \\(\\vec{i}\\) 为 \\(x\\) 轴正方向的单位向量 \\(\\overrightarrow{OA}=a\\vec{i}\\) \\(\\vec{j}\\) 为 \\(y\\) 轴正方向的单位向量 \\(\\overrightarrow{OB}=b\\vec{j}\\) \\(\\vec{k}\\) 为 \\(z\\) 轴正反向的单位向量 \\(\\overrightarrow{OC}=c\\vec{k}\\) 向量线性运算的代数描述 设 \\(\\vec{a}=\\{a_1,b_1,c_1\\}\\) , \\(\\vec{b}=\\{a_2,b_2,c_2\\}\\) \\(\\vec{a}+\\vec{b}=\\{a_1+a_2,b_1+b_2,c_1+c_2\\}\\) \\(\\vec{a}-\\vec{b}=\\{a_1-a_2,b_1-b_2,c_1-c_2\\}\\) \\(k\\vec{a}=\\{ka_1,kb_1,kc_1\\}\\) 向量的模, 方向角, 方向余弦. 在坐标轴上的投影 向量的模 设 \\(\\vec{a}=\\{a_1,b_1,c_1\\}\\), 则 \\(\\vec{a}\\) 的模 \\(|\\vec{a}|=\\sqrt{a_1^2+b_1^2+c_1^2}\\) (空间勾股定理) 对应单位向量 设 \\(\\vec{a}=\\{a_1,b_1,c_1\\}\\neq\\vec{0}\\) , \\(\\vec{a}\\) 对应的单位向量记为 \\(\\vec{a}^0\\) \\(\\vec{a}^0=\\frac{1}{|\\vec{a}|}\\cdot\\vec{a}=\\frac{1}{\\sqrt{a_1^2+b_1^2+c_1^2}}\\cdot\\{a_1,b_1,c_1\\}=\\{\\frac{a_1}{\\sqrt{a_1^2+b_1^2+c_1^2}},\\frac{b_1}{\\sqrt{a_1^2+b_1^2+c_1^2}},\\frac{c_1}{\\sqrt{a_1^2+b_1^2+c_1^2}}\\}\\) 方向角和方向余弦 设 \\(\\vec{a}=\\{a_1,b_1,c_1\\}\\neq\\vec{0}\\) , \\(\\vec{a}\\) 与 \\(x\\)、\\(y\\)、\\(z\\) 轴正方向的夹角称为方向角, 记 \\(\\alpha\\)、\\(\\beta\\)、\\(\\gamma\\) 称 \\(\\cos\\alpha\\)、\\(\\cos\\beta\\)、\\(\\cos\\gamma\\) 为 \\(\\vec{a}\\) 的方向余弦 \\(\\because\\cos\\alpha=\\frac{a_1}{|\\vec{a}|}=\\frac{a_1}{\\sqrt{a_1^2+b_1^2+c_1^2}},\\cos\\beta=\\frac{b_1}{|\\vec{a}|}=\\frac{b_1}{\\sqrt{a_1^2+b_1^2+c_1^2}},\\cos\\gamma=\\frac{c_1}{|\\vec{a}|}=\\frac{c_1}{\\sqrt{a_1^2+b_1^2+c_1^2}}\\) \\(\\therefore\\{\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\}=\\vec{a}^0=\\frac{\\vec{a}}{|\\vec{a}|}\\) 推论: \\(\\cos^2\\alpha+\\cos^2\\beta+\\cos^2\\gamma=1\\) 向量在坐标轴上的投影 \\(\\overrightarrow{A_1B_1}\\) 称为 \\(\\overrightarrow{AB}\\) 在 \\(u\\) 轴上的投影向量, \\(\\overrightarrow{A_1B_1}=(x_2-x_1)\\vec{e}\\) \\(A_1B_1=x_2-x_1\\) 称为 \\(\\overrightarrow{AB}\\) 在 \\(u\\) 轴上的投影, 记 \\(Pr j_u\\overrightarrow{AB}\\) 设 \\(\\overrightarrow{AB}\\) 与 \\(u\\) 轴夹角为 \\(\\theta\\) , 则 \\(Pr j_u\\overrightarrow{AB}=|\\overrightarrow{AB}|\\cdot\\cos\\theta\\) 向量的数量积与向量积 向量的数量积(参与运算的是向量, 结果是数) 产生的背景: 做功 \\(W=|\\vec{F}|\\cdot\\cos\\theta\\cdot|\\overrightarrow{AB}|=|\\vec{F}|\\cdot|\\overrightarrow{AB}|\\cdot\\cos(\\widehat{\\overrightarrow{AB},\\vec{F}})\\hArr\\vec{F}\\cdot\\overrightarrow{AB}\\) 向量的数量积定义(几何) \\(\\vec{a}\\cdot\\vec{b}\\) 称为 \\(\\vec{a}\\) 与 \\(\\vec{b}\\) 的数量积 \\(\\vec{a}\\cdot\\vec{b}=|\\vec{a}|\\cdot|\\vec{b}|\\cdot\\cos(\\widehat{\\vec{a},\\vec{b}})\\) 性质 \\(\\vec{a}\\cdot\\vec{b}=\\vec{b}\\cdot\\vec{a}\\) \\(\\vec{a}\\cdot\\vec{a}=|\\vec{a}|^2\\) \\(\\vec{a}\\cdot\\vec{b}=0\\hArr\\vec{a}\\perp\\vec{b}\\) \\(\\vec{a}\\cdot\\vec{a}=0\\hArr\\vec{a}=\\vec{0}\\) 向量数量积的代数描述 设 \\(\\vec{a}=\\{a_1,b_1,c_1\\}=a_1\\vec{i}+b_1\\vec{j}+c_1\\vec{k}\\) \\(\\vec{b}=\\{a_2,b_2,c_2\\}=a_2\\vec{i}+b_2\\vec{j}+c_2\\vec{k}\\) 则 \\(\\vec{a}\\cdot\\vec{b}=(a_1\\vec{i}+b_1\\vec{j}+c_1\\vec{k})\\cdot(a_2\\vec{i}+b_2\\vec{j}+c_2\\vec{k})=a_1a_2+b_1b_2+c_1c_2\\) (推导思路: \\(\\vec{i}\\)、\\(\\vec{j}\\)、\\(\\vec{k}\\) 三个向量为正交单位向量, 互相乘的值为零) 推论: \\(\\vec{a}\\cdot\\vec{b}=0\\hArr\\vec{a}\\perp\\vec{b}\\hArr a_1a_2+b_1b_2+c_1c_2=0\\) 向量的向量积(参与运算的是向量, 结果还是向量) 产生的背景: 法向量(垂直于某一平面的向量) 向量的向量积定义 \\(\\vec{a}\\times\\vec{b}\\) 称为 \\(\\vec{a}\\)、\\(\\vec{b}\\) 的向量积 几何刻划: \\(\\vec{a}\\times\\vec{b}\\begin{cases} \\text{方向:右手准则(拇指食指中指分别对应}\\vec{a},\\vec{b},\\vec{c}) \\\\ \\text{大小:}|\\vec{a}\\times\\vec{b}|=|\\vec{a}|\\cdot|\\vec{b}|\\cdot\\sin(\\widehat{\\vec{a},\\vec{b}}) \\end{cases}\\) 代数刻划: 设 \\(\\vec{a}=\\{a_1,b_1,c_1\\}=a_1\\vec{i}+b_1\\vec{j}+c_1\\vec{k}\\) \\(\\vec{b}=\\{a_2,b_2,c_2\\}=a_2\\vec{i}+b_2\\vec{j}+c_2\\vec{k}\\) 则 $$ \\vec{a}\\times\\vec{b}=\\{b_1c_2-b_2c_1,a_2c_1-a_1c_2,a_1b_2-a_2b_1\\}=\\{ \\begin{vmatrix} b_1 & c_1 \\\\ b_2 & c_2 \\end{vmatrix} ,\\begin{vmatrix} c_1 & a_1 \\\\ c_2 & a_2 \\end{vmatrix} ,\\begin{vmatrix} a_1 & b_1 \\\\ a_2 & b_2 \\end{vmatrix}\\} $$ 推导: $$ \\begin{aligned} \\vec{a}\\times\\vec{b} & =(a_1\\vec{i}+b_1\\vec{j}+c_1\\vec{k})\\times(a_2\\vec{i}+b_2\\vec{j}+c_2\\vec{k}) \\\\ & =\\mskip{1.2em}a_1a_2\\vec{i}\\times\\vec{i}+a_1b_2\\vec{i}\\times\\vec{j}+a_1c_2\\vec{i}\\times\\vec{k} \\\\ & \\mskip{1.2em}+b_1a_2\\vec{j}\\times\\vec{i}+b_1b_2\\vec{j}\\times\\vec{j}+b_1c_2\\vec{j}\\times\\vec{k} \\\\ & \\mskip{1.2em}+c_1a_2\\vec{k}\\times\\vec{i}+c_1b_2\\vec{k}\\times\\vec{j}+c_1c_2\\vec{k}\\times\\vec{k} \\\\ & =\\mskip{1.2em}a_1b_2\\vec{i}\\times\\vec{j}+a_1c_2\\vec{i}\\times\\vec{k} \\\\ & \\mskip{1.2em}+b_1a_2\\vec{j}\\times\\vec{i}+b_1c_2\\vec{j}\\times\\vec{k} \\\\ & \\mskip{1.2em}+c_1a_2\\vec{k}\\times\\vec{i}+c_1b_2\\vec{k}\\times\\vec{j} \\\\ & =a_1b_2\\vec{k}-a_1c_2\\vec{j}-b_1a_2\\vec{k}+b_1c_2\\vec{i}+c_1a_2\\vec{j}-c_1b_2\\vec{i} \\enspace(\\text{结合下面性质3和4}) \\\\ & =(a_1b_2-b_1a_2)\\vec{k}+(c_1a_2-a_1c_2)\\vec{j}+(b_1c_2-c_1b_2)\\vec{i} \\\\ & =\\{b_1c_2-b_2c_1,a_2c_1-a_1c_2,a_1b_2-a_2b_1\\} \\end{aligned} $$ 性质 \\(\\vec{a}\\times\\vec{b}=\\vec{0}\\hArr\\vec{a}\\parallel\\vec{b}\\) \\(\\vec{a}\\times\\vec{b}\\perp\\vec{a},\\vec{b}\\) \\(\\vec{a}\\times\\vec{b}=-\\vec{b}\\times\\vec{a}\\) \\(\\begin{cases} \\vec{i}\\times\\vec{i}=\\vec{0},\\vec{j}\\times\\vec{j}=\\vec{k}\\times\\vec{k}=\\vec{0} \\\\ \\vec{i}\\times\\vec{j}=\\vec{k},\\vec{k}\\times\\vec{i}=\\vec{j},\\vec{j}\\times\\vec{k}=\\vec{i} \\end{cases}\\) \\(|\\vec{a}\\times\\vec{b}|=2S_\\Delta\\) 推导: \\(\\begin{aligned} S_\\Delta &amp; =\\frac{1}{2}|\\vec{a}|\\cdot|\\vec{b}|\\cdot\\sin(\\widehat{\\vec{a},\\vec{b}}) \\\\ &amp; =\\frac{1}{2}|\\vec{a}\\times\\vec{b}| \\end{aligned}\\) 空间曲面及方程 空间曲面 设 \\(F(x,y,z)=0\\) 为一个三元方程, \\(\\Sigma\\) 为曲面 若 \\(F(x,y,z)=0\\) 的任一解 \\((x_0,y_0,z_0)\\) 对应的点 \\(M_0(x_0,y_0,z_0)\\) 在曲面 \\(\\Sigma\\) 上 或者说曲面 \\(\\Sigma\\) 上存在点 \\(M(x_0, y_0, z_0)\\) 使得 \\(F(x_0,y_0,z_0)=0\\) 称 \\(F(x,y,z)=0\\) 为曲面 \\(\\Sigma\\) 的方程, \\(\\Sigma\\) 为方程 \\(F(x,y,z)=0\\) 对应的曲面 记 \\(\\Sigma:F(x,y,z)=0\\) 柱面 \\(\\Sigma:F(x,y)=0\\) 为母线(延伸方向)平行于 \\(z\\) 轴的柱面 \\(\\Sigma:G(y,z)=0\\) 为母线平行于 \\(x\\) 轴的柱面 \\(\\Sigma:H(x,z)=0\\) 为母线平行于 \\(y\\) 轴的柱面 例: 同一个方程 \\(x^2+y^2=4\\) , 在二维坐标系中是一个半径为 2 的圆(称作母线); 在三维坐标系中在 \\(z\\) 轴无限延申, 成为了到 \\(z\\) 轴的距离为 2 的点形成的曲面 设 \\(T(0,0,z)\\) 为 \\(z\\) 轴上一点, \\(\\forall M(x,y,z)\\in\\Sigma\\) 有 \\(|MT|=2\\rArr\\sqrt{(x-0)^2+(y-0)^2+(z-z)^2}=2\\rArr x^2+y^2=4\\) \\(\\therefore\\Sigma:x^2+y^2=4\\) 柱面 \\(\\Sigma:F(x,y)=0\\) 在 \\(xOy\\) 面内的投影曲线为 \\(L:\\begin{cases} F(x,y)=0 \\\\ z=0 \\end{cases}\\) 旋转曲面 设 \\(L:\\begin{cases} F(x,y)=0 \\\\ z=0 \\end{cases}\\) 设 \\(L\\) 绕 \\(x\\) 轴旋转一周形成的曲面为 \\(\\Sigma_x\\) \\(\\forall M(x,y,z)\\in\\Sigma_x\\) , \\(M_0(x,y_0,0)\\in L\\) , \\(T(x, 0, 0)\\) 由 \\(|M_0T|=|MT|\\) 得 \\(\\sqrt{(x-x)^2+(y_0-0)^2+(0-0)^2}=\\sqrt{(x-x)^2+(y-0)^2+(z-0)^2}\\) \\(\\hArr\\sqrt{y_0^2}=\\sqrt{y^2+z^2}\\) \\(\\hArr y_0=\\pm\\sqrt{y^2+z^2}\\) \\(\\because M_0\\in L\\) \\(\\therefore F(x,y_0)=0\\) \\(\\therefore\\Sigma_x:F(x,\\pm\\sqrt{y^2+z^2})=0\\) 设 \\(L\\) 绕 \\(y\\) 轴旋转一周形成的曲面为 \\(\\Sigma_y\\) \\(\\Sigma_y:f(\\pm\\sqrt{x^2+z^2},y)=0\\) (参考绕 \\(x\\) 轴) 空间平面(空间曲面的特殊情形) 平面的点法式方程 设曲面某点 \\(M_0(x_0,y_0,z_0)\\in\\pi\\) , 法向量 \\(\\vec{n}=\\{A,B,C\\}\\perp\\pi\\) \\(\\forall M(x,y,z)\\in\\pi\\rArr\\vec{n}\\perp\\overrightarrow{M_0M}\\rArr\\vec{n}\\cdot\\overrightarrow{M_0M}=0\\) 代入 \\(\\overrightarrow{M_0M}=\\{x-x_0,y-y_0,z-z_0\\}\\) 得到 \\(\\pi:A(x-x_0)+B(y-y_0)+C(z-z_0)=0\\) 截距式方程 \\(\\overrightarrow{AB}=\\{-a,b,0\\}\\) , \\(\\overrightarrow{AC}=\\{-a,0,c\\}\\) 平面 \\(ABC\\) 的法向量 \\(\\vec{n}=\\overrightarrow{AB}\\times\\overrightarrow{AC}=\\{bc,ac,ab\\}\\) 将点 \\(C\\) 代入点法式方程: \\(\\pi:bc(x-a)+ac(y-0)+an(z-0)=0\\rArr bc(x-a)+acy+abz=0\\) \\(\\hArr bcx+acy+abz=abc\\hArr\\frac{x}{a}+\\frac{y}{b}+\\frac{z}{c}=1\\) 即 \\(\\pi:\\frac{x}{a}+\\frac{y}{b}+\\frac{z}{c}=1\\) 一般式方程 \\(\\pi:Ax+By+Cz+D=0\\) , 法向量 \\(\\vec{n}=\\{A,B,C\\}\\) 两个平面夹角 \\(\\pi_1:A_1x+B_1y+C_1z+D_1=0\\) , \\(\\vec{n_1}=\\{A_1,B_1,C_1\\}\\) \\(\\pi_2:A_2x+B_2y+C_2z+D_2=0\\) , \\(\\vec{n_2}=\\{A_2,B_2,C_2\\}\\) 若 \\((\\widehat{\\vec{n_1},\\vec{n_2}})\\in[0,\\frac{\\pi}{2}]\\) , 则平面夹角 \\(\\theta=(\\widehat{\\vec{n_1},\\vec{n_2}})\\) 有 \\(\\cos\\theta=\\cos(\\widehat{\\vec{n_1},\\vec{n_2}})=\\frac{\\vec{n_1}\\cdot\\vec{n_2}}{|\\vec{n_1}|\\cdot|\\vec{n_2}|}\\) 若 \\((\\widehat{\\vec{n_1},\\vec{n_2}})\\in(\\frac{\\pi}{2},\\pi]\\) , 则平面夹角 \\(\\theta=\\pi-(\\widehat{\\vec{n_1},\\vec{n_2}})\\) 有 \\(\\cos\\theta=\\cos(\\pi-(\\widehat{\\vec{n_1},\\vec{n_2}}))=-\\cos(\\widehat{\\vec{n_1},\\vec{n_2}})=-\\frac{\\vec{n_1}\\cdot\\vec{n_2}}{|\\vec{n_1}|\\cdot|\\vec{n_2}|}\\) 平面夹脚应是锐角, 因此综合 1、2 得: \\(\\cos\\theta=|\\frac{\\vec{n_1}\\vec{n_2}}{|\\vec{n_1}|\\cdot|\\vec{n_2}|}|\\) 空间曲线及方程 空间曲线的形式 一般形式 (两个空间曲面的交点集合是一条空间曲线) \\(L:\\begin{cases} F(x,y,z)=0 \\\\ G(x,y,z)=0 \\end{cases}\\) 参数式 \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\\\ z=\\omega(t) \\end{cases}\\) 如: \\(L:\\begin{cases} x^2+y^2=1 \\\\ x+y-z-2=0 \\end{cases}\\rArr\\) 化为参数式 \\(L:\\begin{cases} x=\\cos t \\\\ y=\\sin t \\\\ z=\\sin t+\\cos t-2 \\end{cases}\\) 空间直线(空间曲线的特殊情形) 点向式(对称式)方程: \\(L:\\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}\\) 设 \\(M_0(x_0,y_0,z_0)\\in L\\) , \\(\\vec{S}=\\{m,n,p\\}\\parallel L\\) \\(\\forall M(x,y,z)\\in L\\), 有 \\(\\overrightarrow{M_0M}=\\{x-x_0,y-y_0,z-z_0\\}\\) 且 \\(\\overrightarrow{M_0M}\\parallel\\vec{S}\\) \\(\\because\\overrightarrow{M_0M}\\parallel\\vec{S}\\hArr\\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}\\) \\(\\therefore L:\\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}\\) 参数式方程: 若 \\(\\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}=t\\) 则 \\(L:\\begin{cases} x=mt+x_0 \\\\ y=nt+y_0 \\\\ z=pt+z_0 \\end{cases}\\) 一般式 \\(L:\\begin{cases} A_1x+B_1y+C_1z+D_1=0 \\\\ A_2x+B_2y+C_2z+D_2=0 \\end{cases}\\) (两平面相交得到一条直线) 投影曲线 设 \\(L:\\begin{cases} F(x,y,z)=0 \\\\ G(x,y,z)=0 \\end{cases}\\) 曲线 \\(L\\) 向 \\(xOy\\) 面铅直投影得到投影曲线 \\(L_0\\) 由 \\(\\begin{cases} F(x,y,z)=0 \\\\ G(x,y,z)=0 \\end{cases}\\xRightarrow{\\text{消}\\large z}H(x,y)=0\\) 得到 \\(L_0:\\begin{cases} H(x,y)=0 \\\\ z=0 \\end{cases}\\) 杂知识点 夹角 两向量的夹角: 设向量 \\(\\vec{a}=\\{a_1,b_1,c_1\\}\\) , \\(\\vec{b}=\\{a_2,b_2,c_2\\}\\) , \\((\\widehat{\\vec{a},\\vec{b}})=\\theta \\enspace\\) (\\(0\\leqslant\\theta\\leqslant\\pi\\)) 由 \\(\\vec{a}\\cdot\\vec{b}=|\\vec{a}|\\cdot|\\vec{b}|\\cdot\\cos\\theta\\) 得 \\(\\cos\\theta=\\frac{\\vec{a}\\cdot\\vec{b}}{|\\vec{a}||\\vec{b}|}=\\frac{a_1a_2+b_1b_2+c_1c_2}{\\sqrt{a_1^2+b_1^2+c_1^2}\\sqrt{a_2^2+b_2^2+c_2^2}}\\) 两平面夹角: \\(\\pi_1:A_1x+B_1y+C_1z+D_1=0\\) \\(\\pi_2:A_2x+B_2y+C_2z+D_2=0\\) 设 \\(\\pi_1\\) , \\(\\pi_2\\) 夹角为 \\(\\theta\\) \\((\\widehat{\\vec{n_1},\\vec{n_2}})\\in[0,\\frac{\\pi}{2}]\\) 时 \\(\\theta=(\\widehat{\\vec{n_1},\\vec{n_2}})\\) \\((\\widehat{\\vec{n_1},\\vec{n_2}})\\in(\\frac{\\pi}{2},\\pi]\\) 时 \\(\\theta=\\pi-(\\widehat{\\vec{n_1},\\vec{n_2}})\\) 综合得 \\(\\cos\\theta=|\\cos(\\widehat{\\vec{n_1},\\vec{n_2}})|=\\frac{|\\vec{n_1}\\cdot\\vec{n_2}|}{|\\vec{n_1}||\\vec{n_2}|}=\\frac{|A_1A_2+B_1B_2+C_1C_2|}{\\sqrt{A_1^2+B_1^2+C_1^2}\\sqrt{A_2^2+B_2^2+C_2^2}}\\) 两直线夹角: \\(L_1:\\frac{x-x_1}{m_1}=\\frac{y-y_1}{n_1}=\\frac{z-z_1}{p_1}\\) \\(L_2:\\frac{x-x_2}{m_2}=\\frac{y-y_2}{n_2}=\\frac{z-z_1}{p_2}\\) 设 \\(L_1\\) , \\(L_2\\) 夹脚为 \\(\\theta\\enspace\\) (\\(0\\leqslant\\theta\\leqslant\\frac{\\pi}{2}\\)) \\((\\widehat{\\vec{s_1},\\vec{s_2}})\\in[0,\\frac{\\pi}{2}]\\) , 则 \\(\\theta=(\\widehat{\\vec{s_1},\\vec{s_2}})\\) \\((\\widehat{\\vec{s_1},\\vec{s_2}})\\in(\\frac{\\pi}{2},\\pi]\\) , 则 \\(\\theta=\\pi-(\\widehat{\\vec{s_1},\\vec{s_2}})\\) 综合得 \\(\\cos\\theta=|\\cos(\\widehat{\\vec{s_1},\\vec{s_2}})|=\\frac{|\\vec{s_1}\\cdot\\vec{s_2}|}{|\\vec{s_1}||\\vec{s_2}|}=\\frac{|m_1m_2+n_1n_2+p_1p_2|}{\\sqrt{m_1^2+n_1^2+p_1^2}\\sqrt{m_2^2+n_2^2+p_2^2}}\\) 直线与平面夹角: \\(L:\\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}\\) , \\(\\vec{s}=\\{m,n,p\\}\\parallel L\\) \\(\\pi:Ax+By+Cz+D=0\\) , \\(\\vec{n}=\\{A,B,C\\}\\) 若 \\((\\widehat{\\vec{n},\\vec{s}})\\in[0,\\frac{\\pi}{2}]\\) 则 \\(\\varphi+(\\widehat{\\vec{n},\\vec{s}})=\\frac{\\pi}{2}\\rArr\\varphi=\\frac{\\pi}{2}-(\\widehat{\\vec{n},\\vec{s}})\\) \\(\\therefore\\sin\\varphi=\\cos(\\widehat{\\vec{n},\\vec{s}})\\) 若 \\((\\widehat{\\vec{n},\\vec{s}})\\in(\\frac{\\pi}{2},\\pi]\\) 则 \\((\\widehat{\\vec{n},\\vec{s}})=\\frac{\\pi}{2}+\\varphi\\rArr\\varphi=-(\\frac{\\pi}{2}-(\\widehat{\\vec{n},\\vec{s}}))\\) \\(\\therefore\\sin\\varphi=-\\cos(\\widehat{\\vec{n},\\vec{s}})\\) 综合 1、2 得 \\(\\sin\\varphi=|\\cos(\\vec{n},\\vec{s})|=\\frac{|\\vec{n}\\cdot\\vec{s}|}{|\\vec{n}|\\cdot|\\vec{s}|}\\) 距离 两点距离: 设 \\(A(x_1,y_1,z_1)\\) , \\(B(x_2,y_2,z_2)\\) 则 \\(AB\\) 距离 \\(d=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2+z_1)^2}\\) 点到平面距离 设 \\(\\pi:Ax+By+Cz+D=0\\) , \\(M_0(x_0,y_0,z_0)\\notin\\pi\\) , \\(\\forall M_1(x_1, y_1, z_1)\\in\\pi\\) 有 \\(\\overrightarrow{M_0M_1}=\\{x_1-x_0, y_1-y_0, z_1-z_0\\}\\) $$ \\begin{aligned} Prj_{\\vec{n}}\\overrightarrow{M_0M_1}=\\frac{\\vec{n}\\cdot\\overrightarrow{M_0M_1}}{|\\vec{n}|} & =\\frac{A(x_1-x_0)+B(y_1-y_0)+C(z_1-z_0)}{\\sqrt{A^2+B^2+C^2}} \\\\ & =\\frac{(Ax_1+By_1+Cz_1)-(Ax_0+By_0+Cz_0)}{\\sqrt{A^2+B^2+C^2}} \\end{aligned} $$ 将 \\(M_1\\) 代入平面 \\(\\pi\\) 得 \\(Ax_1+By_1+Cz_1=-D\\) \\(\\therefore Prj_{\\vec{n}}\\overrightarrow{M_0M_1}=-\\frac{Ax_0+By_0+Cz_0+D}{\\sqrt{A^2+B^2+C^2}}\\) \\(\\therefore d=|Prj_{\\vec{n}}\\overrightarrow{M_0M_1}|=\\frac{|Ax_0+By_0+Cz_0+D|}{\\sqrt{A^2+B^2+C^2}}\\) 平面束 \\(L\\) 为直线, 经过 \\(L\\) 的所有平面称为平面束 设 \\(L:\\begin{cases} A_1x+B_1y+C_1z+D_1=0 \\\\ A_2x+B_2y+C_2z+D_2=0 \\end{cases}\\) 过 \\(L\\) 的平面束为 \\(\\pi:A_1x+B_1y+C_1z+D_1+\\lambda(A_2x+B_2y+C_2z+D_2)=0\\) \\(\\hArr\\pi:(A_1+A_2\\lambda)x+(B_1+B_2\\lambda)y+(C_1+C_2\\lambda)z+(D_1+D_2\\lambda)=0\\) 例: 求直线 \\(\\begin{cases} x+y-z-1=0 \\\\ x-y+z+1=0 \\end{cases}\\) 在平面 \\(x+y+z=0\\) 上的投影直线 解: 过直线 \\(L\\) 的平面束为 \\(\\pi:x+y-z-1+\\lambda(x-y+z+1)=0\\) 即 \\(\\pi:(\\lambda+1)x+(1-\\lambda)y+(\\lambda-1)z+\\lambda-1=0\\) 在平面束 \\(\\pi\\) 中找一个平面 \\(\\pi_0\\) , 使其与平面 \\(x+y+z=0\\) 垂直, \\(\\pi_0\\) 与 \\(x+y+z=0\\) 相交的直线即为 \\(L\\) 的投影直线 \\(\\{(\\lambda+1),(1-\\lambda),(\\lambda-1)\\}\\cdot\\{1,1,1\\}=0\\rArr \\lambda=-1\\) 投影直线 \\(L_0:\\begin{cases} 2y-2z-2=0 \\\\ x+y+z=0 \\end{cases}\\) 多元函数微分学及应用 多元函数的基本概念 平面点集 邻域: 设 \\(M_0(x_0, y_0)\\in D\\) , \\(\\delta&gt;0\\) 称 \\(\\{(x, y)|\\sqrt{(x-x_0)^2+(y-y_0)^2}&lt;\\delta\\}\\) 为 \\(M_0\\) 的 \\(\\delta\\) 邻域, 记 \\(\\bigcup(M_0, \\delta)\\) 称 \\(\\{(x, y)|0&lt;\\sqrt{(x-x_0)^2+(y-y_0)^2}&lt;\\delta\\}\\) 为 \\(M_0\\) 的去心 \\(\\delta\\) 邻域, 记 \\(\\mathring{\\bigcup}(M_0, \\delta)\\) 开集: 设 \\(D\\) 为 \\(xOy\\) 面上的点集, 若 \\(\\forall M_0(x_0,y_0)\\in D\\) , \\(\\exist\\delta&gt;0\\) 使 \\(\\bigcup(M_0,\\delta)\\subset D\\) , 称 \\(D\\) 为开集 区域: 连通的开集称为区域(开区域) 闭区域: 开区域连同边界称为闭区域 多元函数的概念(空间中的一个曲面) 设 \\(D\\) 为区域, \\(x,y,z\\) 为变量, 若 \\(\\forall(x,y)\\in D\\) , \\(\\exist z\\) 与 \\((x,y)\\) 对应, 称 \\(z\\) 为 \\((x,y)\\) 的函数, 记 \\(z=f(x,y)\\) \\(D\\) 为定义域, 值域 \\(R=\\{z|z=f(x,y),(x,y)\\in D\\}\\) 多元函数的极限 回顾一元函数极限定义: 设 \\(y=f(x)\\enspace\\) (\\(x\\in D\\)) 若 \\(\\forall\\varepsilon&gt;0\\) , \\(\\exist\\delta&gt;0\\) , 当 \\(0&lt;|x-x_0|&lt;\\delta\\) 时, 有 \\(|f(x)-A|&lt;\\varepsilon\\) 称 \\(A\\) 为 \\(f(x)\\) 当 \\(x\\to x_0\\) 的极限, 记 \\(\\lim\\limits_{x\\to x_0}f(x)=A\\) 二元函数极限定义: 设 \\(z=f(x,y)\\enspace\\) (\\((x,y)\\in D\\)) , \\(M_0(x_0,y_0)\\in D\\) 若 \\(\\forall\\varepsilon&gt;0\\) , \\(\\exist\\delta&gt;0\\) , 当 \\(0&lt;\\sqrt{(x-x_0)^2-(y-y_0)^2}&lt;\\delta\\) 时, 有 \\(|f(x, y)-A|&lt;\\varepsilon\\) 称 \\(A\\) 为 \\(f(x,y)\\) 当 \\((x,y)\\to(x_0,y_0)\\) 的极限, 记 \\(\\lim\\limits_{\\substack{x\\to x_0 \\\\ y\\to y_0}}f(x,y)=A\\) 多元函数连续性与性质 设 \\(z=f(x,y)\\enspace\\) (\\((x,y)\\in D\\)) , \\(M_0(x_0,y_0)\\in D\\) 若 \\(\\lim\\limits_{\\substack{x\\to x_0 \\\\ y\\to y_0}}f(x,y)=f(x_0,y_0)\\) , 称 \\(f(x,y)\\) 在 \\((x_0,y_0)\\) 处连续 多元函数在有界闭区域上的性质 最值定理 设 \\(D\\) 为有界闭区域, \\(f(x,y)\\) 在 \\(D\\) 上连续 则 \\(f(x,y)\\) 在 \\(D\\) 上取到最小值 \\(m\\) 和最大值 \\(M\\) 有界定理 设 \\(D\\) 为有界闭区域, \\(f(x,y)\\) 在 \\(D\\) 上连续 则 \\(\\exist k&gt;0,\\forall(x,y)\\in D\\) , 有 \\(|f(x,y)|\\leqslant k\\) 介值定理 设 \\(D\\) 为有界闭区域, \\(f(x,y)\\) 在 \\(D\\) 上连续 则 \\(\\forall\\delta\\in[m,M]\\) , \\(\\exist(\\xi,\\eta)\\in D\\) 使 \\(f(\\xi,\\eta)=\\delta\\) 偏导数 定义 设 \\(z=f(x,y)\\enspace\\) (\\((x,y)\\in D)\\) , \\(M_0(x_0,y_0)\\in D\\) 偏增量 \\(f(x,y)\\) 在 \\(M_0\\) 处关于 \\(x\\) 的偏增量: \\(\\Delta z_x=f(x_0+\\Delta x,y_0)-f(x_0,y_0)=f(x,y_0)-f(x_0,y_0)\\) \\(f(x,y)\\) 在 \\(M_0\\) 处关于 \\(y\\) 的偏增量: \\(\\Delta z_y=f(x_0, y_0+\\Delta y)-f(x_0, y_0)=f(x_0,y)-f(x_0,y_0)\\) \\(f(x,y)\\) 在 \\(M_0\\) 处的全增量: \\(\\Delta z=f(x_0+\\Delta x,y_0+\\Delta y)-f(x_0,y_0)=f(x,y)-f(x_0,y_0)\\) 偏导数 若 \\(\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta z_x}{\\Delta x}\\) 存在, 称 \\(f(x,y)\\) 在 \\(M_0\\) 处关于 \\(x\\) 可偏导, 该极限称为 \\(f(x,y)\\) 在 \\(M_0\\) 处关于 \\(x\\) 的偏导数, 记 \\(f_x^\\prime(x_0,y_0)\\) 或 \\(\\frac{\\partial z}{\\partial x}|_{(x_0,y_0)}\\) 若 \\(\\lim\\limits_{\\Delta y\\to 0}\\frac{\\Delta z_y}{\\Delta y}\\) 存在, 称 \\(f(x,y)\\) 在 \\(M_0\\) 处关于 \\(y\\) 可偏导, 该极限称为 \\(f(x,y)\\) 在 \\(M_0\\) 处关于 \\(y\\) 的偏导数, 记 \\(f_y^\\prime(x_0,y_0)\\) 或 \\(\\frac{\\partial z}{\\partial y}|_{(x_0,y_0)}\\) 若 \\(\\forall(x,y)\\in D\\) , \\(f(x,y)\\) 对 \\(x\\)、\\(y\\) 皆可偏导, 称 \\(f_x^\\prime(x,y)\\)、\\(f_y^\\prime(x,y)\\) 为 \\(f(x,y)\\) 对 \\(x\\)、\\(y\\) 的偏导数 高阶偏导数 设 \\(z=f(x,y)\\) 在 \\(D\\) 内对 \\(x\\)、\\(y\\) 可偏导, \\(f_x^\\prime(x,y)=\\frac{\\partial z}{\\partial x}\\) 为 \\(f(x,y)\\) 对 \\(x\\) 偏导数, \\(f_y^\\prime(x,y)=\\frac{\\partial z}{\\partial y}\\) 为 \\(f(x,y)\\) 对 \\(y\\) 偏导数. 若 \\(f_x^\\prime(x,y)\\) 对 \\(x\\) 可偏导, 其对 \\(x\\) 的偏导数称为 \\(f(x,y)\\) 对 \\(x\\) 的二阶偏导数, 记 \\(f_{xx}^{\\prime\\prime}\\) 或 \\(\\frac{\\partial^2z}{\\partial x^2}\\) 若 \\(f_y^\\prime(x,y)\\) 对 \\(y\\) 可偏导, 其对 \\(y\\) 的偏导数称为 \\(f(x,y)\\) 对 \\(y\\) 的二阶偏导数, 记 \\(f_{yy}^{\\prime\\prime}\\) 或 \\(\\frac{\\partial^2z}{\\partial y^2}\\) 若 \\(f_x^\\prime(x,y)\\) 对 \\(y\\) 可偏导, 其对 \\(y\\) 的偏导数称为 \\(f(x,y)\\) 对 \\(x\\)、\\(y\\) 的二阶混合偏导数, 记 \\(f_{xy}^{\\prime\\prime}(x,y)\\) 或 \\(\\frac{\\partial^2z}{\\partial x\\partial y}\\) 若 \\(f_y^\\prime(x,y)\\) 对 \\(x\\) 可偏导, 其对 \\(x\\) 的偏导数称为 \\(f(x,y)\\) 对 \\(y\\)、\\(x\\) 的二阶混合偏导数, 记 \\(f_{yx}^{\\prime\\prime}(x,y)\\) 或 \\(\\frac{\\partial^2z}{\\partial y\\partial x}\\) 定理: 若 \\(z=f(x,y)\\) 的二阶混合偏导数 \\(\\frac{\\partial^2z}{\\partial x\\partial y}\\)、\\(\\frac{\\partial^2z}{\\partial y\\partial x}\\) 皆连续, 则 \\(\\frac{\\partial^2z}{\\partial x\\partial y}=\\frac{\\partial^2z}{\\partial y\\partial x}\\) , 即 \\(f_{xy}^{\\prime\\prime}=f_{yx}^{\\prime\\prime}\\) 全微分 二元函数全微分定义 设 \\(z=f(x,y)\\enspace\\) (\\((x,y)\\in D\\)) , \\(M_0(x_0,y_0)\\in D\\) , 全增量 \\(\\Delta z=f(x_0+\\Delta x,y_0+\\Delta y)-f(x_0,y_0)=f(x,y)-f(x_0,y_0)\\) 若 \\(\\Delta z=A\\Delta x+B\\Delta y+\\circ(\\rho)\\) , \\(\\rho=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}\\) 称 \\(f(x,y)\\) 在 \\((x_0,y_0)\\) 处可全微, \\(A\\Delta x+B\\Delta y\\) 为 \\(f(x,y)\\) 在 \\((x_0,y_0)\\) 处的全微分, 记 \\(\\mathrm{d}z|_{(x_0,y_0)}=A\\mathrm{d}x+B\\mathrm{d}y\\) 全微分: \\(\\mathrm{d}z|_{(x_0,y_0)}=f_x^\\prime(x_0,y_0)\\mathrm{d}x+f_y^\\prime(x_0,y_0)\\mathrm{d}y=\\frac{\\partial z}{\\partial x}\\mathrm{d}x+\\frac{\\partial z}{\\partial y}\\mathrm{d}y\\) 性质 设 \\(z=f(x,y)\\enspace\\) (\\((x, y)\\in D\\)) , \\(M_0(x_0,y_0)\\in D\\) 若 \\(f(x,y)\\) 在 \\(M_0\\) 处可微, 则 \\(f(x,y)\\) 在 \\(M_0\\) 连续且可偏导, 反之不对 可微充分条件: 若 \\(z=f(x,y)\\) 连续可偏导, 则 \\(f(x,y)\\) 可微 例: \\(z=f(x,y)=|x|+|y|\\) 在 \\((0,0)\\) 连续, 证 \\(f(x,y)\\) 在 \\((0,0)\\) 不可微 证: \\(\\lim\\limits_{x\\to 0}\\frac{f(x,0)-f(0,0)}{x}=\\lim\\limits_{x\\to 0}\\frac{|x|}{x}\\) 不存在 \\(\\rArr f(x,y)\\) 在 \\((0,0)\\) 对 \\(x\\) 不可偏导. 同理 \\(f(x,y)\\) 在 \\((0,0)\\) 不可偏导 \\(\\therefore f(x,y)\\) 在 \\((0,0)\\) 不可微 多元复合函数求导法则 情形一: \\(z=f(u,v)\\) , \\(\\begin{cases} u=\\varphi(t) \\\\ v=\\psi(t) \\end{cases}\\rArr z=f[\\varphi(t),\\psi(t)]\\) 若 \\(z=f(u,v)\\) 关于 \\(u\\)、\\(v\\) 连续可偏导, \\(\\varphi(t)\\) , \\(\\psi(t)\\) 可导, 则 \\(z=f[\\varphi(t),\\psi(t)]\\) 可导, 且 \\(\\frac{\\mathrm{d}z}{\\mathrm{d}t}=\\frac{\\partial f}{\\partial u}\\cdot\\frac{\\mathrm{d}u}{\\mathrm{d}t}+\\frac{\\partial f}{\\partial v}\\cdot\\frac{\\mathrm{d}v}{\\mathrm{d}t}=f_{u}^\\prime\\cdot\\varphi(t)^\\prime+f_{v}^\\prime\\cdot\\psi^\\prime(t)\\) 证明: (\\(\\Delta u=\\varphi(t+\\Delta t)-\\varphi(t)\\) , \\(\\Delta v=\\psi(t+\\Delta t)-\\psi(t)\\)) \\(\\because z=f(u,v)\\) 关于 \\(u\\)、\\(v\\) 连续可偏导 \\(\\therefore z=f(u,v)\\) 可微 \\(\\therefore\\Delta z=\\frac{\\partial f}{\\partial u}\\Delta u+\\frac{\\partial f}{\\partial v}\\Delta v+\\circ(\\rho)\\) , \\(\\rho=\\sqrt{(\\Delta u)^2+(\\Delta v)^2}\\) \\(\\rArr\\frac{\\Delta z}{\\Delta t}=\\frac{\\partial f}{\\partial u}\\frac{\\Delta u}{\\Delta t}+\\frac{\\partial f}{\\partial v}\\frac{\\Delta v}{\\Delta t}+\\frac{\\circ(\\rho)}{\\Delta t}\\) \\(\\rArr\\frac{\\mathrm{d}z}{\\mathrm{d}t}=\\frac{\\partial f}{\\partial u}\\cdot\\frac{\\mathrm{d}u}{\\mathrm{d}t}+\\frac{\\partial f}{\\partial v}\\cdot\\frac{\\mathrm{d}v}{\\mathrm{d}t}=f_{u}^\\prime\\cdot\\varphi(t)^\\prime+f_{v}^\\prime\\cdot\\psi^\\prime(t)\\) 情形二: \\(z=f(u,v)\\) , \\(\\begin{cases} u=\\varphi(x,y) \\\\ v=\\psi(x,y) \\end{cases}\\rArr z=f[\\varphi(x,y),\\psi(x,y)]\\) \\(z=f(u,v)\\) 关于 \\(u\\)、\\(v\\) 连续可偏导, \\(\\begin{cases} u=\\varphi(x,y) \\\\ v=\\psi(x,y) \\end{cases}\\) 对 \\((x,y)\\) 可偏导 则 \\(z=f[\\varphi(x,y),\\psi(x,y)]\\) 关于 \\(x\\)、\\(y\\) 可偏导, 且 \\(\\frac{\\partial z}{\\partial x}=\\frac{\\partial f}{\\partial u}\\cdot\\frac{\\partial u}{\\partial x}+\\frac{\\partial f}{\\partial v}\\cdot\\frac{\\partial v}{\\partial x}\\) \\(\\frac{\\partial z}{\\partial y}=\\frac{\\partial f}{\\partial u}\\cdot\\frac{\\partial u}{\\partial y}+\\frac{\\partial f}{\\partial v}\\cdot\\frac{\\partial v}{\\partial y}\\) 隐函数求导法则 一个约束条件的情形 隐函数显式化: \\(f(x,y)=0\\rArr y=\\varphi(x)\\) 定理一: 设 \\(F(x,y)\\) 在点 \\(M_0(x_0,y_0)\\) 邻域内连续可偏导且 \\(F(x_0,y_0)=0\\) , 若 \\(F_y^\\prime(x_0,y_0)\\neq 0\\enspace\\) 则由 \\(F(x,y)=0\\) 在 \\(M_0\\) 邻域内确定唯一连续可导函数 \\(y=f(x)\\) 使 \\(y_0=f(x_0)\\) (隐函数显式化), 则 \\(\\dfrac{\\mathrm{d}y}{\\mathrm{d}x}=-\\dfrac{F_x^\\prime}{F_y^\\prime}\\) 证明: \\(F(x,y)=0\\) , 把 \\(y\\) 看成 \\(x\\) 的函数 \\(f(x)\\) , 则 \\(F(x,f(x))=0\\) 两边对 \\(x\\) 求导, \\(F_x^\\prime+F_y^\\prime f^\\prime(x)=F_x^\\prime+F_y^\\prime\\frac{\\mathrm{d}y}{\\mathrm{d}x}=0\\rArr\\frac{\\mathrm{d}y}{\\mathrm{d}x}=-\\frac{F_x^\\prime}{F_y^\\prime}\\) 定理二: 设 \\(F(x,y,z)\\) 在 \\(M_0(x_0,y_0,z_0)\\) 邻域内连续可偏导且 \\(F(x_0,y_0,z_0)=0\\) 若 \\(F_z^\\prime(x_0,y_0,z_0)\\neq 0\\enspace\\) 则由 \\(F(x,y,z)=0\\) 在 \\(M_0\\) 邻域内确定唯一连续可偏导函数 \\(z=\\varphi(x,y)\\) 使 \\(z_0=\\varphi(x_0,y_0)\\) , 则 \\(\\dfrac{\\partial z}{\\partial x}=-\\dfrac{F_x^\\prime}{F_z^\\prime}\\) , \\(\\dfrac{\\partial z}{\\partial y}=-\\dfrac{F_y^\\prime}{F_z^\\prime}\\) 证明: \\(F(x,y,z)=0\\rArr z=\\varphi(x,y)\\) 两边对 \\(x\\) 求偏导, \\(F_x^\\prime+F_z^\\prime\\frac{\\partial z}{\\partial x}=0\\rArr\\frac{\\partial z}{\\partial x}=-\\frac{F_x^\\prime}{F_z^\\prime}\\) 两边对 \\(y\\) 求偏导, \\(F_y^\\prime+F_z^\\prime\\frac{\\partial z}{\\partial y}=0\\rArr\\frac{\\partial z}{\\partial y}=-\\frac{F_y^\\prime}{F_z^\\prime}\\) 多元函数微分学的几何应用 空间曲线(求曲线切线和法平面) 设 \\(M_0(x_0,y_0,z_0)\\in L\\) , \\(M(x_0+\\Delta x,y_0+\\Delta y,z_0+\\Delta z)\\in L\\) \\(\\overrightarrow{M_0M}=\\{\\Delta x,\\Delta y,\\Delta z\\}\\) 直线 \\(\\overline{M_0M}:\\frac{x-x_0}{\\Delta x}=\\frac{y-y_0}{\\Delta y}=\\frac{z-z_0}{\\Delta z}\\) 情况一 \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\\\ z=\\omega(t) \\end{cases}\\) , \\(M_0(x_0,y_0,z_0)\\hArr t=t_0\\) , \\(M(x_0+\\Delta x,y_0+\\Delta y,z_0+\\Delta z)\\hArr t=t_0+\\Delta t\\) \\(\\overline{M_0M}=\\frac{x-x_0}{\\Delta x}=\\frac{y-y_0}{\\Delta y}=\\frac{z-z_0}{\\Delta z}\\hArr\\frac{x-x_0}{\\frac{\\Delta x}{\\Delta t}}=\\frac{y-y_0}{\\frac{\\Delta y}{\\Delta t}}=\\frac{z-z_0}{\\frac{\\Delta z}{\\Delta t}}\\) 当 \\(\\Delta t\\to 0\\) 时, \\(\\overline{M_0M}\\) 即为切线 \\(\\therefore\\) 切线: \\(\\frac{x-x_0}{\\varphi^\\prime(t_0)}=\\frac{y-y_0}{\\psi^\\prime(t_0)}=\\frac{z-z_0}{\\omega^\\prime(t_0)}\\) , 曲线方向向量 \\(\\vec{T}=\\{\\varphi^\\prime,\\psi^\\prime,\\omega^\\prime\\}\\) , 法平面 \\(\\varphi^\\prime(x-x_0)+\\psi^\\prime(y-y_0)+\\omega^\\prime(z-z_0)=0\\) 情况二 \\(L:\\begin{cases} F(x,y,z)=0 \\\\ G(x,y,z)=0 \\end{cases}\\) , \\(M_0(x_0,y_0,z_0)\\in L\\) 曲线方向向量 \\(\\vec{T}=\\{\\begin{vmatrix} F_y^\\prime &amp; F_z^\\prime \\\\ G_y^\\prime &amp; G_z^\\prime \\end{vmatrix},\\begin{vmatrix} F_z^\\prime &amp; F_x^\\prime \\\\ G_z^\\prime &amp; G_x^\\prime \\end{vmatrix},\\begin{vmatrix} F_x^\\prime &amp; F_y^\\prime \\\\ G_x^\\prime &amp; G_y^\\prime \\end{vmatrix}\\}\\) 将曲线方向向量代入切线和法平面方程即可(方程参考情况一) 空间曲面(求曲面切平面和法线) 求空间曲面上某一点的法向量: 设曲面 \\(\\Sigma:F(x,y,z)=0\\) , \\(M_0(x_0,y_0,z_0)\\in\\Sigma\\) 在 \\(\\Sigma\\) 内过 \\(M_0\\) 任取一曲线 \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\\\ z=\\omega(t) \\end{cases}\\) , \\(M_0\\hArr t=t_0\\) \\(\\because L\\subset\\Sigma\\) \\(\\therefore F[\\varphi(t),\\psi(t),\\omega(t)]=0\\) 两边对 \\(t\\) 求导: \\(F_x^\\prime[\\varphi(t),\\psi(t),\\omega(t)]\\cdot\\varphi^\\prime(t)+F_y^\\prime[\\varphi(t),\\psi(t),\\omega(t)]\\psi^\\prime(t)+F_z^\\prime[\\varphi(t),\\psi(t),\\omega(t)]\\omega^\\prime(t)=0\\enspace\\) (多元复合函数求导情形一) 将 \\(t=t_0\\) 代入: \\(F_x^\\prime(x_0,y_0,z_0)\\varphi^\\prime(t_0)+F_y^\\prime(x_0,y_0,z_0)\\psi^\\prime(t_0)+F_z^\\prime(x_0,y_0,z_0)\\omega^\\prime(t_0)=0\\) 可拆为两个向量点乘: \\(\\{F_x^\\prime,F_y^\\prime,F_z^\\prime\\}_{M_0}\\cdot\\{\\varphi^\\prime(t_0),\\psi^\\prime(t_0),\\omega^\\prime(t_0)\\}=0\\) 则法向量 \\(\\vec{n}=\\{F_x^\\prime,F_y^\\prime,F_z^\\prime\\}_{M_0}\\) (后者是曲线在点 \\(M_0\\) 的方向向量, 那么与之垂直的前者就是法向量了) 方向导数与梯度 方向导数 定义 二元函数 设 \\(z=f(x,y)\\enspace\\) (\\((x,y)\\in D\\)) , \\(M_0(x_0,y_0)\\in D\\) 在 \\(xOy\\) 面内过 \\(M_0\\) 作射线 \\(L\\) , 取 \\(M(x_0+\\Delta x,y_0+\\Delta y)\\in L\\) , \\(\\rho=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}\\) \\(\\Delta z=f(x_0+\\Delta x,y_0+\\Delta y)-f(x_0,y_0)\\) 若 \\(\\lim\\limits_{\\rho\\to 0}\\frac{\\Delta z}{\\rho}\\) 存在, 称此极限为函数 \\(z=f(x,y)\\) 在 \\(M_0\\) 处沿射线 \\(L\\) 的方向导数, 记 \\(\\frac{\\partial z}{\\partial L}|_{M_0}\\) 三元函数 设 \\(u=f(x,y,z)\\enspace\\) (\\((x,y,z)\\in\\Omega\\)) , \\(M_0(x_0,y_0,z_0)\\in\\Omega\\) 过 \\(M_0\\) 作射线 \\(L\\), 取 \\(M(x_0+\\Delta x,y_0+\\Delta y,z_0+\\Delta z)\\in L\\) , \\(\\rho=\\sqrt{(\\Delta x)^2+(\\Delta y)^2+(\\Delta z)^2}\\) \\(\\Delta u=f(x_0+\\Delta x,y_0+\\Delta y,z_0+\\Delta z)-f(x_0,y_0,z_0)\\) 若 \\(\\lim\\limits_{\\rho\\to 0}\\frac{\\Delta u}{p}\\) 存在, 称此极限为 \\(u=f(x,y,z)\\) 在 \\(M_0\\) 处沿射线 \\(L\\) 的方向导数, 记 \\(\\frac{\\partial u}{\\partial L}|_{M_0}\\) 方向导数计算方法 二元函数 \\(z=f(x,y)\\) 在 \\(M_0(x_0,y_0)\\) 可微, 在 \\(xOy\\) 面内过 \\(M_0\\) 作射线 \\(L\\) , 方向角为 \\(\\alpha\\)、\\(\\beta\\) , 则 \\(\\frac{\\partial z}{\\partial L}|_{M_0}=f_x^\\prime(x_0,y_0)\\cdot\\cos\\alpha+f_y^\\prime(x_0,y_0)\\cos\\beta\\) 三元函数 \\(u=f(x, y, z)\\) 在 \\(M_0(x_0, y_0, z_0)\\) 可微, 过 \\(M_0\\) 作射线 \\(L\\) , 方向角为 \\(\\alpha\\)、\\(\\beta\\)、\\(\\gamma\\) , 则 \\(\\frac{\\partial u}{\\partial L}|_{M_0}=\\frac{\\partial u}{\\partial x}|_{M_0}\\cos\\alpha+\\frac{\\partial u}{\\partial y}|_{M_0}\\cos\\beta+\\frac{\\partial u}{\\partial z}|_{M_0}\\cos\\gamma\\) 梯度 \\(u=f(x,y,z)\\) , \\(M_0(x_0,y_0,z_0)\\in\\Omega\\) , 过 \\(M_0\\) 作射线 \\(L\\) , 方向角为 \\(\\alpha\\)、\\(\\beta\\)、\\(\\gamma\\) 则有方向导数 \\(\\frac{\\partial u}{\\partial L}|_{M_0}=\\frac{\\partial u}{\\partial x}|_{M_0}\\cos\\alpha+\\frac{\\partial u}{\\partial y}|_{M_0}\\cos\\beta+\\frac{\\partial u}{\\partial z}|_{M_0}\\cos\\gamma\\) 上式可分离为两个向量点乘: \\(\\frac{\\partial u}{\\partial L}|_{M_0}=\\{\\frac{\\partial u}{\\partial x},\\frac{\\partial u}{\\partial y},\\frac{\\partial u}{\\partial z}\\}|_{M_0}\\cdot\\{\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\}\\) 这两个向量中前者称作梯度, 即函数 \\(u\\) 的梯度: \\(\\nabla u=\\{\\frac{\\partial u}{\\partial x}, \\frac{\\partial u}{\\partial y}, \\frac{\\partial u}{\\partial z}\\}|_{M_0}\\) 后者是与 \\(L\\) 同向的单位向量, 记 \\(\\vec{e}=\\{\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\}\\) 则 \\(\\frac{\\partial u}{\\partial L}|_{M_0}=\\nabla u\\cdot\\vec{e}=\\sqrt{(\\frac{\\partial u}{\\partial x})^2+(\\frac{\\partial u}{\\partial y})^2+(\\frac{\\partial u}{\\partial z})^2}\\cdot1\\cdot\\cos\\theta\\enspace\\) (\\(\\theta\\) 为 \\(\\nabla u\\) 与 \\(\\vec{e}\\) 间的夹角) 由该式可知当 \\(\\cos\\theta=1\\) , 即 \\(\\theta=0\\) 时, 这个点的方向导数 \\(\\frac{\\partial u}{\\partial L}|_{M_0}\\) 取最大值 因此梯度的方向即函数增大速度最快的方向, 或方向导数取最大值的方向 代数应用–多元函数的极值 定义: 设\\(z=f(x,y)\\enspace\\) (\\((x, y)\\in D\\)) , \\(M_0(x_0,y_0)\\in D\\) 若 \\(\\exist\\delta&gt;0\\) , \\(\\forall (x,y)\\in\\mathring{\\bigcup}(M_0,\\delta)\\) \\(f(x,y)&gt;f(x_0,y_0)\\) , 称 \\((x_0,y_0)\\) 为极小点 \\(f(x,y)&lt;f(x_0,y_0)\\) , 称 \\((x_0,y_0)\\) 为极大点 无条件极值 设 \\(z=f(x,y)\\enspace\\) (\\((x, y)\\in D\\)) , \\(D\\) 为开区域 求 \\(z=f(x,y)\\) 在 \\(D\\) 内的极值称为无条件极值 通过令 \\(\\begin{cases} \\frac{\\partial z}{\\partial x}=0 \\\\ \\frac{\\partial z}{\\partial y}=0 \\end{cases}\\) 求对应 \\(x\\)、\\(y\\) 值 判别法 设 \\((x_0,y_0)\\) 为驻点, \\(A=f_{xx}^{\\prime\\prime}(x_0,y_0)\\) , \\(B=f_{xy}^{\\prime\\prime}(x_0,y_0)\\) , \\(C=f_{yy}^{\\prime\\prime}(x_0,y_0)\\) 若 \\(AC-B^2&gt;0\\rArr(x_0,y_0)\\) 为极值点 \\(A&lt;0\\rArr(x_0,y_0)\\) 为极大点 \\(A&gt;0\\rArr(x_0,y_0)\\) 为极小点 若 \\(AC-B^2&lt;0\\rArr(x_0,y_0)\\) 不是极值点 条件极值 二元函数: \\(z=f(x,y)\\) , 约束条件 \\(\\varphi(x,y)=0\\) 解法: 设 \\(F=f(x,y)+\\lambda\\varphi(x,y)\\) 令 \\(\\begin{cases} F_x^\\prime=\\frac{\\partial F}{\\partial x}=f_x^\\prime+\\lambda\\varphi_x^\\prime=0 \\\\ F_y^\\prime=\\frac{\\partial F}{\\partial y}=f_y^\\prime+\\lambda\\varphi_y^\\prime=0 \\\\ F_\\lambda^\\prime=\\frac{\\partial F}{\\partial\\lambda}=\\varphi(x,y)=0 \\end{cases}\\) 解方程组, 求出 \\(x\\)、\\(y\\) 值 (之后的就不必多说了吧, 懂得都懂) 三元函数(以及更多元): \\(u=f(x,y,z)\\) , 约束条件 \\(\\begin{cases} \\varphi(x,y,z)=0 \\\\ \\psi(x,y,z)=0 \\end{cases}\\) 解法: 设 \\(F=f+\\lambda\\varphi+\\mu\\psi\\) 令 \\(\\begin{cases} F_x^\\prime=0 \\\\ F_y^\\prime=0 \\\\ F_z^\\prime=0 \\\\ F_\\lambda^\\prime=0 \\\\ F_\\mu^\\prime=0 \\end{cases}\\) 解方程组, 求出 \\(x\\)、\\(y\\)、\\(z\\) 值 重积分 二重积分的概念与性质 二重积分的定义 设 \\(f(x,y)\\) 在 \\(xOy\\) 面有限闭区域 \\(D\\) 内有界 \\(D\\) 可划分为 \\(\\Delta\\sigma_1,\\Delta\\sigma_2,\\dots,\\Delta\\sigma_n\\) \\(\\forall(\\xi_i,\\eta_i)\\in\\Delta\\sigma_i\\) 作 \\(\\displaystyle\\sum_{i=1}^n f(\\xi_i,\\eta_i)\\Delta\\sigma_i\\enspace\\) (\\(\\Delta\\sigma_i\\) 可视为底面面积) \\(\\lambda\\) 为 \\(\\Delta\\sigma_1,\\Delta\\sigma_2,\\dots,\\Delta\\sigma_n\\) 中的最大值 若 \\(\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n f(\\xi_i,\\eta_i)\\Delta\\sigma_i\\) 存在, 称此极限为 \\(f(x,y)\\) 在 \\(D\\) 上的二重积分, 记 \\(\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\) 二重积分的性质 设 \\(f(x,y)\\)、\\(g(x,y)\\) 在区域 \\(D\\) 上可积, 则 \\(\\iint\\limits_D[af(x,y)+bg(x,y)]\\mathrm{d}\\sigma=a\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma+b\\iint\\limits_D g(x,y)\\mathrm{d}\\sigma\\) 若 \\(D=D_1+D_2\\) 且 \\(D_1\\cap D_2=\\varnothing\\) , 则 \\(\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma=\\iint\\limits_{D_1}f(x,y)\\mathrm{d}\\sigma+\\iint\\limits_{D_2}f(x,y)\\mathrm{d}\\sigma\\) \\(\\iint\\limits_D 1\\mathrm{d}\\sigma=A\\) 若 \\(f(x,y)\\geqslant g(x,y)\\enspace\\) (\\((x, y)\\in D\\)) 则 \\(\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\geqslant\\iint\\limits_D g(x,y)\\mathrm{d}\\sigma\\) 若 \\(f(x,y)\\) 和 \\(|f(x,y)|\\) 在 \\(D\\) 上可积, 则 \\(|\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma|\\leqslant\\iint\\limits_D|f(x,y)|\\mathrm{d}\\sigma\\) 二重积分中值定理 \\(D\\) 为有限闭区域, \\(f(x,y)\\) 在 \\(D\\) 上连续 则 \\(\\exist(\\xi,\\eta)\\in D\\) , 使 \\(\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma=f(\\xi,\\eta)A\\enspace\\) (\\(A\\) 为区域 \\(D\\) 的面积) 证明: \\(\\because f(x,y)\\in c(D)\\) \\(\\therefore f(x,y)\\) 在 \\(D\\) 上有上下界 \\(m\\)、\\(M\\) , 使 \\(m\\leqslant f(x,y)\\leqslant M\\) \\(\\therefore \\iint\\limits_D m\\mathrm{d}\\rho\\leqslant\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\leqslant \\iint\\limits_D M\\mathrm{d}\\rho\\) \\(\\rArr m\\iint\\limits_D 1\\mathrm{d}\\rho\\leqslant\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\leqslant M\\iint\\limits_D 1\\mathrm{d}\\rho\\) \\(\\rArr mA\\leqslant\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\leqslant MA\\) \\(\\rArr m\\leqslant\\frac{1}{A}\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\leqslant M\\) \\(\\exist(\\xi,\\eta)\\in D\\) , 使 \\(f(\\xi,\\eta)=\\frac{1}{A}\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma\\rArr\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma=f(\\xi,\\eta)A\\) 二重积分的计算法 直角坐标法计算二重积分 情况1 (沿着 \\(x\\) 轴扫 \\(y\\) 轴) \\(D=\\{(x,y)|a\\leqslant x\\leqslant b,\\varphi_1(x)\\leqslant y\\leqslant \\varphi_2(x)\\}\\) 则 \\(\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma=\\int_a^b[\\int_{\\varphi_1(x)}^{\\varphi_2(x)}f(x,y)\\mathrm{d}y]\\mathrm{d}x\\) 情况2 (沿着 \\(y\\) 轴扫 \\(x\\) 轴) \\(D=\\{(x,y)|c\\leqslant y\\leqslant d,\\varphi_1(y)\\leqslant x\\leqslant\\varphi_2(y)\\}\\) 则 \\(\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma=\\int_c^d[\\int_{\\varphi_1(y)}^{\\varphi_2(y)}f(x,y)\\mathrm{d}x]\\mathrm{d}y\\) 极坐标法计算二重积分 特征: 区域 \\(D\\) 的边界含 \\(x^2+y^2\\) \\(f(x,y)\\) 含 \\(x^2+y^2\\) 变换: \\(\\begin{cases} x=r\\cos\\theta \\\\ y=r\\sin\\theta \\end{cases}\\) , \\(\\alpha\\leqslant\\theta\\leqslant\\beta\\) , \\(r_1(\\theta)\\leqslant r\\leqslant r_2(\\theta)\\) \\(\\mathrm{d}\\sigma\\) 取 \\([\\theta,\\theta+\\mathrm{d}\\theta]\\) 取 \\([r,r+\\mathrm{d}x]\\) 则 \\(\\mathrm{d}\\sigma=\\mathrm{d}r\\cdot r\\mathrm{d}\\theta\\) \\(\\therefore\\iint\\limits_D f(x,y)\\mathrm{d}\\sigma=\\int_\\alpha^\\beta[\\int_{r_1(\\theta)}^{r_2(\\theta)}r\\cdot f(r\\cos\\theta, r\\sin\\theta)\\mathrm{d}r]\\mathrm{d}\\theta\\) 三重积分 三重积分的定义 设 \\(\\Omega\\) 为空间有限几何体, \\(f(x,y,z)\\) 在 \\(\\Omega\\) 上有界 将 \\(\\Omega\\) 划分为 \\(\\Delta V_1,\\Delta V_2,\\dots,\\Delta V_n\\) \\(\\forall(\\xi_i,\\eta_i,\\zeta_i)\\in\\Delta V_i\\) , 作 \\(\\displaystyle\\sum_{i=1}^n f(\\xi_i,\\eta_i,\\zeta_i)\\Delta V_i\\) \\(\\lambda\\) 为 \\(\\Delta V_1,\\Delta V_2,\\dots,\\Delta V_n\\) 直径最大值 若 \\(\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n f(\\xi_i,n_i,\\zeta_i)\\Delta V_i\\) 存在, 称此极限为 \\(f(x,y,z)\\) 在 \\(\\Omega\\) 上的三重积分, 记 \\(\\iiint\\limits_\\Omega f(x,y,z)\\mathrm{d}v\\) 即 \\(\\iiint\\limits_\\Omega f(x,y,z)\\mathrm{d}v=\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n f(\\xi_1,\\eta_i,\\zeta_i)\\Delta V_i\\) (三重积分的几何意义是空间几何体的质量) 三重积分的性质 \\(\\iiint\\limits_\\Omega 1\\mathrm{d}v=V\\) 三重积分中值定理: \\(\\Omega\\) 为有限闭区域, \\(f(x,y,z)\\) 在 \\(\\Omega\\) 上连续, 则 \\(\\exist(\\xi,\\eta,\\zeta)\\in\\Omega\\) 使 \\(\\iiint\\limits_\\Omega f(x,y,z)\\mathrm{d}v=f(\\xi,\\eta,\\zeta)V\\) 三重积分的计算方法 直角坐标法 铅直投影法 (\\(\\Sigma_1\\) 为下半球曲面, \\(\\Sigma_2\\) 为上半球曲面) \\(\\Omega=\\{(x,y,z)|(x,y)\\in Dxy,\\varphi_1(x,y)\\leqslant z\\leqslant\\varphi_2(x,y)\\}\\) \\(\\iiint\\limits_\\Omega f(x,y,z)\\mathrm{d}v=\\iint\\limits_{Dxy}[\\int_{\\varphi_1(x,y)}^{\\varphi_2(x,y)}f(x,y,z)\\mathrm{d}z]\\mathrm{d}x\\mathrm{d}y\\) 切片法 (每层切片的 \\(D\\) 都不同, 用 \\(Dz\\) 表示) \\(\\Omega=\\{(x,y,z)|(x,y)\\in Dz, c\\leqslant z\\leqslant d\\}\\) \\(\\iiint\\limits_\\Omega f(x,y,z)\\mathrm{d}v=\\int_c^d[\\iint\\limits_{Dz} f(x,y,z)\\mathrm{d}x\\mathrm{d}y]\\mathrm{d}z\\) 柱面坐标变换法(柱面坐标=极坐标+\\(z\\) 轴) 特征: 区域 \\(\\Omega\\) 的边界含 \\(x^2+y^2\\) \\(f(x,y,z)\\) 含 \\(x^2+y^2\\) 变换: \\(\\Omega=\\{(x,y,z)|(x,y)\\in Dxy,\\varphi_1(x,y)\\leqslant z\\leqslant\\varphi_2(x,y)\\}\\) 令 \\(\\begin{cases} x=r\\cos\\theta \\\\ y=r\\sin\\theta \\\\ z=z \\end{cases}\\) , 其中 \\(\\alpha\\leqslant\\theta\\leqslant\\beta\\) , \\(r_1(\\theta)\\leqslant r\\leqslant r_2(\\theta)\\) , \\(\\varphi_1(r\\cos\\theta,r\\sin\\theta)\\leqslant z\\leqslant\\varphi_2(r\\cos\\theta,r\\sin\\theta)\\) \\(\\mathrm{d}v\\) \\(\\mathrm{d}v=\\mathrm{d}r\\cdot r\\mathrm{d}\\theta\\cdot\\mathrm{d}z\\) (再乘上 \\(z\\) 轴的微分) \\(\\iiint\\limits_{\\Omega}f(x,y,z)\\mathrm{d}v=\\int_\\alpha^\\beta\\mathrm{d}\\theta\\int_{r_1(\\theta)}^{r_2(\\theta)}\\mathrm{d}r\\int_{\\varphi_1(r\\cos\\theta,r\\sin\\theta)}^{\\varphi_2(r\\cos\\theta,r\\sin\\theta)}r\\cdot f(r\\cos\\theta, r\\sin\\theta,z)\\mathrm{d}z\\) 球面坐标变换法 特征: \\(\\Omega\\) 的表面含 \\(x^2+y^2+z^2\\) \\(f(x,y,z)\\) 含 \\(x^2+y^2+z^2\\) 变换 (\\(OM\\) 跟 \\(Ox\\) 方向的夹角为 \\(\\theta\\) ; 跟 \\(Oz\\) 方向的夹角为 \\(\\varphi\\)) \\(\\begin{cases} x=r\\cos\\theta\\sin\\varphi \\\\ y=r\\sin\\theta\\sin\\varphi \\\\ z=r\\cos\\varphi \\end{cases}\\) \\(\\mathrm{d}v\\) \\([\\theta,\\theta+\\mathrm{d}\\theta]\\) \\([\\varphi,\\varphi+\\mathrm{d}\\varphi]\\) \\([r,r+\\mathrm{d}r]\\) (\\(\\mathrm{d}v\\) 是一个立方体) \\(\\mathrm{d}v=\\mathrm{d}r\\cdot r\\mathrm{d}\\varphi\\cdot r\\sin\\varphi\\mathrm{d}\\theta=r^2\\sin\\varphi\\mathrm{d}r\\mathrm{d}\\theta\\mathrm{d}\\varphi\\) 重积分的应用 几何应用 面积 \\(D\\) 为 \\(xOy\\) 面内有限闭区域, 则 \\(D\\) 的面积为 \\(A=\\iint\\limits_D 1\\mathrm{d}\\sigma\\) 空间曲面的面积 \\(\\Sigma:z=f(x,y)\\enspace\\) (\\((x,y)\\in Dxy\\)) \\(\\forall\\mathrm{d}\\sigma\\subset Dxy\\) 法向量 \\(\\vec{n}=\\{-f_x^\\prime,-f_y^\\prime,1\\}\\) 推导: (来自多元函数微分学的几何应用-空间曲面上某一点的法向量) 若 \\(\\Sigma:F(x,y,z)=0\\), 法向量 \\(\\vec{n}=\\{F_x^\\prime,F_y^\\prime,F_z^\\prime\\}_{M_0}\\) 这里 \\(\\Sigma:z=f(x,y)\\rArr F(x,y,z)=z-f(x,y)=0\\) 因此 \\(\\vec{n}=\\{-f_x^\\prime,-f_y^\\prime,1\\}\\) \\(\\mathrm{d}s=\\sqrt{1+f_x^{\\prime 2}+f_y^{\\prime 2}}\\mathrm{d}\\sigma\\) 推导: \\(\\cos\\gamma=\\frac{1}{\\sqrt{1+f_x^{\\prime 2}+f_y^{\\prime 2}}}\\) (法向量和 \\(z\\) 轴夹角, 参见向量及其线性运算-向量方向角和方向余弦) \\(\\because\\mathrm{d}s\\cos\\gamma=\\mathrm{d}\\sigma\\) \\(\\therefore\\mathrm{d}s=\\sqrt{1+f_x^{\\prime 2}+f_y^{\\prime 2}}\\mathrm{d}\\sigma\\) 面积 \\(A=\\iint\\limits_{Dxy}\\mathrm{d}s=\\iint\\limits_{Dxy}\\sqrt{1+f_x^{\\prime 2}+f_y^{\\prime 2}}\\mathrm{d}\\sigma\\) 物理应用 质心 二维 \\(m=\\iint\\limits_D\\rho(x,y)\\mathrm{d}\\sigma\\) \\(\\bar{x}=\\frac{\\iint\\limits_D x\\rho(x,y)\\mathrm{d}\\sigma}{\\iint\\limits_D\\rho(x,y)\\mathrm{d}\\sigma}\\) , \\(\\bar{y}=\\frac{\\iint\\limits_D y\\rho(x,y)\\mathrm{d}\\sigma}{\\iint\\limits_D\\rho(x,y)\\mathrm{d}\\sigma}\\) 三维 \\(m=\\iiint\\limits_\\Omega\\rho(x,y,z)\\mathrm{d}v\\) \\(\\bar{x}=\\frac{\\iiint\\limits_\\Omega x\\rho(x,y,z)\\mathrm{d}v}{\\iiint\\limits_\\Omega\\rho(x,y,z)\\mathrm{d}v}\\) , \\(\\bar{y}=\\frac{\\iiint\\limits_\\Omega y\\rho(x,y,z)\\mathrm{d}v}{\\iiint\\limits_\\Omega\\rho(x,y,z)\\mathrm{d}v}\\) , \\(\\bar{z}=\\frac{\\iiint\\limits_\\Omega z\\rho(x,y,z)\\mathrm{d}v}{\\iiint\\limits_\\Omega\\rho(x,y,z)\\mathrm{d}v}\\) 转动惯量(刚体绕轴转动时的惯性, 大小为质量乘以距离的平方 \\(I=mr^2\\)) 二维 绕直线 \\(L\\) 旋转: \\(I_L=\\iint\\limits_D d^2\\rho(x,y)\\mathrm{d}\\sigma\\) 绕 \\(x\\) 轴旋转: \\(I_x=\\iint\\limits_D y^2\\rho(x,y)\\mathrm{d}\\sigma\\) 绕 \\(y\\) 轴旋转: \\(I_y=\\iint\\limits_D x^2\\rho(x,y)\\mathrm{d}\\sigma\\) 绕原点旋转: \\(I_o=\\iint\\limits_D(x^2+y^2)\\rho(x,y)\\mathrm{d}\\sigma\\) 三维 \\(I_x=\\iiint\\limits_\\Omega(y^2+z^2)\\rho(x,y,z)\\mathrm{d}v\\) \\(I_y=\\iiint\\limits_\\Omega(x^2+z^2)\\rho(x,y,z)\\mathrm{d}v\\) \\(I_z=\\iiint\\limits_\\Omega(x^2+y^2)\\rho(x,y,z)\\mathrm{d}v\\) 引力 求到质量为 \\(m\\) 的点 \\((0,0,c)\\) 的引力: \\(\\forall\\mathrm{\\sigma}\\subset D\\) \\(\\mathrm{d}|\\vec{F}|=k\\frac{m\\cdot\\rho\\mathrm{d}\\sigma}{x^2+y^2+c^2}\\) (\\(k\\) 为引力常数) \\(\\mathrm{d}|\\vec{F_x}|=\\mathrm{d}|\\vec{F}|\\cdot\\cos\\theta\\cdot\\cos\\alpha\\) \\(\\mskip{2.5em}=\\mathrm{d}|\\vec{F}|\\cdot\\frac{\\sqrt{x^2+y^2}}{\\sqrt{x^2+y^2+c^2}}\\cdot\\frac{x}{\\sqrt{x^2+y^2}}\\) \\(\\mskip{2.5em}=\\frac{km\\cdot\\rho(x,y)\\cdot x}{(x^2+y^2+c^2)^{\\frac{3}{2}}}\\mathrm{d}\\sigma\\) \\(x\\) 轴的分力 \\(|\\vec{F_x}|=\\iint\\limits_{D}\\mathrm{d}|\\vec{F_x}|=km\\iint\\limits_{D}\\frac{x\\rho(x,y)}{(x^2+y^2+c^2)^{\\frac{3}{2}}}\\mathrm{d}\\sigma\\) 曲线积分与曲面积分 对弧长的曲线积分 背景: \\(\\rho(x,y)\\) 为线密度函数 经典积分思想: \\(L\\) 划分为 \\(\\Delta S_1,\\dots,\\Delta S_n\\) \\(\\forall(\\xi_i,\\eta_i)\\in\\Delta S_i\\) \\(\\Delta m_i=\\rho(\\xi_i,\\eta_i)\\Delta S_i\\) 令 \\(\\lambda\\) 为 \\(\\Delta S_1,\\dots,\\Delta S_n\\) 最大值 曲线总质量 \\(m=\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n\\rho(\\xi_i,\\eta_i)\\Delta S_i\\) 元素法思想: \\(\\forall\\mathrm{d}s\\subset L\\) \\(\\mathrm{d}m=\\rho(x,y)\\mathrm{d}s\\) \\(m=\\int_L\\mathrm{d}m=\\int_L\\rho(x,y)\\mathrm{d}s\\) 对弧长曲线积分定义: \\(\\int_L f(x,y)\\mathrm{d}s\\) 性质 \\(\\int_L\\alpha f+\\beta g\\mathrm{d}s=\\alpha\\int_L f\\mathrm{d}s+\\beta\\int_L g\\mathrm{d}s\\) \\(L=L_1+L_2\\) 且 \\(L_1\\cap L_2=\\varnothing\\) , 则 \\(\\int_L f(x,y)\\mathrm{d}s=\\int_{L_1} f(x,y)\\mathrm{d}s+\\int_{L_2} f(x,y)\\mathrm{d}s\\) \\(\\int_L 1\\mathrm{d}s=L\\) 若在 \\(L\\) 上 \\(f(x,y)\\leqslant g(x,y)\\) , 则 \\(\\int_L f(x,y)\\mathrm{d}s\\geqslant\\int_L g(x,y)\\mathrm{d}s\\) \\(|\\int_L f(x,y)\\mathrm{d}s|\\leqslant\\int_L|f(x,y)|\\mathrm{d}s\\) 对弧长曲线积分计算方法 \\(L\\) 为直角坐标形式 \\(L:y=\\varphi(x)\\enspace\\) (\\(a\\leqslant x\\leqslant b)\\) \\(\\mathrm{d}s=\\sqrt{(\\mathrm{d}x)^2+(\\mathrm{d}y)^2}=\\sqrt{1+(\\frac{\\mathrm{d}y}{\\mathrm{d}x})^2}\\mathrm{d}x=\\sqrt{1+[f^\\prime(x)]^2}\\mathrm{d}x\\) \\(\\int_L f(x,y)\\mathrm{d}s=\\int_a^b f[x,\\varphi(x)]\\sqrt{1+[f^\\prime(x)]^2}\\mathrm{d}x\\) \\(L\\) 为参数形式 \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\end{cases}\\enspace\\) (\\(\\alpha\\leqslant t\\leqslant\\beta\\)) \\(\\mathrm{d}s=\\sqrt{[\\varphi^\\prime(t)]^2+[\\psi^\\prime(t)]^2}\\mathrm{d}t\\) \\(\\int_L f(x,y)\\mathrm{d}s=\\int_\\alpha^\\beta f[\\varphi(t),\\psi(t)]\\cdot\\sqrt{[\\varphi^\\prime(t)]^2+[\\psi^\\prime(t)]^2}\\mathrm{d}t\\) 对坐标的曲线积分(第二类曲线积分) 背景: 做功(力的正交分解) 二维 \\(\\vec{F}=\\{P(x,y),Q(x,y)\\}\\) \\(\\forall\\vec{\\mathrm{d}s}\\subset L\\) \\(\\vec{\\mathrm{d}s}=\\{\\mathrm{d}x,\\mathrm{d}y\\}\\) \\(\\mathrm{d}w=\\vec{F}\\cdot\\vec{\\mathrm{d}s}=P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y\\) \\(w=\\int_L\\mathrm{d}w=\\int_L p(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y\\) 三维 \\(\\forall\\vec{d}s\\subset L\\) \\(\\vec{d}s=\\{\\mathrm{d}x,\\mathrm{d}y,\\mathrm{d}z\\}\\) \\(\\mathrm{d}w=\\vec{F}\\cdot\\vec{\\mathrm{d}s}=P\\mathrm{d}x+Q\\mathrm{d}y+R\\mathrm{d}z\\) \\(w=\\int_L\\mathrm{d}w=\\int_L P\\mathrm{d}x+Q\\mathrm{d}y+R\\mathrm{d}z\\) 对坐标的曲线积分定义 二维: \\(\\int_L P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y\\) 其中 \\(\\int_L P(x,y)\\mathrm{d}x\\) 称为函数 \\(P(x,y)\\) 在有向曲线段 \\(L\\) 上对坐标 \\(x\\) 的曲线积分. 三维: \\(\\int_L P(x,y,z)\\mathrm{d}x+Q(x,y,z)\\mathrm{d}y+R(x,y,z)\\mathrm{d}z\\) 性质 \\(\\int_L [af_1(x,y)+bf_2(x,y)]\\mathrm{d}x=a\\int_L f_1(x,y)\\mathrm{d}x+b\\int_L f_2(x,y)\\mathrm{d}x\\) \\(\\int_{L^-}P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y=-\\int_L P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y\\) 对坐标的曲线积分基本计算法(二维) 直角坐标法 对 \\(\\int_L P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y\\) \\(L:y=\\varphi(x)\\enspace\\) (\\(x\\in[a,b]\\)) \\(\\int_L P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y=\\int_a^b P[x,\\varphi(x)]\\mathrm{d}x+Q[x,\\varphi(x)]\\cdot\\varphi^\\prime(x)\\mathrm{d}x\\) 参数方程法 \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\end{cases}\\enspace\\) (\\(t\\in[\\alpha,\\beta]\\)) \\(\\int_L P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y=\\int_\\alpha^\\beta P[\\varphi(t),\\psi(t)]\\varphi^\\prime(t)\\mathrm{d}t+Q[\\varphi(t),\\psi(t)]\\psi^\\prime(t)\\mathrm{d}t\\) 格林公式及应用 二维区域的边界 (单连通区域边界逆时针为正向; 多连通区域外边界逆时针为正向, 内边界顺时针为正向) 格林公式: 设 \\(D\\) 为连通区域, \\(L\\) 为 \\(D\\) 的正向边界 若 \\(P(x,y)\\)、\\(Q(x,y)\\) 在 \\(D\\) 上连续可偏导, 则 \\(\\oint_L P\\mathrm{d}x+Q\\mathrm{d}y=\\iint\\limits_D(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y})\\mathrm{d}\\sigma\\enspace\\) (\\(\\oint\\) 表示封闭边界, 即边界是闭合的. 依旧用 \\(\\int\\) 也行) 证明: 单连通区域 \\(\\oint_L P\\mathrm{d}x=-\\iint\\limits_D\\frac{\\partial P}{\\partial y}\\mathrm{d}\\sigma\\) \\(\\oint_L P\\mathrm{d}x=\\int_{L_1}P\\mathrm{d}x+\\int_{L_2}P\\mathrm{d}x\\) \\(=\\int_a^b P[x,\\varphi_1(x)]\\mathrm{d}x+\\int_b^a P[x,\\varphi_2(x)]\\mathrm{d}x\\) \\(=\\int_a^b\\{P[x,\\varphi_1(x)]-P[x,\\varphi_2(x)]\\}\\mathrm{d}x\\) \\(\\iint\\limits_D\\frac{\\partial P}{\\partial y}d\\sigma=\\int_a^b\\mathrm{d}x\\int_{\\varphi_1(x)}^{\\varphi_2(x)}\\frac{\\partial P}{\\partial y}\\mathrm{d}y\\) \\(=\\int_a^b P(x,y)|_{\\varphi_1(x)}^{\\varphi_2(x)}\\mathrm{d}x=\\int_a^b\\{P[x,\\varphi_2(x)]-P[x,\\varphi_1(x)]\\}\\mathrm{d}x\\) \\(\\therefore\\oint_L P\\mathrm{d}x=-\\iint\\limits_D\\frac{\\partial P}{\\partial y}\\mathrm{d}\\sigma\\) \\(\\oint_L Q\\mathrm{d}y=\\iint\\limits_{D}\\frac{\\partial Q}{\\partial x}\\mathrm{d}\\sigma\\) \\(\\oint_L Q\\mathrm{d}y=\\int_{L_1}Q\\mathrm{d}y+\\int_{L_2}Q\\mathrm{d}y\\) \\(=\\int_d^c Q[\\psi_1(y),y]\\mathrm{d}y+\\int_c^d Q[\\psi_2(y),y]\\mathrm{d}y\\) \\(=\\int_c^d\\{Q[\\psi_2(y),y]-Q[\\psi_1(y),y]\\}\\mathrm{d}y\\) \\(\\iint\\limits_{D}\\frac{\\partial Q}{\\partial x}\\mathrm{d}\\sigma=\\int_c^d\\mathrm{d}y\\int_{\\psi_1(y)}^{\\psi_2(y)}\\frac{\\partial Q}{\\partial x}\\mathrm{d}x\\) \\(=\\int_c^d Q(x,y)|_{\\psi_1(y)}^{\\psi_2(y)}\\mathrm{d}y=\\int_c^d\\{Q[\\psi_2(y),y]-Q[\\psi_1(y),y]\\}\\mathrm{d}y\\) \\(\\therefore\\oint_L Q\\mathrm{d}y=\\iint\\limits_{D}\\frac{\\partial Q}{\\partial x}\\mathrm{d}\\sigma\\) \\(\\oint_L P\\mathrm{d}x+Q\\mathrm{d}y=\\iint\\limits_D(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y})\\mathrm{d}\\sigma\\enspace\\) 多联通区域 \\(\\oint\\limits_{\\overline{AMB}+\\overline{BD}+\\overline{DEC}+\\overline{CA}}P\\mathrm{d}x+Q\\mathrm{d}y=\\iint\\limits_{D_1}(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y}\\mathrm{d}\\sigma)\\) \\(\\oint\\limits_{\\overline{AC}+\\overline{CFD}+\\overline{DB}+\\overline{BNA}}P\\mathrm{d}x+Q\\mathrm{d}y=\\iint\\limits_{D_2}(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y})\\mathrm{d}\\sigma\\) \\(\\because(\\overline{AMB}+\\overline{BD}+\\overline{DEC}+\\overline{CA})+(\\overline{AC}+\\overline{CFD}+\\overline{DB}+\\overline{BNA})\\) \\(\\mskip{1em}=\\overline{AMB}+\\overline{DEC}+\\overline{CFD}+\\overline{BNA}=L_1+L_2=L\\) \\(\\therefore\\oint_{L}P\\mathrm{d}x+Q\\mathrm{d}y=\\iint\\limits_{D}(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y})\\mathrm{d}\\sigma\\) 对面积的曲面积分 背景 经典积分思想: \\(\\Sigma\\) 划分为 \\(\\Delta S_1,\\dots,\\Delta S_n\\) \\(\\forall(\\xi_i,\\eta_i,\\zeta_i)\\in\\Delta S_i\\) \\(\\Delta m_i\\approx \\rho(\\xi_i,\\eta_i,\\zeta_i)\\Delta S_i\\) 令 \\(\\lambda\\) 为 \\(\\Delta S_1,\\dots,\\Delta S_n\\) 直径最大值 曲面总质量 \\(m=\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n\\rho(\\xi_i,\\eta_i,\\zeta_i)\\Delta S_i\\) 元素法思想: \\(\\forall\\mathrm{d}s\\subset\\Sigma\\) \\(\\mathrm{d}m=\\rho(x,y,z)\\mathrm{d}s\\) \\(m=\\iint\\limits_{\\Sigma}\\rho(x,y,z)\\mathrm{d}s\\) 对面积的曲面积分的定义: \\(\\iint\\limits_{\\Sigma}f(x,y,z)\\mathrm{d}s\\) 计算方法: 二重积分法 \\(\\Sigma:z=\\varphi(x,y)\\enspace\\) (\\((x,y)\\in Dxy\\)) \\(\\mathrm{d}s=\\sqrt{1+z_x^{\\prime 2}+z_y^{\\prime^2}}\\mathrm{d}\\sigma\\) (参见重积分应用-空间曲面的面积) 面积 \\(\\iint\\limits_\\Sigma f(x,y,z)\\mathrm{d}s=\\iint\\limits_{Dxy} f[x,y,\\varphi(x,y)]\\cdot\\sqrt{1+\\varphi_x^{\\prime 2}+\\varphi_y^{\\prime 2}}\\mathrm{d}\\sigma\\) 对坐标的曲面积分 曲面分有侧和无侧(如莫比乌斯环) 背景: 求流体的流量 流速 \\(\\vec{v}=\\{P(x,y,z),Q(x,y,z),R(x,y,z)\\}\\) 则有通量 \\(\\Phi=\\vec{v}\\cdot\\vec{s}=|\\vec{v}|\\mathrm{d}s\\cdot\\cos\\theta\\) 对坐标的曲面积分的定义 设有侧曲面块 \\(\\Sigma\\) , \\(P(x,y,z)\\)、\\(Q(x,y,z)\\)、\\(R(x,y,z)\\) 在有侧曲面上有界 \\(\\Sigma\\) 分为 \\(\\overrightarrow{\\Delta s_1},\\dots,\\overrightarrow{\\Delta s_n}\\) \\(\\overrightarrow{\\Delta S_i}\\) 在 \\(yOz\\) 面、\\(xOz\\) 面、\\(xOy\\) 面投影为 \\((\\Delta s_i)_{yz}\\)、\\((\\Delta s_i)_{xz}\\)、\\((\\Delta s_i)_{xy}\\) , \\(\\forall(\\xi_i,\\eta_i,\\zeta_i)\\in\\overrightarrow{\\Delta S_i}\\) , 作 \\(\\displaystyle\\sum_{i=1}^n P(\\xi_i,\\eta_i,\\zeta_i)(\\Delta s_i)_{yz}\\) \\(\\displaystyle\\sum_{i=1}^n Q(\\xi_i,\\eta_i,\\zeta_i)(\\Delta s_i)_{xz}\\) \\(\\displaystyle\\sum_{i=1}^n R(\\xi_i,\\eta_i,\\zeta_i)(\\Delta s_i)_{xy}\\) 令 \\(\\lambda\\) 为 \\(\\overrightarrow{\\Delta s_1},\\dots,\\overrightarrow{\\Delta s_n}\\) 直径最大值 (前提是极限存在) \\(\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n P(\\xi_i,\\eta_i,\\zeta_i)(\\Delta s_i)_{yz}=\\iint\\limits_\\Sigma P(x,y,z)\\mathrm{d}y\\mathrm{d}z\\enspace\\) (称为 \\(P\\) 在有侧曲面 \\(\\Sigma\\) 上对坐标 \\(y\\)、\\(z\\) 的曲面积分) \\(\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n Q(\\xi_i,\\eta_i,\\zeta_i)(\\Delta s_i)_{xz}=\\iint\\limits_\\Sigma Q(x,y,z)\\mathrm{d}x\\mathrm{d}z\\enspace\\) (称为 \\(P\\) 在有侧曲面 \\(\\Sigma\\) 上对坐标 \\(x\\)、\\(z\\) 的曲面积分) \\(\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n R(\\xi_i,\\eta_i,\\zeta_i)(\\Delta s_i)_{xy}=\\iint\\limits_\\Sigma R(x,y,z)\\mathrm{d}x\\mathrm{d}y\\enspace\\) (称为 \\(P\\) 在有侧曲面 \\(\\Sigma\\) 上对坐标 \\(x\\)、\\(y\\) 的曲面积分) 因此有 \\(\\iint\\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+\\iint\\limits_\\Sigma Q\\mathrm{d}x\\mathrm{d}z+\\iint\\limits_\\Sigma R\\mathrm{d}x\\mathrm{d}y=\\iint\\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}x\\mathrm{d}z+R\\mathrm{d}x\\mathrm{d}y\\) 性质: \\(\\iint\\limits_\\Sigma=\\iint\\limits_{\\Sigma_1}+\\iint\\limits_{\\Sigma_2}\\) \\(\\iint\\limits_{\\Sigma^-}=-\\iint\\limits_\\Sigma\\) (\\(\\Sigma^-\\) 代表曲面的另一侧) 两类曲面积分关系 对 \\(\\iint\\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}z\\mathrm{d}x+R\\mathrm{d}x\\mathrm{d}y\\) , 有 \\(\\mathrm{d}y\\mathrm{d}z=\\mathrm{d}s\\cdot\\cos\\alpha\\) \\(\\mathrm{d}x\\mathrm{d}z=\\mathrm{d}s\\cdot\\cos\\beta\\) \\(\\mathrm{d}x\\mathrm{d}y=\\mathrm{d}s\\cdot\\cos\\gamma\\) \\(\\iint\\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}x\\mathrm{d}z+R\\mathrm{d}x\\mathrm{d}y=\\iint\\limits_\\Sigma (P\\cos\\alpha+Q\\cos\\beta+R\\cos\\gamma)\\mathrm{d}s\\) 计算方法: 二重积分法 \\(\\Sigma:z=\\varphi(x,y)\\enspace\\) (\\((x,y)\\in Dxy\\)) \\(\\iint\\limits_\\Sigma R(x,y,z)\\mathrm{d}x\\mathrm{d}y=\\pm\\iint\\limits_{Dxy}R[x,y,\\varphi(x,y)]\\mathrm{d}x\\mathrm{d}y\\) (\\(\\Sigma\\) 取上侧为正, \\(\\Sigma\\) 取下侧为负) 高斯公式 定义: \\(\\Omega\\) 为几何体, 曲面 \\(\\Sigma\\) 为 \\(\\Omega\\) 的外表面 函数 \\(P\\)、\\(Q\\)、\\(R\\) 在 \\(\\Omega\\) 上连续可偏导, 则 \\(\\oiint\\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}z\\mathrm{d}x+R\\mathrm{d}x\\mathrm{d}y=\\iiint\\limits_\\Omega(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z})\\mathrm{d}v\\) (\\(\\oiint\\) 表示封闭曲面, 依旧用 \\(\\iint\\) 同样可行) 证明: (仅证 \\(\\oiint\\limits_\\Sigma R\\mathrm{d}x\\mathrm{d}y=\\iiint\\limits_\\Omega\\frac{\\partial R}{\\partial z}\\mathrm{d}v\\)) \\(\\oiint\\limits_\\Sigma R\\mathrm{d}x\\mathrm{d}y=\\iint\\limits_{\\Sigma_1}R\\mathrm{d}x\\mathrm{d}y-\\iint\\limits_{\\Sigma_2}R\\mathrm{d}x\\mathrm{d}y\\) \\(\\iint\\limits_{\\Sigma_1} R\\mathrm{d}x\\mathrm{d}y=-\\iint\\limits_{Dxy}R[x,y,\\varphi_1(x,y)]\\mathrm{d}x\\mathrm{d}y\\) \\(\\iint\\limits_{\\Sigma_2} R\\mathrm{d}x\\mathrm{d}y=\\iint\\limits_{Dxy}R[x,y,\\varphi_2(x,y)]\\mathrm{d}x\\mathrm{d}y\\) \\(\\therefore\\oiint\\limits_\\Sigma R\\mathrm{d}x\\mathrm{d}y=\\iint\\limits_{Dxy}\\{R[x,y,\\varphi_2(x,y)]-R[x,y,\\varphi_1(x,y)]\\}\\mathrm{d}x\\mathrm{d}y\\) \\(\\Omega=\\{(x,y,z)|(x,y)\\in Dxy,\\varphi_1(x,y)\\leqslant z\\leqslant\\varphi_2(x,y)\\}\\) \\(\\iiint\\limits_\\Omega\\frac{\\partial R}{\\partial z}\\mathrm{d}v=\\iint\\limits_{Dxy}\\mathrm{d}x\\mathrm{d}y\\int_{\\varphi_1(x,y)}^{\\varphi_2(x,y)}\\frac{\\partial R}{\\partial z}\\mathrm{d}z\\) \\(=\\iint\\limits_{Dxy}R(x,y,z)|_{\\varphi_1(x,y)}^{\\varphi_2(x,y)}\\mathrm{d}x\\mathrm{d}y\\) \\(=\\iint\\limits_{Dxy}\\{R(x,y,\\varphi_1(x,y))-R(x,y,\\varphi_2(x,y))\\}\\mathrm{d}x\\mathrm{d}y\\) \\(\\therefore\\oiint\\limits_\\Sigma R\\mathrm{d}x\\mathrm{d}y=\\iiint\\limits_\\Omega\\frac{\\partial R}{\\partial z}\\mathrm{d}v\\) 斯托克斯公式 定义: \\(\\Sigma\\) 为光滑曲面块, \\(\\Gamma\\) 为 \\(\\Sigma\\) 的界, \\(\\Sigma\\) 的侧与 \\(\\Gamma\\) 的方向按右手确定 函数 \\(P, Q, R\\) 在 \\(\\Sigma\\) 连续可偏导, 则 $$ \\oint_L P\\mathrm{d}x+Q\\mathrm{d}y+R\\mathrm{d}z=\\iint\\limits_\\Sigma \\begin{vmatrix} \\mathrm{d}y\\mathrm{d}z & \\mathrm{d}z\\mathrm{d}x & \\mathrm{d}x\\mathrm{d}y \\\\ \\frac{\\partial}{\\partial x} & \\frac{\\partial}{\\partial y} & \\frac{\\partial}{\\partial z} \\\\ P & Q & R \\end{vmatrix} =\\iint\\limits_\\Sigma \\begin{vmatrix} \\cos\\alpha & \\cos\\beta & \\cos\\gamma \\\\ \\frac{\\partial}{\\partial x} & \\frac{\\partial}{\\partial y} & \\frac{\\partial}{\\partial z} \\\\ P & Q & R \\end{vmatrix}\\mathrm{d}s $$ 其中 \\(\\cos\\alpha, \\cos\\beta, \\cos\\gamma\\) 为曲面 \\(\\Sigma\\) 法向量的方向余弦 无穷级数 常数项级数的概念和性质 定义: 设常数列 \\({a_n}\\) , 称 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 为常数项级数 \\(S_n=a_1+\\dots+a_n\\) 为部分和 若 \\(\\lim\\limits_{n\\to\\infty}S_n=S\\) 称级数收敛于 \\(S\\) ; 若极限不存在, 称级数发散 \\(S_n\\neq\\displaystyle\\sum_{n=1}^\\infty a_n\\) , \\(\\lim\\limits_{n\\to\\infty}S_n=\\displaystyle\\sum_{n=1}^\\infty a_n\\) 常数项级数性质: \\(\\displaystyle\\sum_{n=1}^\\infty a_n=A\\) , \\(\\displaystyle\\sum_{n=1}^\\infty b_n=B\\) , 则 \\(\\begin{cases} \\displaystyle\\sum_{n=1}^\\infty (a_n+b_n)=A+B \\\\ \\displaystyle\\sum_{n=1}^\\infty (a_n-b_n)=A-B \\end{cases}\\) \\(\\displaystyle\\sum_{n=1}^\\infty ka_n=kS\\) 级数中添加、减少、改变有限项, 级数的收敛性不变 添加括号后收敛性不降低(即收敛性可能会提高) 如 \\(S_n=1-1+1-1+\\dots\\) 发散 但 \\(S_n=(1-1)+(1-1)+\\dots\\) 收敛于0 收敛必要条件: 设 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 收敛, 则 \\(\\lim\\limits_{n\\to\\infty} a_n=0\\) , 反之不对(如调和级数) 几何级数: \\(\\displaystyle\\sum_{n=1}^\\infty aq^n\\begin{cases} |q|\\geqslant1 &amp; \\text{发散} \\\\ |q|&lt;1 &amp; =\\frac{\\text{首项}}{1-\\text{公比}} \\end{cases}\\) (公式推导参考等比数列) 常数项级数的审敛法 正向级数及审敛法 定义: 设 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) , 若 \\(\\forall n\\) , \\(a_n\\geqslant0\\) , 称 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 为正向级数 若 \\(S_1\\leqslant S_2\\leqslant S_3\\leqslant\\dots\\) , 记 \\(\\{S_n\\}\\uarr\\) (表示 \\(S_n\\) 单调递增); 情况1：\\(\\{S_n\\}\\) 无上界 \\(\\rArr \\lim\\limits_{n\\to\\infty} S_n=+\\infty \\rArr \\displaystyle\\sum_{n=1}^\\infty a_n\\) 发散 情况2: \\(S_n\\leqslant M\\rArr\\lim\\limits_{n\\to\\infty}S_n\\) 存在 \\(\\rArr\\displaystyle\\sum_{n=1}^\\infty a_n\\) 收敛 审敛法 比较法 \\(a_n\\leqslant b_n\\) 且 \\(\\displaystyle\\sum_{n=1}^\\infty b_n\\) 收敛, 则 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 收敛 \\(a_n\\geqslant b_n\\) 且 \\(\\displaystyle\\sum_{n=1}^\\infty b_n\\) 发散, 则 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 发散 比较法(极限形式) 设正项级数 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\)、\\(\\displaystyle\\sum_{n=1}^\\infty b_n\\) 若 \\(\\lim\\limits_{n\\to\\infty}\\frac{b_n}{a_n}=l\\enspace\\) (\\(0&lt;l&lt;+\\infty\\)) 则 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 与 \\(\\displaystyle\\sum_{n=1}^\\infty b_n\\) 敛散性相同 比值法 设正项级数 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 若 \\(\\lim\\limits_{n\\to\\infty}\\dfrac{a_{n+1}}{a_n}=\\rho\\) 则 \\(\\rho&lt;1\\) 时, 级数收敛; \\(\\mskip{1em}\\rho&gt;1\\) 时, 级数发散. 根值法 设正项级数 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 若 \\(\\lim\\limits_{n\\to\\infty}\\sqrt[n]{a_n}=\\rho\\) 则 \\(\\rho&lt;1\\) 时, 级数收敛; \\(\\mskip{1em}\\rho&gt;1\\) 时, 级数发散. \\(p-\\)级数: \\(\\displaystyle\\sum_{n=1}^\\infty \\frac{1}{n^p}\\) 称为 \\(p-\\)级数 若 \\(p=1\\) , 称 \\(\\displaystyle\\sum_{n=1}^\\infty \\frac{1}{n}\\) 为调和级数 \\(\\displaystyle\\sum_{n=1}^\\infty \\frac{1}{n^p} \\begin{cases} p&gt;1 &amp; \\text{收敛} \\\\ p\\leqslant 1 &amp; \\text{发散} \\end{cases}\\) (审敛法使用根值法) 交错级数及审敛法 交错级数: 形如 \\(a_1-a_2+a_3-a_4+\\dots\\) 或 \\(-a_1+a_2-a_3+a_4-\\dots\\enspace\\) (\\(\\forall n, a_n\\geqslant 0\\)) 即 \\(\\displaystyle\\sum_{n=1}^\\infty (-1)^{n-1}a_n\\) 或 \\(\\displaystyle\\sum_{n=1}^\\infty(-1)^n a_n\\enspace(\\forall n,a_n\\geqslant 0)\\) 莱布尼茨审敛法 对于 \\(\\displaystyle\\sum_{n=1}^\\infty(-1)^{n-1}a_n\\enspace\\) (\\(\\forall n,a_n\\geqslant 0\\)) 若 \\(\\{a_n\\}\\darr\\) 且 \\(\\lim\\limits_{n\\to\\infty}a_n=0\\) 则 \\(\\displaystyle\\sum_{n=1}^\\infty(-1)^{n-1}a_n\\) 收敛, 且 \\(S\\leqslant a_1\\) 绝对收敛与条件收敛 取绝对值(提高发散性): \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\rarr\\displaystyle\\sum_{n=1}^\\infty|a_n|\\) 定义 当 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 收敛, 而 \\(\\displaystyle\\sum_{n=1}^\\infty|a_n|\\) 发散, 称 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 条件收敛 如 \\(\\displaystyle\\sum_{n=1}^\\infty\\frac{(-1)^{n-1}}{n}=1-\\frac{1}{2}+\\frac{1}{3}-\\frac{1}{4}+\\dots\\) 收敛 但 \\(\\displaystyle\\sum_{n=1}^\\infty|\\frac{(-1)^{n-1}}{n}|=\\displaystyle\\sum_{n=1}^\\infty\\frac{1}{n}\\) 发散 (\\(p-\\)级数) 当 \\(\\displaystyle\\sum_{n=1}^\\infty|a_n|\\) 收敛, 称 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 绝对收敛 结论: 若 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 绝对收敛, 则 \\(\\displaystyle\\sum_{n=1}^\\infty a_n\\) 收敛 幂级数的概念与分析性质 函数项级数的概念 设函数数列 \\(\\{u_n(x)\\}\\) , 称 \\(\\displaystyle\\sum_{n=1}^\\infty u_n(x)\\) 为函数项级数 若 \\(x=x_0\\) 时 \\(\\displaystyle\\sum_{n=1}^\\infty u_n(x_0)\\) 收敛, 称 \\(x=x_0\\) 为收敛点 若 \\(x=x_1\\) 时 \\(\\displaystyle\\sum_{n=1}^\\infty u_n(x_1)\\) 发散, 称 \\(x=x_1\\) 为发散点 例: \\(x+x^2+x^3+x^4+\\dots=\\displaystyle\\sum_{n=1}^\\infty x^n\\) 当 \\(x=\\frac{2}{3}\\) 时收敛; 当 \\(x=2\\) 时发散. 幂级数概念与基本定理 幂级数定义: \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n=a_0+a_1x+a_2x^2+\\dots\\) 或 \\(\\displaystyle\\sum_{n=0}^\\infty a_n(x-x_0)^n=a_0+a_1(x-x_0)+a_2(x-x_0)^2+\\dots\\) 基本定理(Abel定理) 若 \\(x=x_0(\\neq 0)\\) 时 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x_0^n\\) 收敛. 则当 \\(|x|&lt;|x_0|\\) 时, \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n\\) 绝对收敛 若 \\(x=x_1\\) 时 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x_1^n\\) 发散. 则当 \\(|x|&gt;|x_1|\\) 时, \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n\\) 发散 收敛半径与收敛域 \\(\\displaystyle\\sum_{n=1}^\\infty u_n(x)\\) 的所有收敛点组成的集合称为收敛域, 记为 \\(D\\) 收敛半径 \\((-R,R)\\) 内级数绝对收敛, \\((-\\infty,-R)\\cup(R,+\\infty)\\) 内级数发散, \\(x=\\pm R\\) 时可能收敛可能发散 定理1: 对于 \\(\\displaystyle\\sum_{n=0}^\\infty a_nx^n\\) 若 \\(\\lim\\limits_{n\\to\\infty}|\\dfrac{a_{n+1}}{a_n}|=\\rho\\) \\(\\rho=0\\rArr R=+\\infty\\) \\(\\rho=+\\infty\\rArr R=0\\) \\(0&lt;\\rho&lt;+\\infty\\rArr R=\\frac{1}{\\rho}\\) 定理2: 对于 \\(\\displaystyle\\sum_{n=0}^\\infty a_nx^n\\) 若 \\(\\lim\\limits_{n\\to\\infty}\\sqrt[n]{|a_n|}=\\rho\\) \\(\\rho=0\\rArr R=+\\infty\\) \\(\\rho=+\\infty\\rArr R=0\\) \\(0&lt;\\rho&lt;+\\infty\\rArr R=\\frac{1}{\\rho}\\) 对于 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^{2n+1}=a_0x+a_1x^3+a_2x^5+\\dots\\) \\(\\lim\\limits_{n\\to\\infty}|\\frac{a_{n+1}}{a_n}|=\\rho\\) \\(\\rho=0\\rArr R=+\\infty\\) \\(\\rho=+\\infty\\rArr R=0\\) \\(0&lt;\\rho&lt;+\\infty\\rArr R=\\sqrt{\\frac{1}{\\rho}}\\) 幂级数和函数的分析性质 \\(\\forall x\\in D\\) , 和函数 \\(S(x)=\\displaystyle\\sum_{n=1}^\\infty u_n(x)\\) 逐项可积性 若 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n\\) 的和函数 \\(S(x)\\) 在其收敛域上可积 则 \\(\\int_0^x S(x)\\mathrm{d}x=\\int_0^x (\\displaystyle\\sum_{n=0}^\\infty a_n x^n)\\mathrm{d}x=\\displaystyle\\sum_{n=0}^\\infty\\int_0^x a_nx^n\\mathrm{d}x=\\displaystyle\\sum_{n=0}^\\infty\\dfrac{a_n}{n+1}x^{n+1}\\) 且 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n\\) 与 \\(\\displaystyle\\sum_{n=0}^\\infty \\dfrac{a_n}{n+1}x^{n+1}\\) 收敛半径相同 逐项可导性 若 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n\\) 的和函数 \\(S(x)\\) 在其收敛域上可导 则 \\((\\displaystyle\\sum_{n=0}^\\infty a_n x^n)^\\prime=\\displaystyle\\sum_{n=0}^\\infty(a_n x^n)^\\prime=\\displaystyle\\sum_{n=1}^\\infty n a_n x^{n-1}\\) 且 \\(\\displaystyle\\sum_{n=0}^\\infty a_n x^n\\) 与 \\(\\displaystyle\\sum_{n=1}^\\infty n a_n x^{n-1}\\) 收敛半径相同 函数展开成幂级数 直接法 设 \\(f(x)\\) 在 \\(x=x_0\\) 邻域内任意阶可导. 则 \\(f(x)\\) 在 \\(x=x_0\\) 邻域内展成 \\(\\displaystyle\\sum_{n=0}^\\infty\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\\) 的充要条件是 \\(\\lim\\limits_{n\\to\\infty} R_n(x)=0\\) \\(x=0\\) 时, \\(\\displaystyle\\sum_{n=0}^\\infty\\frac{f^{(n)}(0)}{n!}(x-x_0)^n\\) 称作麦克劳林级数 (参见泰勒级数) 间接法 (基于直接法推导出来的已有公式进行展开) 常用公式: (注意后面的值域范围) \\(e^x=\\displaystyle\\sum_{n=0}^\\infty\\frac{x^n}{n!}=1+x+\\frac{x^2}{2!}+\\dots+\\frac{x^n}{n!}+\\circ(x^n)\\enspace\\) (\\(-1&lt;x&lt;1\\)) \\(\\sin x=\\displaystyle\\sum_{n=0}^\\infty\\frac{(-1)^n}{(2n+1)!}x^{2n+1}=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}+\\dots+(-1)^n\\frac{x^{2n+1}}{(2n+1)!}+\\circ(x^{2n+1})\\enspace\\) (\\(-\\infty&lt;x&lt;+\\infty\\)) \\(\\cos x=\\displaystyle\\sum_{n=0}^\\infty\\frac{(-1)^n}{(2n)!}x^{2n}=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+\\dots+(-1)^n\\frac{x^{2n}}{(2n)!}+\\circ(x^{2n})\\enspace\\) (\\(-\\infty&lt;x&lt;+\\infty\\)) \\(\\frac{1}{1-x}=\\displaystyle\\sum_{n=0}^\\infty x^n=1+x+x^2+x^3+\\dots+x^n+\\circ(x^n)\\enspace\\) (\\(-1&lt;x&lt;1\\)) \\(\\frac{1}{1+x}=\\displaystyle\\sum_{n=0}^\\infty (-1)^n x^n=1-x+x^2-x^3+\\dots+(-1)^nx^n+\\circ(x^n)\\enspace\\) (\\(-1&lt;x&lt;1\\)) \\(\\ln(1+x)=\\displaystyle\\sum_{n=1}^\\infty\\frac{(-1)^{n-1}}{n}x^n=x-\\frac{x^2}{2}+\\frac{x^3}{3}-\\frac{x^4}{4}+\\dots+(-1)^{n-1}\\frac{x^n}{n}+\\circ(x^n)\\enspace\\) (\\(-1&lt;x\\leqslant1\\)) \\(-\\ln(1-x)=\\displaystyle\\sum_{n=1}^\\infty\\frac{x^n}{n}=x+\\frac{x^2}{2}+\\frac{x^3}{3}+\\frac{x^4}{4}+\\dots+\\frac{x^n}{n}+\\circ(x^n)\\enspace\\) (\\(-1\\leqslant x&lt;1\\)) 欧拉公式: \\(e^{i\\theta}=\\cos\\theta+i\\sin\\theta\\) 利用幂级数和函数的逐项可导、可积性 傅里叶级数 背景 单一周期信号: \\(a_n\\cos n\\omega t+b_n\\sin n\\omega t\\) 设 \\(f(x)\\) 是以 \\(2\\pi\\) 为周期的信号 Q1: \\(f(x)\\) 可否分解为 \\(\\dfrac{a_0}{2}+\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)\\) 的形式? \\(a_0=\\text{?}\\enspace a_n=\\text{?}\\enspace b_n=\\text{?}\\) \\(\\dfrac{a_0}{2}\\) 称为直流成份 \\(a_1\\cos x+b_1\\sin x\\) 称为一次谐波 \\(a_2\\cos 2x+b_2\\sin 2x\\) 称为二次谐波 Q2: \\(f(x)\\) 与 \\(\\dfrac{a_0}{2}+\\underbrace{\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)}_{\\text{三角级数}}\\) 什么关系? 三角函数系及正交性 三角函数系: \\(1(=\\cos 0x=\\sin 0x),\\cos x,\\sin x,\\cos 2x,\\sin 2x,\\dots,\\cos(nx),\\sin(nx)\\) 正交性: \\(\\int_{-\\pi}^\\pi 1\\cdot\\cos nx\\mathrm{d}x=0\\enspace\\) (\\(n=1,2,3,\\dots\\)) \\(\\int_{-\\pi}^\\pi 1\\cdot\\cos nx\\mathrm{d}x=0\\enspace\\) (\\(n=1,2,3,\\dots\\)) \\(\\int_{-\\pi}^\\pi\\sin mx\\cos nx\\mathrm{d}x=0\\enspace\\) (\\(m\\)、\\(n=1,2,3,\\dots\\)) \\(\\int_{-\\pi}^\\pi\\cos mx\\cos nx\\mathrm{d}x=\\begin{cases} 2\\pi &amp; m=n=0 \\\\ \\pi &amp; m=n\\geqslant 1 \\\\ 0 &amp; m\\neq n \\end{cases}\\) \\(\\int_{-\\pi}^\\pi\\sin mx\\sin nx\\mathrm{d}x=\\begin{cases} \\pi &amp; m=n\\geqslant 1 \\\\ 0 &amp; m\\neq n \\end{cases}\\) 推导思路: 第三个可用和差角公式的变换 \\(\\sin\\alpha\\cos\\beta=\\frac{1}{2}[\\sin(\\alpha+\\beta)+\\sin(\\alpha-\\beta)]\\) 第四个变体二(\\(m=n\\geqslant 1\\)) 可用二倍角公式的变换 \\(\\cos^2\\alpha=\\frac{1}{2}(1+\\cos 2\\alpha)\\) 第四个变体三同样可用和差叫公式的变换 \\(\\cos\\alpha\\cos\\beta=\\frac{1}{2}[\\cos(\\alpha+\\beta)+\\cos(\\alpha-\\beta)]\\) 第五个变体二同样可用和差叫公式的变换 \\(\\sin\\alpha\\sin\\beta=\\frac{1}{2}[\\cos(\\alpha-\\beta)x-\\cos(\\alpha+\\beta)]\\) 周期为 \\(2π\\) 的函数展开成傅里叶级数 Dirichlet 充分条件: 设 \\(f(x)\\) 是以 \\(2\\pi\\) 为周期的周期级数. 若满足: \\(f(x)\\) 在 \\([-\\pi,\\pi]\\) 内连续或存在有限个第一类间断点 \\(f(x)\\) 在 \\([-\\pi,\\pi]\\) 内仅有有限个极值点 则: \\(f(x)\\) 可以展成 \\(\\frac{a_0}{2}+\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)\\) . 且 \\(a_0=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\mathrm{d}x\\) \\(a_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\cos nx\\mathrm{d}x\\enspace\\) (\\(n=1,2,3,\\dots)\\) \\(b_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\sin nx\\mathrm{d}x\\enspace\\) (\\(n=1,2,3,\\dots)\\) \\(x\\) 为 \\(f(x)\\) 连续点时, 则 \\(\\frac{a_0}{2}+\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)=f(x)\\) \\(x\\) 为 \\(f(x)\\) 间断点时, 则 \\(\\frac{a_0}{2}+\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)=\\frac{f(x-0)+f(x+0)}{2}\\) 例: \\(f(x)\\) 以 \\(2\\pi\\) 为周期, \\(f(x)\\) 在 \\([-\\pi,\\pi]\\) 上表达式为 \\(f(x)=\\begin{cases} -1 &amp; -\\pi\\leqslant x&lt;0 \\\\ 1 &amp; 0\\leqslant x&lt;\\pi \\end{cases}\\) 请将 \\(f(x)\\) 展成 Fourier 级数, 并作其和函数图像. 解: 作 \\(y=f(x)\\) 图, \\(x=k\\pi\\enspace\\) (\\(k\\in Z\\) 为 \\(f(x)\\) 间断点 \\(a_0=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\mathrm{d}x=0\\) \\(a_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\cos nx\\mathrm{d}x=0\\enspace\\) (\\(n=1,2,3,\\dots)\\) \\(b_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\sin nx\\mathrm{d}x=\\frac{2}{\\pi}\\int_0^\\pi\\sin nx\\mathrm{d}x=-\\frac{2}{n\\pi}\\cos nx|_0^\\pi=\\frac{2[1-(-1)^n]}{n\\pi}=\\) \\(\\begin{cases} \\frac{4}{n\\pi} &amp; n=1,3,5,\\dots \\\\ 0 &amp; n=2,4,6,\\dots \\end{cases}\\) \\(f(x)=\\frac{4}{\\pi}(\\frac{1}{1}\\sin 1x+\\frac{1}{3}\\sin 3x+\\frac{1}{5}\\sin 5x+\\dots)=\\frac{4}{\\pi}\\displaystyle\\sum_{n=0}^\\infty\\frac{\\sin(2n+1)x}{2n+1}\\enspace\\) (\\(-\\infty&lt;x&lt;+\\infty\\) 且 \\(x\\neq k\\pi(k\\in Z)\\) (即 \\(x\\) 取不到间断点)) 当 \\(x=k\\pi(k\\in Z)\\) 时 \\(\\frac{4}{\\pi}\\displaystyle\\sum_{n=0}^\\infty\\frac{\\sin(2n+1)x}{2n+1}=\\frac{f(k\\pi-0)+f(k\\pi+0)}{2}=0\\) (结果是观察图像得出的) 令 \\(S(x)=\\frac{4}{\\pi}\\displaystyle\\sum_{n=0}^\\infty\\frac{\\sin(2n+1)x}{2n+1}\\) 作图: 定义于 \\([−\\pi,\\pi]\\) 上函数的傅里叶级数(非周期函数) 思想: 设 \\(f(x)\\) 定义于 \\([-\\pi,\\pi)\\) 1. \\(F(x)\\) 展成傅里叶级数 \\(a_0=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi F(x)\\mathrm{d}x=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\mathrm{d}x\\) \\(a_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\cos nx\\mathrm{d}x\\) \\(b_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\sin nx\\mathrm{d}x\\) \\(F(x)=\\frac{a_0}{2}+\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)\\enspace\\) (\\(-\\infty&lt;x&lt;+\\infty\\) , \\(x\\neq\\) 间断点) \\(f(x)=\\frac{a_0}{2}+\\displaystyle\\sum_{n=1}^\\infty(a_n\\cos nx+b_n\\sin nx)\\) \\(x\\) 延拓后有四种可能: \\(\\begin{pmatrix} -\\pi\\leqslant x\\leqslant\\pi , -\\pi\\leqslant x&lt;\\pi \\\\ -\\pi&lt;x\\leqslant\\pi , -\\pi&lt;x&lt;\\pi \\end{pmatrix}\\) , 选择哪个得看延拓后的点能否接上. 上图中延拓后两端依旧断开所以选择 (\\(-\\pi&lt;x\\leqslant\\pi\\)) 例: 求 \\(f(x)=|x|\\enspace\\) (\\(-\\pi\\leqslant x\\leqslant\\pi\\)) 的傅里叶级数 对 \\(f(x)\\) 进行周期延拓 \\(a_0=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\mathrm{d}x=\\frac{2}{\\pi}\\int_0^\\pi x\\mathrm{d}x=\\pi\\) \\(a_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\cos nx\\mathrm{d}x=\\frac{2}{\\pi}\\int_0^\\pi x\\cos nx\\mathrm{d}x=\\frac{2}{n\\pi}\\int_0^\\pi x\\mathrm{d}\\sin nx\\) \\(=\\frac{2}{n\\pi}[(x\\sin nx)|_0^\\pi-\\int_0^\\pi\\sin nx\\mathrm{d}x]\\) (分部积分法) \\(=\\frac{2}{n^2\\pi}\\cos nx|_0^\\pi=\\frac{2}{n^2\\pi}[(-1)^n-1]=\\begin{cases} -\\frac{4}{n^2\\pi} &amp; n=1,3,5,\\dots \\\\ 0 &amp; n=2,4,6,\\dots \\end{cases}\\) \\(b_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\sin nx\\mathrm{d}x=0\\enspace\\) (奇函数 \\(\\times\\) 偶函数 \\(=\\) 奇函数) \\(|x|=\\frac{\\pi}{2}-\\frac{4}{\\pi}(\\frac{1}{1^2}\\cos x+\\frac{1}{3^2}\\cos 3x+\\frac{1}{5^2}\\cos 5x+\\dots)\\enspace\\) (\\(-\\pi\\leqslant x\\leqslant\\pi\\)) 意外的收获: \\(x=0\\) 时有 \\(0=\\frac{\\pi}{2}-\\frac{4}{\\pi}(\\frac{1}{1^2}+\\frac{1}{3^2}+\\frac{1}{5^2}+\\dots)\\) \\(\\rArr\\frac{1}{1^2}+\\frac{1}{3^2}+\\frac{1}{5^2}+\\dots=\\frac{\\pi^2}{8}\\) 即 \\(\\displaystyle\\sum_{n=0}^\\infty\\frac{1}{(2n+1)^2}=\\frac{\\pi^2}{8}\\) \\(\\displaystyle\\sum_{n=1}^\\infty\\frac{1}{n^2}=S\\) $$ \\begin{aligned} S & =\\frac{1}{1^2}+\\frac{1}{2^2}+\\frac{1}{3^2}+\\dots \\\\ & =(\\frac{1}{1^2}+\\frac{1}{3^2}+\\frac{1}{5^2}+\\dots)+(\\frac{1}{2^2}+\\frac{1}{4^2}+\\frac{1}{6^2}+\\dots) \\\\ & =\\frac{\\pi^2}{8}+\\frac{1}{4}(\\frac{1}{1^2}+\\frac{1}{2^2}+\\frac{1}{3^2}+\\dots) \\\\ & =\\frac{\\pi^2}{8}+\\frac{1}{4}S\\rArr S=\\frac{\\pi^2}{6} \\end{aligned} $$ 即 \\(\\displaystyle\\sum_{n=1}^\\infty\\frac{1}{n^2}=\\frac{\\pi^2}{6}\\) 定义于 \\([0,π]\\) 上函数的傅里叶级数 思想: 先区间延拓, 再周期延拓. 区间延拓, 在 \\([-\\pi, 0]\\) 上补充定义: 奇延拓(补充后图像关于原点对称) 偶延拓(补充后图像关于\\(y\\) 轴对称) 周期延拓: 奇延拓, 周期延拓(正弦级数) \\(a_0=0\\) \\(a_n=0\\) \\(b_n=\\frac{2}{\\pi}\\int_0^\\pi f(x)\\sin nx\\mathrm{d}x\\enspace\\) (\\(n=1,2,3,\\dots\\)) \\(\\displaystyle f(x)=\\sum_{n=1}^\\infty b_n\\sin nx\\) (正弦级数) 区间 \\(\\begin{pmatrix} 0 \\leqslant x \\leqslant \\pi , 0 \\leqslant x &lt; \\pi \\\\ 0 &lt; x \\leqslant \\pi , 0 &lt; x &lt; \\pi \\end{pmatrix}\\) , 选择哪个得看延拓后的点能否接上 偶延拓, 周期延拓(余弦级数) \\(a_0=\\frac{2}{\\pi}\\int_0^\\pi f(x)\\mathrm{d}x\\) \\(a_n=\\frac{2}{\\pi}\\int_0^\\pi f(x)\\cos nx\\mathrm{d}x\\) \\(b_n=0\\) \\(\\displaystyle f(x)=\\frac{a_0}{2}+\\sum_{n=1}^\\infty a_n\\cos nx\\) (余弦级数) 区间 \\((0\\leqslant x\\leqslant\\pi)\\) 周期为 \\(2l\\) 的傅里叶级数 \\(f(x)\\) 以 \\(2l\\) 为周期 设 \\(x=\\frac{l}{\\pi}t\\) \\(f(x)=f(\\frac{l}{\\pi}t)=F(t)\\) \\(F(t+2\\pi)=f[\\frac{l}{\\pi}(t+2\\pi)]=f(\\frac{l}{\\pi}t+2l)=f(\\frac{l}{\\pi}t)=F(t)\\) 尝试将 \\(F(x)\\) 化为傅里叶级数: \\(a_0=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi F(t)\\mathrm{d}t\\xlongequal{t=\\frac{\\pi}{l}x}\\frac{1}{\\pi}\\int_{-l}^l f(x)\\cdot\\frac{\\pi}{l}\\mathrm{d}x=\\frac{1}{l}\\int_{-l}^l f(x)\\mathrm{d}x\\) (换元后积分上下界要变, 比如把下界的值代入: \\(-\\pi=\\frac{\\pi}{l}x\\rArr x=-l\\)) \\(a_n=\\frac{1}{\\pi}\\int_{-\\pi}^\\pi F(t)\\cos nt\\mathrm{d}t\\xlongequal{t=\\frac{\\pi}{l}x}\\frac{1}{\\pi}\\int_{-l}^l f(x)\\cos(\\frac{n\\pi x}{l})\\cdot\\frac{\\pi}{l}\\mathrm{d}x=\\frac{1}{l}\\int_{-l}^l f(x)\\cos(\\frac{n\\pi x}{l})\\mathrm{d}x\\) \\(b_n=\\frac{1}{l}\\int_{-l}^l f(x)\\sin(\\frac{n\\pi x}{l})\\mathrm{d}x\\) \\(F(t)\\) 的傅里叶级数为 \\(\\displaystyle\\frac{a_0}{2}+\\sum_{n=1}^\\infty(a_n\\cos nt+b_n\\sin nt)=\\frac{a_0}{2}+\\sum_{n=1}^\\infty(a_n\\cos(\\frac{n\\pi x}{l})+b_n\\sin(\\frac{n\\pi x}{l}))\\) 定理: \\(f(x)\\) 以 \\(2l\\) 为周期, 在 \\([-l,l)\\) 上满足 Dirichlet 充分条件, 则: \\(f(x)\\) 可展成 \\(\\displaystyle\\frac{a_0}{2}+\\sum_{n=1}^\\infty(a_n\\cos(\\frac{n\\pi x}{l})+b_n\\sin(\\frac{n\\pi x}{l}))\\) \\(a_0=\\frac{1}{l}\\int_{-l}^l f(x)\\mathrm{d}x\\) \\(a_n=\\frac{1}{l}\\int_{-l}^l f(x)\\cos(\\frac{n\\pi x}{l})\\mathrm{d}x\\) \\(b_n=\\frac{1}{l}\\int_{-l}^l f(x)\\sin(\\frac{n\\pi x}{l})\\mathrm{d}x\\) 当 \\(x\\) 为 \\(f(x)\\) 连续点时 \\(\\displaystyle\\frac{a_0}{2}+\\sum_{n=1}^\\infty(a_n\\cos(\\frac{n\\pi x}{l})+b_n\\sin(\\frac{n\\pi x}{l}))=f(x)\\) 当 \\(x\\) 为 \\(f(x)\\) 间断点时 \\(\\displaystyle\\frac{a_0}{2}+\\sum_{n=1}^\\infty(a_n\\cos(\\frac{n\\pi x}{l})+b_n\\sin(\\frac{n\\pi x}{l}))=\\frac{f(\\text{?}-0)+f(\\text{?}+0)}{2}\\enspace\\) (\\(\\text{?}\\) 为间断点坐标) \\(f(x)\\) 定义于 \\([-l,l]\\) 解决思路: 周期延拓, 最后把 \\(x\\) 限制到 \\([-l,l]\\) , 左右端点是否存在看延拓后是否连续 \\(f(x)\\) 定义于 \\([0,l]\\) 先奇延拓或偶延拓, 然后周期延拓, 最后把 \\(x\\) 限制到 \\([-l,l]\\) , 左右端点是否存在看延拓后是否连续","link":"/zh-cn/learn/mathematics/2021/postgraduate-advanced-mathematics-2/"},{"title":"postgraduate-advanced-mathematics","text":"同济高等数学笔记整合(上) 考研用 基于 wmathor/Postgraduate-Advanced-Mathematics 不定积分是为定积分服务的, 它的目的是找原函数 函数与极限 函数 函数: 有集合 \\(D\\) 和 \\(x\\)、\\(y\\) 两个变量. 若对任意 \\(x\\in D\\), 总存在唯一确定的解 \\(y\\) 与 \\(x\\) 对应, 称 \\(y\\) 为 \\(x\\) 的函数, 记作 \\(y=f(x)\\), \\(D\\) 为 \\(x\\) 的定义域 反函数: \\(y=f(x)\\enspace(x\\in D)\\) 严格单调 (单调函数必有单调反函数) 若 \\(y=f(x) \\implies x=\\varphi(y)\\) 则 \\(\\varphi(y)\\) 就是 \\(f(x)\\) 的反函数 基本初等函数: 幂函数 \\(x^a\\) 指数函数 \\(a^x\\enspace(a&gt;0\\) 且 \\(a\\neq 1)\\) 对数函数 \\(\\log_a{x}\\enspace(a&gt;0\\) 且 \\(a\\neq 1)\\) 三角函数 \\(\\sin x,\\cos x,\\tan x,\\cot x,\\sec x,\\csc x\\) 初等函数: 由常数、基本初等函数经过四则运算、复合运算而成的式子 初等性质 奇偶性 设 \\(y=f(x)\\enspace\\) (\\(x\\in D\\), \\(D\\) 关于原点对称) 若对于 \\(\\forall x\\in D\\), 有 \\(f(-x)=-f(x)\\), 则为奇函数; \\(f(-x)=f(x)\\), 则为偶函数 单调性 设 \\(y=f(x)\\enspace(x\\in D)\\) 若 \\(\\exist x_1,x_2\\in D\\) 且 \\(x_1&lt;x_2\\) 时 , 有 \\(f(x_1)&lt;f(x_2)\\), 称 \\(f(x)\\) 在 \\(D\\) 上严格单调递增; 若 \\(\\exist x_1,x_2\\in D\\) 且 \\(x_1&lt;x_2\\) 时 , 有 \\(f(x_1)&gt;f(x_2)\\), 称 \\(f(x)\\) 在 \\(D\\) 上严格单独递减 有界性 设 \\(y=f(x)\\enspace(x\\in D)\\), 函数的界 \\(M\\) 若 \\(\\exist M&gt;0\\), 对于 \\(\\forall x\\in D\\), 有 \\(|f(x)|\\leqslant M\\), 称 \\(f(x)\\) 在 \\(D\\) 上有界 若 \\(\\forall x\\in D\\), \\(f(x)\\geqslant M_1\\), 有下界 若 \\(\\forall x\\in D\\), \\(f(x)\\leqslant M_2\\), 有上界 如: \\(|f(x)|\\leqslant 3\\hArr\\begin{cases} f(x)\\geqslant -3 \\\\ f(x)\\leqslant 3 \\end{cases}\\) 周期性 设 \\(y=f(x)\\enspace(x\\in D)\\) 若 \\(\\exist T&gt;0\\), 对于 \\(\\forall x\\in D\\enspace(x+T\\in D)\\), 有 \\(f(x+T)=f(x)\\), 称 \\(f(x)\\) 为周期函数 数列极限 数列收敛定义 (\\(\\epsilon−N\\)): 设数列 \\(\\{a_n\\}\\), \\(A\\) 为极限值, 最大误差 \\(\\varepsilon\\), 数列在元素 \\(a_N\\) 后极限有效(即之后数列元素与极限值的差值 \\(\\leqslant\\varepsilon\\)), 若 \\(\\forall\\varepsilon&gt;0\\), \\(\\exist N&gt;0\\), 当 \\(n&gt;N\\) 时 \\(|a_n-A|&lt;\\varepsilon\\) 称数列 \\(\\{a_n\\}\\) 收敛于极限 \\(A\\), 记作 \\(\\lim\\limits_{n\\to\\infty}=A\\) 或 \\(a_n\\to A\\enspace(n\\to\\infty)\\) 例: 设通项公式 \\(a_n=\\frac{n+1}{2n}\\), 具体值为 \\(\\frac{3}{4},\\frac{2}{3},\\frac{5}{8},\\frac{3}{5},\\dots\\), 观察得极限 \\(a_n\\to\\frac{1}{2}\\) 设 \\(\\varepsilon=\\frac{1}{10}&gt;0\\), 则 \\(|a_n-\\frac{1}{2}|=\\frac{1}{2n}&lt;\\frac{1}{10}\\rArr n&gt;5\\). 同理: 若 \\(\\varepsilon=\\frac{1}{100}&gt;0\\), 则 \\(\\frac{1}{2n}&lt;\\frac{1}{100}\\rArr n&gt;50\\) 若 \\(\\varepsilon=\\frac{1}{1000}&gt;0\\), 则 \\(\\frac{1}{2n}&lt;\\frac{1}{1000}\\rArr n&gt;500\\) 由此发现该数列有极限: \\(\\lim\\limits_{n\\to\\infty}a_n=\\frac{1}{2}\\) 性质 唯一性: 数列有极限必唯一 证明: (反证法) 设数列有两个极限 \\(\\lim\\limits_{n\\to\\infty}a_n=A\\), \\(\\lim\\limits_{n\\to\\infty}a_n=B\\), 且 \\(A\\neq B\\) 不妨设 \\(A&gt;B\\), \\(\\varepsilon=-\\frac{A+B}{2}\\) \\(\\because\\lim\\limits_{n\\to\\infty}a_n=A\\) \\(\\therefore\\exist N_1&gt;0\\), 当 \\(n&gt;N_1\\) 时, \\(\\mskip{1em}\\)➀ \\(|a_n-A|&lt;\\varepsilon\\Harr\\frac{3A+B}{2}&lt;a_n&lt;\\frac{A-B}{2}\\) \\(\\because\\lim\\limits_{n\\to\\infty}a_n=B\\) \\(\\therefore\\exist N_2&gt;0\\), 当 \\(n&gt;N_2\\) 时, \\(\\mskip{1em}\\)➁ \\(|a_n-B|&lt;\\varepsilon\\Harr\\frac{A-B}{2}&lt;a_n&lt;\\frac{-A+B}{2}\\) 取 \\(N=\\operatorname{max}\\{N_1,N_2\\}\\), 当 \\(n&lt;N_2\\) 时, ➀、➁ 都成立, 但这两个不等式没有交集, 矛盾, 所以 \\(A&gt;B\\) 不对, 同理 \\(B&gt;A\\) 也不对. \\(\\therefore A=B\\), 极限值只有一个. 有界性: 有极限一一定有界, 有界不一定有极限(必须得是单调有界) 若 \\(\\lim\\limits_{n\\to\\infty}a_n=A\\), 则 \\(\\exist M&gt;0\\), 使得 \\(|a_n|\\leqslant M\\), 反之不成立. 证明: \\(\\rArr\\) 取任意 \\(\\varepsilon&gt;0\\) \\(\\because\\lim\\limits_{n\\to\\infty}a_n=A\\) \\(\\therefore\\exist N&gt;0\\), 当 \\(n&gt;N\\) 时 , \\(|a_n-A|&lt;\\varepsilon\\) \\(\\because||a_n|-|A||\\leqslant|a_n-A|\\) (三角不等式) \\(\\therefore\\) 当 \\(n&gt;N\\) 时, \\(||a_n|-|A||&lt;\\varepsilon\\rArr|a_n|&lt;\\varepsilon+|A|\\) 取 \\(M=\\operatorname{max}\\{|a_1|,|a_2|,\\dots,|a_n|,\\varepsilon+|A|\\}\\), 对于 \\(\\forall n\\), 有 \\(|a_n|\\leqslant M\\) \\(\\nLeftarrow\\) 取 \\(a_n=1+(-1)^n\\), 有 \\(|a_n|\\leqslant 2\\), 但 \\(\\lim\\limits_{n\\to\\infty}a_n\\) 不存在 保号性: 若 \\(\\lim\\limits_{n\\to\\infty}a_n=A\\begin{cases} &gt;0 \\\\ &lt;0 \\end{cases}\\), 则 \\(\\exist N&gt;0\\), 当 \\(n&gt;N\\) 时, \\(a_n\\begin{cases} &gt;0 \\\\ &lt;0 \\end{cases}\\) 证明: 若 \\(A&gt;0\\), 取 \\(\\varepsilon=\\frac{A}{2}&gt;0\\) \\(\\because\\lim\\limits_{n\\to\\infty}a_n=A\\) \\(\\therefore\\exist N&gt;0\\), 当 \\(n&gt;N\\) 时, \\(\\mskip{1em}|a_n-A|&lt;\\frac{A}{2}\\hArr\\frac{A}{2}&lt;a_n&lt;\\frac{3A}{2}\\rArr a_n&gt;\\frac{A}{2}&gt;0\\) 若 \\(A&lt;0\\), 取 \\(\\varepsilon=-\\frac{A}{2}&gt;0\\) \\(\\because\\lim\\limits_{n\\to\\infty}a_n=A\\) \\(\\therefore\\exist N&gt;0\\), 当 \\(n&gt;N\\) 时, \\(\\mskip{1em}|a_n-A|&lt;-\\frac{A}{2}\\hArr\\frac{3A}{2}&lt;a_n&lt;\\frac{A}{2}\\rArr a_n&lt;\\frac{A}{2}&lt;0\\) 函数极限 定义 \\(\\varepsilon-\\delta\\) 语言定义法: (\\(\\varepsilon\\) 为值域的误差, \\(\\delta\\) 为定义域的误差) 若 \\(\\forall\\varepsilon&gt;0\\), \\(\\exist\\delta&gt;0\\), 当 \\(|x-a|&lt;\\delta\\) 时 \\(|f(x)-A|&lt;\\varepsilon\\), 称 \\(f(x)\\) 当 \\(x\\to 0\\) 时以 \\(A\\) 为极限 记作 \\(\\lim\\limits_{x\\to a}f(x)=A\\) 或 \\(f(x)\\to A\\enspace(x\\to a)\\) \\(\\varepsilon-X\\) 语言定义法: (\\(X\\) 为定义域极限存在临界点) 若 \\(\\forall\\varepsilon&gt;0\\), \\(\\exist X&gt;0\\) 当 \\(x&gt;X\\) 时, \\(|f(x)-A|&lt;\\varepsilon\\), \\(\\lim\\limits_{x\\to+\\infty}f(x)=A\\) 当 \\(x&lt;-X\\) 时, \\(|f(x)-A|&lt;\\varepsilon\\), \\(\\lim\\limits_{x\\to-\\infty}f(x)=A\\) 当 \\(|x|&gt;X\\) 时, \\(|f(x)-A|&lt;\\varepsilon\\), \\(\\lim\\limits_{x\\to\\infty}f(x)=A\\) 性质 唯一性(函数有极限必唯一) 证明: 设 \\(\\lim\\limits_{x\\to a}f(x)=A\\), \\(\\lim\\limits_{x\\to a}f(x)=B\\) 不妨设 \\(A&gt;B\\), 取 \\(\\varepsilon=\\frac{A-B}{2}&gt;0\\) \\(\\because\\lim\\limits_{x\\to a}f(x)=A\\) \\(\\therefore\\exist\\delta_1&gt;0\\), 当 \\(|x-a|&lt;\\delta_1\\) 时, \\(\\mskip{1em}\\)➀ \\(|f(x)-A|&lt;\\frac{A-B}{2}\\hArr\\frac{A+B}{2}&lt;f(x)&lt;\\frac{3A-B}{2}\\) 又 \\(\\because\\lim\\limits_{x\\to a}f(x)=B\\) \\(\\therefore\\exist\\delta_2&gt;0\\), 当 \\(|x-a|&lt;\\delta_2\\) 时, \\(\\mskip{1em}\\)➁ \\(|f(x)-B|&lt;\\frac{A-B}{2} \\hArr \\frac{3B-A}{2}&lt;f(x)&lt;\\frac{A+B}{2}\\) 取 \\(\\delta=\\operatorname{min}\\{\\delta_1,\\delta_2\\}\\), 当 \\(|x-a|&lt;\\delta\\) 时 ➀、➁ 皆成立, 矛盾. \\(\\therefore A&gt;B\\) 不对, 同理 \\(A&lt;B\\) 也不对. \\(\\therefore A=B\\), 极限值只有一个. 局部有界性: 设 \\(\\lim\\limits_{x\\to a}f(x)=A\\), \\(\\exist\\delta&gt;0\\)、\\(M&gt;0\\), 当 \\(|x-a|&lt;\\delta\\) 时, \\(|f(x)|\\leqslant M\\) 证明: 取任意 \\(\\varepsilon&gt;0\\) \\(\\because\\lim\\limits_{x\\to a}f(x)=A\\) \\(\\therefore\\exist\\delta&gt;0\\), 当 \\(|x-a|&lt;\\delta\\) 时, \\(|f(x)-A|&lt;\\varepsilon\\) 又 \\(\\because||f(x)|-|A||\\leqslant|f(x)-A|\\) (三角不等式) \\(\\therefore\\) 当 \\(|x-a|&lt;\\delta\\) 时, \\(\\mskip{1em}||f(x)|-|A||&lt;\\varepsilon\\rArr|f(x)|&lt;\\varepsilon+|A|(=M)\\) \\(\\therefore\\) 当 \\(|x-a|&lt;\\delta\\) 时, \\(|f(x)|\\leqslant M\\) 保号性: 设 \\(\\lim\\limits_{x\\to a}f(x)=A\\begin{cases} &gt;0 \\\\ &lt;0 \\end{cases}\\), 则 \\(\\exist\\delta&gt;0\\), 当 \\(|x-a|&lt;\\delta\\) 时, \\(f(x)\\begin{cases} &gt;0 \\\\ &lt;0 \\end{cases}\\) 证明: 若 \\(A&gt;0\\), 取 \\(\\varepsilon=\\frac{A}{2}&gt;0\\) \\(\\because\\lim\\limits_{x\\to a}f(x)=A\\) \\(\\therefore\\exist\\delta&gt;0\\), 当 \\(|x-a|&lt;\\delta\\) 时 \\(|f(x)-A|&lt;\\frac{A}{2}\\rArr f(x)&gt;\\frac{A}{2}&gt;0\\) 若 \\(A&lt;0\\), 取 \\(\\varepsilon=-\\frac{A}{2}&gt;0\\) \\(\\because\\lim\\limits_{x\\to a}f(x)=A\\) \\(\\therefore\\exist\\delta&gt;0\\), 当 \\(|x-a|&lt;\\delta\\) 时 \\(|f(x)-A|&lt;-\\frac{A}{2}\\rArr f(x)&lt;\\frac{A}{2}&lt;0\\) Notes: \\(\\{x|0&lt;|x-a|&lt;\\delta\\}\\) 可表示为 \\(\\mathring{\\bigcup}(a\\cdot\\delta)\\) (读作 \\(a\\) 的去心 \\(\\delta\\) 邻域) \\(x\\to a\\) 时 \\(\\begin{cases} x\\to a^- \\\\ x\\to a^+ \\end{cases}\\) 左极限与右极限 若 \\(\\forall\\varepsilon&gt;0\\), \\(\\exist\\delta&gt;0\\) 当 \\(x\\in(a-\\delta,a)\\) 时 \\(|f(x)-A|&lt;\\varepsilon\\), 此时 \\(A\\) 称为 \\(f(x)\\) 在 \\(x=a\\) 处左极限, 记为 \\(\\lim\\limits_{x\\to a^-}f(x)=A\\) 或 \\(f(a-0)=A\\) 当 \\(x\\in(a,a+\\delta)\\) 时 \\(|f(x)-B)|&lt;\\varepsilon\\), 此时 \\(B\\) 称为 \\(f(x)\\) 在 \\(x=a\\) 处右极限, 记为 \\(\\lim\\limits_{x\\to a^+}f(x)=B\\) 或 \\(f(a+0)=B\\) \\(\\lim\\limits_{x\\to a}f(x)\\) 意味着左右极限存在且相等 \\(\\lim\\limits_{x\\to a}f(x)\\) 与 \\(f(a)\\) 无关 (除非该点连续) 如: 分段函数 \\(f(x)=\\begin{cases} x-1 &amp; x&lt;0 \\\\ 0 &amp; x=0 \\\\ 2x-1 &amp; x&gt;0 \\end{cases}\\), 它的极限为 \\(\\begin{cases} \\lim\\limits_{x\\to 0^+}f(x)=-1 \\\\ \\lim\\limits_{x\\to 0^-}f(x)=-1 \\end{cases}\\rArr\\lim\\limits_{x\\to 0}f(x)=-1\\), 但 \\(f(0)=0\\) \\(\\lim\\limits_{x\\to 2}\\frac{x^2-4}{x-2}=\\lim\\limits_{x\\to 2}(x+2)=4\\), 但 \\(f(2)\\) 时分母为零 无穷小与无穷大 无穷小 \\(\\varepsilon-\\delta\\) 定义: 若 \\(\\forall\\varepsilon&gt;0\\), \\(\\exist\\delta&gt;0\\), 当 \\(|x-x_0|&lt;\\delta\\) 时 , \\(|\\alpha(x)-0| &lt;\\varepsilon\\), 称 \\(\\alpha(x)\\) 在 \\(x\\to x_0\\) 时无穷小, 记 \\(\\lim\\limits_{x\\to x_0}\\alpha(x)=0\\) 常规性质: 若 \\(\\alpha\\to 0\\), \\(\\beta\\to 0\\), 则 \\(\\begin{cases} \\alpha\\pm\\beta\\to 0 \\\\ k\\alpha\\to 0 \\\\ \\alpha\\beta\\to0 \\end{cases}\\) 无穷小乘有界函数还是无穷小: \\(\\alpha\\to 0\\), \\(|\\beta|\\leqslant M\\), 则 \\(\\alpha\\beta\\to 0\\) (重要)任意极限加无穷小还是原极限 \\(\\lim\\limits_{x\\to x_0}f(x)=A \\hArr \\lim\\limits_{x\\to x_0}f(x)=A+\\alpha\\enspace(\\alpha\\to 0)\\) 注意: 0 是无穷小, 但无穷小不一定为 0 无穷大 \\(\\varepsilon-\\delta\\) 定义: 若 \\(\\forall M&gt;0\\), \\(\\exist\\delta&gt;0\\), 当 \\(|x-x_0|&lt;\\delta\\) 时, \\(|f(x)|\\geqslant M\\), 称 \\(f(x)\\) 在 \\(x\\to x_0\\) 时无穷大, 记作 \\(\\lim\\limits_{x\\to x_0}f(x)=\\infty\\) \\(\\varepsilon-X\\) 定义: 若 \\(\\forall M&gt;0\\), \\(\\exist X&gt;0\\), 当 \\(x&gt;X\\) 时, \\(|f(x)|\\geqslant M\\), 称 \\(f(x)\\) 在 \\(x\\to +\\infty\\) 时无穷大, 记作 \\(\\lim\\limits_{x\\to+\\infty}f(x)=\\infty\\) 无穷小与无穷大的关系: \\(\\lim\\limits_{x\\to x_0}f(x)=0\\hArr\\lim\\limits_{x\\to x_0}\\frac{1}{f(x)}=\\infty\\) 极限的运算法则 四则极限法则 有 \\(\\lim\\limits_{x\\to x_0}f(x)=A\\), \\(\\lim\\limits_{x\\to x_0}g(x)=B\\) 加减: \\(\\lim\\limits_{x\\to x_0}[f(x)\\pm g(x)]=\\lim\\limits_{x\\to x_0}f(x)\\pm\\lim\\limits_{x\\to x_0}g(x)=A\\pm B\\) 数乘: \\(\\lim\\limits_{x\\to x_0}kf(x)=k\\lim\\limits_{x\\to x_0}f(x)=kA\\) 乘法: \\(\\lim\\limits_{x\\to x_0}[f(x)g(x)]=\\lim\\limits_{x\\to x_0}f(x)\\cdot\\lim\\limits_{x\\to x_0}g(x)=AB\\) 除法: \\(\\lim\\limits_{x\\to x_0}\\frac{f(x)}{g(x)}=\\frac{\\lim\\limits_{x\\to x_0}f(x)}{\\lim\\limits_{x\\to x_0}g(x)}=\\frac{A}{B}\\) 若最后是无穷大比无穷大, 极限除法的值以最高阶系数为准: 设 \\(P(x)=a_nx^n+\\dots+a_1x+a_0\\), \\(Q(x)=b_mx^m+\\dots+b_1x+b_0\\) 则 \\(\\lim\\limits_{x\\to\\infty}\\frac{P(x)}{Q(x)}=\\begin{cases} \\frac{a_n}{b_m} &amp; n=m \\\\ \\infty &amp; n&gt;m \\\\ 0 &amp; n&lt;m \\end{cases}\\) 复合函数极限法则: 设 \\(u=\\varphi(x)\\neq a\\), \\(\\lim\\limits_{u\\to a}f(u)=A\\), \\(\\lim\\limits_{x\\to x_0}\\varphi(x)=a\\), 则 \\(\\lim\\limits_{x\\to x_0}f[g(x)]=A\\) 极限存在法则和两个重要极限 极限存在准则 夹逼定理 数列型: 若 \\(\\begin{cases} a_n\\leqslant b_n\\leqslant c_n \\\\ \\lim\\limits_{n\\to\\infty}a_n=\\lim\\limits_{n\\to\\infty}c_n=A \\end{cases}\\) 则 \\(\\lim\\limits_{n\\to\\infty}b_n=A\\) 证明方法: 利用 \\(\\varepsilon−N\\) 定义推出 \\(A-\\varepsilon&lt;b_n&lt;A+\\varepsilon\\rArr|b_n-A|&lt;\\varepsilon\\) 函数型: 设 \\(\\begin{cases} f(x)\\leqslant g(x)\\leqslant h(x) \\\\ \\lim f(x)=\\lim h(x)=A \\end{cases}\\) 则 \\(\\lim g(x)=A\\) 单调有界数列必有极限 \\(\\{a_n\\}\\) 有界 \\(\\hArr\\{a_n\\}\\) 有上下界 若 \\(\\{a_n\\}\\) 单调递增: \\(\\begin{cases} \\text{有上界}\\rArr\\lim\\limits_{n\\to\\infty}a_n \\text{存在} \\\\ \\text{无上界}\\rArr\\lim\\limits_{n\\to\\infty}a_n\\text{不存在} \\end{cases}\\) 若 \\(\\{a_n\\}\\) 单调递减: \\(\\begin{cases} \\text{有下界}\\rArr\\lim\\limits_{n\\to\\infty}a_n \\text{存在} \\\\ \\text{无下界}\\rArr\\lim\\limits_{n\\to\\infty}a_n\\text{不存在} \\end{cases}\\) 两个重要极限 \\(\\lim\\limits_{x\\to 0}\\frac{\\sin x}{x}=1\\) 证明: 设 \\(0&lt;x&lt;\\frac{\\pi}{2}\\) \\(S_{\\triangle AOB}=\\frac{1}{2}\\sin x\\) \\(S_{扇形AOB}=\\frac{1}{2}x\\) \\(S_{RT\\triangle AOC}=\\frac{1}{2}\\tan x\\) \\(\\therefore\\) 结合图片和三者面积公式可得 \\(\\sin x&lt;x&lt;\\tan x \\rArr 1&lt;\\frac{x}{\\sin x}&lt;\\frac{1}{\\cos x}\\) \\(\\because\\lim\\limits_{x\\to0}\\cos x=1\\) \\(\\therefore\\lim\\limits_{x\\to0}\\frac{1}{\\cos x}=1\\), \\(\\lim\\limits_{x\\to0}1=1\\rArr\\lim\\limits_{x\\to 0}\\frac{x}{\\sin x}=1\\) (夹逼定理) \\(\\rArr\\lim\\limits_{x\\to 0}\\frac{\\sin x}{x}=1\\) 欧拉数 \\(e\\) 的定义: \\(\\lim\\limits_{n\\to\\infty}(1+\\frac{1}{n})^n=e\\) 无穷小的比较 无穷小的比较 \\(\\alpha\\to 0\\), \\(\\beta\\to 0\\) 若 \\(\\lim\\frac{\\beta}{\\alpha}=0\\), 称 \\(\\beta\\) 为 \\(\\alpha\\) 的高阶无穷小, 记 \\(\\beta=o(\\alpha)\\) 若 \\(\\lim\\frac{\\beta}{\\alpha}=\\infty\\), 称 \\(\\beta\\) 为 \\(\\alpha\\) 的低阶无穷小 若 \\(\\lim\\frac{\\beta}{\\alpha^k}=k\\enspace(k\\neq 0,\\infty)\\), 称 \\(\\beta\\) 为 \\(\\alpha\\) 的 \\(k\\) 阶无穷小 若 \\(\\lim\\frac{\\beta}{\\alpha}=k\\enspace(k\\neq 0,\\infty)\\), 称 \\(\\beta\\) 为 \\(\\alpha\\) 的同阶无穷小, 记 \\(\\beta=O(\\alpha)\\) 若 \\(\\lim\\frac{\\beta}{\\alpha}=1\\), 称 \\(\\beta\\) 为 \\(\\alpha\\) 的等价无穷小, 记 \\(\\beta\\sim\\alpha\\) 等价无穷小是同阶无穷小的充分不必要条件 等价无穷小的性质 \\(\\alpha\\to 0\\), \\(\\beta\\to 0\\) \\(\\alpha\\sim\\beta\\hArr\\beta=\\alpha+o(\\alpha)\\) 若 \\(\\alpha\\sim\\alpha_1\\), \\(\\beta\\sim\\beta_1\\), \\(\\lim\\frac{\\beta_1}{\\alpha_1}=A\\), 则 \\(\\lim\\frac{\\beta}{\\alpha}=A\\) 常用等价无穷小 (\\(x\\to 0\\)) \\(x\\sim\\sin x\\), \\(x\\sim\\tan x\\), \\(x\\sim\\arcsin x\\), \\(x\\sim\\arctan x\\), \\(x\\sim\\ln(1+x)\\), \\(x\\sim e^x-1\\) \\(1-\\cos x\\sim\\frac{x^2}{2}\\) \\((1+x)^a-1\\sim ax\\) 函数的连续性与间断点 函数连续是极限存在的充分不必要条件, 因为间断不代表极限不存在 连续 函数在一点连续: \\(\\lim\\limits_{x\\to a}f(x)=f(a)\\) 或 \\(f(a-0)=f(a+0)=f(a)\\) 若 \\(f(a-0)=f(a)\\), 称 \\(f(a)\\) 在 \\(x=a\\) 左连续 若 \\(f(a+0)=f(a)\\), 称 \\(f(a)\\) 在 \\(x=a\\) 右连续 函数在闭区间连续: \\(f(x)\\) 在 \\([a,b]\\) 上有定义, 若: \\(f(x)\\) 在 \\((a,b)\\) 内处处连续 \\(f(a)=f(a+0)\\), \\(f(b)=f(b-0)\\) 则称 \\(f(x)\\) 在 \\([a,b]\\) 上连续, 记 \\(f(x)\\in C[a,b]\\) 间断点及分类 间断: 若 \\(\\lim\\limits_{x\\to a}f(x)\\neq f(a)\\), 称 \\(f(x)\\) 在 \\(x=a\\) 间断 分类: 第一类间断点: \\(f(a-0)\\), \\(f(a+0)\\) 皆存在 可去间断点: \\(f(a-0)=f(a+0)\\neq f(a)\\) 跳跃间断点: \\(f(a-0)\\neq f(a+0)\\) 如 \\(\\lim\\limits_{x\\to 0^-}e^\\frac{1}{x}=0\\), \\(\\lim\\limits_{x\\to 0^+}e^\\frac{1}{x}=+\\infty\\) 第二类间断点: \\(f(a-0)\\), \\(f(a+0)\\) 至少一个不存在 连续函数运算及初等函数连续性 连续函数运算 四则运算 \\(f(x)\\), \\(g(x)\\) 在 \\(x=x_0\\) 处连续, 则 \\(f(x)\\pm g(x)\\) 在 \\(x=x_0\\) 处连续 \\(f(x)g(x)\\) 在 \\(x=x_0\\) 处连续 \\(\\frac{f(x)}{g(x)}\\) 在 \\(x=x_0\\) 处连续 \\((g(x)\\neq 0)\\) (证明思路是证明该点处极限与函数实际取该点值相等, 也就是上节讲到的函数连续定义) 复合运算 \\(f(u)\\), \\(u=\\varphi(x)\\neq a\\) 若 \\(\\lim\\limits_{u\\to a}f(u)=f(a)\\), \\(\\lim\\limits_{x\\to x_0}\\varphi(x)=a\\), 则 \\(\\lim\\limits_{x\\to x_0}f[\\varphi(x)]=f[\\lim\\limits_{x\\to x_0}\\varphi(x)]=f(a)\\) 初等函数连续性: 基本初等函数、初等函数在其定义域内连续 闭区间上连续函数的性质 最值定理 \\(f(x)\\in C[a,b]\\) \\(f(x)\\) 在 \\([a,b]\\) 上取到最小值 \\(m\\) 和最大值 \\(M\\) 即 \\(\\exist x_1,x_2\\in[a,b]\\), 使 \\(f(x_1)=m\\), \\(f(x_2)=M\\) 有界定理 \\(f(x)\\in C[a,b]\\) \\(\\exist k&gt;0\\), 使 \\(\\forall x\\in[a,b]\\) 有 \\(|f(x)|\\leqslant k\\) 零点定理 \\(f(x)\\in C[a,b]\\) 若 \\(f(a)f(b)&lt;0\\) \\(\\exist c\\in[a,b]\\) 使 \\(f(c)=0\\) 介值定理 \\(f(x)\\in C[a,b]\\) \\(\\forall\\eta\\in[m,M]\\), \\(\\exist\\xi\\in[a,b]\\) 使 \\(f(\\xi)=\\eta\\) 导数与微分 导数的概念 导数定义 设 \\(y=f(x)\\enspace(x\\in D)\\), \\(\\Delta y=f(x_0+\\Delta x)-f(x_0)\\enspace(x_0,(x_0+\\Delta x)\\in D)\\) 若 \\(\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta y}{\\Delta x}\\) 存在, 称 \\(f(x)\\) 在 \\(x=x_0\\) 处可导, 该极限称为 \\(f(x)\\) 在 \\(x=x_0\\) 处的导数, 记 \\(f^\\prime(x_0)\\) 或 \\(\\left.\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\right|_{x=x_0}\\) $$ f^\\prime(x_0)=\\lim\\limits_{\\Delta x\\to 0}\\frac{f(x_0+\\Delta x)-f(x_0)}{\\Delta x}=\\lim\\limits_{x\\to x_0}\\frac{f(x)-f(x_0)}{x-x_0} $$ (证明方法: 代入 \\(\\Delta x=x-x_0\\)) 导函数定义: \\(f^\\prime(x)=\\lim\\limits_{\\Delta x\\to0}\\frac{f(x+\\Delta x)-f(x)}{\\Delta x}=\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\) 注意: 可导时左右导数存在且相等 左导数: \\(\\left.\\begin{array}{c} \\lim\\limits_{\\Delta x\\to 0^-}\\frac{\\Delta y}{\\Delta x} \\\\ \\lim\\limits_{x\\to x_0^-}\\frac{f(x)-f(x_0)}{x-x_0} \\end{array}\\right\\} =f_-^\\prime(x_0)\\) 右导数: \\(\\left.\\begin{array}{c} \\lim\\limits_{\\Delta x\\to 0^+}\\frac{\\Delta y}{\\Delta x} \\\\ \\lim\\limits_{x\\to x_0^+}\\frac{f(x)-f(x_0)}{x-x_0} \\end{array}\\right\\} =f_+^\\prime(x_0)\\) 可导一定连续, 连续不一定可导. (因为连续函数在点 \\(f^\\prime(x)=0\\) 处不可导, 如正弦曲线的 \\(y=1\\) 处左右导数不同) 常见初等函数的导函数 \\(C^\\prime=0\\) \\((x^n)^\\prime=nx^{n-1}\\) \\((a^x)^\\prime=a^x\\ln a\\) 特别地 \\((e^x)^\\prime=e^x\\) \\((\\log_a x)^\\prime=\\frac{1}{x\\ln a}\\) \\((\\ln x)^\\prime=\\frac{1}{x}\\) \\((\\sin x)^\\prime=\\cos x\\) \\((\\cos x)^\\prime=-\\sin x\\) \\((\\tan x)^\\prime=\\sec^2x\\) \\((\\cot x)^\\prime=-\\csc^2x\\) \\((\\sec x)^\\prime=\\sec x\\tan x\\) \\((\\csc x)^\\prime=-\\csc x\\cot x\\) \\((\\arcsin x)^\\prime=\\frac{1}{\\sqrt{1-x^2}}\\) \\((\\arccos x)^\\prime=-\\frac{1}{\\sqrt{1-x^2}}\\) \\((\\arctan x)^\\prime=\\frac{1}{1+x^2}\\) \\((\\operatorname{arccot}x)^\\prime=-\\frac{1}{1+x^2}\\) \\((\\sin x)^{(n)}=\\sin(x+\\frac{nx}{2})\\) \\((\\cos x)^{(n)}=\\cos(x+\\frac{nx}{2})\\) \\((\\frac{1}{ax+b})^{(n)}=(-1)^n n!\\frac{a^n}{(ax+b)^{n+1}}\\) 证明: 第一步代入 \\(f^\\prime(x)=\\lim\\limits_{\\Delta x\\to0}\\frac{f(x+\\Delta x)-f(x)}{\\Delta x}\\) \\((x^n)^\\prime=nx^{n-1}\\) 会用到二项式展开式 \\((a^x)^\\prime=a^x\\ln a\\) 会用到 \\(x=e^{\\ln x}\\) 和 \\(x\\sim(e^x-1)\\) \\((\\log_a x)^\\prime=\\frac{1}{x\\ln a}\\) $$ f^\\prime(x)=\\dfrac{\\mathrm{d}y}{\\mathrm{d}x} =\\overbrace{\\dfrac{\\log_a(x+\\mathrm{d}x)-\\log_a x}{\\mathrm{d}x}=\\dfrac{\\log_a(\\frac{x+\\mathrm{d}x}{x})}{\\mathrm{d}x}}^{\\log_a \\frac{M}{N} =\\log_a M-\\log_a N}=\\dfrac{\\log_a(1+\\frac{\\mathrm{d}x}{x})}{\\mathrm{d}x} =\\overbrace{\\dfrac{\\frac{\\ln(1+\\frac{\\mathrm{d}x}{x})}{\\ln a}}{\\mathrm{d}x}}^{\\log_a N=\\frac{\\log_b N}{\\log_b a}} =\\overbrace{\\dfrac{\\frac{\\frac{\\mathrm{d}x}{x}}{\\ln a}}{\\mathrm{d}x}}^{x\\sim\\ln(1+x)}=\\dfrac{1}{x\\ln a} $$ $$ \\lim\\limits_{\\Delta x\\to 0}\\frac{\\sin(x+\\Delta x)-\\sin x}{\\Delta x} =\\underbrace{\\lim\\limits_{\\Delta x\\to 0}\\frac{\\sin x\\cos\\Delta x+\\cos x\\sin\\Delta x-\\sin x}{\\Delta x}}_{\\text{和差角公式}} =\\lim\\limits_{\\Delta x\\to 0}\\frac{\\sin x(\\cos\\Delta x-1)}{\\Delta x}+\\cos x\\lim\\limits_{\\Delta x\\to 0}\\underbrace{\\frac{\\sin\\Delta x}{\\Delta x}}_{x\\sim\\sin x}=\\cos x $$ \\((\\cos x)^\\prime\\) 的证明也同理 后面的都是将其化为 \\(\\sin x\\) 和 \\(\\cos x\\) 的形式然后利用求导的四则运算法则证明 (如 \\(\\sec x=\\frac{1}{\\cos x}\\)、\\(\\csc x=\\frac{1}{\\sin x}\\)) 使用反函数求导法则: 这里只证明 \\(\\arcsin x\\) \\(f(x):y=\\arcsin x\\), \\(\\varphi(y):x=\\sin y\\) \\(f^\\prime(x)=\\frac{1}{\\varphi^\\prime(y)}\\rArr(\\arcsin x)^\\prime=\\dfrac{1}{\\cos y}=\\underbrace{\\frac{1}{\\sqrt{1-\\sin^2 y}}}_{\\text{平方关系式}}=\\underbrace{\\frac{1}{\\sqrt{1-x^2}}}_{\\text{带入} x=\\sin y}\\) 使用高阶导数归纳法 \\(f(x)=\\sin x\\) \\(f^\\prime(x)=\\cos x=\\sin(x+\\frac{\\pi}{2})\\) \\(f^{\\prime\\prime}(x)=-\\sin x=\\sin(x+\\frac{2\\pi}{2})\\) \\(f^{\\prime\\prime\\prime}(x)=-\\cos x=\\sin(x+\\frac{3\\pi}{2})\\) \\(f^{(4)}(x)=\\sin x=\\sin(x+\\frac{4\\pi}{2})\\) \\(\\therefore f^{(n)}(x)=\\sin(x+\\frac{nx}{2})\\) 同理 \\((\\cos x)^{(n)}=\\cos(x+\\frac{nx}{2})\\) \\(f(x)=(2x+1)^{-1}\\) \\(f^\\prime(x)=(-1)(2x+1)^{-2}\\times 2\\) \\(f^{\\prime\\prime}(x)=(-1)(-2)(2x+1)^{-3}\\times 2^2\\) \\(\\therefore f^{(n)}(x)=(-1)^n\\times n! \\times 2^n \\times (2x+1)^{-(n+1)}\\) 求导法则 四则法则 设 \\(u(x)\\), \\(v(x)\\) 可导, 则 加减: \\([u(x)\\pm v(x)]^\\prime=u^\\prime(x)\\pm v^\\prime(x)\\) 数乘: \\((ku)^\\prime=ku^\\prime\\) 乘: \\([u(x)v(x)]^\\prime=u^\\prime(x)v(x)+u(x)v^\\prime(x)\\) 除: \\([\\frac{u(x)}{v(x)}]^\\prime=\\frac{u^\\prime(x)v(x)-u(x)v^\\prime(x)}{v^2(x)}\\enspace(v(x)\\neq 0)\\) 推论: \\((uvw)^\\prime=u^\\prime vw+uv^\\prime w+uvw^\\prime\\) 证明: 令 \\(\\varphi(x)=u(x)+v(x)\\) \\(\\begin{array}{rl} \\Delta\\varphi &amp; =\\varphi(x+\\Delta x)-\\varphi(x) \\\\ &amp; =u(x+\\Delta x)+v(x+\\Delta x)-u(x)-v(x) \\\\ &amp; =\\Delta u+\\Delta v \\end{array}\\) \\(\\lim\\limits_{\\Delta x\\to0}\\frac{\\Delta\\varphi}{\\Delta x}=\\lim\\limits_{\\Delta x\\to0}\\frac{\\Delta u}{\\Delta x}+\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta v}{\\Delta x}=u^\\prime(x)+v^\\prime(x)\\) 令 \\(\\varphi(x)=u(x)v(x)\\) $$ \\begin{array}{rl} \\footnotesize\\Delta\\varphi & \\footnotesize=\\varphi(x+\\Delta x)-\\varphi(x) \\\\ & \\footnotesize=u(x+\\Delta x)v(x+\\Delta x)-u(x)v(x) \\\\ & \\footnotesize=u(x+\\Delta x)v(x+\\Delta x)-u(x)v(x+\\Delta x)+u(x)v(x+\\Delta x)-u(x)v(x) \\\\ & \\footnotesize=\\Delta uv(x+\\Delta x)+u(x)\\Delta v \\end{array} $$ \\(\\begin{array}{rl} \\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta\\varphi}{\\Delta x} &amp; =\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta u}{\\Delta x}\\cdot\\lim\\limits_{\\Delta x\\to 0}v(x+\\Delta x)+u(x)\\lim\\limits_{\\Delta x\\to0}\\frac{\\Delta v}{\\Delta x} \\\\ &amp; =u^\\prime(x)v(x)+u(x)v^\\prime(x) \\end{array}\\) 提示: \\(\\lim\\limits_{\\Delta x\\to0}v(x+\\Delta x)=v(x)\\) 令 \\(\\varphi(x)=\\dfrac{u(x)}{v(x)}\\enspace(v(x)\\neq 0)\\) $$ \\begin{array}{rl} \\footnotesize\\Delta\\varphi=\\varphi(x+\\Delta x)-\\varphi(x) & =\\frac{u(x+\\Delta x)}{v(x+\\Delta x)}-\\frac{u(x)}{v(x)} \\\\ & =\\frac{u(x+\\Delta x)v(x)-v(x+\\Delta x)u(x)}{v(x+\\Delta x)v(x)} \\\\ & =\\frac{[u(x+\\Delta x)v(x)-u(x)v(x)]-[u(x)v(x+\\Delta x)-u(x)v(x)]}{v(x+\\Delta x)v(x)} \\\\ & =\\frac{\\Delta uv(x)-u(x)\\Delta v}{v(x+\\Delta x)v(x)} \\end{array} $$ \\(\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta\\varphi}{\\Delta x}=\\frac{\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta u}{\\Delta x}\\cdot v(x)-u(x)\\cdot\\lim\\limits_{\\Delta x\\to0}\\frac{\\Delta v}{\\Delta x}}{v(x)\\lim\\limits_{\\Delta x\\to0}v(x+\\Delta x)}=\\frac{u^\\prime(x)v(x)-u(x)v^\\prime(x)}{v^2(x)}\\) 提示: \\(\\lim\\limits_{\\Delta x\\to 0}v(x+\\Delta x)=v(x)\\) 反函数求导法则 \\(y=f(x)\\) 可导且 \\(f(x)^\\prime\\neq 0\\) (导数不为零意味着严格单调, 即反函数存在条件), 则反函数 \\(x=\\varphi(y)\\) 可导且 \\(\\varphi^\\prime(y)=\\frac{1}{f^\\prime(x)}\\) 证明: \\(\\varphi^\\prime(y)=\\lim\\limits_{\\Delta y\\to 0}\\frac{\\Delta x}{\\Delta y}=\\lim\\limits_{\\Delta y\\to 0}\\frac{1}{\\frac{\\Delta y}{\\Delta x}}=\\underbrace{\\lim\\limits_{\\Delta x\\to 0}}_{\\text{式➀}}\\frac{1}{\\frac{\\Delta y}{\\Delta x}}=\\frac{1}{f^\\prime(x)}\\) ➀ \\(\\lim\\limits_{\\Delta x\\to0}\\frac{\\Delta y}{\\Delta x}\\neq 0,\\infty\\rArr\\Delta y=O(\\Delta x)\\) 同阶无穷小 复合函数求导法则 (如何判断复合函数: 看其中一个函数的值域是否是另一个函数的定义域的子集) \\(y=f(u)\\) 可导, \\(u=\\varphi(x)\\) 可导且 \\(\\varphi^\\prime(x)\\neq 0\\), 则 \\(y=f(\\varphi(x))\\) 可导 有 \\(f[\\varphi(x)]^\\prime=f^\\prime[\\varphi(x)]\\varphi^\\prime(x)\\) 证明: 用极限: $$ \\begin{array}{rl} f[\\varphi(x)]^\\prime & =\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta y}{\\Delta x} \\\\ & =\\lim\\limits_{\\Delta x\\to 0}(\\frac{\\Delta y}{\\Delta u}\\cdot\\frac{\\Delta u}{\\Delta x}) \\\\ & =\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta y}{\\Delta u}\\cdot\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta u}{\\Delta x} \\\\ & =\\underbrace{\\lim\\limits_{\\Delta u\\to 0}}_{\\text{式➀}}\\frac{\\Delta y}{\\Delta u}\\cdot\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta u}{\\Delta x} \\\\ & =f^\\prime(u)\\cdot\\varphi^\\prime(x) \\end{array} $$ ➀ \\(\\varphi^\\prime(x)=\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta u}{\\Delta x}\\neq 0,\\infty\\rArr\\Delta u=O(\\Delta x)\\) 同阶无穷小 用微分: \\(f[\\varphi(x)]^\\prime=\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\frac{\\mathrm{d}y}{\\mathrm{d}u}\\cdot\\frac{\\mathrm{d}u}{\\mathrm{d}x}=f^\\prime(u)\\cdot\\varphi^\\prime(x)=f^\\prime[\\varphi(x)]\\varphi^\\prime(x)\\) 高阶导数 二阶及以上的导数称为高阶导数. 二阶导数: 对导数再求导一次就是二阶导数 \\(f^{\\prime\\prime}(x)=[f^\\prime(x)]^\\prime=\\frac{\\mathrm{d}(\\frac{\\mathrm{d}y}{\\mathrm{d}x})}{\\mathrm{d}x}=\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}\\) 同理三阶导数 \\(\\frac{\\mathrm{d}^3y}{\\mathrm{d}x^3}\\), \\(n\\) 阶导数 \\(f^{(n)}=\\frac{\\mathrm{d}^ny}{\\mathrm{d}x^n}\\) 高阶导数求导方法: 归纳法 公式法: \\((uv)^\\prime=u^\\prime v+uv^\\prime\\rArr(uv)^{\\prime\\prime}=(u^\\prime v)^\\prime+(uv^\\prime)^\\prime=u^{\\prime\\prime}v+2u^\\prime v^\\prime+uv^{\\prime\\prime}\\) (重要)莱布尼茨公式 \\((uv)^{(n)}=C_n^0 u^{(n)}v+C_n^1 u^{(n-1)}v^\\prime+C_n^2 u^{(n-2)}v^{\\prime\\prime}+\\dots+C_n^n uv^{(n)}\\) 隐函数及由参数方程确定的函数求导 隐函数求导 显函数: \\(y=f(x)\\) 隐函数: \\(F(x,y)=0\\enspace\\underrightarrow{\\text{显式化}}\\enspace y=f(x)\\) 方法: \\(F(x,y)=0\\), 将 \\(y\\) 视作关于 \\(x\\) 的函数 (\\(y=f(x)\\)), 两边对 \\(x\\) 求导. 求导时 \\(y^\\prime=f^\\prime(x)=\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\), 最终将一边化为 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\) 例: \\(e^{x+y}=x^2+y+1\\) 确定 \\(y\\) 为 \\(x\\) 的函数, 求 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\) 解: 两边对 \\(x\\) 求导得 $$ \\begin{array}{rl} & e^{x+y}(1+\\frac{\\mathrm{d}y}{\\mathrm{d}x})=2x+\\frac{\\mathrm{d}y}{\\mathrm{d}x} \\\\ \\hArr & (e^{x+y}-1)\\frac{\\mathrm{d}y}{\\mathrm{d}x}=2x-e^{x+y} \\\\ \\hArr & \\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\frac{2x-e^{x+y}}{e^{x+y}-1} \\end{array} $$ 参数方程确定的函数求导 \\(\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\end{cases}\\), 其中 \\(\\varphi(t) , \\psi(t)\\) 可导, 则 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\frac{\\psi^\\prime(t)}{\\varphi^\\prime(t)}\\enspace(\\varphi(t)\\neq 0)\\) 证明: \\(\\because\\varphi^\\prime(t)=\\frac{\\mathrm{d}x}{\\mathrm{d}t}\\), \\(\\psi^\\prime(t)=\\frac{\\mathrm{d}y}{\\mathrm{d}t}\\) \\(\\therefore\\frac{\\psi^\\prime(t)}{\\varphi^\\prime(t)}=\\frac{\\frac{\\mathrm{d}y}{\\mathrm{d}t}}{\\frac{\\mathrm{d}x}{\\mathrm{d}t}}=\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\) 微分 (一般情况下都是先有导数后求微分, 微分的主要应用是在知道导数的情况下求 \\(\\Delta y\\) 的近似值 \\(\\mathrm{d}y\\)) 微分定义 什么是微分 \\(y=f(x)\\enspace(x\\in D)\\), \\(\\Delta y=f(x_0+\\Delta x)-f(x_0)\\enspace(x_0,(x_0+\\Delta x)\\in D)\\) 若 \\(\\Delta x\\to 0\\) 时 , \\(\\Delta y\\) 和 \\(\\Delta x\\) 的关系能化为线性形式: \\(\\Delta y=A\\Delta x+o(\\Delta x)\\) 则称该函数在点 \\(x=x_0\\) 可微, 记作 \\(\\left.\\mathrm{d}y\\right|_{x=x_0}=A\\Delta x=A\\mathrm{d}x\\) 定理: 可导 \\(\\hArr\\) 可微 证明: 设函数 \\(f(x)\\) 在 \\(x=x_0\\) 处可微, 则有 \\(\\Delta y=A\\Delta x+o(\\Delta x)\\). 当 \\(\\Delta x\\neq 0\\) 时 $$ \\begin{array}{rl} \\frac{\\Delta y}{\\Delta x} & =A+\\frac{o(\\Delta x)}{\\Delta x} \\\\ \\hArr\\left.\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\right|_{x=x_0}=\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta y}{\\Delta x} & =\\lim\\limits_{\\Delta x\\to 0}[A+\\frac{o(\\Delta x)}{\\Delta x}]=A \\end{array} $$ 由上述证明可知, 若函数 \\(f(x)\\) 在 \\(x=x_0\\) 处可微, 其微分为 $$ \\left.\\mathrm{d}y\\right|_{x=x_0}=f^\\prime(x_0)\\Delta x $$ \\(\\Delta y\\) 可表示为该点的微分 \\(\\left.\\mathrm{d}y\\right|_{x=x_0}\\) 加上 \\(\\Delta y\\) 与 \\(\\left.\\mathrm{d}y\\right|_{x=x_0}\\) 的差值: $$ \\begin{array}{rl} & \\Delta y=\\left.\\mathrm{d}y\\right|_{x=x_0}+(\\Delta y-\\left.\\mathrm{d}y\\right|_{x=x_0}) \\\\ \\rArr & \\Delta y=f^\\prime(x_0)\\Delta x+\\underbrace{[\\Delta y-f^\\prime(x_0)\\Delta x]}_{\\text{式➀}} \\end{array} $$ 当 \\(\\Delta x\\to 0\\) 时 $$ \\begin{array}{rl} \\text{➀} & =\\lim\\limits_{\\Delta x\\to0}\\Delta y-f^\\prime(x_0)\\lim\\limits_{\\Delta x\\to 0}\\Delta x \\\\ & =\\lim\\limits_{\\Delta x\\to 0}\\Delta y-\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta y}{\\Delta x}\\cdot\\lim\\limits_{\\Delta x\\to 0}\\Delta x \\\\ & =\\lim\\limits_{\\Delta x\\to 0}(\\frac{\\Delta y\\Delta x}{\\Delta x}-\\frac{\\Delta y\\Delta x}{\\Delta x}) \\\\ & =\\lim\\limits_{\\Delta x\\to 0}(\\frac{0}{\\Delta x})=0 \\rArr o(\\Delta x) \\end{array} $$ 函数的微分: 结合导函数定义可得 \\(\\mathrm{d}y=f^\\prime(x)\\Delta x=f^\\prime(x)\\mathrm{d}x\\) (\\(\\mathrm{d}x=x^\\prime\\Delta x=\\Delta x\\)) 近似计算: 若要求 \\(f(x)\\) 的值, 可以找离 \\(x\\) 较近的点 \\(x_0\\), 它们的距离是 \\(\\Delta x\\), 且 \\(f(x_0)\\) 的值已知 则 \\(f(x)=f(x_0+\\Delta x)=f(x_0)+\\Delta y\\approx f(x_0)+f^\\prime(x_0)\\Delta x\\) 求近似值还可利用 0 的特殊性: \\(x\\to 0\\) 时, \\(f(x)=f(0+x)\\approx f(0)+f^\\prime(0)x\\) \\(\\sqrt[n]{1+x}\\approx 1+\\frac{x}{n}\\) \\(e^x\\approx 1+x\\) \\(\\ln(1+x)\\approx x\\) 微分公式 \\(\\mathrm{d}(c)=c^\\prime\\mathrm{d}x=0\\) \\(\\mathrm{d}(x^a)=ax^{a-1}\\mathrm{d}x\\) \\(\\mathrm{d}(a^x)=a^x\\ln a\\mathrm{d}x\\) \\(\\mathrm{d}(\\log_a x)=\\frac{1}{x\\ln a}\\mathrm{d}x\\) \\(\\mathrm{d}(\\sin x)=\\cos x\\mathrm{d}x\\) \\(\\mathrm{d}(\\cos x)=-\\sin x\\mathrm{d}x\\) \\(\\mathrm{d}(\\tan x)=\\sec^2 x\\mathrm{d}x\\) \\(\\mathrm{d}(\\cot x)=-csc^2 x\\mathrm{d}x\\) \\(\\mathrm{d}(\\sec x)=\\sec x\\tan x\\mathrm{d}x\\) \\(\\mathrm{d}(\\csc x)=-\\csc x\\cot x\\mathrm{d}x\\) \\(\\mathrm{d}(\\arcsin x)=\\frac{1}{\\sqrt{1-x^2}}\\mathrm{d}x\\) \\(\\mathrm{d}(\\arccos x)=-\\frac{1}{\\sqrt{1-x^2}}\\mathrm{d}x\\) \\(\\mathrm{d}(\\arctan x)=\\frac{1}{1+x^2}\\mathrm{d}x\\) \\(\\mathrm{d}(\\operatorname{arccot} x)=-\\frac{1}{1+x^2}\\mathrm{d}x\\) 微分四则运算 设函数 \\(u\\), \\(v\\) 加减: \\(\\mathrm{d}(u\\pm v)=\\mathrm{d}u\\pm\\mathrm{d}v\\) 乘: \\(\\mathrm{d}(uv)=\\mathrm{d}u\\cdot v+u\\cdot\\mathrm{d}v\\) 除: \\(\\mathrm{d}(\\frac{u}{v})=\\frac{\\mathrm{d}u\\cdot v-u\\cdot \\mathrm{d}v}{v^2}\\) 复合函数求微分 \\(y=f(u)\\), \\(u=\\varphi(x)\\) 则 \\(\\mathrm{d}y=f^\\prime[\\varphi(x)]\\varphi^\\prime(x)\\mathrm{d}x=f^\\prime[\\varphi(x)]\\mathrm{d}\\varphi(x)=f^\\prime(u)\\mathrm{d}u\\) 微分中值定理及导数应用 微分中值定理 罗尔中值定理 若: \\(f(x)\\in C[a,b]\\) \\(f(x)\\) 在 \\((a,b)\\) 内可导 \\(f(a)=f(b)\\) 则 \\(\\exist\\xi\\in(a,b)\\), 使 \\(f^\\prime(\\xi)=0\\) 拉格朗日中值定理 若: \\(f(x)\\in C[a,b]\\) \\(f(x)\\) 在 \\((a,b)\\) 内可导 则 \\(\\exist\\xi\\in(a,b)\\), 使 \\(f^\\prime(\\xi)=\\frac{f(b)-f(a)}{b-a}\\) (几何意义为 \\(a\\), \\(b\\) 间存在某个点的斜率等于 \\(a\\), \\(b\\) 两点所成直线的斜率. 某点导数就是该点切线的斜率) 证明: 作虚线 \\(L_{ab}\\) 连接点 \\(a\\)、\\(b\\), 带入直线点斜式方程可得: \\(L_{ab}:y-f(a)=\\frac{f(b)-f(a)}{b-a}(x-a)\\hArr y=f(a)+\\frac{f(b)-f(a)}{b-a}(x-a)\\) 令 \\(\\varphi(x)=\\text{曲}-\\text{直}=f(x)-y=f(x)-f(a)-\\frac{f(b)-f(a)}{b-a}(x-a)\\) \\(\\varphi(x)\\in C[a,b]\\), \\(\\varphi(x)\\) 在 \\((a,b)\\) 内可导且 \\(\\varphi(a)=\\varphi(b)=0\\) 根据罗尔中值定理, \\(\\exist\\xi\\in(a,b)\\), 使 \\(\\varphi^\\prime(\\xi)=0\\) \\(\\therefore\\varphi^\\prime(\\xi)=f^\\prime(\\xi)-\\frac{f(b)-f(a)}{b-a}=0\\rArr f^\\prime(\\xi)=\\frac{f(b)-f(a)}{b-a}\\) 柯西中值定理 若: \\(f(x),g(x)\\in C[a,b]\\) \\(f(x),g(x)\\) 在 \\((a,b)\\) 内可导 \\(g^\\prime(x)\\neq 0\\enspace(x\\in(a,b))\\) 则 \\(\\exist\\xi\\in(a,b)\\), 使 \\(\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}=\\frac{f(b)-f(a)}{g(b)-g(a)}\\) 证明: 构造辅助函数 \\(\\varphi(x)=f(x)-f(a)-\\frac{f(b)-f(a)}{g(b)-g(a)}[g(x)-g(a)]\\) \\(\\varphi(x)\\in C[a,b]\\), \\(\\varphi(x)\\) 在 \\((a,b)\\) 内可导且可知 \\(\\varphi(a)=\\varphi(b)=0\\) \\(\\therefore\\exist\\xi\\in(a,b)\\), 使 \\(\\varphi^\\prime(\\xi)=0\\) \\(\\therefore\\varphi^\\prime(\\xi)=f^\\prime(\\xi)-\\frac{f(b)-f(a)}{g(b)-g(a)}g^\\prime(\\xi)=0\\rArr\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}=\\frac{f(b)-f(a)}{g(b)-g(a)}\\) 洛必达法则 问题的起源: 求 \\(\\lim\\limits_{x\\to 0}\\frac{\\tan x-\\sin x}{x^3}\\) 解: 法1: 原式 \\(=\\lim\\limits_{x\\to 0}\\frac{\\tan x(1-\\overbrace{\\cos x)}^{\\tan x=\\frac{\\sin x}{\\cos x}}}{x^3}=\\lim\\limits_{x\\to 0}\\frac{x\\cdot\\frac{x^2}{2}}{x^3}=\\frac{1}{2}\\) 法2: 原式 \\(=\\lim\\limits_{x\\to 0}\\frac{x-x}{x^3}=0\\) (不行, 精确度不够) 同样使用等价无限小, 却得到了不同的结果. 说明对于存在 无穷小比无穷小(\\(\\frac{0}{0}\\)) 的极限 , 用等价无穷小解极限有局限性, 分子分母经等价无穷小转化后不同阶, 导数精确度不够 洛必达法则的目标: 解 \\(\\frac{0}{0}\\), \\(\\frac{\\infty}{\\infty}\\) 类极限新方法 洛必达法则: 若: \\(f(x)\\)、\\(g(x)\\) 在点 \\(x=a\\) 的去心邻域内可导且 \\(g^\\prime(x)\\neq 0\\) \\(\\frac{0}{0}\\) 型: \\(\\lim\\limits_{x\\to a}f(x)=0\\), \\(\\lim\\limits_{x\\to a}g(x)=0\\) \\(\\frac{\\infty}{\\infty}\\) 型: \\(\\lim\\limits_{x\\to a}f(x)=\\infty\\), \\(\\lim\\limits_{x\\to a}g(x)=\\infty\\) \\(\\lim\\limits_{x\\to a}\\frac{f^\\prime(x)}{g^\\prime(x)}=A\\) 则 \\(\\lim\\limits_{x\\to a}\\frac{f(x)}{g(x)}=A\\) 洛必达法则证明: (利用柯西中值定理) \\(\\lim\\limits_{x\\to a}f(x)=0\\), \\(\\lim\\limits_{x\\to a}g(x)=0\\) \\(\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}=\\frac{f(x)-f(a)}{g(x)-g(a)}\\enspace(\\xi\\in(a,x))\\) \\(\\therefore\\lim\\limits_{x\\to a}\\frac{f(x)-f(a)}{g(x)-g(a)}=\\lim\\limits_{x\\to a}\\frac{f(x)}{g(x)}=\\lim\\limits_{x\\to a}\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}=\\lim\\limits_{\\xi\\to a}\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}=A\\) (\\(x\\to a\\), \\(\\xi\\) 介于 \\(a\\) 与 \\(x\\) 之间 \\(\\rArr\\xi\\to a\\)) \\(\\lim\\limits_{x\\to a}f(x)=\\infty\\), \\(\\lim\\limits_{x\\to a}g(x)=\\infty\\) $$ \\begin{array}{rl} \\frac{f(x)}{g(x)} & =\\frac{f(x)-f(a)}{g(x)}+\\frac{f(a)}{g(x)} \\\\ & =\\frac{g(x)-g(a)}{g(x)}\\cdot\\frac{f(x)-f(a)}{g(x)-g(a)}+\\frac{f(a)}{g(x)} \\\\ & =[1-\\frac{g(a)}{g(x)}]\\cdot\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}+\\frac{f(a)}{g(x)}\\enspace(\\xi\\in(a,x)) \\end{array} $$ \\(\\hArr\\lim\\limits_{x\\to a}\\frac{f(x)}{g(x)}=\\lim\\limits_{x\\to a}[1-\\frac{g(a)}{g(x)}]\\cdot\\lim\\limits_{x\\to a}\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}+\\lim\\limits_{x\\to a}\\frac{f(a)}{g(x)}\\) \\(\\because f(a)\\)、\\(g(a)\\) 是定值 (因此远远小于 \\(\\infty\\)) \\(\\therefore\\lim\\limits_{x\\to a}\\frac{f(x)}{g(x)}=\\lim\\limits_{x\\to a}\\frac{f^\\prime(\\xi)}{g^\\prime(\\xi)}=A\\) 注意 若 \\(\\lim\\limits_{x\\to a}\\frac{f^\\prime(x)}{g^\\prime(x)}\\) 不存在, 只表明洛必达法则不能使用, 不代表极限 \\(\\lim\\limits_{x\\to a}\\frac{f(x)}{g(x)}\\) 不存在 \\(\\lim\\limits_{x\\to+\\infty}\\frac{\\ln x}{x^a}=0\\enspace(a&gt;0)\\) \\(\\lim\\limits_{x\\to+\\infty}\\frac{x^a}{b^x}=0\\enspace(a&gt;0,b&gt;1)\\) 泰勒公式 泰勒公式 设 \\(f(x)\\) 在 \\(x=x_0\\) 邻域内 \\(n+1\\) 阶可导 则 \\(f(x)=P_n(x)+R_n(x)\\) 其中: \\(P_n(x)=f(x_0)+f^\\prime(x_0)(x-x_0)+\\frac{f^{\\prime\\prime}(x_0)}{2!}(x-x_0)^2+\\dots+\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\\) \\(R_n(x)=o((x-x_0)^n)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)^{n+1}\\enspace\\) (\\(\\xi\\) 介于 \\(x_0\\) 与 \\(x\\) 之间) 如果 \\(x_0=0\\), 这个式子被称为麦克劳林公式 泰勒公式证明: 设 \\(\\footnotesize f(x)=a_0+a_1(x-x_0)+a_2(x-x_0)^2+a_3(x-x_0)^3+\\dots+a_n(x-x_0)^n\\) 要使这个式子派用场, 得找到 \\(a_0,a_1,\\dots\\) 这些系数的值, 怎么做呢? 要得到 \\(a_0\\), 可以使 \\(x=x_0\\), 这样其他项就消除了 那其他的 \\(a_1,a_2,a_3\\) 呢? 我们可以不断对该式求它的一阶, 二阶, 三阶, … 导数: \\(f^\\prime(x)=a_1+2a_2(x-x_0)+3a_3(x-x_0)^2+\\dots+na_n(x-x_0)^{n-1}\\) \\(f^{\\prime\\prime}(x)=2a_2+3\\cdot 2a_3(x-x_0)^2+\\dots+n(n-1)(x-x_0)^{n-2}\\) \\(\\dots\\) 发现规律了吗, 将 \\(x=x_0\\) 带入, 可以轻松得到对应项的系数值: \\(a_1=\\frac{f^\\prime(x_0)}{1}\\), \\(a_2=\\frac{f^{\\prime\\prime}(x_0)}{1\\cdot 2}\\), \\(a_3=\\frac{f^{\\prime\\prime\\prime}(x_0)}{1\\cdot 2\\cdot 3}\\rArr a_n=\\frac{f^{(n)}(x_0)}{n!}\\) 然后式子就能写成 \\(\\footnotesize f(x)=f(x_0)+f^\\prime(x_0)(x-x_0)+\\frac{f^{\\prime\\prime}(x_0)}{2!}(x-x_0)^2+\\dots+\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\\) (常见泰勒展开式见章节: 无穷级数-&gt;函数展开成幂级数) 导数与函数单调性和曲线凹凸性的关系 导数与函数单调性 导数可以判别函数的单调性: \\(f(x)\\enspace(x\\in[a,b])\\) 在 \\((a,b)\\) 内可导 若 \\(f^\\prime(x)&gt;0\\enspace(a&lt;x&lt;b)\\), 则 \\(f(x)\\) 在 \\([a,b]\\) 上单调递增 若 \\(f^\\prime(x)&lt;0\\enspace(a&lt;x&lt;b)\\), 则 \\(f(x)\\) 在 \\([a,b]\\) 上单调递减 导数与曲线凹凸性 曲线凹凸性的定义: 若 \\(\\forall x_1,x_2\\in D\\) 且 \\(x_1\\neq x_2\\), 有 \\(f(\\frac{x_1+x_2}{2})&lt;\\frac{f(x_1)+f(x_2)}{2}\\) 则 \\(f(x)\\) 在 \\(D\\) 内为凹函数 若 \\(\\forall x_1,x_2\\in D\\) 且 \\(x_1\\neq x_2\\), 有 \\(f(\\frac{x_1+x_2}{2})&gt;\\frac{f(x_1)+f(x_2)}{2}\\) 则 \\(f(x)\\) 在 \\(D\\) 内为凸函数 二阶导数判别法: \\(f(x)\\enspace(x\\in[a,b])\\) 在 \\((a,b)\\) 内二阶可导 若 \\(f^{\\prime\\prime}(x)&gt;0\\enspace(a&lt;x&lt;b)\\), 则 \\(y=f(x)\\) 图像在 \\([a,b]\\) 上是凹的 若 \\(f^{\\prime\\prime}(x)&lt;0\\enspace(a&lt;x&lt;b)\\), 则 \\(y=f(x)\\) 图像在 \\([a,b]\\) 上是凸的 极值与最值 一个函数中, 极大值、极小值可以有很多, 但最大值、最小值只能有一个 极大值与极小值 定义: 设 \\(y=f(x)\\enspace(x,x_0\\in D)\\) 若 \\(\\exist\\delta&gt;0\\), 当 \\(0&lt;|x-x_0|&lt;\\delta\\) 时 有 \\(f(x)&gt;f(x_0)\\), 称 \\(x_0\\) 为极小点, \\(f(x_0)\\) 为极小值 有 \\(f(x)&lt;f(x_0)\\), 称 \\(x_0\\) 为极大点, \\(f(x_0)\\) 为极大值 求极值的步骤: 法一(利用目标点附近导数) 若同时满足 \\(\\begin{array}{cc} x&lt;x_0 &amp; f^\\prime(x)&lt;0 \\\\ x&gt;x_0 &amp; f^\\prime(x)&gt;0 \\end{array}\\) 则 \\(x=x_0\\) 为极小点 若同时满足 \\(\\begin{array}{cc} x&lt;x_0 &amp; f^\\prime(x)&gt;0 \\\\ x&gt;x_0 &amp; f^\\prime(x)&lt;0 \\end{array}\\) 则 \\(x=x_0\\) 为极大点 法二(利用二阶导数) 设 \\(f^\\prime(x_0)=0\\), \\(f^{\\prime\\prime}(x_0)\\begin{cases} &gt;0 &amp; x_0 \\text{为极小点} \\\\ &lt; 0 &amp; x_0 \\text{为极大点} \\end{cases}\\) 最大值与最小值 设 \\(f(x)\\in C[a,b]\\) 则极小值和极大值可在 \\(f(a)\\)、\\(f(b)\\) 和其他使 \\(f^\\prime(x)=0\\text{或不存在}\\) 的点之中找到 函数图像描绘 渐近线 设函数 \\(f(x)\\) 水平渐近线: 若 \\(\\lim\\limits_{x\\to\\infty}f(x)=A\\) 称 \\(f(x)\\) 有水平渐近线 \\(y=A\\) 垂直渐近线: 若 \\(\\lim\\limits_{x\\to a}f(x)=\\infty\\) 称 \\(f(x)\\) 有垂直渐近线 \\(x=a\\) 斜渐近线: 若 \\(\\lim\\limits_{x\\to\\infty}\\frac{f(x)}{x}=k \\quad\\) (可以理解为斜率) \\(\\lim\\limits_{x\\to\\infty}[f(x)-kx]=b\\) 称 \\(f(x)\\) 有斜渐近线 \\(y=kx+b\\) 作图 (根据一阶和二阶导数的值描绘函数曲线) 设函数 \\(f(x)\\enspace(x\\in D)\\) 在定义域内: 找出 \\(f^\\prime(x)=0\\text{或不存在}\\) 的所有点 找出 \\(f^{\\prime\\prime}(x)=0\\text{或不存在}\\) 的所有点 画渐近线 作表 \\(x\\) () ? () ? \\(\\dots\\) \\(f^\\prime(x)\\) \\(+\\) \\(-\\) \\(f^{\\prime\\prime}(x)\\) \\(+\\) \\(+\\) \\(f(x)\\) \\(\\nearrow\\) 极大 \\(\\searrow\\) 在坐标系上找到关键点, 描图 弧微分与曲率 弧微分 前面的微分能让我们求 \\(\\Delta y\\) 的近似值, 也就是从 \\(x\\) 到 \\(x_0\\) 后 \\(y\\) 轴的偏移量近似值 但如果我们想要求从 \\(x\\) 到 \\(x_0\\) 间这段函数曲线长度的近似值(即弧微分)呢? 两种弧微分形式: 普通函数 \\(L:f(x)\\) \\(\\mathrm{d}s=\\sqrt{(\\mathrm{d}x)^2+(\\frac{\\mathrm{d}y}{\\mathrm{d}x})^2(\\mathrm{d}x)^2}=\\sqrt{1+(\\frac{\\mathrm{d}y}{\\mathrm{d}x})^2}\\mathrm{d}x=\\sqrt{1+[f^\\prime(x)]^2}\\mathrm{d}x\\) 参数方程 \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\end{cases}\\) \\(\\footnotesize\\mathrm{d}s=\\sqrt{(\\mathrm{d}x)^2+(\\mathrm{d}y)^2}=\\sqrt{[\\varphi^\\prime(t)]^2(\\mathrm{d}t)^2+[\\psi^\\prime(t)]^2(\\mathrm{d}t)^2}=\\sqrt{[\\varphi^\\prime(t)]^2+[\\psi^\\prime(t)]^2}\\mathrm{d}t\\) 曲率与曲率半径 曲率大小的因素: 角度一定, 弯曲度与两点间的弧长成反比 \\(\\Delta\\alpha\\) 一定, \\(|\\stackrel\\frown{M_1N_1}|&lt;|\\stackrel\\frown{M_2N_2}|\\) 弧长一定, 弯曲度与切线夹角成正比 \\(|\\stackrel\\frown{MN}|\\) 一定, \\(\\Delta\\alpha_1&gt;\\Delta\\alpha_2\\) 曲率定义: 设 \\(L:f(x)\\), \\(|\\stackrel\\frown{MM^\\prime}|=\\Delta s\\) 平均曲率 \\(\\bar{k}=\\dfrac{|\\Delta\\alpha|}{|\\Delta s|}\\) 某点曲率 \\(k=\\lim\\limits_{\\Delta x\\to 0}|\\frac{\\Delta\\alpha}{\\Delta s}|=|\\frac{\\mathrm{d}\\alpha}{\\mathrm{d}s}|=\\frac{|f^{\\prime\\prime}(x)|}{(1+[f^\\prime(x)]^2)^\\frac{3}{2}}\\) 证明: 可知 \\(f^\\prime(x)=\\lim\\limits_{\\Delta x\\to 0}\\tan\\alpha\\), 两边对 \\(x\\) 求导得 \\(f^{\\prime\\prime}(x)=\\sec^2\\alpha\\cdot\\frac{\\mathrm{d}\\alpha}{\\mathrm{d}x}\\) \\(\\because\\sec^2\\alpha=1+\\tan^2\\alpha=1+[f^\\prime(x)]^2\\) \\(\\therefore\\frac{\\mathrm{d}\\alpha}{\\mathrm{d}x}=\\frac{f^{\\prime\\prime}(x)}{1+[f^\\prime(x)]^2}\\rArr\\mathrm{d}\\alpha=\\frac{f^{\\prime\\prime}(x)}{1+[f^\\prime(x)]^2}\\mathrm{d}x\\) 曲率半径: \\(R=\\frac{1}{k}\\) 不定积分 不定积分的概念与性质 原函数: 设 \\(f(x)\\), \\(F(x)\\enspace(x\\in I)\\) 若 \\(\\forall x\\in I\\), 有 \\(F^\\prime(x)=f(x)\\), 称 \\(F(x)\\) 为 \\(f(x)\\) 的其中一个原函数 注意: 一个函数若有原函数, 则一定有无数个原函数 设 \\(F^\\prime(x)=f(x)\\) 则 \\(F(x)+C\\) 为 \\(f(x)\\) 的一切原函数 一个函数的的任意两个原函数之差 \\(\\in C\\) 不定积分 \\(F(x)+C\\) 为 \\(f(x)\\) 的所有原函数 则称 \\(F(x)+C\\) 就是 \\(f(x)\\) 的不定积分, 记作 \\(\\int f(x)\\mathrm{d}x\\) 不定积分公式 \\(\\int k\\mathrm{d}x=kx+C\\) \\(\\int x^a\\mathrm{d}x=\\begin{cases} \\frac{1}{a+1}x^{a+1}+C &amp; (a\\neq -1) \\\\ \\ln|x|+C &amp; (a=-1) \\end{cases}\\) \\(\\int a^x\\mathrm{d}x=\\frac{a^x}{\\ln a}+C\\) \\(\\int\\sin x\\mathrm{d}x=-\\cos x+C\\) \\(\\int\\cos x\\mathrm{d}x=\\sin x+C\\) \\(\\int\\tan x\\mathrm{d}x=-\\ln|\\cos x|+C\\) \\(\\int\\cot x\\mathrm{d}x=\\ln|\\sin x|+C\\) \\(\\int\\csc x\\mathrm{d}x=\\ln|\\csc x-\\cot x|+C=\\ln|\\tan\\frac{x}{2}|+C\\) \\(\\int\\sec x\\mathrm{d}x=\\ln|\\sec x+\\tan x|+C\\) \\(\\int\\sec^2x\\mathrm{d}x=\\tan x+C\\) \\(\\int\\csc^2x\\mathrm{d}x=-\\cot x+C\\) \\(\\int\\sec x\\tan x\\mathrm{d}x=\\sec x+C\\) \\(\\int\\csc x\\cot x\\mathrm{d}x=-\\csc x+C\\) \\(\\int\\frac{1}{\\sqrt{1-x^2}}\\mathrm{d}x=\\arcsin x+C\\) \\(\\int\\frac{1}{\\sqrt{a^2-x^2}}\\mathrm{d}x=\\arcsin\\frac{x}{a}+C\\) \\(\\int\\frac{1}{1+x^2}\\mathrm{d}x=\\arctan x+C\\) \\(\\int\\frac{1}{a^2+x^2}\\mathrm{d}x=\\frac{1}{a}\\arctan\\frac{x}{a}+C\\) \\(\\int\\frac{1}{x^2-a^2}\\mathrm{d}x=\\frac{1}{2a}\\ln|\\frac{x-a}{x+a}|+C\\) \\(\\int\\frac{1}{\\sqrt{x^2+a^2}}\\mathrm{d}x=\\ln(x+\\sqrt{x^2+a^2})+C\\) \\(\\int\\frac{1}{\\sqrt{x^2-a^2}}\\mathrm{d}x=\\ln|x+\\sqrt{x^2-a^2}|+C\\) \\(\\int\\frac{1}{\\sqrt{a^2-x^2}}\\mathrm{d}x=\\frac{a^2}{2}\\arcsin\\frac{x}{a}+\\frac{1}{2}x\\sqrt{a^2-x^2}+C\\) 证明: \\(\\footnotesize\\int x^a\\mathrm{d}x\\enspace(a=-1)\\rArr\\begin{cases} \\int\\frac{1}{x}\\mathrm{d}x=\\ln(-x)+C &amp; (x&lt;0) \\\\ \\int\\frac{1}{x}\\mathrm{d}x=\\ln(x)+C &amp; (x&gt;0) \\end{cases}\\rArr\\ln|x|+C\\) \\(\\int\\tan x\\mathrm{d}x=\\int\\frac{\\sin x}{\\cos x}\\mathrm{d}x=-\\int\\frac{1}{\\cos x}\\mathrm{d}(\\cos x)=-\\ln|\\cos x|+C\\) \\(\\int\\cot x\\mathrm{d}x=\\int\\frac{\\cos x}{\\sin x}\\mathrm{d}x=\\int\\frac{1}{\\sin x}\\mathrm{d}(\\sin x)=\\ln|\\sin x|+C\\) 这里只证明 \\(\\int\\frac{1}{\\sqrt{x^2+a^2}}\\mathrm{d}x\\) 令 \\(x=a\\tan t\\) (第二类换元积分法) $$ \\begin{array}{rl} \\text{原式}=\\int\\frac{a\\sec^2t}{a\\sec t}\\mathrm{d}t & =\\int\\sec t\\mathrm{d}t \\\\ & =\\ln|\\sec t+\\tan t|+C \\\\ & =\\ln|\\frac{\\sqrt{x^2+a^2}}{a}+\\frac{x}{a}|+C \\\\ & =\\ln|x+\\sqrt{x^2+a^2}|\\cdot\\frac{1}{a}+C \\\\ & =\\ln|x+\\sqrt{x^2+a^2}|+\\ln\\frac{1}{a}+C \\\\ & =\\ln|x+\\sqrt{x^2+a^2}|+C\\enspace(\\ln\\frac{1}{a}\\text{并入}C) \\\\ & =\\ln|x+\\sqrt{x^2+a^2}|+C \\\\ & =\\ln(x+\\sqrt{x^2+a^2})+C \\end{array} $$ 不定积分性质 \\(\\int[f(x)\\pm g(x)]\\mathrm{d}x=\\int f(x)\\mathrm{d}x+\\int g(x)\\mathrm{d}x\\) \\(\\int af(x)\\mathrm{d}x=a\\int f(x)\\mathrm{d}x\\) 不定积分的换元积分法与分部积分法 换元积分法 第一类换元积分法 \\(f(u)\\) 存在原函数 \\(F(u)\\) 且 \\(\\varphi(x)\\) 可导, 则 \\(\\footnotesize\\int f[\\varphi(x)]\\underbrace{\\varphi^\\prime(x)\\mathrm{d}x}_{f^\\prime(x)\\mathrm{d}x=\\mathrm{d}f(x)}=\\int\\underbrace{f[\\varphi(x)]\\mathrm{d}\\varphi(x)}_{\\text{设}\\varphi(x)=t}=\\int f(t)\\mathrm{d}t=F(t)+C=F[\\varphi(x)]+C\\) 第二类换元积分法 \\(x=\\psi(t)\\) 可导且 \\(\\psi^\\prime(t)\\neq 0\\) \\(\\footnotesize\\int f(x)\\mathrm{d}x=\\int f[\\psi(t)]\\mathrm{d}\\psi(t)=\\int f[\\psi(t)]\\psi^\\prime(t)\\mathrm{d}t=\\int g(t)\\mathrm{d}t=G(t)+C=G[\\psi^{-1}(x)]+C\\) 例: \\(\\int\\frac{1}{\\sqrt{x}+\\sqrt[3]{x}}\\mathrm{d}x\\) 解: 令 \\(x=t^6\\) $$ \\begin{array}{rl} \\text{原式} & =6\\int\\frac{t^5}{t^3+t^2}\\mathrm{d}t \\\\ & =6\\int\\frac{(t^3+1)-1}{t+1}\\mathrm{d}t \\\\ & =6\\int\\frac{t^3+t^2+1-t^2}{t+1}-\\frac{1}{t+1}\\mathrm{d}t \\\\ & =6\\int\\frac{t^2(t+1)+(1+t)(1-t)}{t+1}-\\frac{1}{t+1}\\mathrm{d}t \\\\ & =6\\int(t^2-t+1)-\\frac{1}{t+1}\\mathrm{d}t \\\\ & =6[\\frac{1}{3}t^3-\\frac{1}{2}t^2+t-\\ln|t+1|]+C \\\\ & =2t^3-3t^2+6t-6\\ln|t+1|+C \\\\ & =2\\sqrt{x}-3\\sqrt[3]{x}+6\\sqrt[6]{x}-6\\ln|\\sqrt[6]{x}+1|+C \\end{array} $$ 分部积分法 先用换元积分法将积分式变成 \\(\\int u\\mathrm{d}v\\) 的形式 然后用分部积分公式: \\(\\int u\\mathrm{d}v=uv-\\int v\\mathrm{d}u\\) 证明: \\(uv=\\int(uv)^\\prime\\mathrm{d}x=\\int u^\\prime v\\mathrm{d}x+\\int uv^\\prime\\mathrm{d}x=\\int v\\mathrm{d}u+\\int u\\mathrm{d}v\\) 例: \\(\\int x^2\\ln x\\mathrm{d}x\\) 解: $$ \\begin{aligned} \\int x^2\\ln x\\mathrm{d}x & =\\int\\ln x\\mathrm{d}(\\frac{1}{3}x^3) \\\\ & =\\frac{1}{3}x^3\\ln x-\\int\\frac{1}{3}x^3\\mathrm{d}(\\ln x) \\\\ & =\\frac{1}{3}x^3\\ln x-\\frac{1}{3}\\int x^2\\mathrm{d}x \\\\ & =\\frac{1}{3}x^3\\ln x-\\frac{1}{9}x^3+C \\end{aligned} $$ 定积分 定积分的概念与性质 定积分定义 设 \\(f(x)\\) 在 \\([a,b]\\) 上有界, \\(x_1,x_2,\\dots,x_n\\) 为 \\([a,b]\\) 间的分段点 \\(a=x_0&lt;x_1&lt;x_2&lt;\\dots&lt;x_n=b\\), \\(\\Delta x_i=x_i-x_{i-1}\\enspace(1\\leqslant i\\leqslant n)\\) \\(\\exist s_i\\in[x_{i-1},x_i]\\), \\(\\displaystyle\\sum_{i=1}^n f(\\xi_i)\\Delta x_i\\) \\(\\lambda=\\operatorname{max}\\{\\Delta x_1,\\Delta x_2,\\dots,\\Delta x_n\\}\\) 若 \\(\\displaystyle\\lim\\limits_{\\lambda\\to 0}\\sum_{i=1}^n f(\\xi_i)\\Delta x_i\\) 存在, 称 \\(f(x)\\) 在 \\([a,b]\\) 上可积 称该极限为 \\(f(x)\\) 在 \\([a,b]\\) 上的定积分, 记作 \\(\\int_a^b f(x)\\mathrm{d}x\\) 即 \\(\\lim\\limits_{\\lambda\\to 0}\\displaystyle\\sum_{i=1}^n\\textstyle f(\\xi_1)\\Delta x_i=\\int_a^b f(x)\\mathrm{d}x\\) 注: \\(L:y=f(x)\\geqslant 0\\enspace(x\\in[a,b])\\) 则 \\(A=\\int_a^b f(x)\\mathrm{d}x\\) 例: 物理中知道速度函数和时间求位移(\\(v\\) 为速度, \\(t\\) 为时间) 设 \\(v=V(t)\\enspace(t\\in[a,b])\\) 则 \\(S=\\int_a^b V(t)\\mathrm{d}t\\) \\(\\displaystyle\\lim\\limits_{\\lambda\\to 0}\\sum_{i=1}^n f(\\xi_1)\\Delta x_i\\) 与 \\([a,b]\\) 分法及 \\(\\xi_i\\) 取法无关 \\(f(x)\\) 在 \\([a,b]\\) 上有界不一定可积 如分段函数 \\(f(x)=\\begin{cases} 1 &amp; x\\in Q \\\\ 0 &amp; x\\in R-Q \\end{cases}\\) 若 \\(f(x)\\in C[a,b]\\), 则 \\(f(x)\\) 在 \\([a,b]\\) 上可积 若 \\(f(x)\\) 在 \\([a,b]\\) 上只有有限个第一类间断点, 则 \\(f(x)\\) 在 \\([a,b]\\) 上可积 定积分的一般性质 \\(\\int_a^a f(x)\\mathrm{d}x=0\\) \\(\\int_a^b f(x)\\mathrm{d}x=-\\int_b^a f(x)\\mathrm{d}x\\) \\(\\int_a^b[f(x)\\pm g(x)]\\mathrm{d}x=\\int_a^b f(x)\\mathrm{d}x\\pm\\int_a^b g(x)\\mathrm{d}x\\) \\(\\int_a^b kf(x)\\mathrm{d}x=k\\int_a^b f(x)\\mathrm{d}x\\) \\(\\int_a^b f(x)\\mathrm{d}x=\\int_a^c f(x)\\mathrm{d}x+\\int_c^b f(x)\\mathrm{d}x\\enspace(a&lt;b)\\) (即使 \\(c&lt;a&lt;b\\) 也成立, 因为 \\(\\int_a^c\\) 是负的, 正好减去了 \\(\\int_c^b\\) 多出来的, \\(a&lt;b&lt;c\\) 同理) \\(\\int_a^b 1\\mathrm{d}x=b-a\\) 定积分间的比较 \\(f(x)\\geqslant 0\\enspace(a\\leqslant x\\leqslant b)\\), 则 \\(\\int_a^b f(x)\\mathrm{d}x\\geqslant 0\\) \\(f(x)\\geqslant g(x)\\enspace(a\\leqslant x\\leqslant b)\\), 则 \\(\\int_a^b f(x)\\mathrm{d}x\\geqslant\\int_a^b g(x)\\mathrm{d}x\\) 若 \\(f(x)\\)、\\(|f(x)|\\) 在 \\([a,b]\\) 上可积, 则 \\(|\\int_a^b f(x)\\mathrm{d}x|\\leqslant\\int_a^b|f(x)|\\mathrm{d}x\\) 积分中值定理 设 \\(f(x)\\in C[a,b]\\), 则 \\(\\exist\\xi\\in[a,b]\\), 使 \\(\\underbrace{\\int_a^b f(x)\\mathrm{d}x}_{\\text{曲边梯形面积}}=\\underbrace{f(\\xi)(b-a)}_{\\text{矩形面积}}\\) 证明: \\(\\because f(x)\\in C[a,b]\\) \\(\\therefore\\exist m,M\\in[a,b]\\), 使 \\(m(b-a)\\leqslant\\int_a^b f(x)\\mathrm{d}x\\leqslant M(b-a)\\) \\(\\rArr m\\leqslant\\frac{1}{b-a}\\int_a^b f(x)\\mathrm{d}x\\leqslant M\\) \\(\\therefore\\exist\\xi\\in[a,b]\\), 使 \\(f(\\xi)=\\frac{1}{b-a}\\int_a^b f(x)\\mathrm{d}x\\rArr\\int_a^b f(x)\\mathrm{d}x=(b-a)f(\\xi)\\) (介值定理) 积分基本定理 积分上限函数及其与目标函数的关系: 设 \\(f(x)\\in C[a,b]\\), 令 \\(\\varPhi(x)=\\int_a^x f(t)\\mathrm{d}t\\), 则 \\(\\varPhi^\\prime(x)=\\frac{\\mathrm{d}}{\\mathrm{d}x}\\int_a^x f(t)\\mathrm{d}t=f(x)\\) 复合函数推论: \\(\\varPhi[\\varphi(x)]^\\prime=\\frac{\\mathrm{d}}{\\mathrm{d}x}\\int_a^{\\varphi(x)}f(t)\\mathrm{d}t=\\frac{\\mathrm{d}}{\\mathrm{d}\\varphi(x)}\\int_a^{\\varphi(x)}f(t)\\mathrm{d}t\\cdot\\frac{\\varphi(x)}{x}=f[\\varphi(x)]\\varphi^\\prime(x)\\) 证明: \\(\\footnotesize\\Delta\\varPhi=\\varPhi(x+\\Delta x)-\\varPhi(x)=\\int_a^{x+\\Delta x}f(t)\\mathrm{d}t-\\int_a^x f(t)\\mathrm{d}t=\\int_x^{x+\\Delta x}f(t)\\mathrm{d}t\\) \\(\\because f(x)\\in C[a,b]\\rArr f(x)\\in C[x,x+\\Delta x]\\) \\(\\therefore\\exist\\xi\\in[x,x+\\Delta x]\\), 使(积分中值定理) $$ \\begin{array}{rl} \\footnotesize f(\\xi)\\Delta x=\\int_x^{x+\\Delta x}f(t)\\mathrm{d}t=\\Delta\\varPhi & \\rArr\\frac{\\Delta\\varPhi}{\\Delta x}=f(\\xi) \\\\ & \\rArr\\footnotesize\\lim\\limits_{\\Delta x\\to 0}\\frac{\\Delta\\varPhi}{\\Delta x}=\\lim\\limits_{\\Delta x\\to 0}f(\\xi)=\\lim\\limits_{\\xi\\to x}f(\\xi)=f(x) \\\\ & \\rArr\\varPhi^\\prime(x)=f(x) \\end{array} $$ 定积分与不定积分的比较: \\(\\int f(x)\\neq\\int f(t)\\enspace(x\\) 与 \\(t\\) 可能是不同的函数, 他们的值域不同, 导致积结果不同) \\(\\int_a^b f(x)\\mathrm{d}x=\\int_a^b f(t)\\mathrm{d}t\\enspace\\) (\\(x\\) 与 \\(t\\) 可能是不同的函数, 但积分范围被限制在 \\([a,b]\\), 即 \\(x,t\\in[a,b]\\), 所以相等) 因此: 定积分由上下限、函数关系确定, 与积分变量无关 即 \\(\\varPhi(x)=\\int_a^x f(x)\\mathrm{d}x=\\int_a^x f(t)\\mathrm{d}t\\enspace\\) (注意自变量的 \\(x\\) 与积分上限的 \\(x\\) 不同) 牛顿莱布尼茨公式 \\(f(x)\\in C[a,b]\\), \\(F(x)\\) 为 \\(f(x)\\) 的一个原函数, 则 \\(\\int_a^b f(x)\\mathrm{d}x=F(b)-F(a)=\\left.F(x)\\right|_a^b\\) 证明: \\(\\because F^\\prime(x)=f(x)\\), \\(\\varPhi^\\prime(x)=f(x)\\) (\\(F(x)\\) 与 \\(\\varPhi(x)\\) 皆为 \\(f(x)\\) 的原函数) \\(\\therefore \\begin{cases} F(a)-\\varPhi(a)=C_0 \\\\ F(b)-\\varPhi(b)=C_0 \\end{cases}\\rArr F(a)-\\varPhi(a)=F(b)-\\varPhi(b)\\) \\(\\because\\varPhi(a)=\\int_a^a f(t)\\mathrm{d}t=0\\) \\(\\therefore F(a)=F(b)-\\varPhi(b)\\hArr\\int_a^b f(x)\\mathrm{d}x=\\varPhi(b)=F(b)-F(a)\\) 积分中值定理的推广 \\(f(x)\\in C[a,b]\\), 则 \\(\\exist\\xi\\in(a,b)\\) (这里变成了闭区间), 使 \\(\\int_a^b f(x)\\mathrm{d}x=f(\\xi)(b-a)\\) 证明: 设 \\(F(x)=\\int_a^x f(t)\\mathrm{d}t\\), \\(F^\\prime(x)=f(x)\\) \\(\\exist\\xi\\in(a,b)\\) 使 \\(F^\\prime(\\xi)=\\frac{F(b)-F(a)}{b-a}\\) (拉格朗日中值定理) \\(\\footnotesize\\therefore\\int_a^b f(x)\\mathrm{d}x=F(b)-F(a)=F^\\prime(\\xi)(b-a)=f(\\xi)(b-a)\\enspace(\\xi\\in(a,b))\\) 定积分的换元积分法与分部积分法 换元积分法 若 \\(f(x)\\in C[a,b]\\), \\(x=\\varphi(t)\\) 满足: \\(\\varphi(t)\\) 为单调函数且 \\(\\varphi(\\alpha)=a\\), \\(\\varphi(\\beta)=b\\) \\(x=\\varphi(t)\\) 连续可导 则 \\(\\int_a^b f(x)\\mathrm{d}x=\\int_\\alpha^\\beta f[\\varphi(t)]\\varphi^\\prime(t)\\mathrm{d}t\\) 证明: 设 \\(F(x)\\) 为 \\(f(x)\\) 的原函数 $$ \\begin{array}{rl} \\int_\\alpha^\\beta f[\\varphi(t)]\\varphi^\\prime(t)\\mathrm{d}t & =\\int_\\alpha^\\beta f[\\varphi(t)]\\mathrm{d}\\varphi(t) \\\\ & =F[\\varphi(\\beta)]-F[\\varphi(\\alpha)] \\\\ & =F(b)-F(a) \\\\ & =\\int_a^b f(x)\\mathrm{d}x \\end{array} $$ 分部积分法 \\(\\int_a^b u\\mathrm{d}v=(uv)|_a^b-\\int_a^b v\\mathrm{d}u\\) 证明: \\(\\left.uv\\right|_a^b=\\int_a^b(uv)^\\prime\\mathrm{d}x=\\int_a^b u^\\prime v\\mathrm{d}x+\\int_a^b uv^\\prime\\mathrm{d}x=\\int_a^b v\\mathrm{d}u+\\int_a^b u\\mathrm{d}v\\) 例: 导出 \\(I_n=\\int_0^\\frac{\\pi}{2}\\sin^n x\\mathrm{d}x\\) (\\(n\\) 为非负整数)的递推公式 解: 易见 \\(I_0=\\int_0^\\frac{\\pi}{2}1\\mathrm{d}x=\\frac{\\pi}{2}\\), \\(I_1=\\int_0^\\frac{\\pi}{2}\\sin x\\mathrm{d}x=1\\). 当 \\(n\\geqslant 2\\) 时 $$ \\begin{array}{rl} I_n=\\int_0^\\frac{\\pi}{2}\\sin^n x\\mathrm{d}x & =\\int_0^\\frac{\\pi}{2}\\sin^{n-1}x\\cdot\\sin x\\mathrm{d}x \\\\ & =\\int_0^\\frac{\\pi}{2}\\sin^{n-1}x[-(\\cos x)^\\prime]\\mathrm{d}x \\\\ & =-\\int_0^\\frac{\\pi}{2}\\sin^{n-1}x\\mathrm{d}\\cos x \\\\ & =\\left.-(\\sin^{n-1}x\\cdot\\cos x)\\right|_0^\\frac{\\pi}{2}+\\int_0^\\frac{\\pi}{2}\\cos x\\mathrm{d}\\sin^{n-1}x \\\\ & =\\int_0^\\frac{\\pi}{2}\\cos x(\\sin^{n-1}x)^\\prime\\mathrm{d}x \\\\ & =\\int_0^\\frac{\\pi}{2}\\cos x\\cdot\\sin^{n-1\\prime}x(\\sin x)^\\prime\\mathrm{d}x \\\\ & =(n-1)\\int_0^\\frac{\\pi}{2}\\sin^{n-2}x\\cos^2 x\\mathrm{d}x \\\\ & =(n-1)\\int_0^\\frac{\\pi}{2}\\sin^{n-2}x(1-\\sin^2 x)\\mathrm{d}x \\\\ & =(n-1)[\\int_0^\\frac{\\pi}{2}\\sin^{n-2}\\mathrm{d}x-\\int_0^\\frac{\\pi}{2}\\sin^n x\\mathrm{d}x] \\\\ & =(n-1)(I_{n-2}-I_n) \\end{array} $$ 从而得到递推公式 \\(I_n=\\frac{n-1}{n}I_{n-2}\\) 反常积分 正常积分标准: 区间有限 \\(f(x)\\) 在区间上连续或有限个第一类间断点 积分区间无限 \\(f(x)\\in C[a,+\\infty)\\) 有 \\(\\int_a^{+\\infty} f(x)\\mathrm{d}x=\\lim\\limits_{b\\to+\\infty}[F(b)-F(a)]\\) 若 \\(\\lim\\limits_{b\\to+\\infty}[F(b)-F(a)]\\) 存在, 称 \\(\\int_a^{+\\infty} f(x)\\mathrm{d}x\\) 收敛 若 \\(\\lim\\limits_{b\\to+\\infty}[F(b)-F(a)]\\) 不存在, 称 \\(\\int_a^{+\\infty} f(x)\\mathrm{d}x\\) 发散 \\(f(x)\\in C(-\\infty,a]\\) 有 \\(\\lim\\limits_{b\\to-\\infty}[F(a)-F(b)]=\\int_{-\\infty}^a f(x)\\mathrm{d}x\\) 若 \\(\\lim\\limits_{b\\to-\\infty}[F(a)-F(b)]\\) 存在, 称 \\(\\int_{-\\infty}^a f(x)\\mathrm{d}x\\) 收敛 若 \\(\\lim\\limits_{b\\to-\\infty}[F(a)-F(b)]\\) 不存在, 称 \\(\\int_{-\\infty}^a f(x)\\mathrm{d}x\\) 发散 \\(f(x)\\in C(-\\infty,+\\infty)\\) 若 \\(\\int_{-\\infty}^{+\\infty}f(x)\\mathrm{d}x\\) 收敛 \\(\\hArr\\int_{-\\infty}^{a}f(x)\\mathrm{d}x\\) 与 \\(\\int_{a}^{+\\infty}f(x)\\mathrm{d}x\\) 收敛 且 \\(\\int_{-\\infty}^{+\\infty}f(x)\\mathrm{d}x=\\int_{-\\infty}^a f(x)\\mathrm{d}x+\\int_a^{+\\infty}f(x)\\mathrm{d}x\\) Gamma 函数 \\(\\Gamma\\) 定义: \\(\\Gamma(\\alpha)=\\int_0^{+\\infty}x^{\\alpha-1}\\cdot e^{-x}\\mathrm{d}x\\) 特性: \\(\\Gamma(\\alpha+1)=\\alpha\\Gamma(\\alpha)\\) \\(\\Gamma(n+1)=n!\\enspace(n\\in Z)\\) \\(\\Gamma(\\frac{1}{2})=\\sqrt{\\pi}\\) 无界函数反常积分 左无界: \\(f(x)\\in c(a,b]\\) 且 \\(f(a+0)=\\infty\\enspace\\) (\\(a\\) 称作瑕点) \\(\\forall\\varepsilon&gt;0\\), \\(\\lim\\limits_{\\varepsilon\\to 0^+}[F(b)-F(a+\\varepsilon)]=\\int_{a+\\varepsilon}^b f(x)\\mathrm{d}x\\) 若 \\(\\lim\\limits_{\\epsilon\\to 0^+}[F(b)-F(a+\\varepsilon)]\\) 存在, 称 \\(\\int_a^b f(x)\\mathrm{d}x\\) 收敛 若 \\(\\lim\\limits_{\\varepsilon\\to 0^+}[F(b)-F(a+\\varepsilon)]\\) 不存在, 称 \\(\\int_a^b f(x)\\mathrm{d}x\\) 发散 右无界: \\(f(x)\\in c[a,b)\\) 且 \\(f(b-0)=\\infty\\) \\(\\forall\\varepsilon&gt;0\\), \\(F(b-\\varepsilon)-F(a)=\\int_a^{b-\\varepsilon}f(x)\\mathrm{d}x\\) 若 \\(\\lim\\limits_{\\epsilon\\to 0^+}[F(b-\\varepsilon)-F(a)]\\) 存在, 称 \\(\\int_a^b f(x)\\mathrm{d}x\\) 收敛 若 \\(\\lim\\limits_{\\epsilon\\to 0^+}[F(b-\\varepsilon)-F(a)]\\) 不存在, 称 \\(\\int_a^b f(x)\\mathrm{d}x\\) 发散 中无界: \\(f(x)\\in c[a,c)\\cup(c,b]\\) 且 \\(\\lim\\limits_{x\\to c}f(x)=\\infty\\) 若 \\(\\int_a^b f(x)\\mathrm{d}x\\) 收敛 \\(\\hArr\\int_a^c f(x)\\mathrm{d}x\\) 与 \\(\\int_c^b f(x)\\mathrm{d}x\\) 收敛 且 \\(\\int_a^b f(x)\\mathrm{d}x=\\int_a^c f(x)\\mathrm{d}x+\\int_c^b f(x)\\mathrm{d}x\\) 定积分应用 元素法 经典积分思想: 分成无数细小的段然后加起来 元素法思想: 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}A=f(x)\\mathrm{d}x\\) \\(A=\\int_a^b\\mathrm{d}A=\\int_a^b f(x)\\mathrm{d}x\\) 例: 求 \\(L:x^2+y^2=R^2\\) 围成的面积 解: 取 \\([x,x+\\mathrm{d}x]\\subset[0,R]\\) \\(\\mathrm{d}A_1=\\sqrt{R^2-x^2}\\mathrm{d}x\\) \\(A_1=\\int_0^R\\sqrt{R^2-x^2}\\mathrm{d}x\\) 设 \\(x=R\\sin t\\), 则有 \\(\\int_0^\\frac{\\pi}{2}\\sqrt{R^2-R^2\\sin^2t}(R\\cos t)\\mathrm{d}t\\) \\(=\\int_0^\\frac{\\pi}{2}R^2\\sqrt{1-\\sin^2t}\\cos t\\mathrm{d}t\\) \\(=\\int_0^\\frac{\\pi}{2}R^2\\cos^2t\\mathrm{d}t\\) \\(=R^2\\int_0^\\frac{\\pi}{2}\\cos^2t\\mathrm{d}t\\) \\(=R^2\\times\\frac{1}{2}I_0=\\frac{\\pi}{4}R^2\\) \\(\\therefore A=4A_1=\\pi R^2\\) 几何应用(元素法的拓展) 面积 贴 \\(x\\) 轴曲面 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}A=f(x)\\mathrm{d}x\\) \\(A=\\int_a^b f(x)\\mathrm{d}x\\) 浮空曲边 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}A=[f(x)-g(x)]\\mathrm{d}x\\) \\(A=\\int_a^b[f(x)-g(x)]\\mathrm{d}x\\) 曲边扇形面积(以下内容为弧度制) \\(L:R=r(\\theta)\\enspace(\\theta\\in[\\alpha,\\beta])\\) 取 \\([\\theta,\\theta+\\mathrm{d}\\theta]\\subset[\\alpha,\\beta]\\) \\(\\mathrm{d}A=\\frac{1}{2}r^2(\\theta)\\mathrm{d}\\theta\\) (曲边扇形面积公式) \\(A=\\int_\\alpha^\\beta\\mathrm{d}A=\\int_\\alpha^\\beta\\frac{1}{2}r^2(\\theta)\\mathrm{d}\\theta\\) 体积 旋转体的体积 \\(V_x\\) (绕 \\(x\\) 轴旋转) 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}V_x=\\pi f^2(x)\\mathrm{d}x\\) \\(V_x=\\pi\\int_a^b f^2(x)\\mathrm{d}x\\) \\(V_y\\) (绕 \\(y\\) 轴旋转) 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}V_y=2\\pi|x|\\cdot|f(x)|\\cdot\\mathrm{d}x\\) \\(V_y=2\\pi\\int_a^b |x|\\cdot|f(x)|\\mathrm{d}x\\) 截口面积已知求几何体体积 有关于底面积的函数 \\(A(x)\\) 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}V=A(x)\\mathrm{d}x\\) \\(V=\\int_a^b A(x)\\mathrm{d}x\\) 弧长 \\(L:y=f(x)\\enspace(a\\leqslant x\\leqslant b)\\) 取 \\([x,x+\\mathrm{d}x]\\subset[a,b]\\) \\(\\mathrm{d}s=\\sqrt{(\\mathrm{d}x)^2+(\\mathrm{d}y)^2}=\\sqrt{1+(\\frac{\\mathrm{d}y}{\\mathrm{d}x})^2}\\mathrm{d}x=\\sqrt{1+[f^\\prime(x)]^2}\\mathrm{d}x\\) \\(l=\\int_a^b\\mathrm{d}s\\mathrm{d}x=\\int_a^b\\sqrt{1+[f^\\prime(x)]^2}\\mathrm{d}x\\) \\(L:\\begin{cases} x=\\varphi(t) \\\\ y=\\psi(t) \\end{cases}\\enspace(\\alpha\\leqslant t\\leqslant\\beta)\\) 取 \\([t,t+\\mathrm{d}t]\\subset[\\alpha,\\beta]\\) \\(\\mathrm{d}s=\\sqrt{(\\mathrm{d}x)^2+(\\mathrm{d}y)^2}=\\sqrt{[\\varphi^\\prime(t)]^2+[\\psi^\\prime(t)]^2}\\mathrm{d}t\\) \\(l=\\int_\\alpha^\\beta\\mathrm{d}s\\mathrm{d}t=\\int_\\alpha^\\beta\\sqrt{[\\varphi^\\prime(x)]^2+[\\psi^\\prime(x)]^2}\\mathrm{d}t\\) 微分方程 解微分方程的目的即根据已知微分条件求目标函数 微分方程的基本概念 微分方程: 含有导数或微分的方程 常微分方程: 只含一个自变量, 一个函数的微分方程, 如 \\(f^\\prime(x)+7f(x)=0\\) 这里探讨的范围仅限于常微分方程 微分方程的阶: 在微分方程中, 导数或微分的最高阶数 微分方程的解: 已知 \\(y\\) 关于 \\(x\\) 的微分方程 \\(F(y^{(n)},y^{(n-1)},\\dots,y^\\prime,y,x)=0\\) 若代入函数 \\(y=\\varphi(x)\\) 能够满足 \\(F(y^{(n)},y^{(n-1)},\\dots,y^\\prime,y,x)=0\\) 称 \\(y=\\varphi(x)\\) 为该微分方程的解 通解: 设 \\(n\\) 阶微分方程 \\(F(y^{(n)},y^{(n-1)},\\dots,y^\\prime,y,x)=0\\), 若该方程的解含 \\(n\\) 个相互独立的任意常数, 称该解为通解 如 \\(y=C_1e^x+C_2e^{2x}\\) 为 \\(y^{\\prime\\prime}-3y^\\prime+2y=0\\) 的通解 特解: 不含任意常数的解 可分离变量微分方程 定义: 形如 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\varphi_1(x)\\varphi_2(y)\\) 解法 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\varphi_1(x)\\varphi_2(y)\\rArr\\frac{\\mathrm{d}y}{\\varphi_2(y)}=\\varphi_1(x)\\mathrm{d}x\\) 两边积分: \\(\\int\\frac{\\mathrm{d}y}{\\varphi_2(y)}=\\int\\varphi_1(x)\\mathrm{d}x+C\\) (注意微分方程中自变量一端要加 \\(C\\)) 齐次微分方程 定义: 形如 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\varphi(\\frac{y}{x})\\) 解法 换元法, 设 \\(u=\\frac{y}{x}\\), 则 \\(y=ux\\rArr y^\\prime=u^\\prime x+ux^\\prime\\rArr\\frac{\\mathrm{d}y}{\\mathrm{d}x}=x\\frac{\\mathrm{d}u}{\\mathrm{d}x}+u\\) 将 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}=x\\frac{\\mathrm{d}u}{\\mathrm{d}x}+u\\) 和 \\(u=\\frac{y}{x}\\) 代入方程两边得到 \\(x\\frac{\\mathrm{d}u}{\\mathrm{d}x}+u=\\varphi(u)\\) 然后就可以分离变量, 最后两边积分: \\(\\frac{\\mathrm{d}x}{x}=\\frac{\\mathrm{d}u}{\\varphi(u)-u}\\rArr\\int\\frac{\\mathrm{d}x}{x}=\\int\\frac{\\mathrm{d}u}{\\varphi(u)-u}+C\\) 一阶线性微分方程 一阶齐次线性方程 定义: 形如 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}+P(x)y=0\\) 解法及通解公式 情况1 \\(y=0\\) 为方程的解 情况2 \\(y\\neq 0\\) 时, 先分离变量, 然后两边积分, 再套用积分公式求解: $$ \\begin{aligned} \\frac{1}{y}\\mathrm{d}y=-P(x)\\mathrm{d}x & \\rArr\\int\\frac{1}{y}\\mathrm{d}y=\\int-P(x)\\mathrm{d}x \\\\ & \\rArr\\ln|y|=-\\int P(x)\\mathrm{d}x+C_0 \\\\ & \\rArr|y|=e^{-\\int P(x)\\mathrm{d}x+C_0} \\\\ & \\rArr y=\\pm e^{C_0}\\cdot e^{-\\int P(x)\\mathrm{d}x}=Ce^{-\\int P(x)\\mathrm{d}x} \\end{aligned} $$ 通解 \\(y=Ce^{-\\int P(x)\\mathrm{d}x}\\) 一阶非齐线性微分方程 定义: 形如 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}+P(x)y=Q(x)\\) 解法 通过常数易变法, 将上面齐次方程通解中的常数项换成关于 \\(x\\) 的函数 \\(C=u(x)\\), 得到 ➀ \\(y=u(x)e^{-\\int P(x)\\mathrm{d}x}\\) 然后对 \\(y\\) 求导: (这里注意 \\(e^{-\\int P(x)\\mathrm{d}x}\\) 是复合函数) ➁ \\(y^\\prime=\\frac{\\mathrm{d}y}{\\mathrm{d}x}=u^\\prime(x)e^{-\\int P(x)\\mathrm{d}x}-u(x)P(x)e^{-\\int P(x)\\mathrm{d}x}\\) 将 ➀、➁ 代入一阶非齐线性微分方程: \\(u^\\prime(x)e^{-\\int P(x)\\mathrm{d}x}-u(x)P(x)e^{-\\int P(x)\\mathrm{d}x}+P(x)u(x)e^{-\\int P(x)\\mathrm{d}x}=Q(x)\\) \\(\\rArr u^\\prime(x)e^{-\\int P(x)\\mathrm{d}x}=Q(x)\\) \\(\\rArr u^\\prime(x)=Q(x)e^{\\int P(x)\\mathrm{d}x}\\) \\(\\rArr\\int u^\\prime(x)\\mathrm{d}x=\\int Q(x)e^{\\int P(x)\\mathrm{d}x}\\mathrm{d}x+C\\) \\(\\rArr u(x)=\\int Q(x)e^{\\int P(x)\\mathrm{d}x}\\mathrm{d}x+C\\) 求得的 \\(u(x)\\) 再次带入通解式得 \\(y=[\\int Q(x)e^{\\int P(x)\\mathrm{d}x}\\mathrm{d}x+C]e^{-\\int P(x)\\mathrm{d}x}\\) 可降阶的高阶微分方程 \\(y^{(n)}=f(x)\\enspace(n\\geqslant2)\\) 解法: 直接积分 \\(y^{(n-1)}=\\int f(x)\\mathrm{d}x=F(x)+C\\) \\(y^{(n-2)}=\\int(\\int(F(x)+C)\\mathrm{d}x\\) \\(\\dots\\) 例: \\(y^{\\prime\\prime}=x^3+e^{2x}\\) 解: \\(y^\\prime=\\frac{1}{4}x^4+\\frac{1}{2}e^{2x}+C_1\\) \\(y=\\frac{1}{20}x^5+\\frac{1}{4}e^{2x}+C_1x+C_2\\) (缺失 \\(y\\)) \\(f(x,y^\\prime,y^{\\prime\\prime})=0\\) 解法: 令 \\(y^\\prime=p\\), \\(y^{\\prime\\prime}=\\frac{\\mathrm{d}p}{\\mathrm{d}x}\\) 代入得 \\(f(x,p,\\frac{\\mathrm{d}p}{\\mathrm{d}x})=0\\rArr p=\\varphi(x,C_1)\\), 即 \\(\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\varphi(x,C_1)\\) \\(\\therefore y=\\int\\varphi(x, C_1)\\mathrm{d}x+C_2\\) 例: 求 \\(xy^{\\prime\\prime}+2y^\\prime=0\\) 通解 解: 令 \\(y^\\prime=p\\), \\(y^{\\prime\\prime}=\\frac{\\mathrm{d}p}{\\mathrm{d}x}\\), 代入得 \\(x\\frac{\\mathrm{d}p}{\\mathrm{d}x}+2p=0\\rArr\\frac{\\mathrm{d}p}{p}=-\\frac{2\\mathrm{d}x}{x}\\) \\(\\rArr\\int\\frac{1}{p}\\mathrm{d}p=-2\\int\\frac{1}{x}\\mathrm{d}x+C_0\\) \\(\\rArr\\ln|p|=-2\\ln|x|+C_0\\) \\(\\rArr|p|=e^{-2\\ln|x|+C_0}=\\frac{e^{C_0}}{x^2}\\) \\(\\rArr p=\\pm\\frac{e^{C_0}}{x^2}=\\frac{C_1}{x^2}\\), 即 \\(y^\\prime=\\frac{C_1}{x^2}\\) \\(\\therefore y=-\\frac{C_1}{x}+C_2\\) (缺失 \\(x\\)) \\(f(y,y^\\prime,y^{\\prime\\prime})=0\\) 解法: 令 \\(y^\\prime=p\\), \\(y^{\\prime\\prime}=\\frac{\\mathrm{d}p}{\\mathrm{d}x}\\rArr y^{\\prime\\prime}=\\frac{\\mathrm{d}p}{\\mathrm{d}y}\\cdot\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\frac{\\mathrm{d}p}{\\mathrm{d}y}\\cdot p\\), 代入得 $$ \\begin{array}{rl} f(y,p,\\frac{\\mathrm{d}p}{\\mathrm{d}y}\\cdot p)=0 & \\rArr p=\\varphi(y,C_1) \\\\ & \\hArr\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\varphi(y,C_1) \\\\ & \\hArr\\frac{\\mathrm{d}y}{\\varphi(y,C_1)}=\\mathrm{d}x \\\\ & \\rArr\\int\\frac{\\mathrm{d}y}{\\varphi(y,C_1)}=\\int\\mathrm{d}x+C_2 \\end{array} $$ 例: 求 \\(yy^{\\prime\\prime}-y^{\\prime 2}=0\\) 满足初始条件 \\(y(0)=1\\), \\(y^\\prime(0)=1\\) 的特解 解: 令 \\(y^\\prime=p\\), \\(y^{\\prime\\prime}=p\\frac{\\mathrm{d}p}{\\mathrm{d}y}\\), 代入得 \\(yp\\frac{\\mathrm{d}p}{\\mathrm{d}y}-p^2=0\\) $$ \\begin{array}{ll} \\because p\\neq 0 & \\\\ \\therefore y\\frac{\\mathrm{d}p}{\\mathrm{d}y}-p=0 & \\hArr\\frac{\\mathrm{d}p}{\\mathrm{d}y}-\\frac{1}{y}p=0 \\\\ & \\rArr p=C_0e^{-\\int-\\frac{1}{y}p\\mathrm{d}y} (\\text{\\footnotesize一阶齐次线性微分方程通解})\\\\ & \\hArr p=C_0e^{\\ln|y|} \\\\ & \\rArr p=C_1y \\\\ & \\hArr\\frac{\\mathrm{d}y}{\\mathrm{d}x}=C_1y \\\\ & \\hArr\\frac{\\mathrm{d}y}{C_1y}=\\mathrm{d}x \\\\ & \\rArr\\int\\frac{\\mathrm{d}y}{C_1y}=\\int\\mathrm{d}x+C_2 \\\\ & \\hArr\\ln|C_1y|=x+C_2 \\\\ & \\rArr y=\\frac{C_3e^x}{C_1} \\\\ & \\rArr y=C_4e^x \\end{array} $$ \\(\\because y(0)=1,y^\\prime(0)=1\\) \\(\\therefore C_4=1\\), 特解为 \\(y=e^x\\) 高阶线性微分方程 基本概念 二阶齐次线性微分方程: \\(y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=0\\) 二阶非齐线性微分方程: \\(y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=c(x)\\) \\(n\\) 阶齐次线性微分方程: \\(y^{(n)}+a_1(x)y^{(n-1)}+\\dots+a_{n-1}y^\\prime+a_n(x)y=0\\) \\(n\\) 阶非齐线性微分方程: \\(\\footnotesize y^{(n)}+a_1(x)y^{(n-1)}+\\dots+a_{n-1}y^\\prime+a_n(x)y=f(x)\\) 线性相关和线性无关: \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 为两个函数 若 \\(\\frac{\\varphi_1(x)}{\\varphi_2(x)}\\equiv k\\in R\\), 称 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 线性相关, 若 \\(\\frac{\\varphi_1(x)}{\\varphi_2(x)}=u(x)\\) (两函数的比例与 \\(x\\) 相关, 不恒为某个常数), 则称线性无关. 如 \\(x^2\\) 和 \\(\\sin x\\) 线性无关, \\(x^2\\) 和 \\(3x^2\\) 线性相关 性质 设 \\(\\begin{cases} \\text{➀ }y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=0 \\\\ \\text{➁ }y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=c(x) \\end{cases}\\) 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 为 ➀ 的解, 则 \\(y=C_1\\varphi_1(x)+C_2\\varphi_2(x)\\) 仍为 ➀ 的解(线性组合) 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 分别为 ➀, ➁ 的解, 则 \\(y=\\varphi_1(x)+\\varphi_2(x)\\) 为 ➁ 的解 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 为 ➁ 的解, 则 \\(y=\\varphi_2(x)-\\varphi_1(x)\\) 为 ➀ 的解 证明: 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 为 ➁ 的解 则有 \\(\\begin{cases} \\varphi_1^{\\prime\\prime}+a(x)\\varphi_1^\\prime+b(x)\\varphi_1=c(x) \\\\ \\varphi_2^{\\prime\\prime}+a(x)\\varphi_2^\\prime+b(x)\\varphi_2=c(x) \\end{cases}\\) 将 \\(y=\\varphi_2(x)-\\varphi_1(x)\\) 代入 ➁: \\((\\varphi_2-\\varphi_1)^{\\prime\\prime}+a(x)(\\varphi_2-\\varphi_1)^\\prime+b(x)(\\varphi_2-\\varphi_1)\\) \\(=(\\varphi_2^{\\prime\\prime}+a(x)\\varphi_2^\\prime+b(x)\\varphi_2)-(\\varphi_1^{\\prime\\prime}+a(x)\\varphi_1^\\prime+b(x)\\varphi_1)\\) \\(=c(x)-c(x)=0\\) \\(\\therefore y=\\varphi_2(x)-\\varphi_1(x)\\) 为 ➀ 的解 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 为 ➀ 的两个线性无关的特解, \\(\\varphi_0(x)\\) 为 ➁ 的一个特解 则 ➀ 通解为 \\(y=C_1\\varphi_1(x)+C_2\\varphi_2(x)\\); ➁ 的通解为 \\(y=C_1\\varphi_1(x)+C_2\\varphi_2(x)+\\varphi_0(x)\\) ➂ \\(y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=f_1(x)+f_2(x)\\) ➂’ \\(\\enspace y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=f_1(x)\\) ➂’’ \\(\\enspace y^{\\prime\\prime}+a(x)y^\\prime+b(x)y=f_2(x)\\) 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 分别为 ➂’, ➂’’ 的特解, 则 \\(y=\\varphi_1(x)+\\varphi_2(x)\\) 为 ➂ 的特解 证明: 若 \\(\\varphi_1(x)\\), \\(\\varphi_2(x)\\) 为 ➂’, ➂’’ 的解 则有 \\(\\begin{cases} \\varphi_1^{\\prime\\prime}+a(x)\\varphi_1^\\prime+b(x)\\varphi_1=f_1(x) \\\\ \\varphi_2^{\\prime\\prime}+a(x)\\varphi_2^\\prime+b(x)\\varphi_2=f_2(x) \\end{cases}\\) 将 \\(y=\\varphi_1(x)+\\varphi_2(x)\\) 代入 ➂: \\((\\varphi_1+\\varphi_2)^{\\prime\\prime}+a(x)(\\varphi_1+\\varphi_2)^\\prime+b(x)(\\varphi_1+\\varphi_2)=f(x)\\) \\(\\hArr(\\varphi_1^{\\prime\\prime}+a(x)\\varphi_1^\\prime+b(x)\\varphi_1)+(\\varphi_1^{\\prime\\prime}+a(x)\\varphi_2^\\prime+b(x)\\varphi_2)=f(x)\\) \\(\\hArr f_1(x)+f_2(x)=f(x)\\) \\(\\therefore y=\\varphi_1(x)+\\varphi_2(x)\\) 为 ➂ 的解 常系数齐次线性微分方程 二阶常系数齐次线性微分方程: \\(y^{\\prime\\prime}+py^\\prime+qy=0\\) 它的特征方程: \\(\\lambda^2+p\\lambda+q=0\\) , \\(\\Delta=b^2-4q\\) \\(\\Delta&gt;0\\), \\(y=C_1e^{\\lambda_1x}+C_2e^{\\lambda_2x}\\) \\(\\Delta=0\\), \\(y=(C_1+C_2x)e^{\\lambda_1x}\\) \\(\\Delta&lt;0\\), \\(y=e^{\\alpha x}[C_1\\cos(\\beta x)+C_2\\sin(\\beta x)]\\) 这种根据二阶常系数齐次线性方程的特征方程的根直接确定其通解的方法称为特征方程法 特征方程法解释: 二阶常系数齐次线性微分方程 \\(y^{\\prime\\prime}+py^\\prime+qy=0\\enspace\\) (\\(p\\)、\\(q\\) 为常数) (⁕) 猜测: (⁕) 解的形式? \\(\\begin{cases} e^{\\lambda x} \\\\ \\sin(\\beta x)\\cdot\\cos(\\beta x) \\end{cases}\\) 令 \\(y=e^{\\lambda x}\\) 为 (⁕) 的解, 有 \\(\\lambda^2e^{\\lambda x}+p\\lambda e^{\\lambda x}+qe^{\\lambda x}=0\\rArr\\lambda^2+p\\lambda+q=0\\), 称其为 (⁕) 的特征方程 情况1 \\(\\Delta=p^2-4q&gt;0\\) 则 \\(\\lambda^2+p\\lambda+q=0\\) 有两个不同实根 \\(\\lambda_1\\)、\\(\\lambda_2\\) 因此 \\(y_1=e^{\\lambda_1x}\\), \\(y_2=e^{\\lambda_2x}\\) 为 (⁕) 的特解 \\(\\because\\lambda_1\\neq\\lambda_2\\) \\(\\therefore\\frac{y_1}{y_2}=e^{(\\lambda_1-\\lambda_2)x}\\) 不恒为某个常数, \\(y_1\\) 与 \\(y_2\\) 线性无关 \\(\\therefore\\) (⁕) 的通解为 \\(y=C_1e^{\\lambda_1x}+C_2e^{\\lambda_2x}\\) (高阶线性线性微分方程性质 4) 情况2 \\(\\Delta=p^2-4q=0\\) 则 \\(\\lambda^2+p\\lambda+q=0\\) 有两个相等的实根 \\(\\lambda_1=\\lambda_2\\) \\(y_1=e^{\\lambda_1x}\\) 为 (⁕) 的一个特解, 还要找出与 \\(y_1\\) 线性无关的另一个特解 \\(y_2\\) (满足 \\(\\frac{y_2}{y_1}\\) 不是恒常数的 \\(y_2\\)) 令 \\(\\frac{y_2}{y_1}=u(x)(\\neq C)\\) 且 \\(y_2\\) 为 (⁕) 的解, 得到 \\(\\begin{cases} y_2=ue^{\\lambda_1x} \\\\ y_2^\\prime=u^\\prime e^{\\lambda_1x}+\\lambda_1ue^{\\lambda_1x} \\\\ y_2^{\\prime\\prime}=u^{\\prime\\prime}e^{\\lambda_1x}+2\\lambda_1u^\\prime e^{\\lambda_1x}+\\lambda_1^2ue^{\\lambda_1x} \\end{cases}\\) 将以上三式代入 (⁕) 得 \\(u^{\\prime\\prime}e^{\\lambda_1x}+2\\lambda_1u^\\prime e^{\\lambda_1x}+\\lambda_1^2ue^{\\lambda_1x}+pu^\\prime e^{\\lambda_1x}+p\\lambda_1ue^{\\lambda_1x}+que^{\\lambda_1x}=0\\) \\(\\rArr u^{\\prime\\prime}+2\\lambda_1u^\\prime+\\lambda_1^2u+pu^\\prime+p\\lambda_1u+qu=0\\) \\(\\rArr u^{\\prime\\prime}+(2\\lambda_1+p)u^\\prime+(\\lambda_1^2+p\\lambda_1+q)u=0\\) \\(\\because \\begin{cases} \\lambda_1^2+p\\lambda_1+q=0 \\\\ \\lambda_1+\\lambda_2=-p \\rArr 2\\lambda_1+p=0\\enspace\\footnotesize(\\text{韦达定理} x_1+x_2=-\\frac{b}{a}) \\end{cases}\\) \\(\\therefore u^{\\prime\\prime}=0\\), 取 \\(u(x)=C_1x+C_2\\) \\(\\therefore y_2=(C_1x+C_2)e^{\\lambda_1x}=C_1xe^{\\lambda_1x}+C_2e^{\\lambda_1x}\\) 则通解 \\(\\footnotesize y=C_0e^{\\lambda_1x}+C_1xe^{\\lambda_1x}+C_2e^{\\lambda_1x}=(C_0+C_1x+C_2)e^{\\lambda_1x}=(C_3+C_1x)e^{\\lambda_1x}\\) 情况3 \\(\\Delta=p^2-4q&lt;0\\) 则 \\(\\lambda^2+p\\lambda+q=0\\) 有一对共轭复根 \\(\\footnotesize\\lambda_{1,2}=-\\frac{1}{2}p\\pm\\frac{1}{2}\\sqrt{4q-p^2}i=\\alpha\\pm\\beta i\\) \\(y_1=e^{(\\alpha+\\beta i)x}\\) 与 \\(y_2=e^{(\\alpha-\\beta i)x}\\) 为 (⁕) 的复值函数形式特解 为了求出实值函数形式的特解, 将 \\(y_1\\) 与 \\(y_2\\) 改写为: \\(y_1=e^{\\alpha x+\\beta xi}=e^{\\alpha x}\\cdot e^{\\beta xi}=e^{\\alpha x}\\cdot\\underbrace{[\\cos(\\beta x)+i\\sin(\\beta x)]}_{\\text{欧拉公式 }e^{i\\theta}=\\cos\\theta+i\\sin\\theta}\\) \\(y_2=e^{\\alpha x-\\beta xi}=e^{\\alpha x}\\cdot e^{-\\beta xi}=e^{\\alpha x}\\cdot[\\cos(\\beta x)-i\\sin(\\beta x)]\\) 取方程的两个特解: (高阶线性线性微分方程性质 1) \\(Y_1=\\frac{1}{2}(y_1+y_2)=e^{\\alpha x}\\cos(\\beta x)\\) \\(Y_2=\\frac{1}{2i}(y_1-y_2)=e^{\\alpha x}\\sin(\\beta x)\\) \\(\\because\\frac{Y_2}{Y_1}=\\tan(\\beta x)\\) \\(\\therefore\\) \\(Y_1\\) 与 \\(Y_2\\) 线性无关, (⁕) 的通解为 \\(\\footnotesize y=C_1e^{\\alpha x}\\cos(\\beta x)+C_2e^{\\alpha x}\\sin(\\beta x)=e^{\\alpha x}[C_1\\cos(\\beta x)+C_2\\sin(\\beta x)]\\) \\(n\\) 阶常系数齐次线性微分方程 \\(y^{(n)}+p_1y^{(n-1)}+\\cdots+p_{n-1}y^\\prime+p_ny=0\\) 其特征方程: \\(\\lambda^n+p_1\\lambda^{n-1}+\\cdots+p_{n-1}\\lambda+p_n=0\\) 特征方程的根 通解中的对应项 \\(k\\) 重根 \\(\\lambda_1=\\lambda_2=\\cdots=\\lambda_k\\) \\(y=C_1+C_2x+\\cdots+C_kx^{k-1})e^{\\lambda_1x}\\) \\(k\\) 重共轭复根 \\(\\lambda_{1,\\cdots,n}=\\alpha\\pm\\beta i\\) \\(e^{\\alpha x}[(C_1+C_2x+\\cdots+C_kx^{n-1})\\cos(\\beta x) \\\\ +(D_0+D_1x+\\cdots+D_kx^{k-1})\\sin(\\beta x)]\\) 例: \\(y^{\\prime\\prime\\prime}+py^{\\prime\\prime}+qy^\\prime+ry=0\\), 它的特征方程 \\(\\lambda^3+p\\lambda^2+q\\lambda+r=0\\) \\(\\lambda_1\\)、\\(\\lambda_2\\)、\\(\\lambda_3\\) 为实数且各不相等 \\(y=C_1e^{\\lambda_1x}+C_2e^{\\lambda_2x}+C_3e^{\\lambda_3x}\\) \\(\\lambda_1\\)、\\(\\lambda_2\\)、\\(\\lambda_3\\) 为实数且 \\(\\lambda_1=\\lambda_2\\neq\\lambda_3\\) \\(y=(C_1+C_2x)e^{\\lambda_1x}+C_3e^{\\lambda_3x}\\) \\(\\lambda_1\\)、\\(\\lambda_2\\)、\\(\\lambda_3\\) 为实数且相等 \\(y=(C_1+C_2x+C_3x^2)e^{\\lambda_1x}\\) \\(\\lambda_1\\in R\\), \\(\\lambda_{2,3}=\\alpha\\pm i\\beta\\) \\(y=C_1e^{\\lambda_1x}+e^{\\alpha x}[C_2\\cos(\\beta x)+C_3\\sin(\\beta x)]\\) 常系数非齐次线性微分方程 形如 \\(y^{\\prime\\prime}+py^\\prime+qy=f(x)\\enspace\\) (\\(p\\)、\\(q\\) 为常数, \\(f(x)\\) 称为自由项) 通解思路: (高阶线性微分方程性质 5) 先求 \\(y^{\\prime\\prime}+py^\\prime+qy=0\\) 通解 找 \\(y^{\\prime\\prime}+py^\\prime+qy=f(x)\\) 的一个特解 \\(y_0(x)\\) (很困难, 接下来只谈两种使用待定系数法的情况) 有通解 \\(y=C_1e^{-x}+C_2e^{2x}+y_0(x)\\) 自由项 \\(f(x)=P_n(x)e^{kx}\\) 其中 \\(P_n(x)=a_0x^n+a_1x^{n-1}+\\cdots+a_{n-1}x+a_n\\) 令特解为 \\(y_0=x^l(ax+b)e^{kx}\\) , 其中 \\(l\\) 为与 \\(k\\) 的值相等的特征值个数 例1: 求 \\(y^{\\prime\\prime}-3y^\\prime+2y=(2x+3)e^x\\) 通解 解: 特征方程: \\(\\lambda^2-3\\lambda+2=0\\rArr\\lambda_1=1\\), \\(\\lambda_2=2\\) \\(y^{\\prime\\prime}-3y^\\prime+2y=0\\) 通解为 \\(y=C_1e^{x}+C_2e^{2x}\\) \\(k=1=\\lambda_1\\), 因此令特解 \\(y_0(x)=x(ax+b)e^x=(ax^2+bx)e^x\\), 有 \\(\\begin{array}{rl} y_0^\\prime(x) &amp; =(2ax+b)e^x+(ax^2+bx)e^x=(ax^2+2ax+bx+b)e^x \\\\ y_0^{\\prime\\prime}(x) &amp; =(2ax+2a+b)e^x+(ax^2+2ax+bx+b)e^x \\\\ &amp; =(ax^2+4ax+bx+2a+2b)e^x \\end{array}\\) 代入原式, 得到: $$ \\begin{array}{l} \\footnotesize(ax^2+4ax+bx+2a+2b)e^x-3(ax^2+2ax+bx+b)e^x+2(ax^2+bx)e^x=(2x+3)e^x \\\\ \\footnotesize\\hArr(ax^2+4ax+bx+2a+2b)-3(ax^2+2ax+bx+b)+2(ax^2+bx)=2x+3 \\\\ \\footnotesize\\hArr -2ax+2a-b=2x+3 \\\\ \\footnotesize\\rArr\\begin{cases} -2ax=2x & \\hArr a=-1\\\\ 2a-b=3 & \\hArr b=-5 \\end{cases} \\end{array} $$ 即 \\(y_0(x)=-(x^2+5x)e^x\\) \\(\\therefore\\) 原方程通解为 \\(y=C_1e^x+C_2e^{2x}-(x^2+5x)e^x\\) 例2: 求 \\(y^{\\prime\\prime}-2y^\\prime+y=(3x+2)e^x\\) 通解 解: 特征方程 \\(\\lambda^2-2\\lambda+1=0\\rArr\\lambda_1=\\lambda_2=1\\) \\(y^{\\prime\\prime}-2y^\\prime+y=0\\) 通解 \\(y=(C_1+C_2x)e^x\\) \\(k=1=\\lambda_1=\\lambda_2\\), 因此令特解 \\(\\footnotesize y_0(x)=x^2(ax+b)e^x=(ax^3+bx^2)e^x\\) \\(y_0^\\prime(x)=\\cdots\\), \\(y_0^{\\prime\\prime}(x)=\\cdots\\) 代入原方程解得 \\(a=\\frac{1}{2}\\), \\(b=1\\) 即 \\(y_0(x)=(\\frac{1}{2}x^3+x^2)e^x\\) \\(\\therefore\\) 原方程通解为 \\(y=(C_1+C_2x)e^x+(\\frac{1}{2}x^3+x^2)e^x\\) 例3: 求 \\(y^{\\prime\\prime}-2y^\\prime-3y=6x-1\\) 通解 解: \\(\\lambda^2-2\\lambda-3=0\\rArr\\lambda_1=-1\\), \\(\\lambda_2=3\\) \\(y^{\\prime\\prime}-2y^\\prime-3y=0\\) 通解为 \\(y=C_1e^{-x}+C_2e^3\\) 自由项 \\(6x-1\\) 可视为 \\((6x-1)e^0x\\), 即 \\(k=0\\). 注意此题中 \\(\\lambda\\) 的值没有与 \\(k=0\\) 相同的 因此令特解 \\(y_0(x)=ax+b\\) (余下略) \\(\\dots\\) \\(\\dots\\) \\(f(x)=e^{\\alpha x}\\) [\\(\\text{多项式}\\cdot\\cos(\\beta x)+\\text{多项式}\\cdot\\sin(\\beta x)\\)] 令特解为 \\(\\footnotesize y_0(x)=x^le^{\\alpha x}[a\\cdot\\cos(\\beta x)+b\\cdot\\sin(\\beta x)]\\enspace\\) (\\(a\\)、\\(b\\) 根据多项式内容决定, \\(l\\) 的值为与 \\(\\alpha+i\\beta\\) 的值相等的特征值个数) 注: \\(\\alpha\\)、\\(\\beta\\) 的值已经在方程中给出, 因此解对应非齐次方程通解可以直接用 例1: 求 \\(y^{\\prime\\prime}+4y=3\\cos 2x\\) 通解 解: \\(\\lambda^2+4=0\\rArr\\lambda_{1,2}=\\pm 2i\\) \\(y^{\\prime\\prime}+4y=0\\) 通解为 \\(y=C_1\\cos 2x+C_2\\sin 2x\\) \\(\\alpha=0\\), \\(\\beta=2\\rArr\\alpha+i\\beta=2i=\\lambda_1\\) 因此令特解 \\(y_0(x)=x(a\\cos 2x+b\\sin 2x)\\enspace\\) (\\(\\cos\\) 和 \\(\\sin\\) 都不能少哦) (余下略) \\(\\dots\\) \\(\\dots\\) 例2: \\(y^{\\prime\\prime}-2y^\\prime+2y=(x+1)e^x\\cos x\\) 解: \\(\\lambda^2-2\\lambda+2=0\\rArr\\lambda_{1,2}=1\\pm i\\) \\(y^{\\prime\\prime}-2y^\\prime+2y=0\\) 通解为 \\(y=e^x(\\cos x+\\sin x)\\) \\(\\alpha=1\\), \\(\\beta=1\\rArr\\alpha+i\\beta=1+i=\\lambda_1\\) 因此令特解 \\(y_0(x)=xe^x[(ax+b)\\cos x+(cx+d)\\sin x]\\) (余下略, 解出 \\(a,b,c,d\\), 最后得出通解) \\(\\dots\\) \\(\\dots\\)","link":"/zh-cn/learn/mathematics/2021/postgraduate-advanced-mathematics/"},{"title":"suspicious-stew","text":"可疑的炖菜: 就是一些来路不明的未整合笔记 二次元萌萌人语录 (u1s1, 看着这些内容我都不自觉地脸红…) 呐呐呐，服务员欧内酱~~（超级肉麻） 诶多捏诶多捏，瓦塔西就是那个，二次元得斯~~（超级得意） 二次元の美好，米娜桑都知道的吧！（转身超级大声跟店里的顾客说了这句话） 哒嘎啦，人家厚洗一对，那个二次元的徽章呐~偶捏该，瓦塔西斯够固sikisiki呆！！siki那个徽章呐~ 纳尼?一定要那个口号吗….呜呜呜，哈子卡西….得莫，为了超级想要的二次元徽章….瓦塔西会干巴爹的！！！ 异世相遇！！！！（华丽转圈圈）尽享美味！！！！！（转圈停下来然后跳起来对着服务员左手叉腰右手比着 ） 阿里嘎多欧内酱！！！呆siki了！ 米~娜~桑！新春佳节又来了desu哇~阿喏呐阿喏呐(｡&gt;∀&lt;｡)，首先呢新的一年呀，要-给-米-娜-桑拜个年desu！(^ω^)（姆Q）米娜桑新年おめでとうそしてそして在新的一年里，米~娜~桑的生活要摩多摩~~~多の西亚☆哇塞♡desu呦✧٩(ˊωˋ*)و✧，和往年一样呢，米~娜~桑的祝福呐！/ 3B1B 向量是什么 https://www.bilibili.com/video/av5987715 导数的本质 https://www.bilibili.com/video/av24325548 构图 可应用于绘画, 摄影 常用画面 1:1, 3:2, 4:3, 6:4, 按需裁剪 中心构图法: 画面尽量对称; 将视觉主体和周围环境紧密结合, 但不能色彩撞衫导致主次不清 对角线构图法 第一眼让观众知道你拍的视觉主体是什么 景物内容尽量完整 人物视觉对象不能是显得堵的东西 虚化对象要保留起码的特征 尽量使主题出现在黄金分割线 需要避免的 非刻意情况下画面要有层次感, 避免引起视觉错觉 人物在视觉上不能在顶房梁 脚不能被卡出画面外 附加 飞向镜头的物品能增加视觉冲击力 街头纪实摄影, 比如巷道口那样的一线天画内搭画框 字体 明日方舟标题英文字体是: NOVECENTOWIDE 明日方舟基建英文字体是 Bender TNO字体: 主标题字体 Tannenberg, 旧版GUI字体 VT323, 新版GUI字体Aldrich Mechanism 一些零件规格, PCB 打样可以找嘉立创 DIY 准备工作: 防割板 电阻电容样品本(Pingcon 样品本 0603 封装, 0402 封装, 常用 IC 元件) 示波器推荐 DS213 开源示波器 Screws M3x10 3mm直径, 10mm螺纹端长度 M4x10r 4mm直径, 10mm螺纹端长度, 圆顶 螺母 M3nS 方形 Pulley GT2-16 Motor 42步进电机 无刷伺服电机 同步带 聚氨酯 PU 同步带 驱动器 软件 multisim 模拟电路仿真 Altium Designer 有开源替代 kicad Autodesk Fusion 或 Rhino 6 Visual Studio Extension: Visual Micro Grandle 设置代理: gradle.properties12345...systemProp.http.proxyHost=hostnamesystemProp.http.proxyPort=8080systemProp.http.proxyUser=usernamesystemProp.http.proxyPassword=xxx 椭圆参数方程 \\(\\begin{cases} x=a\\cos t \\\\ y=b\\sin t \\end{cases}(0\\leqslant t\\leqslant 2\\pi)\\) 变形后可得椭圆方程: \\(\\begin{array}{l}\\frac{x}{a}=\\cos t \\\\ \\frac{y}{b}=\\sin t\\end{array}\\rArr\\begin{array}{l}\\frac{x^2}{y^2}=\\cos^2 t \\\\ \\frac{y^2}{b^2}=\\sin^2 t\\end{array}\\rArr\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=\\cos^2 t+\\sin^2 t=1\\) 因式分解 整式乘法与整式除法 整式乘法: 以 \\((x+1)(2x^2+3x-2)=2x^3+5x^2+x-2\\) 为例 $$ \\begin{array}{rrrrrrrr} & & & 2x^2 & + & 3x & - & 2 \\\\ \\times & & & & & x & + & 1 \\\\ \\hline & & & 2x^2 & + & 3x & - & 2 \\\\ & 2x^3 & + & 3x^2 & - & 2x & & \\\\ \\hline & 2x^3 & + & 5x^2 & + & x & - & 2 \\end{array} $$ 整式除法: 以 \\((2x^3+5x^2+x-2)\\div(x+1)=(2x^2+3x-2)\\) 为例 因式定理与余数定理: 因式定理: 如果多项式 \\(f(a)=0\\) , 则多项式必含因式 \\((x-a)\\) ; 反之, 若多项式含有因式 \\((x-a)\\) , 则 \\(f(a)=0\\) 余数定理: 用 \\((x-a)\\) 去除多项式 \\(f(x)\\) , 所得余式(相当于除法中的余数)是一个值为 \\(f(a)\\) 的常数 试根法: 分解高次多项式时, 用常数项因数与最高次项系数之因数的比值(记为 \\(a\\))去试根, 若验证 \\(f(a)=0\\) 则 \\((x-a)\\) 可整除原多项式, 即 \\((x-a)\\) 为 \\(f(x)\\) 因式 (试根法的本质是因式定理) 如: \\(2x^3+5x^2+x-2=(x+1)(2x^2+3x-2)=(x+1)(2x-1)(x+2)\\) 它的常数项因数(\\(\\pm1\\)、\\(\\pm2\\))和最高次项系数之因数(\\(\\pm1\\)、\\(\\pm2\\))的比值有 \\(\\pm1\\)、\\(\\pm2\\)、\\(\\pm\\frac{1}{2}\\) , 代入得其中 \\(-1\\)、\\(-2\\)、\\(\\frac{1}{2}\\) 可整除原多项式 IUPAC Organic 123456789101112131415161718192021222324252627282930313233343536373839(1S,3R,4R,5R)-3-{[(2E)-3-(3,4-dihydroxyphenyl)prop-2-enoyl]oxy}-1,4,5-trihydroxycyclohexanecarboxylic acidtri hydroxy cyclo hexane carboxylic三羟基环己烷羧酸Latinate series Ordinal numeralprimarysecondarytertiaryquaternary, quartaryquinarysenaryseptenaryoctonarynonarydecenaryundenaryduodenarytri- 三meth- 甲eth- 乙prop- 丙but- 丁pent- 戊hex- 己hept- 庚oct- 辛non- 壬dec- 癸methylp 甲基hydroxy 羟基phenyl 苯基cyclo- 环-ane 烷(Alkanes)carboxylic 羧酸 利用 Zerotier 白嫖校园网 “Zerotier 打洞, 永远滴神” 首先确定你的校园网有IPv6, 一个简单的方法是看看号称支持IPv6的手机支付宝, 能不能在只连接校园网且未登录Wifi的状态下正常使用. 网关机配置转发和NAT:123sudo iptables -t filter -A FORWARD -i zt+ -s &lt;你的Zerotier网络地址段&gt; -d 0.0.0.0/0 -j ACCEPTsudo iptables -t filter -A FORWARD -i eth0 -s 0.0.0.0/0 -d &lt;你的Zerotier网络地址段&gt; -j ACCEPTsudo iptables -t nat -A POSTROUTING -o eth0 -s &lt;你的Zerotier网络地址段&gt; -j SNAT --to-source &lt;你的网关机公网地址&gt; 在 ZeroTier Central 中添加路由: 0.0.0.0/0 via &lt;你的网关机在Zerotier网络中的地址&gt; 在想要白嫖的电脑上, 启用 Zerotier 的 Allow Default Route 最小二乘法求回归直线方程的公式推导 回归直线方程: \\(\\hat{y}=a+bx\\) 其中: \\(\\hat{b}=\\frac{\\sum_{i=1}^n x_iy_i-n\\bar{x}\\bar{y}}{\\sum_{i=1}^n x_i^2-n\\bar{x}^2}\\) , \\(\\hat{a}=\\bar{y}-\\hat{b}\\bar{x}\\) (\\(\\bar{x}\\) 和 \\(\\bar{y}\\) 为 \\(x_i\\) 和 \\(y_i\\) 的均值) 证明: 用所有离差(近似值 \\(\\hat{y}_i\\) 和观察值 \\(y_i\\) 的差)的平方和来表示总离差: \\(\\displaystyle Q=\\sum_{i=1}^n(y_i-\\hat{y}_i)^2=\\sum_{i=1}^n(y_i-a-bx_i)^2\\) (因为离差有正有负, 直接加可能相互抵消) 由于平方又叫二乘方, 所以这种使&quot;离差平方和为最小的方法&quot;称为最小二乘法 开始变形: $$ \\scriptsize \\begin{array}{l} Q=\\displaystyle\\sum_{i=1}^n(y_i-a-bx_i)^2=(y_1-a-bx_1)^2+\\dots+(y_n-a-bx_n)^2 \\\\ =(y_1^2+a^2+b^2x_1^2+2abx_1-2ay_1-2bx_1y_1)+\\dots+(y_n^2+a^2+b^2x_n^2+2abx_n-2ay_n-2bx_ny_n) \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2+na^2+b^2\\sum_{i=1}^n x_i^2+2ab\\sum_{i=1}^n x_i-2a\\sum_{i=1}^n y_i-2b\\sum_{i=1}^n x_iy_i \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2+na^2+b^2\\sum_{i=1}^n x_i^2+2ab\\cdot n\\bar{x}-2a\\cdot n\\bar{y}-2b\\sum_{i=1}^n x_iy_i \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2-2b\\sum_{i=1}^n x_iy_i+b^2\\sum_{i=1}^n x_i^2+na^2-2na(\\bar{y}-b\\bar{x}) \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2-2b\\sum_{i=1}^n x_iy_i+b^2\\sum_{i=1}^n x_i^2+n(a^2-2a(\\bar{y}-b\\bar{x})) \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2-2b\\sum_{i=1}^n x_iy_i+b^2\\sum_{i=1}^n x_i^2+n(a^2-2a(\\bar{y}-b\\bar{x})+(\\bar{y}-b\\bar{x})^2-(\\bar{y}-b\\bar{x})^2) \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2-2b\\sum_{i=1}^n x_iy_i+b^2\\sum_{i=1}^n x_i^2+n(a-(\\bar{y}-b\\bar{x}))^2-n(\\bar{y}-b\\bar{x})^2 \\\\ =\\displaystyle\\sum_{i=1}^n y_i^2-2b\\sum_{i=1}^n x_iy_i+b^2\\sum_{i=1}^n x_i^2+n(a-(\\bar{y}-b\\bar{x}))^2-n\\bar{y}^2+2nb\\bar{x}\\bar{y}-nb^2\\bar{x}^2 \\\\ =\\displaystyle(\\sum_{i=1}^n y_i^2-n\\bar{y}^2)-2b(\\sum_{i=1}^n x_iy_i+n\\bar{x}\\bar{y})+b^2(\\sum_{i=1}^n x_i^2-n\\bar{x}^2)+n(a-(\\bar{y}-b\\bar{x}))^2 \\end{array} $$ 到此, 需要两个关键变形公式以继续变形: \\(\\displaystyle\\sum_{i=1}^n(x_i-\\bar{x})^2=\\sum_{i=1}^nx_i^2-n\\bar{x}^2\\) 证明: $$ \\scriptsize \\begin{array}{ll} \\displaystyle\\sum_{i=1}^n(x_i-\\bar{x})^2 & =(x_1-\\bar{x})^2+\\dots+(x_n-\\bar{x})^2 \\\\ & =(x_1^2-2x_1\\bar{x}+\\bar{x}^2)+\\dots+(x_n^2-2x_n\\bar{x}+\\bar{x}^2) \\\\ & =(x_1^2+\\dots+x_n^2)+n\\bar{x}^2-2\\bar{x}(x_1+\\dots+x_n) \\\\ & \\displaystyle=\\sum_{i=1}^n x_i^2+n\\bar{x}^2-2n\\bar{x}\\frac{(x_1+\\dots+x_n)}{n} \\\\ & \\displaystyle=\\sum_{i=1}^n x_i^2+n\\bar{x}^2-2n\\bar{x}^2 \\\\ & \\displaystyle=\\sum_{i=1}^n x_i^2-n\\bar{x}^2 \\end{array} $$ \\(\\displaystyle\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})=\\sum_{i=1}^n x_iy_i-n\\bar{x}\\bar{y}\\) 证明: $$ \\scriptsize \\begin{array}{ll} \\displaystyle\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y}) & =(x_1-\\bar{x})(y_1-\\bar{y})+\\dots+(x_n-\\bar{x})(y_n-\\bar{y}) \\\\ & =(x_1y_1+\\bar{x}\\bar{y}-x_1\\bar{y}-y_1\\bar{x})+\\dots+(x_ny_n+\\bar{x}\\bar{y}-x_n\\bar{y}-y_n\\bar{x}) \\\\ & =(x_1y_1+\\dots+x_ny_n)+n\\bar{x}\\bar{y}-\\bar{y}(x_1+\\dots+x_n)-\\bar{x}(y_1+\\dots+y_n) \\\\ & \\displaystyle=\\sum_{i=1}^n x_iy_i+n\\bar{x}\\bar{y}-n\\bar{y}\\frac{x_1+\\dots+x_n}{n}-n\\bar{x}\\frac{y_1+\\dots+y_n}{n} \\\\ & \\displaystyle=\\sum_{i=1}^n x_iy_i+n\\bar{x}\\bar{y}-n\\bar{y}\\bar{x}-n\\bar{x}\\bar{y} \\\\ & \\displaystyle=\\sum_{i=1}^n x_iy_i-n\\bar{x}\\bar{y} \\end{array} $$ 接上面: $$ \\scriptsize \\begin{array}{rl} Q= & \\displaystyle(\\sum_{i=1}^n y_i^2-n\\bar{y}^2)-2b(\\sum_{i=1}^n x_iy_i+n\\bar{x}\\bar{y})+b^2(\\sum_{i=1}^n x_i^2-n\\bar{x}^2)+n(a-(\\bar{y}-b\\bar{x}))^2 \\\\ = & \\displaystyle\\sum_{i=1}^n(y_i-\\bar{y})^2-2b\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})+b^2\\sum_{i=1}^n(x_i-\\bar{x})^2+n(a-(\\bar{y}-b\\bar{x}))^2 \\\\ = & \\displaystyle\\sum_{i=1}^n(y_i-\\bar{y})^2+\\sum_{i=1}^n(x_i-\\bar{x})^2(b^2-2b\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2})+n(a-(\\bar{y}-b\\bar{x}))^2 \\\\ = & \\displaystyle\\sum_{i=1}^n(y_i-\\bar{y})^2+\\sum_{i=1}^n(x_i-\\bar{x})^2(b^2-2b\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2}+(\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2})^2 \\\\ & \\displaystyle-(\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2})^2)+n(a-(\\bar{y}-b\\bar{x}))^2 \\\\ = & \\displaystyle\\sum_{i=1}^n(y_i-\\bar{y})^2+\\sum_{i=1}^n(x_i-\\bar{x})^2(b-\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2})^2 \\\\ & \\displaystyle-\\sum_{i=1}^n(x_i-\\bar{x})^2(\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2})^2+n(a-(\\bar{y}-b\\bar{x}))^2 \\\\ = & \\displaystyle\\sum_{i=1}^n(y_i-\\bar{y})^2+\\sum_{i=1}^n(x_i-\\bar{x})^2(b-\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2})^2 \\\\ & \\displaystyle-\\frac{[\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})]^2}{\\sum_{i=1}^n(x_i-\\bar{x})^2}+n(a-(\\bar{y}-b\\bar{x}))^2 \\\\ \\end{array} $$ 至此, 公式变形结束. 观察公式, 其中 \\(\\scriptsize-\\frac{[\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})]^2}{\\sum_{i=1}^n(x_i-\\bar{x})^2}\\) , \\(\\scriptsize\\sum_{i=1}^n(y_i-\\bar{y})^2\\) 为常数项与 \\(a\\) , \\(b\\) 无关. 因此只需使 \\(b=\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i-\\bar{x})^2}\\) , \\(a=\\bar{y}-b\\bar{x}\\) 即可得到最小 \\(Q\\) 值 咖啡的种植 种子培育 用洗净的中细河沙做催芽基质 种子剥去羊皮纸外壳, 以60度以内温水泡种催芽2-7天[根据地方气候决定催芽时间长短], 夏季2-4天即可. 每日换水一次, 直到白色胚芽凸起. 可以正式育苗. 种子均匀铺在苗床上, 种子不可重叠, 点种是种子裂口处朝上覆盖一层稻草或其他保湿物. 或以珍珠棉和泡沫箱盖住, 留有部分空间不可盖严. 2-3日浇一次水, 如气温高水分蒸发过快需每日浇水. (用喷雾) 可在上面搭建塑料透明薄膜棚子, 但待苗出土后幺注意遮阴. 20-40天出苗, 但各地气温不同, 出苗会有前后. 催芽床可用600倍多菌灵喷雾喷催芽床四周, 催芽过程中, 适时喷药. 预防小苗猝倒病, 如有猝倒及时隔离. 预防蚂蚁蟋蟀地老虎等害虫. 育苗期 搭建遮阴棚遮阴, 咖啡喜阴不可在太阳下直晒. 将20公分左右的咖啡幼苗移植到装有营养土的营养袋. 适度浇水, 保持土壤抓起来可成团, 搓, 可散开. 移植幼苗成活后, 30天左右可少量施水肥. 咖啡盆栽管理 咖啡习性: 咖啡喜阴怕晒, 耐热怕冷, 怕旱怕涝, 喜肥怕贫瘠. 咖啡苗移盆时尽量不要弄散原培养土, 所换花盆盆地加碎石子提高沥水性. 土表见干即可浇水, 如出现短暂脱水叶片会蔫掉浇水后6小时即可回转. 施肥: 咖啡施肥每个月一次调水浇灌, 最好使用专用肥. 用量少效果好, 没有也可用普通氮磷钾肥代替效果可能稍差. 施肥量专用肥一年苗不超过20粒每次[调水浇]. 三年苗不超过80粒每次[调水浇]. 施肥后一个星期不可出现脱水现象. 防虫: 咖啡主要有蚜虫, 钻心虫, 蚧壳虫, 毛毛虫. 使用石灰水刷咖啡主干可有效防止. 如出现害虫用吡虫啉喷雾可有效杀死害虫. 病害: 炭疽病, 锈病. 本人也只是听说从未见过. 我地多年来从未出现过咖啡病害, 本人也无计可施. 咖啡品种分辨 铁皮卡即蓝山咖啡, 铁皮卡是阿拉比卡系列里血统最纯品质最高的品种. 树系高大枝叶稀疏形似野生, 新叶呈古铜色, 叶质轻薄柳长. 籽粒椭圆略长于其他品种, 颜色略微泛黄. 卡蒂姆(Catimor): 1959年, 葡萄牙人将巴西卡杜拉与提摩混血, 培育出抗病能力强的卡蒂姆/卡提摩, 目前是商用豆的重要品种. 波邦分黄波邦和波邦, 黄波邦果实呈黄色. 树形与卡蒂姆难于区分…卡蒂姆产量高于波邦. 唯有挂果期好分辨… 尺码对照表 上衣(女) 标准 国际 中国 胸围(cm) 腰围(cm) 肩宽(cm) 适合身高(cm) 尺码明细 XXXS 145/73A 74~76 58~60 34 147~150 XXS 150/76A 76~78 60~62 35 150~153 XS 155/80A 78~81 62~66 36 153~157 S 160/84A 82~85 67~70 38 158~162 M 165/88A 86~89 71~74 40 163~167 L 170/92A 90~93 75~79 42 168~172 XL 175/96A 94~97 80~84 44 173~177 XXL 180/100A 98~102 85~89 46 177~180 裤子(女) 标准 国际 中国 腰围(cm) 臀围(cm) 尺码明细 XXXS 23 55~57 77~80 XXS 24 57~60 80~83 XS 25 60 83 S 26 63 87 M 27 67 90 L 28 70 93 XL 29 73 97 XXL 30 77 100 XXXL 31 80 103 上衣(男) 标准 国际 中国 胸围(cm) 腰围(cm) 肩宽(cm) 适合身高(cm) 尺码明细 S 165/80A 82~85 72~75 42 163~167 M 170/84A 86~89 76~79 44 168~172 L 175/88A 90~93 80~84 46 173~177 XL 180/92A 94~97 85~88 48 178~182 XXL 185/96A 98~102 89~92 50 182~187 XXXL 190/100A 103~107 93~96 52 187~190 裤子(男) 标准 国际 中国 身高 腰围(cm) 臀围(cm) 尺码明细 XXXS 28 70 93 XXS 29 160/66A 73 97 XS 30 165/70A 77 100 S 31 170/74A 80 103 M 32 175/78A 83 107 L 33 180/82A 87 110 XL 34 185/86A 90 113 XXL 36 185/86A 93 117 XXXL 38 190/90A 97 123~127 上述腰围指实际腰围, 并不是裤子的尺码 维修 BGA推荐风枪温度: 拆卸(原厂高温锡) 424°C 植锡/焊盘清理 334°C 烙铁推荐温度: 原厂高温锡 300-350°C 其他 280-320°C 读书摘录 “I tell you I must go!” I retorted, roused to something like passion. “Do you think I can stay to become nothing to you? Do you think I am an automaton? — a machine without feelings? and can bear to have my morsel of bread snatched from my lips, and my drop of living water dashed from my cup? Do you think, because I am poor, obscure, plain, and little, I am soulless and heartless? You think wrong! — I have as much soul as you, — and full as much heart! And if God had gifted me with some beauty and much wealth, I should have made it as hard for you to leave me, as it is now for me to leave you. I am not talking to you now through the medium of custom, conventionalities, nor even of mortal flesh; — it is my spirit that addresses your spirit; just as if both had passed through the grave, and we stood at God’s feet, equal, — as we are!” — Jane Eyre “I am no bird; and no net ensuares me: I am a free human being with an independent will, which I now exert to leave you.” — Jane Eyre “在写作当中运用别人的语句并不就意味着模仿或抄袭, 写出来的东西并非毫无价值可言, 因为它至少 能够说明我已经能够灵活地驾驭这些优美的文字, 能够表达我对那些优美的、富有诗意的思想的欣赏” ⸺《儒林外史》 “但在绝大部分的明清通俗小说中, 尽管对于科举制度的不平、愤激、斥责俯首皆是, 但叙述时字里行间却仍然包含了对于科举的依赖和眷念, 这尤其体现为男主人公获得进士科名往往是小说团圆大结局结局不可或缺的元素.” ⸺《儒林外史》-导读 叶楚炎 “而与之相比, 吴敬梓对于科举社会的种种情状却有着更深的洞察力和表现力: 无论是对于科举社会中士人生存困境的呈现, 还是对于诸多弊端的反思, 以及对于儒林中人出路的探寻,《儒林外史》都远远地超过了同题材的这些作品.” ⸺《儒林外史》-导读 叶楚炎 &quot;消除胆怯为当务之急, 对此, 英国大作家汤玛士·卡莱尔曾说: “要想成为一个真正的人, 第一就要征服恐惧不安.” 为了达到征服的目的, 第一步骤就是 “行动”. 也就是说要积极向前迈进. 如此, 恐惧不安必能被消除. 勇敢采取行动向前迈进吧. 希尔多·罗斯福就是因这种积极的行动, 结果很成功地消除了恐惧不安. 他说: &quot;我经常被 ‘不安’ 所困扰, 可是我从不向他低头, 也从不担心未来的任何事, 所以, ‘不安’ 就逐渐消失了. “” ⸺《如何消除胆怯》 (ISBN7-5048-2005-9/Z·290) “如果碰到你不懂的事又不敢或不肯问, 那么你就真的注定要笨到底了. 因为怕显得笨而更笨的人是无可救药的.” ⸺《如何消除胆怯》 (ISBN7-5048-2005-9/Z·290) “我们随别人喜而喜, 随别人忧而忧. 如是说来, 你我果真成了一张扑克牌, 一张任人揉捏、任别人摆弄的扑克牌? 没有自己的主张, 没有自己的愿望, 更没有自己的自尊. 就这样一生都摆脱不了别人的支配与选择? 果真是这样吗? 不! 我们绝不是一张扑克牌! 扑克牌毕竟没有思维, 而我们, 却是一群有着高级思维能力的活生生的人啊! 我们本该拥有与扑克牌截然不同的人生! 自己的历史靠自己书写, 自己的青春靠自己去创造, 自己的世界靠自己去闯! 而不是像牌那样在冥冥中失去自我!” ⸺《如何消除胆怯》 (ISBN7-5048-2005-9/Z·290) “感到畏惧的时候, 你就去做你畏惧的事, 不久你就不用再畏惧它了. 如果你害怕某一件事, 你试着不要让自己沉溺于这事的想象中, 首要的责任是征服恐惧, 为此需要积极的、勇往直前的行动, 去攻击恐惧, 攻击的力量越大. 畏惧消失得也就越快.” ⸺《如何消除胆怯》 (ISBN7-5048-2005-9/Z·290) &quot;罪恶之源无关紧要, 人们关心的是对抗它和战胜它, 既不要乐观, 也不要悲观, 要把不懈努力使事情变得更美好作为唯一指南. &quot; ⸺ (西) 伊巴涅斯 &quot;每天务必要做一点你所不愿意做的事情. 这是一条最宝贵的准则, 它可以使你养成认真尽责而不以为善的习惯. &quot; ⸺ (美) 马克·吐温 “理想的 (绝大多数是内在的) 学习动机着重于战略和战术, 而并不那么强调立竿见影的效果, 因此, 需有极强的忍受挫折的耐力才行, 因为解决问题的方法只有在重重困难中方可产生. 因此可以判断, 程序教学的学习计划和形式把任何微不足道的思维活动都当作成功的做法, 是与创造力敌对的” ⸺《创造力》 (德) 海纳特 &quot; 许多人提到的另一问题是关于 “智力” 这个术语的实际定义和含义. 他们对于智力的解释含糊不清感到不满意. 而事实上, 尽管心理学家们使用的智力测验大多雷同, 但他们的理论解释也不尽一致. 这里有必要弄明白正在测量的是什么和如何测量它. 我想就关于由智力测验来量度的智力的本性说几句话. 在此之前, 我要说明, 根据文献知识和在此领域多年来的实际工作经验, 我所说的只是自己对此问题的看法. 对于我的观点, 其他心理学家未必会赞同, 当然它也可能是十分错误的. 不过真理或许正在我这方面. 当我们详细地分析智力测验的执行情况时, 我们发现有一个显著的特征, 它比其它因素在决定成败上更为重要, 这就是思维速度. 如果你出了大量十分简单的题目 (全是同一类型), 比如说一个字母序列 A, C, E, G? 你会发现, 很少有人会打错, 或者会发现题目太难. 然而, 某些人能在几秒钟内解答二十题或三十题, 而另一些人做这些题几乎要花几分钟. 速度上的差异在原来越难的题目中同样有所表现; 换句话说, 那些对容易题目做得快的人, 对难题也做得快; 而那些对容易题目做得慢的人, 对难题也做得慢. 我认为这种普遍存在的思维速度的不同是由造成人们智力差异的、基本的遗传因素所决定的. 然而, 思维速度又不能与智商等同, 这是因为在任何智商测量中, 各种非智力的个性因素也同样起作用. 首先我们要明白, 在典型的智商测验中速度的确是一个重要的变量. 你还可能会发现, 尽管你在规定的半小时内只能答出几道题, 但如果你愿意坚持做下去, 实际上, 每道题你都会做. 因此, 测验的时间限制是最基本的, 否则几乎每个人都会得到优异的成绩. 因此在典型的智力测验中不可能出很复杂和很难的试题. 如果注意一下 “考考智力巨人” 那部分测验题, 你将看到, 我们如果要给出时间限制的话, 则必须规定为几小时, 甚至几天, 这在管理上实际是难以执行的. 即使不限制时间, 人们也得不到满分. 这是由于某些个性因素造成的. 测验时间一长这些个性因素就会影响成绩. 即使时间短也常有影响. 在这方面试验研究确定了与此有关的两种主要个性, 它们通常被称为粗心和缺乏坚韧性. 如果你的思维速度慢, 那么, 对于某一测验, 思维速度快的人在半小时内就可答完, 而你可能要花上 20 个小时. 这样在测验时间结束之前, 你的积极性可能已经大大衰减, 因此可能放弃掉某些认为答不上来的问题. 其实, 只要能再坚持一会儿是可以答上来的. 当然, 如果缺乏坚韧性, 即使时间短也会影响成绩的. 有些人只愿意在一个题目上花费半分钟而不愿花费两分钟. 实际上, 题目的难易程度和解答它所需的时间之间似乎有一种对数关系, 这就要求思维速度相当慢的人的坚韧性比其他人强得多才行. 在日常生活及不限时间的测验中是有这种可能性的, 即可以用坚韧性来换取思维速度; 这就是所谓 “失之东隅, 收之桑榆”, 反之亦然. 即使你的思维速度快而且有坚韧性, 但你可能粗心大意, 就是说只要想出一种答案也不考虑一下它实际上是否正确就将它答上. “验错机构” 失灵, 如同思维速度慢和没有坚韧性一样都会使得分降低. 性格外向的人在这方面就更差. 他们比性格内向的人会出更多的错误. 有足够的证据证明, 有创造性的人 (他们擅长于开放题测试) 在闭式题测验中常常粗心. 这是我们重提用 “11+ 考试” 来评价某些有才智的人是否公平的另一个理由. &quot; ⸺《了解自己的智力 2》 (英) H. J. 艾森克 “心理战, 是运用心理学的原理, 通过宣传等方式从精神上瓦解敌方军民的斗志, 或消除敌方宣传所造成影响的对抗活动. 其手段包括: 宣传、威慑、谋略等. 在信息化条件下, 敌方对我实施心理战的主要目的是: ①动摇人民群众的防空信心; ② 制造人们对高科技武器的心理; ③ 扰乱人们的正常思维和行为; ④ 造成人的生理机能紊乱, 形成战争综合征.” ⸺《民防知识》 江苏省民防局&amp;江苏省教育厅 ISBN 978-7-305-11263-8 《创造力》笔记 作者: (德)海纳特, Gottfried Heinelt 译者: 陈钢林 原版出版商: Verlag Herder KG Freiburg im Breisgau 译文出版商: 工人出版社 原版版次: 1974 译文版次: 1986年2月第1版 书号: 7007·173 创造力的概念: 创造力的各式各样的定义(针对创造力的本性、“本质”): 米德 (M·Mead) 在解释创造力是强调主观创新: &quot;当一个人自己想出、做出或发明了一样新东西, 就可以说他完成了一次创造性行动. 这样看来, 一个二十世纪的儿童自己发现, 在直角三角形里, 勾、股边的平方之和等于弦边的平方, 那么他也就完成了一次跟毕达哥拉斯一样的创造性行动, 尽管这个发现的结果对于文化传统来说等于零, 因为这句话早已是几何学的组成部分了. &quot; (P16, P17) 德雷夫达尔 (J·E·Drevdahl) 着重指出 “目的性” 和 “目标明确性”, 以及在各个领域里的实现: “创造力是人产生任何一种形式的思维结果的能力, 而这些思维结果在本质上是新颖的, 是产生它们的人事先所不知的. 他有可能是想象力或者是一种不只限于概括的思想综合. 创造力本身包括根据已知信息重新组合新系统的能力. 创造的产品尽管不一定能直接利用, 也无须尽善尽美, 但是, 创造性活动必须是有目的和目标明确的, 而不是无益的、幻想般的. 可以设想它是一种艺术的、文学的或科学的形式, 或者是可以实施的技术设计或方式方法.” (P17) 申克-丹齐格 (L·Schenk-danzinger) 强调信息量和创造积极性之间的关系. 原则上来说, 创造力可以在最小信息量的前提下产生, 亦能在信息完备和充分的条件下产生. 正是在信息不够的情况下, 才产生了解决问题的战略和可能性, 这些战略和可能性都可以看作是富于想象力和富有独创性的: “分散思维过程并不是在定好的轨道中产生的, 而是依据所获得的最低限度的信息 ⸺ 因此是有创造性的.” (P17) 施拉姆尔提醒人们创造力与燥狂性精神病之间的亲缘关系: “观念敏捷性(吉尔福德)和’病态的观念奔逸’, (后者在燥狂性精神病理学`中十分典型) 这两个词的亲缘关系使人不难看出, 创造力和精神病理学领域挨得多么近.” (P19, P20) 托伦斯: “因为创造力的本质是’寻求真理’, 所以重要的是, 让一系列大学研究室去探讨寻求真理的范畴和方法. 没有这些能力, 创造性思维便缺乏深度.” 与托伦斯的看法相似的是韦特墨的观点, 他在试图阐明创造性思维时指出, 创造性思维最终关系到把握 “结构的真理”: “…(创造性)思维需要的是注意和详察结构的特性和要求; …是寻求有结构的而非零碎的真理…就人看来, 在他后面隐藏着一种要求和渴望, 即想注意事物的突出点、结构的核心与情景的根源; (想彻底地研究这件事); 想由事物模糊的和不适当的关系获得清晰的、透明的和直接的对比, 直接地从思维者的内心到达思维对象和问题的核心…这种类型的思维过程以对现实充分肯定的态度为前提.” (P20, P21) 沃尔施勒格将创造性活动提到更大范围的内在联系中去看, 并且宣称, 创造力是理智地改变社会现行规范的发动机: “创造力是揭示新的内在联系的能力, 是理智地改变现行规范的能力, 使用创造力, 可使问题在社会现实中得以普遍的解决.” (P21) 沃尔施勒格认为, 可以把 “社会创造力” 或者 “集体创造力” 看成目标. 这样一来, 立时突破了个人创造力的设计, 引人注目地提出了在有组织的集体里产生创造性活动的可能性. (P21, P22) 创造性活动的模式 (P23~P25) 把析出各种思维模式作为出发点, 给创造力下定义: ⸺ 以具备一些不同的、归属智力范畴的个性特征 (特性) 为前提 (静态模式); ⸺ 是一种在意识区和无意识区流动的创造性过程 (动态模式); ⸺ 是一个有创造力的人的表现形式和 “表达” (个人模式) 类创造力、假性创造力 (P14~P16) 类创造力 (亦被看作前创造力) 是以创造力为目标的创造力雏形, 亦称作创造力的准备阶段: 如缺乏现实性的儿童幻想、内倾型的空想和青年人的想入非非. 假性创造力是一种伪装的创造力. 如某人 “无论如何” 都要具有独到见解, 靠 “权势和权力”, 必要时在社会的压力下, “必须” 出名. 创造型教师: 倘若把创造力作为教育的目标, 那么实现的前提就是创造型教师. (P105) 幽默感与创造力: (P123) 至今仍有一些教师把取笑、挖苦和讽刺归为幽默感的表现, 这是完全错误的看法. 拿别人取乐不属于幽默感, 因为攻击、伤害或者恶语伤人都不是真正的幽默感. 同创造力一样, 强迫和命令都不能产生幽默感. 幽默感并不是每时每刻都能出现的, 而是高兴的一瞬间的果实, 是友好气氛的结晶, 是创造性自由的馈赠; 它是表露, 同时也是作用: 它能消除紧张, 解决争端, 消除不和谐因素. 毫无幽默感的人不会有创造力. 创造型集体 非创造型集体: (P99, P100) 破坏型集体多是权威或反权威教育的结果. 其集体成员多维持着彼此否定、拒绝甚至敌视的关系 情绪和情感上强烈的紧张状态以及流露出来的利己思想将正在形成的集体感扼杀于萌芽状态. 精神和力量耗尽在冲突和各种社会障碍中, 集体气氛和实际的劳动态度更无从谈起. (P99) 持批判态度的成绩型集体的特征是, 其成员的社会差距大, 批判意识强, 无论是同学还是教师都成为他们的批判对象. 他们常用 “合理的客观动机” 作为批判理由. 各种批判性的判断培养了利己主义和不承认同学的唯成绩态度. 每个学生都想方设法击败另一名学生, 因为他感到那人成为他的竞争对象. 我们的教育体系至今还在继续促发这种唯成绩集体. 因此也就有人教育学生要依赖和顺从集体的其他成员和仅有批判眼光的教师. 后进学生的动机和背景无人过问, 跟不上的则要受到严厉的批评. 由于社会关系居于次要的地位, 所以无法与他人建立伙伴式的合作关系. 这种集体根本谈不上创造性活动, 他重视的唯有在成绩单上和获得威望时表现出来的成功. 创造型集体的特征: (P100) 创造型集体以高度团结作为标志. 在这里要区分集体内的团结, 即内部团结, 和与外界的团结, 即外部团结. 外部团结是由家长、学校校长、其他教师和学校管理人员的关系决定的. 创造型集体的目标在于: (P101) ⸺ 消除破坏性的社会紧张; ⸺ 挖掘集体内在的潜力; ⸺ 培养创造型人物. 创造型集体人数限制. 有关文献把理想人数定在八至十人之间. 一般认为超过三十名学生的班级便失去了发挥集体创造力的有利先决条件. 当然, 不应把它作为绝对的标准, 已经结构化的集体人数可以多一些, 但结构差的集体人数须控制在较少的范围. (P102) 创造型学生: 大专院校的实践: 我们今天所面临的相当困难的任务, 无疑是在极端的墨守陈规和彻底的放任自流之间寻找一条中间道路, 这条道路应该是现实的和有建设性的, 换句话说: 创造力意味着从再现反应式的狭隘行为和思想中解放出来, 向灵活性、自发性和独创性的方向发展, 而不走到绝对自由的新极端上去. (P73) 《人生活动的艺术》节选 作者: 顾晓鸣 出版商: 浙江人民出版社 书号: 统一书号 7103·1339, ISBN 7-213-00091-8/G·14 版次: 1987 年 1 月第 1 版 用行动创造 “自己的故事” (P28) 在姑娘生日的早餐, 邮递员送来了一个小小的包裹, 包裹里是一条姑娘最喜欢的围巾, 款式、质地、色泽样样中她心意. 此时, 姑娘的感受难以用 “激动”、“甜蜜” 之类普通的形容词来描述, 小伙子寄来的生日礼物, 大大震动了姑娘的心… 到商店里去买一条围巾, 只需要花上几块钱, 这邮费, 也不过是几毛钱, 谁去买来寄都是这个价, 为什么在姑娘收到的时候, 却觉得贵似金, 重千钧了呢? 这是因为那小伙子创造了一个情境, 区区的围巾在这情境中升值. 升值了的围巾凝聚着旁人所看不见摸不着的 “情” 和 “意”, 成了姑娘人生中的一个纪念品, 一个记忆中永不会被遗忘的闪光点; 而这整个情境和过程, 构成了姑娘一个终身值得回味的故事 ⸺ 他俩的故事! 小伙子用自己的思维和行动写下了一个故事, 一段个人生活史中有声有色的事件… 朋友, 当你用文字在创造, 用工具在创造的时候, 有没有想到用自己那似转瞬即逝的一举一动、一言一笑来创造自己的 “故事” 呢? 我们用自己的行动创造了一个具有美好意境的故事, 它将永远被心灵的眼睛看见, 再看见…它同时成为我们今后人生的一部分, 这个永不消逝的故事把我们导向新的故事, 我的故事引起你的故事, 最后又共同创造了 “我们的” 故事. 当年老力衰, 生命将尽之时, 自己创造的无数悲壮的、动人的、滑稽的…故事会连成一片, 组成个人美好的人生史, 这是我们生命存在过的见证和痕迹, 这是我们的业绩! 还有比这更能宽慰晚年的心灵吗? 正在追求着的朋友们啊, 让我们共同创造一种情境, 创造自己的人生阶段, 用言语行动在心灵的稿子上抒写一个个隽永不朽的故事! 这, 就是我们的故事. 爱情、友谊, 还有生活中的一切活动, 都是创造故事, 抒写自己历史的好题材. 譬如说, 明天是星期天, 你怎样度过这一天? ⸺ 星期天, 这是自己人生历程中一页新的稿纸, 我能在它上面抒写一个怎样的故事, 从而使它成为与以往星期天不一般的日子载入人生的史册? 一旦我们有了这样的战略思考, 那么, 我们不是度过一个星期天, 而是在创造一个星期天! 现在让我们把目光移向整个人生: 学习、工作、研究…在这些事情中, 我们是 “被动地度过” 还是 “主动地创造”? 是追求文凭、金钱、地位之类的东西呢, 还是追求一种伟大美好的人生历程, 用自己的行动写出自己的人生故事. 故事是需要事先有个粗粗的提纲的. 开始步入人生的朋友啊, 自问自己有没有充分的思想准备, 有没有充分的知识准备, 有没有眼界和魄力. 或者象 “走自己的路” 的伟人们那样目标始终如一; 或者象在十五岁时制定了总数达一百二十七个愿望的计划, 到今天已实现了一百零六项愿望的美国人科达尔那样, 自觉地创造生活, 自觉地让生命的画布发挥其最大的价值, 在它上面绘出最宏伟美好的场景, 写下最令人们感动而又最令自己回味的故事. 这些故事, 在每个人的生命航程中, 都会掀起洁白的浪花. 撑竹篙的启示 (P77) 当船离岸的时候, 我们用竹篙轻轻地一点, 沉沉的船就被撑动了. 如果我们心急, 想一下子离岸, 因而使尽力气把竹篙抵向岸边, 船却不动. 其中的道理, 学过力学的同志都是知道的. 但是, 当我们处理生活问题的时候, 却常常忘了这一点. 有的人, 听到人家说学习外语重要, 买了词典买了书, 劲头十足, 一连几天甚至几星期日日夜夜地学, 可是一段时间过去, 感到似乎收获甚微, 从此便心灰意冷, 书积蛛网. 又过了一段时间, 心血来潮, 取出旧书, 又拚命读了一阵, 不久觉得效果不大, 又偃旗息鼓, 不再问津. 多少人如此热热冷冷, 不但花了好些时间, 而且每重复一次, 学习的信心就减退一些. 最后, 只能望 “书” 兴叹, 自以为不是学外文的料. 其实, 这些同志有决心, 舍得花时间, 只是不懂 “撑竹篙” 的道理. 学习的原理和力学的原理有点相像. 公式是: 学习的效果 = 学习的力气 × 时间长度. 可以说, 没有持之以恒的努力, 是不可能学会一门学问的. 如此说来, 是不是要花很多很多的时间去读书呢? 不. 假如你念课文, 在兴头上一连念了十遍, 以后灰心而不念了; 而另一个人, 同样念十遍, 先每天念两遍, 念了三天, 然后, 每天念一遍, 又念了四天, 你说哪一个效果好? 其实, 不只是读书, 学艺、科研, 甚至养病吃药都有这个小原理吧. 你不妨观察体会一下. 那么这里的道理在哪里呢? 原来, 我们每一项活动不但与时间的长短有关, 而且与我们心智、身体和事物发展的节律有关. 药片吃下去, 药性同体内生化反应的过程相作用, 才能影响体质, 抵御疾病; 阅读时眼睛吸收的信息, 需要有一个复杂的记忆、理解、应用的过程相匹配, 才能 “消化”; 至于种田、养猪, 还牵扯到植物和动物的生长节律. 因此, 在诸如此类的场合, 绝对的时间长度的增加, 并不一定有效地促进这些活动的进行, 有时反而成了 “拔苗助长”、“消化不良”, 或者白白做了无用功. 因此, 切合自己心理、体力, 切合所做的事情的自身规律来使用时间、分配时间, 不但能够收到良好的效果, 而且还能 “事半功倍”, 节约大量的时间. 譬如马克思读书, 就喜欢用特别的 “间隔法” 加以复习 ⸺ 他读完一本有价值的书, 就夹张纸做标记, 以后先隔几个月复读一遍, 再隔半年、一年进行浏览, 依靠这种时间安排, 他费时不多, 却牢牢地记住了这些读物内容, 不断加深着理解, 达到 “博闻强记” 的目的. 登山的启示 (P93) 你可知道? 现代登山运动员同早期登山运动员的区别在哪里? 早期的人们登山是乐在目标, 现代登山运动员所追求的则不但在于登上顶峰, 而且乐在途中 ⸺ 他们选择最难攀登的道路, 在一个个危险的关口, 体验自己生命 ⸺ 体力、意志、智力、技巧的力量. 奇妙不奇妙? 由于有了这个动机, 难得、苦的、险的竟成了登山运动员们追求的对象, 苦转化为乐, 而不难、不苦、不险反而使登山者索然无味了! 作为生活的攀登者, 当你向着一个目标挺进的时候, 不也需要现代登山者的这种精神吗? 艰难的学习条件, 不平静的生活环境等等, 正是登山途中的一道道关口. 如果你不是消极地、满腹怨言地去对待它们, 并且征服它们; 那么, 你就不但充满着自信和愉快的情绪, 而且为你潜在生命力的发挥创造了条件. 乐在途中, 不仅乐而已, 而且, 在乐的中间攀登, 会使人更容易走完艰难的路程. 好比你读一本难读的厚厚的书, 你不是让 “真难”、“看不进”、“怕看不到底” 这些消极的念头占据心灵, 而是象登山者那样迎着难点上, 那么, 每翻过一页, 每想通一段疑难的段落, 你心中就有一种胜利的喜悦 ⸺ 乐在途中, 这本书很快就会读完的! 这里所包含的道理, 牵扯到动机的方向问题. 我们做任何一件事情, 心中总会关注于两个方面: 这件事的最终目的和这件事的过程, 事实上常常是 “一心两用” 的. 因此, 做一件事的动机常常包含着两个方向 ⸺ 一是针对目标和目的地, 一是针对过程本身. 在通常的情况下, 崇高的目标、美好的前景会激发我们强烈的动机, 有时会使我们无视过程中的艰难困苦, 但是, 在一般情况下, 由于我们主要地只把动机针对于目标, 因此过程中的困难都被看成是达到目标的障碍, 不免从消极方面去看待过程. 这样就可能成为减弱动机的负因素, 针对过程的动机成为负动机. 而在现代登山运动员看来, 他们的动机明确地分为两个方向, 既关注于目的地, 又把登山过程看作锻炼和检验自己意志和体力的机会, 看成享受生命的机会. 这时, 他们的登山动机受到两方面的激励, 互相补充, 互相促进: 每克服一个险阻, 既尝到自身的快乐, 又因为离目的地进了一步, 而得到双倍的快慰. 因此, 在生活中有意识地分配自己的活动动机, 发掘活动过程中可能带来的意义和乐趣, 克服对过程中困难的消极心理. 就能乐中有乐, 苦中有乐, 处处充满快乐, 而这种心境的出现, 又成为一种良好的活动激情, 又会激起我们前进的动机. 乐在途中, 虽说途中有乐, 但最大的乐毕竟在于登上那巍峨的高峰啊! 消费和&quot;时间的消费&quot; (P116) 在古代社会, 对于一个青年来说: “消费” 究竟意味着什么呢? 当然, 你会说, “消费” 就是指 “花钱” 嘛. 然而, 在社会生活中, “消费” 却并不单单是花钱的问题. 从社会学的角度看, 还有一种与消费金钱相随的消费. 只有了解了这一点, 你才能用一种新颖的眼光去对待经济性的花钱行为, 从而能自觉地设计自己的 “最佳消费方案”. 你花掉好些钱, 百里迢迢来到一个旅游点, 可你连一分钱的土特产也没有买, 讲得更绝对一点, 连吃的东西也是自己带去的, 这时你在 “消费” 着什么呢? 或者, 你为了 “充分地消费掉” 你的收录机, 一边看书一边听录音, 甚至没日没夜地放音乐, 而这却使你心不在焉, 使别的活动效率降低. 这时, 你会明显地感到, 自己虽然充分使用着收录机, 然而却在浪费着时间! 是的, 正是时间, 这是伴随着我们消费行为的另一种 “消费品”. 有些消费行为, 本质上正是在 “消费” 着时间, 如度假、旅游、收听消遣性的流行音乐; 有些消费者是消费物品, 其实也同有没有相应的时间有关 ⸺ 买了一架没有时间去玩的乐器, 等于没有消费这个 “物品”! 反过来, 在 “时间就是金钱” 的现代社会, 不问时间消费是否适当的消费, 实际上是最不合算的消费. 你一定有过这样的体验: 花了钱同朋友或家人出去游玩, 但由于时间局促, 心中老记挂着要做的事, 结果心不在焉, 很不痛快. 为什么我们的消费行为总要同时间 “消费” 紧密相连呢? 因为从社会学来看, 人的时间 “消费” 模式是人的生活方式的指标, 是人的社会活动的表现. 而任何一种被消费的物品, 只有同如何 “消费” 自己的时间结合起来, 才能最大限度地&quot;物尽其用&quot;, 得到充分的消费. 从这个挂念出发, 我们就能体会到, 即使我们钱很少, 无法购买昂贵的消费品, 但是用它买来的一架简陋的半导体, 如果它正是自己人生活动最需要的东西, 我们从中所获得的消费享受也许比一千元价值的收录机还大! 树立消费的 “时间眼光” ⸺ 在添置一件大型消费品或进行一项消费性活动时, 问一问自己, 有没有相应的时间可供 “消费”? 只有同自己的时间分配结构最吻合的消费品, 才能充分使用, 从而使有限的金钱消费到最多的东西. 从另一方面说, 在消费品中要努力寻找那些可以 “生产” 时间的消费品, 例如洗衣机, 常用备查的工具书, 甚至早日买一辆自行车, 虽说不靠它作为上下班的交通工具, 但每天零星的买油买醋之类, 都可以借助它来 “生产” 时间, 而这些时间又可供我们 “消费” 家中其他的消费品! 从而提高自己整个的 “消费水平”! 但这还只讲了一半, 每个人可供自己消费的时间又是受什么制约的呢? 每个人的时间分配和使用方式, 与他所处于的人生周期紧密相连. 什么叫人生周期? 通俗地说: 就是我们的人生阶段 ⸺ 少年, 青年、壮年…由于人的社会角色 (工作、职务、家庭负担) 和心理都与人生周期密切相关, 因此, 可以用于 “消费” 的时间和一般消费的心理都与一定的人生阶段有关. 人生的特定阶段意味着这一时期主要从事的活动. 因为人生的需要和时间的使用情况是处于不断变动之中的, 只有最密切配合当时当地的人生活动的消费, 才是利用率最高的消费, 好比小孩买玩具, 在他智力刚萌芽时恰到好处地买给他一种智力玩具, 才能使他能玩得来, 玩得最起劲, 因此每天玩的时间也最长 ⸺ 最后完全地把玩具 “消费” 掉! 青年期人生活动的变化也很多, 只要你仔细观察一下, 就会发现, 比如上学或业余学习第一年所需要的和所能 “用得来” 的书籍或用具, 二、三年之后的效用就大不相同了. 早买还是晚买, 其消费效果是大不相同的. 再举个小例子, 有的姑娘喜欢买衣料藏起来, 这种消费看似 “节约”, 似乎衣料在家, 什么时候做都一样, 但由于它离开了当时当地的特定活动, 往往反而造成了浪费, 衣料未能及时好好地加以消费 ⸺ 自己岁数大了几岁后, 衣料的颜色也许不合适了. 什么叫合适? 不就是有符合人生特定阶段的活动和需要吗? 顺着这条思路想下去, 我们有时买了一件用具, 却 “保管” 得太好, 舍不得常常使用它, 怕弄坏了弄脏了, 结果在最需要的人生阶段, 该用而不用, 时过境迁, 反而用不着了. 这时尽管它很新, 但对自己来说, 消费价值近乎零. 讲得过头点, 买来的东西, 该用时就要尽量地用, 那怕没几年就用旧用坏了, 但由于它尽了自己的效用, 那才是充分的消费! 然而, 人并不单是为现在而活着的, 人有总体的生活目标, 因此 ⸺ 消费, 还应该按 “人生目标” 来作通盘考虑. 由于人生目标是自己全力贯注的, 会影响到自己往后的岁月, 维系着一生的幸福, 因此, 属于人生目标的活动是我们要费大半生的时间去进行的. 这样, 符合人生目标的消费品是我们最有时间或最舍得花时间去使用的东西, 显然买来后的使用率最高. 而且它们往往跨越 “人生阶段”, 成为长久甚至终身使用和爱好的东西. 譬如说, 酷爱摄影的同志, 不妨下定决心, 早一点买一架较好的照相机, 这看似把一般青年都有的消费品 “挤” 掉了, 但它的利用率最高, 并会长久地为你产生新的经济能力, 从而使你有更大的财力去消费到更多的消费品. 根据人生目标来消费, 我们就有一种战略安排, 先买什么, 后买什么, 先花钱去 “玩”, 还是先花钱去买东西, 等等, 都要有一种内在的次序和结构. 有的青年在毕业后三年中, 不考虑添置大家伙, 而以充足的财力上业余大学或进行业余研究工作, 结果三年之后, 他们学历提高, 为终身的生活目标打好了基础, 同时也由于作出了成绩而晋升了工资, 这样又为进一步消费准备了财力. 随着水平的提高和结婚问题提上议事日程, 再逐步添置大件用品…这只不过是一种例子, 每个青年可以想想自己的人生计划, 然后排一个轻重缓急. 这样该消费时, 消费得痛快, 不该消费的地方, 也不会过分犹豫不决. 可以说, 消费形式是否最佳, 效果是否最好, 主要还是看这种消费是否促进了自己的人生活动, 是不是最大限度地利用了生命的时间, 使我们有限的人生发出最大限度的光, 为 “人类的幸福和自身的完美” (马克思语) 作出了最大的贡献! 这里再提一段 “开发你家庭的空间” (P142) 的内容: 我们的家庭居住面积有限: 因为没有安排好一个可以随时阅读写作的 “角落”, 许多时间就随便放掉 ⸺ 一天疲劳之后, 我们懒得再清理出一块地方进行读书写作, 于是空间限制了家庭活动; 因为没有给孩子留出一块可以搭起房子、大桥的 “场地”, 许多很有趣的玩具常常束之高阁; 如此等等, 由于空间的筹划不够妥当和精明, 我们浪费着时间, 损失着活动的时机, 限制着生活的范围, 收缩着创新的触角! 利用信息, 防止失真与噪声 (P133) 当我们在小橱里找什么药的时候, 一个瓶子一个瓶子看过去, 拧开盖子又盖上, 要花多少时间? 当我们找笔记本时也会发生同样的情况, 一本本地翻阅. 如果每次放药, 每次新开用一本本子, 都在外面写上字, 那么, 这样可以节省好多时间. 这就是信息的功能. 我们用这样的眼光打量一下生活, 就会发现, 每天因为信息不明而浪费了好多人力物力和时间. 如家里钟不准, 造成上班迟到; 朋友的地址不好好记在笔记本上, 临到上路, 还要花好些时间询问. 买衣服买鞋或替别人买衣服, 讲不清尺码, 就容易买得不合适, 如此等等. 发生这些小事, 其实都是因为我们不重视信息在生活中的巨大作用而造成的. 不相信你去试试看, 每天对一次钟, 你的时间信息就准了, 时间观念就会强了; 地址、电话号码等必要的数据随手记在备忘本子上, 查起来就随手可得; 给容易搞混的瓶子做上标记, 不仅随手可得, 而且不易搞错. 这就能起到信息的有效作用. 还有, 如果你今天要迟回来或离家办什么事, 写一张便条给家里人, 这个信息可以省掉他们许多不必要的耽心和等待. 这里的关键是什么呢? 是在于随时把模糊的信息变成确切的信息, 但是, 同一条信息, 例如瓶子上的一个标签、留给家人的一张便条, 由于时间的间隔或过多的转手, 本来清晰的意义也有可能变得不清了. 所以, 我们不仅要利用信息, 而且要防止信息的&quot;失真&quot;. 对于发送信息的人来说, 要尽量精确, 而对接收信息的人说, 则要设法把失真的地方复原. 传播学的研究证明, 信息在传播过程中总要发生或大或小的 “失真”, 因此, 我们利用信息的人在接收到信息时, 一定要清醒地看到这一点. 在广开致富门路的今天, 各方面传来的消息很多, 有的同志一听到别人说起某某地方有什么货源, 某某行当可以发展之类, 急急去办, 结果吃了大亏. 毛病就出在其幼稚的信息观, 他们认为有了某种消息就是信息了, 不知道他所接收到的信息, 由于传播中的种种原因, 已经失真了, 其中有效信息很少, 甚至完全不真实了. 按照不可靠的信息去办事, 哪能成功呢? 因此, 当我们看到和听到某个消息时, 应立即分析 “传播者” 的情况, 分析 “传播者” 的信息和来源, 分析一下这个信息传到自己经过了几个环节 (例如, 朋友听朋友的父亲说的, 朋友的父亲又是听他的同事说的), 然后大致就会衡量出可能的失真度. 如果是重要的信息, 则等待其他渠道传过来的信息加以验证. 这些道理写出来似乎很简单, 但只要想想我们多少人上过 “小道消息” 的当, 就可以知道, 真要在最有吸引力的 “信息” 面前保持冷静的头脑, 该有一点科学眼光才行. 信息在传播过程中, 不但可能失真变音, 还可能伴随 “噪声”, 从而影响其可信度和有效度 ⸺ 正当你听着收音机, 欣赏那美妙动人的音乐的时候, 突然喇叭里发出吱吱叽叽的怪音, 你一定感到讨厌极了, 因为它无法使你欣赏优美的乐曲. 我们知道, 这就是噪声, 在信息 (乐曲) 传播的过程中, 噪声模糊了信息, 信息的利用率就降低了. 不用说, 噪声越小, 信息就清晰, 被人们利用的效果就越好. 其实, 我们交谈、写文章、作报告也都是信息传播的过程. 如果我们有信息的观念, 就会着力把多余的客套话、“话搭头”、不必要的重复减少到最低限度, 因为这些都是信息传播过程中的 “噪声”. 冗长的报告, 哪怕是要传给听众的信息很重要, 但淹没在大量的 “噪声” 中, 听众只想早点摆脱这个报告, 其中的信息听而无闻, 这样的信息传播效果是很低的. 所以, 我们要向别人表达意思的时候, 一定要再三躬身自问: “噪声” 减到最小了吗? 但是, 我们又看到, 社会生活中有时不免会有必要的 “噪声”, 例如, 为了礼貌, 在讲一番话时, 得客气几句; 对长辈或陌生人, 说话要适当拐一个弯, 等等. 确实, 这是社会生活中不同于单纯自然科学信息传播过程的地方. 不过, 尽管这些 “噪声” 有时是必要的, 但它们往往也会模糊真正的意思. 譬如说, 我们做了一件错事, 同志们为了照顾我们的面子, 在批评的实质性话中, 加了很多委婉的语句. 这时, 如果我们一不在意, 就听不出同志们的批评意思, 不能引起对问题的重视. 反过来, 如果我们有一点 “信息和噪声” 的概念, 就会自觉地在客气话的 “噪声” 中接收到十分有价值的 “信息” ⸺ 同志们批评的真正意思. 回到我们一开始举的例子, 如何用最精确、最小失真、最小噪声的信息来显示周围一切, 来与人们进行沟通, 成为现代人突出的基本能力. 你能顺着这一思路, 而举一反三吗? 《创造性与潜意识》笔记 作者: (日) 马场谦一等编著 译者: 李守田、姜在录 译本出版商: 延边教育出版社 书号: 统一书号 2092·1, ISBN 7-80509-259-1/B·1 版次: 1987 年 9 月第 1 版 特殊名词: 情结 (complex): 精神分析学用语. 指被压抑而未上升为意识的, 被强烈情绪歪曲的观念群和记忆群. (P47) 如奥狄普斯情结 (Oedlipuscomplex), 奥狄普斯是希腊神话中的底比斯王子, 曾解过金字塔前斯芬克斯的迷. 后来误杀父亲并娶母亲为妻, 发觉后自刺双目, 流浪而死. 泛指男孩对父亲不怀好意而亲近作为异性的母亲这种潜意识的情结. (P56) 异化: 心理学用语. 使差异显著的两个对象相接近, 以求差异更加突出. (P89) 净化 (katharsis): 精神分析学用语. 把被压抑而停留在潜意识状态的情结导出, 究明其原因并使症状消失的治疗技术. (P89) 虐待淫乱症 (sadism)、受虐待淫乱症 (massochlsm): 给异性以痛苦来满足性欲的异常性欲和接受异性给予的肉体或精神上的痛苦来得到满足的异常性欲. (P53) 口唇期: 根据精神分析学理论划分的性本能发展阶段之一, 人的性本能的第一个阶段 (出生后一年左右), 认为这个时期人的性快感的中心部位在口唇. (P112) 肛门期: 根据精神分析学理论划分的性本能发展阶段之一, 是处在口唇期之后的第二阶段 (约一至三、四岁), 是靠刺激肛门性感带有感觉性快感的时期. (P53) 里比多 (libido): 精神分析学上指从潜意识的深层发出的欲求. (P90) 相貌性体验: 自我与周围世界未分化的一种体验. (P18) 超我 (superego): 弗洛伊德的用语. 由罪恶感、良心的责备表示的处罚性机能 (潜意识的良心) 和用确定理想、价值观, 来维护自己, 褒奖自己的自我理想构成. (P9) 亚尼莫斯象 (animus): 在女性中被压抑而具有潜在的男性特征. (P6) 亚尼玛象 (anima): 在男性中被压抑而具有潜在的女性特征. (P5) 反动: 指潜意识中的强烈愿望, 在行动上却表现为相反的倾向的现象, 如对性的强烈关心, 在行动上表现为对性的藐视等现象. 判断中止 (epokhe): 在古代哲学中指中止判断. 摘录: 精神病和创造性::精神医学与文化价值::精神病 (津本一郎): 病迹学取得作为一门学问的资格, 的确经历了一段长期艰难的历史行程. 创造者个人的人格价值, 理所当然地是从那个社会的文化价值的本身打下的基础. 社会的文化价值与创造这个价值的创造者个人的人格价值, 有着密不可分的关系. “两者的关系并不是两种类别的不同价值, 而是对同一价值从两个侧面进行解释这样一种关系”. 这样, 作为人格倾向的关于创造性的本质的学问, 就是从把实现文化价值看成个性的发现的角度, 遵照这个个性所属的文化价值的规范, 来全面描述一个人的人格倾向, 即个人的经验的事实. 这里所说的创造性, 就是根据文化科学的方法论规定的价值的肯定性概念. 但是, 精神病与创造性完全不同, 它是从另一个角度出发来研究对象的. 从广义上讲, 精神病有心因性精神病、外因性精神病和内因性精神病的区别. 其中心因性精神病一般被认为是特异性质的, 因此, 在我们的讨论中暂把后两种当作精神病来研究. 同精神病打交道的精神医学, 乃是一般医学中的一个特殊部门. 一般医学是把各个异质的个体看做反复多次的、独立的媒体, 从中发现统一这些个体的一般规律的科学, 即发现疾病的学问. 因而它理所当然地属于自然科学范畴. 所以一般医学上的疾病, 本来就是非个性的, 没有普遍价值的概念. 精神医学是一般医学的一个特殊部门, 属于自然科学. 它的方法论也是把各个异质的个体, 看作能够反复多次的同质的对象, 从中发现这些个体的一般规律. 精神病也和其他一般医学的疾病一样, 本来是非个性的、没有普遍价值的概念. 不过, 一个麻烦的问题是, 一般医学上疾病的概念并不完全适用于精神病. 矛盾律 就是说, 谁都可以看得出某个人精神有异常表现, 但是, 如果不能确认其相应的身体变化, 便不能立即断定是一种疾病. 因为单凭精神变化, 确认作为一般性的疾病是非常困难的. 遇到这种情况, 就需以各个时代文化的、精神科学的特殊领域的价值规范为基准, 来确定是不是疾病; 而且要以有没有对社会的非协调性和文化的劣等性为判定的依据. 因此, 某个人格的同一个精神病理学变化, 在某一个社会可能被看作精神病; 某一个被认为是疾病, 而另一个不是. 诸如此类的情况有很多. 正因为如此, 不管人们意识到还是没有意识到, 现在我们这个社会的精神医学的疾病观, 确实是在生物学上的劣等者就是文化上的劣等者这样一个价值观的基础上形成的. 我认为这样说并不过分. 既然如此, 如果遵循现在的精神医学的理念, 对精神病与创造性的内在联系进行探讨, 无论我们付出多大的精力, 我们所能得出的只能是文化价值的创造者是没有资格创造价值的, 从而否定价值的存在这样一个似是而非的结论. 病迹学的历史, 事实上就是为回避在其中内在的价值肯定性和否定性的自相矛盾而奋斗的历史. 精神病和创造性::精神医学与文化价值::新的视野: 今天, 几乎所有精神医学家都否认精神上患病这件事本身就等于创造文化价值这样一个观点. 实际上, 他们很早就放弃了病迹学本来的课题, 把研究的方向转移到精神病怎样使创造物的表现变形的问题上. 这是不是说精神病绝不可能创造什么东西呢? 那也不一定. 正如我们已经讨论过的, 从前古典的病迹学最大的错误在于: 它从来就未敢越出依据精神病者就是文化价值劣等的也是生物学上的劣等者这样一个基本理念形成的体系的范畴一步. 作为病迹学研究对象的精神病者, 尽管在生物学上处于劣等状态, 但是这种人终究非成为文化价值上的优等者不可. 现在对我们来讲, 有必要放弃把精神病理学的现象只看成变态这一偏见, 而要把这些现象看成人的自然的精神现象, 即要采取某种现象学上的判断中止态度. 要放弃向来的精神医学的理念, 同时确立其本身包含客观上合理的价值的精神病理念, 从而早日从矛盾的价值观解脱出来, 以开扩精神病理学的视野, 这就是赋予病迹学极为迫切的研究任务. 等价变换创造理论的全貌 (市川龟久弥) 开头: 等价变换理论同长期以来文学表现手法上的关于隐喻 (metaphor) 的构成技巧这一难题也有直接关系. 使晚年的歌德垂泪的一首诗: 一八三一年八月二十七日正是歌德刚写完诗剧《浮士德》, 迎接他八十二寿辰的前一天. 这一天, 他在年轻时曾经都留过的科齐尔汉的山道上驾着马车, 到了他要专程来看的那幢房子. 他不等陪同前来的人的搀扶, 自己就爬上了楼梯, 急忙走向窗边, 聚精会神地看着一个墙角. 那里居然有用铅笔写下来的他仍然记得的那一首诗. 他认出了写那一首诗的日期 ⸺ 一七六〇年九月十七日, 和自己年轻时的署名. 这是一首题为《游人的夜晚之歌》的八行诗. 然而, 如今的歌德重读自己这首诗时, 再也不能抑制盈眶的泪水. 据传. 当时他把视线调转到附近的森林, 手里拿着手帕, 沉默不语. “群峰, 已有睡意. 树梢上, 微风一丝不起. 静悄悄, 林中鸟儿不啼. 等一会儿, 你也该休息.” 这个插曲的出处虽然不很清楚, 但以上所引却是原同志社大学校长住谷悦治的小册子介绍的要点. 根据他的解释, 此时此刻的歌德可能正处于一种即将来临的 “不在乎自己死亡的心境”. 以 “等一会儿, 你也该休息” 为结语的这一首诗, 是如何包含了容忍他自己的心理过程这一点, 还是要进一步讨论的. 简单地看《旅人的夜晚之歌》, 只不过是一个年轻的文学青年, 在一个夏天夜里的山上, 以随笔的形式轻松挥笔写下来的自然景物. 但是从另一个角度看, 这一首诗仿佛表现了这样的情景: 在阳光灿烂的仲夏, 林中鸟儿叽叽喳喳, 远处雷电闪现的充满着生气的一天已经过去, 寂静的夜晚已经来临, 而在暗淡的灯光下只有他一个人独自徘徊. 这一首诗如实地表现了是该入睡了这样一个旅人的心境. 回首过去, 从几十岁开始进入创作活动以来, 历经炽热的恋爱, 无数的慕名者和不断应付杂事的歌德, 写完《浮士德》以后, 忽然醒悟自己作为人间的游人. 在这个尘世间已经度过了八十二个春秋. 结束了仲夏充满喧嚣和生气的一天, 游人自然想在山上的住处安静地进入梦乡, 游人的这种心情与上面说的歌德的心境之间, 当然没有事先的沟通, 但却存在着本质上的同一性, 也就是下边还要讨论的等价性. 这是完全可以用 “终末观” 一词来概括的一种现象: 虽然人类处在不断流动的历史长河之中, 担任何人都不能逃避对普遍原理的再确认. 正是在这个普遍原理里面隐藏着以接受信息的人的心理的、生活的条件, 从而在意义信息世界里再发现与之对应的世界. 这就是下面所说的隐喻的基本原理. 《方丈记》和《徒然草》里的隐喻 在日本中世纪的文学史上有两位伟大的散文家, 他们是写《方丈记》的鸭长明和写《徒然草》的卜部兼好. 由于作者本人出身属于上层社会, 这些作品的内容都是以作者很高的文化教养作为基础的, 再由于作者本人都是站在出家的和尚和遁世文人的立场, 能把本身的利害得失置之度外, 因而他们心底透明, 思想敏锐, 见识高超, 终于写出了这样不朽的作品. 他们不愧是中世纪的伟大思想家. 然而, 在文学表现的世界里, 作者的某一种见地并不等于是作品的深度. 如果卓越的见地不同适当的题材相结合, 不与传递意义信息的技巧世界恰当地再构成 (表现), 也就不会有什么深刻意义. 正因为如此, 在这个富有意义信息的世界里, 作家负有用隐喻作为表达技巧的使命. 以下根据笔者一九七九年在福井大学召开的日本英文学总会上所作的 “特别讲演” 所提出的论点进行研究. “河水长流不息, 流水不再返回. 漩涡里的泡沫边结聚边消失, 无法留住. 人生世上亦如此.” 人们都会明白, 这是《方丈记》的一节. 虽然只是这么几句话, 如果仔细一想就会明白, 这个概括了中世纪日本社会哲人的人生观, 即带有冷酷意味的 “万物流转” 思想, 毫无疑问对任何一个人都会留下深刻印象. 河水确实是在那里, 可是在那流着的水, 一刻也不再停在同一个地方; 在漩涡上漂浮着的泡沫, 也不会长久留在原处.《方丈记》的作者就是这样断言的. 根据笔者给予定义的等价变换理论, 这是相当于意义信息传达过程的第一阶段中单纯明确的 “思维模型” 的提出一环.《方丈记》的作者, 从这个人人皆知的思维模型里抽出必要而又充分的本质, 提出这个本质与贯串于人生的那个道理是完全同一的 (等价的) 这一新的命题. 从信息接受者的角度看, 这个事实确实要使人从内心涌现出 “蛮有理呀” 这样一种共鸣感. “镜子没有颜色, 也没有影子, 但它可以映出世间万物. 如果它有颜色和影子, 就定然不会映出任何一种东西” 这是《徒然草》第二百三十五段中的一节. 按照前一个例子的方法进行分析, 这一段所涉及的单纯明确的思维模型是不言自明的, 因为它是映照人们脸面的常见的用品之一. 作者先对镜子的功能做了简短说明, 然后告诉人们这样一个道理: 如果一个人有一定的框框、私欲和偏见就不会对人生的意义有深刻的理解和认识. 特别是这段文章最后的结论完全是依靠对对方的主观判断. 这是一个在传达意义的技巧上很好地达到了等价变换理论所说的 “再发现性对应的模型” 的典型例子, 它可以使读者引起强烈感受, 达到较高的认识水准. 以上意义上的等价变换理论的展开, 当然是以弗洛伊德和荣格式的深层心理的世界为出发点的, 是使人预感也可能有深层心理世界的促动因素浮在意识的世界而才生产出作品这样一种情况. 汤川秀树在与笔者合著的《天才的世界》一书里引用过石田六郎的文章, 其中指出的石田对石川琢木的 “在东海小岛的白沙滩上, 我悲叹与螃蟹为伍” 一句的分析, 可以说是一个有代表性的例子. 可以肯定的说, 思维模型的提示, 不管是否在显在意识的世界, 而对对方来讲, 非要具有单纯明确的内容和相当熟悉的对象不可. 我们在前面提到过《游人的夜晚之歌》这一插曲, 其中思维模式就是歌德年轻时自作的那一首诗. 歌德以蕴含在那首八行诗里的等价性为线索, 成功地再发现如同自己过去一夜之眠那样, 轻松地迎接今天到来的人生的终了的心境. 悟到这一点之后, 老歌德绝望的轻松感, 恐怕就要表现在用眼泪把洁白的手帕沾湿这一细微的动作上. 我们这样讲并不算过分. 作为创造理论的等价变换理论: 在本章开头我们已经提到, 笔者在过去四十年来一直在寻找创造理论体系化的途径, 结果感觉到, 从较低的发展阶段再向下一个发展阶段完成次元交换, 就是创造性逻辑的根基. 用一句话概括: 历史发展的逻辑不外乎是等价变换再构成的理论. 再具体一点说, 就是 “以特定的事物和现象为前提, 从中抽出对下一个发展阶段可以成为遗产的东西 (本质), 再在此基础上导入成为新的发展阶段的要素的东西, 并为使两者具有整体性构造而进行再构成作业”. 黑格尔哲学定义中的扬弃这一概念, 也许可以说是摸索到这样一点轮廓的一个概念. 无论如何, 在上述 “抽出作业” 中, 应该成为遗产的本质要素的当然是前后发展阶段都共同具有的有存在价值的东西. 换句话说, 以一定的观点规定的同一性作为思维媒介的等价变换理论, 可以把它用 “等价次元” 一词来概括. 把从不同的对象中寻找这个等价次元的作业, 称之为 “发现等价关系”, 而把使这个作业可能成功的前提条件, 叫做 “等价性” 的存在. 这不仅仅是意义信息的创造性传达作业, 而且是发明、发现等创造性活动的核心部分. 如果以上述的等价性和等价次元的抽出为线索, 把现阶段的事物向下一阶段变换再构成, 那么一定就会出现良好的结果. 概括以上所叙述的历史发展的基本逻辑, 并以符号来概括表现出的, 就是图 1 所列的等价方程式的实质. \\[ \\textbf{\\small 图 1. 等价方程式} \\\\ \\boxed{ \\begin{array}{c} \\begin{array}{ccc} \\underset{\\bm{\\uparrow}}{\\varSigma S_{ca-i}} & & \\\\ A\\omicron & \\stackrel{c\\varepsilon}{=} & B\\tau \\\\ vi\\bm{\\rarr} & & \\stackrel{\\bm{\\uparrow}}{\\varSigma S_{cb-i}} \\end{array} \\\\ \\footnotesize \\begin{array}{l} \\text{$o$: 占 $A$ 事实、现象的座的系 (原系或出发点) \\char\"2E3A $o$ 系} \\\\ \\text{$\\tau$: 占 $B$ 事实、现象的座的系 (变换系或到达系) \\char\"2E3A $\\tau$ 系} \\\\ \\text{$A$: 在原系 $o$ 上出现的事实、现象} \\\\ \\text{$B$: 在变换系 $\\tau$ 上出现的事实、现象或靠 $c\\varepsilon$ 的媒介在 $\\tau$ 系上再构成的事实、现象} \\\\ \\text{$\\varepsilon$: 使方程式的两边可能用等号结合的等价次元} \\\\ \\text{$c$: 具体地定义上述等价次元的限定条件 (但原则上是复数 ($\\varSigma\\leqslant i$))} \\\\ \\text{$\\varSigma S_{ca-i}$: $o$ 系的特殊化了的条件群, 简略写 $\\varSigma a$} \\\\ \\text{$\\varSigma S_{cb-i}$: $\\tau$ 系的特殊化了的条件群, 简略写 $\\varSigma b$} \\\\ \\text{$vi$: 任意观点之一} \\\\ \\text{$\\bm{\\rarr}$: 指示展开方向} \\end{array} \\end{array}} \\] 对于研究人文系统学科的诸位来讲, 这个方程式也许是一个令人看不惯的异次元世界的闯入物. 然而把以上分析的创造理论的核心部分, 最大限度地加以压缩而成为 “逻辑公式” 的就是这个方程式. 方程式左边的符号, 就隐喻的情况而言, 相当于单纯明确的思维模型 (以 \\(Ao\\) 表示). 当然, 这是靠作者的深思熟虑选定的, 是表现意义的核心部分, 在前面引用的《方丈记》里的 “河水长流不息” 和《徒然草》第二百三十五段所讲的 “镜子” 都相当于这一点. 这两部书中写的 “流水不再返回”, “如果它有颜色和影子” 等有关人生的变迁的内容, 是相当于去掉各种夹杂物, 巧妙地抽出与表现目的相一致的事物的本质 (再方程式中 \\(c\\varepsilon\\)) 的思维过程. 然后拿出表现得最终目的, 也就是把作者想主张的关于人生问题的个别信息 (在方程式中 \\(\\varSigma b\\)), 同前者相结合即可 (在方程式中, 再构成 \\(B\\tau\\)) 那么, 这个作业第一阶段的 “思维模型” 是怎样找到的呢? 这与向接收信息的对方传达什么样的意义信息有关, 也就是与作品的内容有关. 假如表现的最终目的如象上面《方丈记》引文那样, 是 “万物流转的厌世主义”, 那么只要找出含有与这个本质等价的内容 (有等价性的)的、单纯明确的人生中的实际事情即可. 这就是使作者采用 “河水长流” 这个题材的原因. 上面提到的日本中世纪文学史中的两个人, 绝不是在贫困潦倒的生活中随心所欲地拾起河流或镜子当作作品的题材的, 相反, 他们有强烈的表达愿望, 而且根据这个愿望从身边的一般生活题材中, 发现并洞察了与作品主题的本质等价的东西. 如果不理解这个原理, 那么, 从内容上来区别单纯记述身边风物的杂文或是真正的随笔文学, 是根本不可能的. 根据以上议论, 可见隐喻的世界的创造性活动的本质就是: (1) 按照表现目的, 发现对社会有价值的主题; (2) 选择含有与这个主题内容相符合的等价性的单纯明确的思维模型 (题材); (3) 以这个思维模型为出发点, 根据表现目的, 再以文字形式进行等价变换再构成. 在以上的分析当中, 为了说明的方便起见, 我举出了谁都可以理解的象征诗体思维模型的实例, 其实写实诗体的表现方法跟它也没有什么不同. 在前一种情况下, 可以从作品的主题所统摄的材料的外部寻找含有等价性的模型; 而在后一种情况下, 就要从主题所统摄的材料的内部寻找含有等价性的模型. 在隐喻和等价变换理论方面, 和笔者持有同样观点的有福井大学文学院芝原宏治. 这可参看他的《修辞学》一书. 等价变换理论概观 等价变换理论作为历史发展的逻辑, 既然具有它的理论体系, 当然也适用于其他一切创造性活动的领域. 同样的创造性活动的原则, 也应当适用于科学上的发明与发现. 例如一九四八年肖克利 (W·Shockley) 等人的晶体管的发明和一九〇五年爱因斯坦特殊相对论的发现. 如果让笔者简单给以说明, 那么, 前一个发明的思维模型是矿石检波器的作用, 而后一个发现的思维模型则是马克斯韦尔电磁力学的整体像. 它们的变换再构成, 在前者的情况下是达成不必放出热电子的、新的电增幅素子; 而在后者的情况下, 是达成不需要作为光的弹性媒体的以太 (ether) 假说的统一的电磁力学. 与生物学上的进化有关的创造性课题, 从等价变换理论的观点看, 也具有绝不比上述例证逊色的戏剧性内容. 关于这一点, 可以用达尔文学派的形态学家赫克尔 (E·H·H·aeckl) 提出的那个著名的 “反复论” 为前提予以概括说明, 这样就更便于理解. 赫克尔认为 “生物个体在一代生长过程中的形态变迁史, 总是极大地反复着伴随该物种进化过程的形态变迁史”. 例如完全变态的昆虫的形态 (即幼虫 \\(\\rarr\\) 蛹 \\(\\rarr\\) 成虫), 大体上反映了该昆虫在进化历程上的形态变迁史. 如图2(a)表示, 发育至终点的成虫, 作为幼虫体的等价变换再构成, 是创造性地出现的东西. 它是经过调节荷尔蒙的过程而实现的, 其大体经过, 看图2(b)就会更加明白. 以上举出的是完全变态这一特殊的个体发展的例子, 如果把上述的逻辑再加细分, 那么对于那些不完全变态的生物的个体的发展 (其中包括着哺乳类), 上述原则也基本上是适用的. 如果进一步把以上原则的适用范围加以扩大, 那么, 在前面提过的社会体系史自不必说, 连我们人的人格形成史即教育的本质论和方法论问题也都可以提到眼前来. 这个领域当然与直观的逻辑构造等也有联系. 我们还是把讨论集中到精神疗法的领域. 自弗洛伊德以来的所谓深层心理方法, 一般来说就是使过去没有自觉到的心理因素在显在意识的世界得到呈现, 并在此基础上重新形成患者的人格. 这个方法论是值得重视的. 这个方法从等价变换理论的角度看, 是相当于把属于一个人格的精神史的统一构造追溯到某一个历史阶段, 并把它加以分解, 再把这个精神史引向将来进行变换再构成的作业. 只少可以讲, 这是靠溶解自闭的、假性的 “蛹期状况”, 实行人格蜕变的作业的过程. 一九四二年罗杰斯 (C·R·Rogers) 采用过所谓 “非直接法” (non-directism), 它的基本内容是 “人格的形成过程本身就是治疗”. 很明显, 这一想法与等价变换创造理论的想法有很多一致之处. 这种治疗活动的实质, 就是要帮助患者提高人的自我洞察能力和感受能力, 而这种方法论的根据, 当然是要追溯到患者前一阶段心理上的某一点, 从中找出可继承的东西. 这正是等价变换创造理论所说的, 创造性地继承一个人物人格中的等价性. 《人体生物钟自测》摘录 什么是人体生物钟? 大量的研究调查发现, 人的情绪、智力、体力都各自存在一种周期性的变化, 并有一定的规律可循. 后来有人把这三种节律组合成体力 ⸺ 情绪 ⸺ 智力三节律, 用正弦波绘出了它们的图像. 人们把这三种节律简称为人体生物钟. 生物钟的种类: 恒生物钟与似稳生物钟 恒生物钟是指节律周期恒定不变的生物钟. 例如, 我国东海滩, 有一种小蟹, 雄的有一只大螯的出现, 意味着要涨潮, 渔民叫它们 “招潮”. 在不同的时间里, 招潮蟹身体颜色亮暗的程度不同, 正好与潮落潮涨相反. 它的体色最暗的时间也是每天后移 50 分钟. 因此, 人们把与潮汐相应的生物钟, 叫做 “潮汐钟”. 它的周期是 24 小时又 50 分钟. 而似稳生物钟则是指周期围绕某时间值变化的生物钟. 如人的情绪为 28 天, 智力为 33 天, 体力为 23 天. 这种生物钟节律, 最明显的要算妇女的月经周期了. 多数妇女的月经周期是 28 天, 但有些妇女则可能为 28 天左右, 总围绕着 28 天这一时间值. 跟自然变化相关的生物钟 本书所说的自然变化, 指地球的自转、月亮的望朔, 地球绕太阳的公转而出现的昼夜、月和年的周期变化. (1) 超日钟 它是指节律比昼夜短的生物钟. 如人的心跳周期、呼吸周期等, 可用分或秒做描述单位. (2) 太阳日钟 指跟地球自转周期相等的生物钟, 它的周期是 24 小时. 国外科学家曾把人体 24 小时里的各种变化做过分析: 凌晨 1 时, 大多数人已睡了三小时, 进入易醒的浅睡阶段, 对疼痛特别敏感. 2 时, 除肝外, 体内的大部分器官工作节律极慢. 3 时, 全身各部分几乎都在休息, 肌肉完全放松. 此时, 血压较低, 脉搏次数相当少. 4 时, 血压最低, 脑部供血量最少. 不少心血管病人在这个钟点死亡, 全身器官工作节律极慢, 但听觉却很灵, 稍有响动就会醒. 5 时, 肾不分泌. 6 时, 血压回升, 心跳加快. 7 时, 人体的免疫功能特别强. 8 时, 肝内的有害物质全部排尽, 对酒精的敏感性特别高. 9 时, 精神活性提高, 痛感降低, 心脏开足马力工作. 10 时, 精力充沛, 处于最佳工作状态. 11 时, 心脏的工作仍在高潮期, 其他各种器官也处于高潮期, 人体不易感觉疲劳. 12 时, 全身各器官仍处在较好的工作状态. 13 时, 肝脏休息, 部分糖分进入血液, 身体各器官的工作能力渐趋疲倦, 需要休息. 14 时, 身体各器官功能达到低潮, 大脑迟钝, 反应很慢. 15 时, 人体各种器官功能好转, 尤以嗅觉和味觉最是灵敏. 16 时, 人血液中的糖分增加. 17 时, 大脑灵活, 机体灵敏. 18 时, 痛感下降, 机体 “希望” 增加活动量. 神经活动降低. 19 时, 血压增至一天中的最高值, 精神最不稳定. 20 时, 集体反应异常迅速, 体重最大. 21 时, 神经活动正常, 大脑记忆细胞最兴奋. 22 时, 血液中白细胞达一日中的密度最大值, 每立方厘米由 5000 到 8000 增加到 12000. 体温下降. 23 时, 人体准备休息, 继续做恢复细胞工作. 24 时, 机体达昼夜中的低潮期. 从以上的分析可以得知, 人在一天时间里的生理机能的变化: 7 时到 10 时机能上升, 达一天中第一个峰值后缓慢下降, 16 时左右较平坦, 但是白天里最低的, 17 时后机能再度上升, 23 时后又急剧下降, 凌晨 3、4 时人体机能达到一昼夜中的最低潮. (3) 自激钟与近昼夜钟 科学家们在研究生物节律中发现: 如果把许多种动物从正常的昼夜环境中放到相同的温度和连续光照下生活几周, 它们的睡眠时间和活动时间仍然同实验外的正常昼夜变化的节律几乎完全一样, 动物在实验室内的连续光照和恒温条件下所保持的节律, 称之为 “自激” 节律, 他们体内的这种钟叫 “自激钟”. 而近昼夜节律则是会随条件的变化使间隔逐渐缩短, 最短只有 18 小时, 最长可达 28 小时. 通过实验证明, 人体也同样存在近昼夜节律. (4) 朔望月节律 它是指周期等于一个朔望月 (29.5 天) 的生物钟. 许多生物都按照此节律活动. 例如, 下弦月时鳗鱼在挪威北海大量出现; 夏季月圆时, 西洋萤火虫大量聚集在百慕大群岛附近. 对人来说, 人的眼睛在朔日对红光和橙光最敏感. (5) 近月钟 它是指周期接近一个朔望月的生物钟. 这种生物钟对人类的行为影响较大. 由于恒星月周期是 27.33 天, 朔望月周期是 29.5 天, 太阳黑子的周期是 27 天, 宇宙电磁对地球的作用也是 27 天. 这些引力和电磁力对人类长期的作用, 人体内各种因子的与之协同, 加上人类独有的高度智能和丰富的情感, 形成了人体的有智力、情绪、体力的近月周期变化. 人的近月生物性, 包括体力钟、情绪钟和智力钟, 组合在一起叫 &quot;人体三节律. 人体三节律还具有这样的特点: 人类独有, 出生起算, 用途很广. 生物钟给人们带来什么 处于高潮期的生理效应 当一个人的体力处于高潮期时, 其体力充沛、朝气十足, 且意志坚强并富于耐力. 当人的情绪处于高潮期时, 感情丰富、精神愉快, 心情舒畅, 觉得诸事如意, 有丰富的创造力和很强的艺术感染力. 当智力处于高潮期时, 人的头脑思维敏捷、记忆力强、信息传递快, 有较好的思维推理和逻辑判断能力. 处于低潮期的生理效应 当体力处于低潮期时, 体乏力虚、身体怠动. 当情绪处于低潮期时, 会感到烦躁或烦闷, 精神恍惚. 当智力处于低潮期时, 会感到反应迟钝, 记忆力差, 没有灵感. 处于临界期的生理效应 在临界期内, 人体细胞的各种机能变化较复杂, 起伏也较大. 当体力处于临界期时, 体内的抵抗力不佳, 容易患病. 当情绪处于临界期时, 精神不易集中, 易出差错. 当智力处于临界期是, 人的判断力差. 对人来说, 最不安全的时刻是临界日和低谷日. 怎样计算人体三节律 求出生日至计算日的总天数 周年天数的计算 例如, 求某人 1970 年 5 月 25 日 (出生日) 至 1971 年 5 月 25 日 (计算日) 的天数. \\(\\begin{aligned} \\text{\\footnotesize 计算的天数} &amp; =(\\text{\\footnotesize 计算年号$-$出生年月})\\times\\text{\\footnotesize 平年天数} \\\\ &amp; =(1971-1970)\\times 365=365 \\text{\\footnotesize(天)}\\end{aligned}\\) 超出周年天数的计算 例如: 求某人 1970 年 5 月 25 日 (出生日) 至 1971 年 7 月 25 日 (计算日) 的天数. 周年部分同上. \\(\\begin{aligned} \\text{\\footnotesize 超出周年的天数} &amp; =\\text{\\footnotesize 计算月、日$-$出生月、日} \\\\ &amp; = \\text{\\footnotesize 7 月 25 日$-$5 月 25 日$=61$ (天)}\\end{aligned} \\\\ \\text{\\footnotesize 实际计算日的天数$=365+61=426$ (天)}\\) 不足周年天数的计算 例如: 求某人 1970 年 5 月 25 日 (出生日) 至 1971 年 5 月 20 日 (计算日) 的天数. \\(\\begin{aligned} \\text{\\footnotesize 不足的天数} &amp;=\\text{\\footnotesize 出生月、日$-$计算月、日} \\\\ &amp;= \\text{\\footnotesize 5 月 25 日$-$5 月 20 日$=5$ (天)}\\end{aligned} \\\\ \\text{\\footnotesize 实际计算日的天数$=365-5=360$ (天)}\\) 闰年有效天数的计算 为了求闰年有效天数, 可分三步: 第一, 先粗略判断闰年年号; 第二, 核实; 第三, 查找对比计算对象是否渡过. 另外也可通过查表 (见表 5) 的方法来确认. 如计算者已渡过此日, 可在计算的天数上增加所跨过的闰年的天数. 例如: 求某人 1970 年 5 月 25 日 (出生日) 至 1990 年 5 月 25 日中所经过的闰年天数. 通过查表得此天经过的闰年天数 5 天. ※: 当年号的十位数及个位数均为零时, 该年是否为闰年, 凡年号能被 400 整除时为闰年, 不能被 400 整除则不是闰年. 由于人从出生起他的生命节律就开始运行, 体力钟以 23 天 为一个周期, 中间为临界, 横轴以上为高潮, 以下为低潮期. 同理, 情绪为 28 天, 智力钟为 33 天. 由于三节律的运行轨迹也不同. 人们为了了解所需日子的三节律情况, 可以通过各种计算方法获取. 这里给出三个节律的简单函数 (可以用 GeoGebra 查看): 体力: \\(f(x)=3\\sin(\\frac{2\\pi}{23}x)\\) 情绪: \\(g(x)=2\\sin(\\frac{2\\pi}{28}x)\\) 智力: \\(h(x)=\\sin(\\frac{2\\pi}{33}x)\\) 这里放一张本人第 8155 天 (22 岁 119 天) 时的三节律情况: The World of English 我所知道的康桥 徐志摩 康桥的灵性全在一条河上; 康河, 我敢说, 是全世界最秀丽的一条水. 河的名字是葛兰大 (Granta), 也有叫康河 (River Cam) 的, 许有上下流的区别, 我不甚清楚. 河身多的是曲折, 上游是有名的拜伦谭 (“Byron’s pool”), 当年拜伦常在那里玩的; 有一个老村子叫格兰骞斯德, 有一个果园, 你可以躺在累累的桃李树荫下吃茶, 花果会掉入你的茶杯, 小雀子会到你桌上来啄食, 那真是别有一番天地. 这是上游; 下游是从骞斯德顿下去, 河面展开, 那是春夏间竟舟的场所. 上下河分界处有一个坝筑, 水流急的很, 在星光下听水声, 听近村晚钟声, 听河畔倦牛刍草声, 是我康桥经验中最神秘的一种: 大自然的优美, 宁静, 调谐在这星光与波光的默契中不期然的淹入了你的性灵. 但康河的精华是在它的中杈著名的 “Backs”, 这两岸是几个最蜚声的学院的建筑. 从上面下来是 Pembroke, St. Katherine’s, King’s, Clare, Trinity, St. John’s, 最令人留连的一节是克莱亚与王家学院的毗连处, 克莱亚的秀丽紧邻着王家教堂 (King’s Chapel) 的闳伟. 别的地方尽有更美更庄严的建筑, 例如巴黎赛因河的罗浮宫一带, 威尼斯的利阿尔多大桥的两岸, 翡冷翠维基鸟大桥的周遭; 但康桥的 “Backs” 自有它的特长, 这不容易用一二个状词来概括, 它那脱尽尘埃气的一种清激秀逸的意境可以说是超出了画图而化生了音乐的神味. 再没有比这一群建筑更调谐更匀称的了! 论画, 可比的许只有柯罗 (Corot) 的田野; 论音乐, 可比的许只有萧班 (Chopin) 的夜曲. 就这也不能给你依稀的印象, 它给你的美感简直是神灵性的一种. 假如你站在王家学院桥边的那颗大椈树荫下眺望, 右侧面, 隔着一大方浅草坪, 是我们的校友居 (Fellows Building), 那年代并不早, 但它的妩媚也是不可掩的, 它那苍白的石壁上春夏间满缀着艳色的蔷薇在和风中摇头. 更移左是那教堂, 森林似的尖阁不可浼的永远直指着天空; 更左是克莱亚, 阿! 那不可信的玲珑的方庭, 谁说这不是圣克莱亚 (St. Clare) 的化身, 哪一块石上不闪耀着她当年圣洁的精神? 在克莱亚后背隐约可辨的是康桥最华贵最骄纵的三清学院 (Trinity), 它那临河的图书楼上坐镇着拜伦神采惊人的雕像. 但这时你的主意早已叫克莱亚的三环洞桥魔术似的摄住. 你见过西湖白堤上的西冷断桥不是 (可怜它们早已叫代表近代丑恶精神的汽车公司给踩平了, 现在它们跟着苍凉的雷峰永远辞别了人间)? 你忘不了那桥上斑驳的苍苔, 木栅的古色, 与那桥拱下泄露的湖光与山色不是? 克莱亚并没有那样体面的衬托, 它也不比庐山栖贤寺旁的观音桥, 上瞰五老奇峰, 下临深潭与飞瀑; 它只是祛怜怜的一座三环洞的小桥,它那桥洞间也只掩映着细纹的波鳞与婆娑的树影, 它那桥上栉比的小穿阑与阑节顶上双双的白石球, 也只是春姑子头上不夸张的香草与野花一类的装饰; 但你凝神的看着, 更凝神的看着, 你再反省你的心境. 看还有一丝屑的俗念沾滞不? 只要你审美的本能不曾汨灭时, 这是你的机会实现纯粹美感的神奇! 但你还得选你赏鉴的时辰. 英国的天时与气候是走极端的. 冬天是荒谬的坏. 逢着连绵的雾盲天你一定不迟疑的甘愿进地狱本身去试试; 春天 (英国是几乎没有夏天的) 是更荒谬的可爱, 尤其是它那四五月间最渐暖最艳丽的黄昏, 那才真是寸寸黄金. 在康河边上过一个黄昏是一服灵魂的补剂. 阿! 我那时蜜甜的单独, 那时蜜甜的闲暇. 一晚又一晚的, 只见我出神似的倚在桥阑上向西天凝望: ⸺ 看一回凝静的桥影, 数一数螺细的波纹: 我倚暖了石阑的青苔, 青苔凉透了我的心坎; ⋯⋯ 还有几句更笨重的怎能仿佛那游丝似轻妙的情景: 难忘七月的黄昏, 远树凝寂, 像墨泼的山形, 衬出轻柔暝色, 密稠稠, 七分鹅黄, 三分橘绿, 那妙意只可去梦边缘捕捉; ⋯⋯ Cambridge As I Knew It1 [An Excerpt] Translted fomr the Chinese by Wang Jiao-sheng The very soul of Cambridge is in a river. The River Cam, I dare say, is the most beautiful stream in the world. Its name is Granta, but some call it the River Cam, maybe to indicate, I am not quite clear, the difference between the upper and lower reaches. The river meanders with many bends. The upper reach boasts the famous Byron’s Pool, where the poet used to roam for pleasure. Here lies an ancient village called Glancester, which has an orchard where you can recline sipping tea in the shade of peach and plum trees laden with fruit. You let some of the fruit drop into your cup, and little sparrows would come down to your table to peck something to eat, so that you have the sensation of being in quite another world. This is the upper reach. The lower reach runs from Chesterton down to where the river broadens to afford an ideal spot for boat-racing between spring and summer. A dam separates the two reaches at a point where the current becomes very swift. To listen under starlight to the sound of the water, the chimes of evening bells wafted from a neighbouring village, and worn-out cows grazing at the river’s edge: these are some of my most mysterious experiences at Cambridge. Here the beauty of Nature, its tranquility, its harmony, flood your soul in spite of yourself, with the starlight and the shimmering waves looking on, as it were, in acquiescence. But the essence of the River Cam is in its center, the famous Backs, where the river is lined on either bank with buildings of some of the best-known collages. Going from the upper to the lower end, you pass in succession Pembroke, St. Katherine’s, King’s, Clare, Trinkty, St. John’s. The juncture of Clare and King’s is where you are most tempted to linger: the enchanting gracefulness of Clare being in close vicinity to the grandeur of King’s Chapel. There may be constructions more beautiful and dignified elsewhere, such as the precincts of the Louvre on the river Seine in Paris, the banks of the great Rialto Bridge in Venice, the environs of the ancient Pont Vecchio in Florence. But the Backs of Cambridge has characteristics all its own that defy summing up with a few epithets. Its lucid, delicate artistic conception, free from all mundane polution, may be said to be beyond the bounds of painting, and transformed into the magic flavour of music. There is nothing more harmonious, more symmetrical, than this group of structures. Comparable to it, perhaps, is only Corot’s “Farmland” in painting, and Chopin’s “Nocturne” in music. Yet even these cannot give you an impression quite so ethreal. The sense of beauty in inspires is *nothing short of2 divine. Imageine yourself standing in the shade of that big cedar tree by King’s College bridge and looking into the distance. To your right, beyond a spacious square of new-mown lawn, is our Fellows Building, which, though of no very ancient date, yet possesses a charm that cannot be concealed. Between spring and summer, on its pallid stone walls, roses sway in the soft breeze in a riot of colour. To the left is the Chapel, with its forest of pinnacles perpetually pointing skyward, not to be sullied. Still further left is St. Clare. Ah, that square court of incredibly exquisite workmanship — who can dispute its being the personification of St. Clare herself? And which of its stones but is glittering with her spirit of holy purity in bygone years? Faintly discernible behind Clare is Cambridge’s most magnificent, most prestigious Trinity College, on top of whose library building, overlooking the river, sits on guard the Sculpture of Byron, his features brimming over with astonishing vitality. However, at the moment your attention has been arrested, as by magic, by Clare’s Three-Arched Bridge. You have seen the Breakoff Bridge at Xi Ling on West Lake’s Bai Causeway, (unfortunately it and its like have long since been trampled down by the Bus Companym, representative of the sordidness of all modernity; they have gone the way of the melancholy Lei Feng Pagoda, and taken leave *for good3 of the world of mortals) haven’t you? Surely you cannot forget the mottled green moss on the bridge, the ancient look of its wooden paling, the beautiful tints of lake and hill stealing from under its arches. St. Clare’s bridge is not so daintily set off as all that. Nor is it comparable to the bridge of the Goddess of Mercy nestling against the Temple of the Virtuous on Mount Lushan, commanding a view of the miraculus Five-Old-Men Peak overhead and the deep pools and cascading waterfalls below. It is no more than a diffidant-looking little bridge with its three arches set of by rippled waves and the whirling shadows of trees. The rows of small railing on the bridge and pairs of white stone balls on top of them are but like the unpretentious herbs and wild flowers country girls deck their hair with. But gaze intently, gaze intently again. Then look in retrospect at the mood you are in and see if it is still tainted with a streak of vulgar thought. This is a wonderful occasion for you to capture a sense of sheer beauty if only your instinctive capacity for the appreciation of beauty has not entirely left you. Still you have to choose a moment opportune for such enjoyment. In England the climate and weather go to extremes. In winter it is beastly even to absurdity. After days of blinding mist, surely you would rather wish to have a taste of Hell itself *without further ado4. On the other hand, spring (in England there is almost no summer) is absurdly lovable, especially between the months of April and May when the evenings are at their loveliest as they get warmer and warmer, and every moment becomes golden. It is a veritable tonic for the soul to pass an evening on the bank of the River Cam. Ah! The days I enjoyed being all by myself and having long hours of leisure, sweet with all the sweetness of honey. How evening after evening found me leaning against the balustrade of the bridge, losing myself in reverie as I gazed toward the western sky. Glance at the bridge’s tranquil shadow, Count fine mother-of-pearl on rippling waves; I nestle up to the stone railing to warm the green moss, Warm the green moss till it cools me To the depth of my heart. Other scenes too cumbersome to merit comparison With the airiness of gossamer; A July evening unforgettable, Trees buried in far-off stillness; Shape of hills ink-spalashed Silhouetted5 against the tenderness of dust — Close-woven, seven-tenths goose-yellow, three-tenths orange-green; A subtle charm there’s no recapturing Save at the edge of an autumn dream… ^ 此题有二种译法: (1) Cambridge As I Knew It 一般写作者对过去在剑桥时的回忆. (2) The Cambridge I knew 侧重于写回忆过去, 对比现在的剑桥. 例如可以说: The Cambridge I know was quite difference from the Cambridge of today. 本文写于 1926 年 1 月, 时作者已阔别康桥二年, 康桥即英国的剑桥大学 (Cambridge University). ^ 简直可以说 (nothing 也可用 little). You use nothing short of or little short of to emphasize how great or extreme something is. ^ 永久地. If something changes or disappears for good, it never changes back or comes back as it was before. ^ 干脆. If you do something without further ado or without more ado, you do it at once and do not discuss or delay it any longer. ^ 轮廓. 可做动词或名词. (1) A silhouette is the solid dark shape that you see when someone or something has a bright light or pale background behind them. (2) The silhouette of something is the outline that it has, which often helps you to recognize it. Prof.Lin Xu Prof.Lin Xu As a new ‘SISTor’ in ShanghaiTech, I feel very exciting, proud, and really lucky. Just the same as my dear colleagues who have shared their experiences, I would like to tell you my own story. But my story will be a little different, I believe. I was born in a small village in the south of Sichuan privince, where people were poor, struggling just for food and clothes. I had to stay at home for one year doing nothing before meeting the age requirement of a primary school, just for saving 5 RMB. Although the financial situation was not good, my childhood was very happy, because, as a child, I did not have any awareness about finance, Instead, what I had were plenty of play time, plenty of little fellows, and plenty of game places, e.g., wild fields, small hills, and rivers. Moreover, we did not have any extra course. In this sense, we were much luckier than today’s kids, particularly the Shanghai kids. I stood out soon after I went to the village’s primary school, especially in math. Like most of my dear colleagues, I also had a dream to become a scientist or an engineer, even though I did not know what a scientist and an engineer really did. It turned out in my later life, this dream was too luxury. Anyway, gradually, I became the so called ‘neighbor’s kid’ and also the hope of my family since it seemed possible for me to change my life by education, which was the only way to leave the countryside for kid like me. Fortunately, I made it. In 1996, I graduated from the middle school with top ranking, meeting the entrance requirements of the best high school in my home county as well as the technical secondary school. As Prof.Pingqiang Zhou mentioned in the first issue of the SIS newsletter, in 1980s and early 1990s, graduation from a technical secondary school guaranteed a job from the government or the state-owned enterprises, and it took only 3 or 4 years after middle school. Therefore, a technical secondary school was cost-effective and usually the first choice for most of the best students from the countryside. But, actually, I preferred to go to the high school and then a university to pursue my dream. Unfortunately, I had to give it up and picked a technical secondary school due to family’s financial situation. This was the first time that I was aware of the impact of finance on my life. Four years later, I graduated from the technical secondary school with honors and was offered to be recommended for admission to a university without exams. Once again, I rejected this offer due to the same goddam financial reason, and then accepted the assigned job in a state-owned enterprise. I still remember my first salary, i.e., 304 RMB, with which I started to live on myself and partially shouldered the burden of my family, e.g., supporting my younger sister for her high school expenses. I was just 19 years old at that moment. Kids with this age should have sat in a spacious and bright classroom absorbing all kinds of invaluable knowledge rather than struggling for living. I was just like half-grouted rice which should have enjoyed the warm sunshine and sweet water and grown rapidly, but were harvested too early. Back to my job. It was an ordinary worker rather than a cadre. An ordinary worker and a cadre were the two fundamental markers for employees in a state-owned enterprise. You may have no idea how huge the gap between them was, but just keep in mind, most of the ordinary workers were not able to cross this gap even exhausting the whole efforts of their entire career. Coming from the countryside without any social resource, I did not think God would shed special light on me such that I could cross the gap, although I was almost there six years later. Furthermore, I did not like the tasks of this job. I worked in a heat-treatment workshop. What I did was to put (manually) the metal material, sometimes very large and heavy, into an electric resistance furnace and take them out after a certain period and then chill them with water or special liquid, in order to alter their physical properties. Today, some software engineers describe their work as ‘moving bricks’ with self-deprecating humor. But my work was really ‘moving metal’, seriously. For me, it was just physical labor requiring no professional knowledge nor skills. Every health adult could do that after a couple of month training. The only good thing was that, after work, I ate well, slept well, and never had hair-loss problem. But what was the value of my four-year study in the techniical secondary school? And what about my childhood dream? Although I had to give up the opportunity to a university twice, I had never given up my dream, ever. So what should I do? Again, education became the straw which might be able to save my drowning life. I took the self-study higher education examination, choosing mechatronics as my major, which was quite different from heat treatment and therefore really challenging. I did the fulltime job and studied the machatronics in the late evening, during what time people around me were having all kinds of fun. As indicated by the name ‘self-study’, I was totally on myself without any external help, any teacher, nor any classmate. What I had were a textbook, a syllabus, and several copies of previous exams for each course. Unlike today, it was not easy to get information through the internet since I could not even afford for a computer at that moment. So basically I had to understand the textbook and figure out every single problem by my self. One example, for the course ‘Microcomputer principle and interface technology’, there were lots of concepts I had never heard before. The first time I just read it as a novel and tried to understand its structure. Then I repeated reading, thinking, reading, thinking, …, and finally passed the exam with a score of 91. But this was only one course, and I had to pass more than 30 courses in order to obtain a bachelor degree. The whole process took me six years, which were the most difficult but also the most valuable years in my life. It was a treasure from the God, I guess, because as Mengzi said, if the God wanted you to do something really big, he would first blablabla… So, thank you, my God, but what was the thing really big? Oh perhaps it was ShanghaiTech, I did not get it until recently. After finishing the bachelor, I made a big decision: to take the National Graduate Entrance Examination (NGEE) with target at University of Electronic Science and Technology of China (UESTC). I believed it was this decision that led me to an academic career, and finally to ShanghaiTech. Just like throwing a little into the quiet water, this news spread soon all over the factory and resulted in quite some surprise, doubt, laugh, …, but no trust. I have seen all kinds of eyes and faces; from which I could hear sounds like ‘are you kidding?’, ‘it is impossible’, et al. Well, nothing is impossible. So just let it be. I ignored all sounds outside and was preparing for the exam following my own pace. An even bigger news came two months later (three months before the NGEE): I rejected a promotion to a cadre (the League secretary) because it was accompanied by the condition of giving up the NGEE. As I said before, in a state-owned enterprise, the gap between a worker and a cadre was so huge that most workers could not cross it during their entire career. So in all people’s minds, I should grab this opportunity. However, they were not me, the ‘stupid’ guy who chose the NGEE which was labeled as impossible. To be honest, I alse cloud not predict the NGEE result at that moment. But what I knew was the this was my last chance to a university pursuing my dream, and if I missed this one I would miss it completely and would definitely regret it in the rest of my life. I alse knew that I cloud live with the worst NGEE reult. So why not? People did not understand me except for my family. My parents and two sisters always trusted me, encouraged me, and supported me. Other people felt like ‘are you crazy’? Yes, I was crazy. I was crazy because this time I could follow the inside of my heart without considering the goddam finance. I was crazy alse because I felt so colse to my dream, only missing the final shot. I felt full of energy in every single nerve and every single cell of my body. As a man, I was fighting against the fate, which, I believe, should only be ontrolled in my own hands. The biggest news came along with the warm sunshine and plaeasant spring breeze: I made it. Again, I saw all kinds of interesting eyes and faces. But this time, the underlying sounds were different. The rest of my life was much easier. I finished my master study at UESTC and then went to boroad for a Ph.D. at the Eindhoven University of Technology, where I also did my postdoc training. When I started looking for a faculty position, ShanghaiTech came into my mind immediately since I knew it quite a few years ago, from my middle school classmate and friend, Prof. Ji Hu, assistant professor at SLST in ShanghaiTech. It was interesting that, different from me choosing the techinical secondary school, Ji went to the high school and then a university. But this was not the point. The thing was that he was that he was a full professor at Xi’an Jiaotong University before joining in ShanghaiTech as assistant professor in 2014. And he was not the only case. I noticed, almost during the same period, another full professor at Nanjing University joined in ShanghaiTech as associate professor, although he was promoted soon. I was so surprised, just like people hearing that I rejected the cadre position. I was curious about what kind of university ShanghaiTech was. After extensive learning about her tenure-track system, founding and education philosophy, high academic freedom, as well as the competitive salary and benefits, I understood their choices. Since then, ShanghaiTech had become my dream insitute to develop an academic career. Again I made it. I received the offer a couple of days after the on-site interview, and accepted it without hesitation. I joined in ShanghaiTech in Sep.2019, with education and research interests focused on biomedical signal processing and its application in neuromuscular rehabilitation and ambulatory health monitoring. To me, like was miraculous. As you see, me and Ji started from the same village school, then followd two totally different trajectories, but finally met again in ShanghaiTech, which confirmed, once again, the very old saying: ‘All roads lead to Rome’. To make it more specific, perhaps I cloud say: ‘All roads lead to ShanghaiTech, sooner or later’. So, just be prepared and patient. And, to make it even further, I would say ‘All roads lead to the same destination - end of the life’. So, just cherish and enjoy every single minute and every single scene in our lives.","link":"/zh-cn/daily-life/2021/suspicious-stew/"},{"title":"data_structure","text":"从 0 开始 需要对C语言的指针和数组有一定的了解 全部代码示例皆为C语言 函数中所有用到的变量都声明在开头 函数名使用帕斯卡命名法 变量使用驼峰命名(我平时用匈牙利命名法) 数据结构概论 了解一下就好 抽象数据类型(Abstruct Data Type, ADT): 数据对象(Int, String, List等)的逻辑描述方法123456789101112131415ADT 线性表(List)Data 创建一个存储 DataType 类型元素的线性表, 线性表的数据对象集合为{a_1, a_2, ..., a_n}, 每个元素的类型均为DataType. 其中除第一个元素 a_1 外, 每一个元素有且只有一个前驱元素; 除了最后一个元素 a_n 外, 每一个元素有且只有一个直接后继元素. 数据元素之间的关系是一对一(链式)的关系.Operation InitList(*L) : 初始化操作, 建立一个空的线性表 L . ListEmpty(L) : 判断线性表是否为空表, 若线性表为空, 返回 true , 否则返回 false . ClearList(*L) : 将线性表清空. GetElem(L, i, *e) : 将线性表 L 中的第 i 个位置元素值返回给 e . LocateElem(L, e) : 在线性表 L 中查找与给定值 e 相等的元素, 如果查找成功, 返回该元素在表中序号表示成功; 否则返回 -1 表示失败 ListInsert(*L, i, e) : 在线性表 L 中第 i 个位置插入新元素 e . ListDelete(*L, i, *e) : 删除线性表 L 中第 i 给位置元素, 并用 e 返回其值. ListLength(L) : 返回线性表 L 的元素个数.endADT 数据的逻辑结构: 有 集合, 线性, 树形, 图形 四类 算法 特性(仅了解): 输入输出: ≥0个输入, ≥1个输出 有穷性: 不会死循环 确定性: 相同的输入, 一样的结果 可行性: 不会消耗过长的时间 要求(仅了解): 正确性 可读性 健壮性: 即使是奇怪的输入也不会导致奇怪的后果 时间效率高 存储量低 时间复杂度 表示随着输入规模增大导致耗时增加的程度 记作: \\(T(n) = O(f(n))\\) , 其中 \\(n\\) 代表问题规模, \\(f(n)\\) 是渐进时间复杂度 (高数中的同阶无穷大) 通常我们用 \\(O(f(n))\\) 来表示算法的时间复杂度, 叫作大O阶 推导大O阶: 只保留 \\(T(n)\\) 中的最高阶项 去除最高阶项的常数(除非最高阶是常数 1) 常见的时间复杂度 函数阶 非正式用语 常见于 \\(O(1)\\) 常数阶 略 \\(O(n)\\) 线性阶 循环结构 \\(O(n^2)\\) 平方阶 嵌套双循环 \\(O(n^3)\\) 立方阶 嵌套3循环 \\(O(2^n)\\) 指数阶 嵌套n个循环(嵌套多了, 就变成指数阶了) \\(O(\\log n)\\) 对数阶 循环子的增长呈指数的循环 \\(O(n\\log n)\\) \\(n\\log n\\) 阶 对数阶+套个循环 耗费的时间从小到大依次是: \\(O(1)&lt;O(\\log n)&lt;O(n)&lt;O(n\\log n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)\\) 最坏情况与平均情况 算法的时间复杂度不是固定的, 依据输入的数据而决定 通常算法给出的时间复杂度都是指最坏情况 空间复杂度 算法所需占用的内存 记作 \\(S(n)=O(f(n))\\) 空间复杂度为 \\(O(1)\\) 时称为原地工作 实际情况下通常不考虑空间复杂度 线性表(List) 定义和抽象数据类型 定义: 线性表的结构长这样: 记作: \\((a_1, a_2, \\dots, a_{i-1}, a_i, a_{i+1}, \\dots, a_n)\\) 若元素个数 n=0 时, 称为空表, i 称作位序 每一个元素有1个前驱和后继, 第一个和最后一个元素除外. 如图中 \\(a_i\\) 有前驱 \\(a_{i-1}\\) 和 后继 \\(a_{i+1}\\) ADT 定义:1234567891011121314151617ADT 线性表(List)Data 线性表的数据对象集合为{a1, a2, ......, an}, 每个元素的类型均为DataType. 其中, 除第一个元素a1外, 每一个元素有且只有一个直接前驱元素, 除了最后一个元素an外, 每一个元素有且 只有一个直接后继元素. 数据元素之间的关系是一对一的关系.Operation InitList(*L): 初始化操作, 建立一个空的线性表L. ListEmpty(L): 若线性表为空, 返回true, 否则返回false. ClearList(*L): 将线性表清空. GetElem(L, i, *e): 将线性表L中的第i个位置元素值返回给e. LocateElem(L, e): 在线性表L中查找与给定值e相等的元素, 如果查找成功, 返回该元素在表中序号表示成功；否则, 返回-1表示失败 ListInsert(*L,i,e): 在线性表L中的第i个位置插入新元素e ListDelete(*L,i,*e): 删除线性表L中的第i个位置元素, 并用e返回其值 ListLength(L): 返回线性表L的元素个数EndADT 线性表的顺序存储结构 结构特点: 用一段地址连续的存储单元依次存储线性表的数据元素 顺序存储结构需要三个属性: 存储空间地址 data 线性表的最大存储容量 MaxSize 线性表的当前有效长度 length 线性表的顺序存储结构代码:12345678typedef int ElemType; // ElemType类型根据实际情况而定, 这里假设为inttypedef struct{ ElemType data[MAXSIZE]; // 数组存储数据元素, 最大值为MAXSIZE int length; // 线性表当前长度} SequenceList; 地址的计算: 要取得 \\(a_i\\) 的地址: ElemType a_i = data + (i-1) * sizeof(ElemType); 线性表顺序存储结果的优缺点 优点 缺点 * 无须为表示表中元素之间的逻辑关系而增加额外的存储空间* 可以快速地存取表中任一位置的数据 * 插入和删除操作需要移动大量元素* 当线性表长度变化较大时, 难以确定存储空间的容量* 造成存储空间的\"碎片\" 顺序存储结构的插入与删除 GetElem(L, i, *e) 的实现 返回 0 代表 OK, -1 代表 ERROR 1234567891011#define OK 0#define ERROR -1int GetElem(SequenceList list, int i, ElemType *e){ if (list.length == 0 || i &lt; 1 || i &gt; L.length) return ERROR; *e = list.data[i - 1]; return OK;} 插入操作 思路: 为了给插入元素腾出空间, 遍历从 i 开始至最后一个元素, 将它们向后移动一个位置(除非插入到表尾). 将元素插入位置 i 处 表长+1 若插入位置不合理, 抛出异常 若线性表已满, 抛出异常或动态增加容量 实现代码如下: 123456789101112131415161718192021#define OK 0#define ERROR -1int ListInsert(SequenceList *list, int i, ElemType e){ if (list-&gt;length == MAXSIZE) /* 顺序线性表已满 */ return ERROR; if (i &lt; 1 || i &gt; list-&gt;length + 1) /* 当i不在范围内时 */ return ERROR; if (i &lt;= list-&gt;length) /* 若插入数据位置不在表尾 */ { for (int k = list-&gt;length - 1; k &gt;= i - 1; k--) /*将要插入位置后数据元素向后移动一位 */ list-&gt;data[k + 1] = list-&gt;data[k]; } list-&gt;data[i - 1] = e; /* 将新元素插入 */ list-&gt;length++; return OK;} 删除操作 思路: 为了缩回空出的地方, 遍历从 i 开始至最后一个元素, 将它们向前移动一个位置(除非删除的是表尾的元素). 表长-1 如果删除位置不合理, 抛出异常 实现代码如下: 12345678910111213141516171819202122#define OK 0#define ERROR -1int ListDelete(SequenceList *list, int i, ElemType *e){ if (list-&gt;length == 0) /* 线性表为空 */ return ERROR; if (i &lt; 1 || i &gt; list-&gt;length) /* 删除位置不正确 */ return ERROR; *e = list-&gt;data[i - 1]; if (i &lt; list-&gt;length) /* 如果删除不是最后位置 */ { for (int k = i; k &lt; list-&gt;length; k++) /* 将删除位置后继元素前移 */ list-&gt;data[k - 1] = list-&gt;data[k]; } list-&gt;length--; return OK;} 插入与删除的时间复杂度分析 如果元素要插入到最后一个位置, 或者删除最后一个元素, 时间复杂度为 \\(O(1)\\), 通常把具有这一特点的存储结构称为随机存取结构. 如果元素要插入到第一个位置或者删除第一个元素, 意味着要移动所有的元素向后或者向前, 时间复杂度为 \\(O(n)\\) 平均情况: 由于元素插入到第 i 个位置, 或删除第 i 个元素, 需要移动 n-i 个元素. 平均执行次数是 \\(\\frac{(n-1)+(n-2)+\\dots+(n-n)}{n}=\\frac{n^2-\\frac{(1+n)n}{2}}{n}=n-\\frac{1+n}{2}=\\frac{n-1}{2}\\) (运用等差数列的知识进行化简) 化为大O阶后平均时间复杂度还是 \\(O(n)\\) 线性表的链式存储结构 顺序线性表的缺点就是插入和删除时需要移动大量元素, 显然很耗费时间 因此有了存储形式非线性的链式线性表 结构特点: 用一组任意的存储单元存储线性表的数据, 这组存储单元可以是连续的, 也可以是不连续的. 这些数据可以存在内存未被占用的任意位置 存储元素的区域称为数据域, 存储后继位置的域称为指针域 这样的一个单元称为结点 因为此链表的每个结点只包含一个指针域, 所以叫作单链表 注意: 为了方便记录链表信息, 可在链表在第一个结点前附设一个头结点, 头结点的数据域可以存储如线性表长度等信息. 指向链表起始位置的指针称为头指针, 若链表有头结点, 则是指向头结点 链表最后一个结点(称为终端结点)的尾指针为空(用 “NULL” 或 “^” 表示) 线性表的单链表存储结构代码12345typedef struct Node{ ElemType data; struct Node *next;} Node, *LinkList; 单链表的读取 获得链表第 i 结点上数据的算法思路: 声明一个指针 p 用于存储遍历的地址, 初始值为第一个结点地址 初始化循环子 j=1, 当 j &lt; 1 时, 就遍历链表, 让 p 指针向后移动, 不断指向下一结点, j 累加 1 若循环到 p 为 NULL (还没到 i 结点就到单链表结尾了), 说明第 i 结点不存在, 抛出异常 若非法输入 i &lt; 1, 抛出异常 实现代码如下:1234567891011121314int GetElem(LinkList list, int i, ElemType *e){ LinkList p = list-&gt;next; /* 声明一指针p, 让p指向链表list的第一个结点 */ int j = 1 /* j为计数器 */ for(; j &lt; i &amp;&amp; p; j++) /* p不为空且计数器j还没有等于i时, 循环继续 */ p = p-&gt;next; /* 让p指向下一个结点 */ if(!p || i &lt; 1) return ERROR /* 第i个结点不存在 */ *e = p-&gt;data; /* 取第i个结点的数据 */ return OK;} 最坏情况时间复杂度为 \\(O(n)\\) (对比顺序线性表读取始终为 \\(O(1)\\)) 单链表的插入与删除 单链表的插入 先把结点 \\(s\\) 的后继指向 \\(p\\to next\\) , 再把结点 \\(p\\) 的后继改为指向结点 \\(s\\) 12s-&gt;next = p-&gt;next;p-&gt;next = s; 执行后: 对于单链表的表头和表尾的情况, 因为只要动前一个元素的后继指向, 所以操作是相同的 单链表插入为第 i 个结点 首先需要获得链表第 i-1 结点的地址(参考上一章, 但不同的是 p 初始没有指向第一个结点) 若查找成功, 生成空结点 s, 将数据 e 赋给 s-&gt;data 进行上面讲的插入操作 实现代码如下: 12345678910111213141516171819int ListInsert(LinkList *list, int i, ElemType e){ LinkList p, s; int j = 1; p = *list; for(; j &lt; i &amp;&amp; p; j++) /* 遍历寻找第i-1个结点 */ p = p-&gt;next; if(!p || i &lt; 1) return ERROR /* 第i个结点不存在 */ s = (LinkList) malloc(sizeof(Node)); /* 分配内存空间(C标准函数) */ s-&gt;data = e; s-&gt;next = p-&gt;next; /* 将p的后继结点赋给s的后继 */ p-&gt;next = s; /* 将s赋值给p的后继 */} 单链表第 i 个结点删除 思路: 首先需要获得链表第 i-1 结点的地址(参考上一章) 将结点 i-1 的后继指向结点 i+1 : p-&gt;next = q-&gt;next 实现代码如下: 123456789101112131415161718192021int ListDelete(LinkList *list, int i, ElemType *e){ LinkList p, q; int j = 1; p = *list; for(; j &lt; i &amp;&amp; p-&gt;next; j++) /* 遍历寻找第i-1个结点 */ p = p-&gt;next; if(!(p-&gt;next) || i &lt; 1) return ERROR; q = p-&gt;next; p-&gt;next = q-&gt;next; /* 将q的后继赋值给p的后继 */ *e = q-&gt;data; /* 将q结点中的数据给e */ free(q); /* 释放内存 */ return OK;} 插入与删除的时间复杂度分析 单链表的插入和删除算法, 都是由遍历查找第 i 结点和插入和删除结点这两部分构成, 时间复杂度都是 \\(O(n)\\) 如果不知道第 i 个结点的指针位置, 单链表结构在插入和删除操作上与顺序线性表是没有太大优势的. 但若希望从第 i 个位置, 插入 10 个结点, 对于顺序存储结构来说每次插入都需要 \\(O(n)\\); 单链表只需要在第一次时找到第 i 个位置的指针, 此时为 \\(O(n)\\) , 接下来只是简单地移动指针, 时间复杂度都是 O(1) . 因此, 对于插入或删除数据越频繁的操作, 单链表的效率优势就越是明显 单链表的整表创建 创建单链表的过程是一个动态生成链表的过程. 即从&quot;空表&quot;的初始状态起, 依次建立各元素结点, 并逐个插入链表 头插法: 类似于插队, 始终让新结点在第一的位置 思路: 创建空表 循环以下动作: 创建新结点, 随机生成数字赋给新结点的数据域 将头指针的值赋给新结点的后继 将新结点插入到头结点之后 实现代码如下: 123456789101112131415161718192021/* n 为要建立的单链表长度 */void CreateListHead(LinkList *list, int n){ LinkList p; // 初始化随机数种子 srand(time(0)); // 先建立一个带头结点的单链表 *list = (LinkList) malloc(sizeof(Node)); (*list)-&gt;next= NULL; for(int i = 0; i &lt; n; i++) { p = (LinkList) malloc(sizeof(Node)); // 生成新结点 p-&gt;data = rand() % 100 + 1; // 随机生成 100 以内的数字 p-&gt;next = (*list)-&gt;next; // 设置结点的后继 (*list)-&gt;next = p; // 插入到表头 }} 尾插法 思路: 创建空表 需要一个指针来记录尾部结点(以下称 r) 循环以下动作: 创建新结点, 随机生成数字赋给新结点的数据域 将尾部结点(也就是 r)的后继设为新结点的地址 将新结点设为尾部结点(r = 新结点) 实现代码如下: 1234567891011121314151617181920212223/* n 为要建立的单链表长度 */void CreateListTail(LinkList *list, int n){ LinkList p, r; // 初始化随机数种子 srand(time(0)); // 先建立一个带头结点的单链表 *list = (LinkList) malloc(sizeof(Node)); r = *list; // r 记录尾部结点的地址(这里表刚创好只有一个结点所以赋 *list) for(int i = 0; i &lt; n; i++) { p = (LinkList) malloc(sizeof(Node)); // 生成新结点 p-&gt;data = rand() % 100 + 1; // 随机生成 100 以内的数字 r-&gt;next = p; // 将表尾结点的后继指向新结点 r = p; // 将新结点定义为表尾结点 } r-&gt;next = NULL; // 别忘了初始化表尾结点的后继} 单链表的整表删除 单链表整表删除: 思路: 新建一个指针 p 存储第一个结点 向后不断遍历结点的后继并删除当前结点, 将 p 不断后移 最终将头指针置空 实现代码如下:123456789101112131415int ClearList(LinkList *list){ LinkList p = (*list)-&gt;next; // p 初始化指向第一个结点 while(p) // 循环直到 p 为 NULL { LinkList q = p-&gt;next; // 需要一个临时变量来存储地址 free(p); p = q; // 将下一结点的地址赋给 p } // 最后将头指针设为空 (*list)-&gt;next = NULL; return OK;} 顺序存储结构和单链表结构的比较 存储分配方式 时间性能 空间性能 * 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素* 单链表采用链式存储结构, 用一组任意的存储单元存放线性表的元素 * 查找 * 顺序存储结构 O(1) * 单链表 O(n)* 插入和删除 * 顺序存储结构需要平均移动表长一半的元素, 时间为 O(n) * 单链表在找出某位置的指针(O(n))后, 插入和删除时间仅为 O(1) * 顺序存储结构需要预分配存储空间, 分大了, 浪费, 分小了易发生上溢* 单链表不需要分配存储空间, 只要有就可以分配, 元素个数也不受限制 若线性表需要频繁查找, 很少进行插入和删除操作时, 宜采用顺序存储结构. 若需要频繁插入和删除时, 宜采用单链表结构 当线性表中的元素个数变化较大或者根本不知道有多大时, 最好用单链表结构, 这样可以不需要考虑存储空间的大小问题. 而如果事先知道线性表的大致长度, 用顺序存储结构效率会高很多 静态链表 用数组储存结点的链表叫做静态链表(游标实现法). 为了方便插入数据, 通常会把数组建得大一些, 以防止空间不够而溢出 1234567#define MAXSIZE 1000typedef struct{ ElemType data; int cur; // 游标(Cursor), 为 0 时表示无指向} Component, StaticLinkList[MAXSIZE]; 如图所示, 静态链表中: 数组中未被使用的空间称为备用链表 数组的第一个结点和终端结点作为特殊结点, 不存数据. 第一个结点(下标为 0)的 cur 存放备用链表的第一个结点的下标; 终端结点的 cur 存放第一个有数值结点的下标(相当于单链表中的头指针), 若整个链表为空时, 则为 0 . 实现代码如下:123456789101112131415161718192021222324// 假设 MAXSIZE = 1000int InitList(StaticLinkList list){ // 初始化数组下标 0~998 的游标 for(int i = 0; i &lt; MAXSIZE -1; i++) list[i].cur = i + 1; // 将终端结点(下标 999)的游标置为 0 list[MAXSIZE - 1].cur = 0; return OK;}// 通过遍历游标并统计遍历次数的方法得到表长int ListLength(StaticLinkList list){ int length = 0; int lastCursor = list[MAXSIZE - 1].cur; while(lastCursor) { lastCursor = list[lastCursor].cur; length++; } return length;} 举个例子: 假设已经将数据存入静态链表, 比如分别存放着&quot;甲&quot;、“乙”、“丁”、“戊”、“己”、&quot;庚&quot;等数据 静态链表的插入操作 首先要解决的是: 如何用静态(预分配了内存空间)模拟动态链表的存储空间分配, 即需要时申请, 无用时释放. 解决方案是将数组上所有未被使用的及已删除的分量用游标链成一个备用链表, 每当进行插入时, 便可以从备用链表取它的第一个分量作为待插入的新结点 实现代码如下: 12345678910// 若备用链表非空, 则返回备用链表第一个分量的下标, 否则返回 0int Malloc_SLL(StaticLinkList list){ // 根据静态链表定义, 当前数组第一个结点的cur存的值, 即为备用链表第一个分量的下标 int i = list[0].cur; if(list[0].cur) // 判断是否还有下一个分量 list[0].cur = list[i].cur; // 将它的下一个分量赋给第一个结点的cur return i;} 插入为第 i 结点: 思路: 首先从备用链表获得一个分量的游标, 然后将数据赋给此分量. 从终端结点的游标开始遍历, 直到第 i-1 号结点的下标; 然后参考单链表的插入操作 实现代码如下: 1234567891011121314151617181920212223242526// i 为要插入的下标int ListInsert(StaticLinkList list, int i, ElemType e){ int lastCursor, spaceCursor; lastCursor = MAXSIZE - 1; // 首先将这个记录用变量初始化为终端结点的下标 if (i &lt; 1 || i &gt; ListLength(list) + 1) return ERROR; spaceCursor = Malloc_SSL(list); if (spaceCursor) { // 将数据 e 赋给此分量 list[spaceCursor].data = e; // 类似于单链表, 找到第 i-1 结点 for (int j = 1; j &lt;= i - 1; j++) lastCurser = list[lastCursor].cur; // 参考单链表的插入操作 list[spaceCursor].cur = list[lastCursor].cur; list[lastCursor].cur = spaceCursor; return OK; } return ERROR;} 静态链表实现了在数组中, 不移动元素, 却插入了数据的操作. (但失去了随机读取的特性) 静态链表的删除操作 首先需要考虑把删除的空间回收到备用链表1234567// 回收第 i 结点void Free_SSL(StaticLinkList list, int i){ // 采用头插法 list[i].cur = list[0].cur; list[0].cur = k;} 删除第 i 结点:1234567891011121314151617int ListDelete(StaticLinkList list, int i){ int j, lastCursor; if (i &lt; 1 || i &gt; ListLength(list)) return ERROR; lastCursor = MAXSIZE - 1; // 类似于单链表, 找到第 i-1 结点 for (j = 1; j &lt;= i - 1; j++) lastCursor = list[lastCursor].cur; j = list[lastCursor].cur; // j 重复利用 list[lastCursor].cur = list[j].cur; // 将 i-1 结点的后继设为 i+1 (跳过第 i 结点) Free_SSL(list, j); return OK} 静态链表优缺点 优点 缺点 * 在插入和删除操作时, 只需要修改游标, 不需要移动元素, 从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点 * 没有解决连续存储分配带来的表长难以确定的问题* 失去了顺序存储结构随机读取的特性 循环链表 将单链表中终端结点的后继由空指针改为指向头结点, 就使整个单链表形成一个环, 称为单循环链表, 简称循环链表(Circular Linked List) 示意图: 空的循环链表(只有一个头结点): 非空的循环链表 循环列表的特点 循环链表和单链表的主要区别在于循环的判断条件上, 原来是判断 p-&gt;next 是否为空, 现在则是 p-&gt;next 不等于头结点, 则循环未结束. 有头结点的单链表可以用 \\(O(1)\\) 的时间访问第一个结点, 访问到终端结点却需要 \\(O(n)\\) 的时间, 因为需要将单链表全部遍历一遍 尾循环列表 为了解决终端结点访问效率低的问题, 再改造一下这个循环链表, 不用头指针而用指向终端结点的尾指针来表示链表. 尾循环列表的特点 终端结点用尾指针 rear 表示, 查找终端结点时间为 \\(O(1)\\) , 第一个结点是 rear-&gt;next-&gt;next , 时间也为 \\(O(1)\\) 合并多个尾循环列表 将尾指针分别是 rearA 和 rearB 的两个循环链表合并成一个表: 合并后: 如图所示, 具体操作为: 将 B 表的 rearB 指向 A 表的头结点 将 A 表的 rearA 指向 B 表的第一个结点, 同时释放 B 表的头结点 实现代码为: 1234CircularLinkList p = rearA-&gt;next; // 保存 A 表的头结点rearA-&gt;next = rearB-&gt;next-&gt;next; // 将 A 表的头结点替换为 B 表的第一个结点free(rearB-&gt;next); // 释放 B 表的头结点(不再需要)rearB-&gt;next = p; // 将 B 表尾指针指向 A 表的头结点 双向链表 双向链表(Double linked list)是在单链表的每个结点中, 再设置一个指向其前驱结点的指针域. 双向链表中的结点都有两个指针域, 一个指向后继, 一个指向后驱 123456typedef struct DuLinkNode{ ElemType data; struct DuLinkNode *prior; // 前驱指针 struct DuLinkNode *next; // 后继指针} DuLinkNode, *DuLinkList; 这里我们讨论循环+双向列表的情况 示意图: 空的循环双向链表: 非空的循环链表 双向链表插入结点 思路: 先搞定 s 的前驱和后继, 再搞定后结点的前驱, 最后解决前结点的后继 实现代码如下:1234s-&gt;prior = p; // 1. s 的前驱是 ps-&gt;next = p-&gt;next; // 2. s 的后继是 p-&gt;nextp-&gt;next-&gt;prior = s; // 3. 后结点的前驱是 sp-&gt;next = s; // 3. 前结点的后继是 s 双向列表删除结点 思路: 先搞定前结点的后继, 再搞定后结点的前驱, 最后释放 p 的空间123p-&gt;prior-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = p-&gt;prior;free(p) 栈与队列 栈的定义 栈(Stack)是限定仅在表尾进行插入和删除操作的线性表 栈顶(top) 允许数据插入和删除, 另一端叫栈底(bottom) 栈又被称为 后进先出(Last In, First Out) 的线性表, 简称LIFO结构 栈的插入操作称作压栈、进栈或入栈 栈的删除操作称作弹栈或出栈 栈的抽象数据类型 12345678910111213ADT 栈(Stack)Data 同线性表. 元素具有相同的类型, 相邻元素具有前驱和后继关系Operation InitStack(*S) : 初始化操作, 建立一个空栈 S DestroyStack(*S) : 将栈销毁 ClearStack(*S) : 将栈清空 StackEmpty(S) : 若栈为空, 返回 true ; 否则返回 false GetTop(S, *e) : 用 e 返回栈 S 的栈顶元素 Push(*S, e) : 插入新元素 e 到栈 S 中并成为栈顶元素. 又称: 压栈, 进栈, 入栈 Pop(*S, *e) : 删除栈 S 中栈顶元素, 并用 e 返回其值. 又称: 弹栈, 出栈 StackLength(S) : 返回栈 S 的元素个数endADT 栈的顺序存储结构及实现 栈的顺序存储结构(Stack Sequence) 栈顶指针top指向当前栈顶部元素的地址. 它在空栈时为 -1 , 存在一个元素时为 0 .1234567// SElemType类型根据实际情况而定, 这里假设为 inttypedef int SElemTypetypedef struct{ SElemType data[MAXSIZE]; int top; // 栈顶指针(下标)} SqStack; 顺序栈的进栈 1234567891011// 插入元素 e 为新的栈顶元素int Push(SqStack *S, SElemType e){ if (S-&gt;top == MAXSIZE - 1) // 栈满 return ERROR; S-&gt;top++; // 栈顶指针+1 S-&gt;data[S-&gt;top] = e; // 将新加入的元素赋给栈顶空间 // 以上两句可以合并为 S-&gt;data[++S-&gt;top] = e; return OK;} 顺序栈的出栈1234567891011// 删除栈顶元素, 用 e 返回其值int Pop(SqStack *S, SElemType *e){ if (S-&gt;top == -1) // 若栈为空 return ERROR; *e = S-&gt;data[S-&gt;top]; // 将要删除的栈顶元素赋值给 e S-&gt;top--; // 栈顶指针-1 // 以上两句可以合并为 *e = S-&gt;data[S-&gt;top--]; return OK;} 值得一提的是, 出栈并没有清除数据, 因为栈在创建时即分配了固定的内存空间, 没有必要清理数据. 时间复杂度分析 入栈和出栈的时间复杂度均是 \\(O(1)\\) 两栈共享空间 两栈共享空间 将一个数组分为两个顶部相连的栈, 一个栈的栈底为数组的始端, 另一个栈的栈顶为数组的末端 实现代码如下:123456typedef struct{ SElemType data[MAXSIZE] int top1; // 栈 1 栈顶指针 int top2; // 栈 2 栈顶指针} SqDoubleStack; 共享栈的进栈 对于两栈共享空间的 Push() 方法, 除了要插入元素值参数外, 还需要有一个判断是栈 1 还是栈 2 的栈号参数 stackNumber123456789101112int Push(SqDoubleStack *S, SElemType e, int stackNumber){ if (S-&gt;top1 + 1 == S-&gt;top2) // 两个栈顶相挨, 说明栈已满 return ERROR; if (stackNumber == 1) S-&gt;data[++S-&gt;top1] = e; // 栈 1 同普通栈 else if (stackNumber == 2) S-&gt;data[--S-&gt;top2] = e; // 栈 2 要先 top2-1 后给数组元素赋值 return OK;} 共享栈的出栈 对于两栈共享空间的 Pop() 方法, 同样需要增加判断栈 1 还是栈 2 的参数 stackNumber12345678910111213141516171819int Pop(SqDoubleStack *S, SElemType *e, int stackNumber){ if (stackNumber == 1) { if (S-&gt;top1 == -1) // 若栈 1 是空栈 return ERROE; *e = S-&gt;data[S-&gt;top1--]; // 栈 1 栈顶元素出栈 } else if (stackNumber == 2) { if (S-&gt;top2 == MAXSIZE) // 若栈 2 已经是空栈, 栈 2 的栈底是 MAXSIZE return ERROR; *e = S-&gt;data[S-&gt;top2++]; // 栈 2 栈顶元素出栈 } return OK;} 栈的作用 栈的引入简化了程序设计的问题, 划分了不同的关注层次, 使得思考范围缩小, 更加聚焦于要解决的问题核心. 反之, 像数组等, 因为要分散精力去考虑数组的下标增减等细节问题, 反而掩盖了问题的本质. 栈的应用 递归 斐波那契数列实现 斐波那契数列介绍 月数 1 2 3 4 5 6 7 8 9 10 11 12 兔子对数 1 1 2 3 5 8 13 21 34 55 89 144 如图, 编号 ① 的一对兔子经过六个月变成8对兔子 数学定义: \\(F(n) = \\begin{cases} 0 &amp; n=0 \\\\ 1 &amp; n=1 \\\\ F(n-1)+F(n-2) &amp; n&gt;1 \\end{cases}\\) 发现规律了吗? 斐波那契数列第 i 个月(i &gt; 1, 第零月算0)的值等于前两个月的和 打印前 40 位的斐波那契数列数, 实现代码如下: 1234567891011121314151617181920212223242526272829303132333435#include &quot;stdio.h&quot;int Fbi(int i) // 斐波那契的递归函数{ if (i &lt; 2) return i == 0 ? 0 : 1; return Fbi(i-1) + Fbi(i-2); // 递归调用(即调用自己)}int main(){ int i; int a[40]; // 方法1 使用迭代来实现斐波那契数列 printf(&quot;迭代显示斐波那契数列: \\n&quot;); a[0]=0; a[1]=1; printf(&quot;&amp;d &quot;, a[0]); printf(&quot;%d &quot;, a[1]); for(i = 2; i &lt; 40; i++) { a[i] = a[i-1] + a[i-2] printf(&quot;%d &quot;, a[i]); } printf(&quot;\\n&quot;); // 方法2 使用迭代来实现斐波那契数列 printf(&quot;递归显示斐波那契数列: \\n&quot;); for(i = 0; i &lt; 40; i++) printf(&quot;%d &quot;, Fbi(i)); return 0;} Fbi(i) 函数当 i=5 的执行过程(分析递归的方法): 递归和迭代的区别 迭代 递归 循环结构 选择结构 不需要反复调用函数和占用额外的内存 使程序结构更清晰简洁, 更容易让人理解, 从而减少读懂代码的时间. 但是大陆的递归调用会建立函数的副本, 从而耗费大量的时间和内存 你可能注意到本章似乎并没有提及栈的内容, 为什么呢? 在前行阶段, 对于每一层递归, 函数的局部变量、参数值以及返回地址都被压入栈中. 在退回阶段, 位于栈顶的局部变量、参数值和返回地址被弹出, 用于返回调用层次中执行代码的其余部分, 也就是恢复了调用的状态. 后缀表达式 我们平时描述数字表达式用的是中缀表达法, 但计算机解析它需要递归, 从而耗费大量的资源 后缀表达式能够解决这个问题 后缀表示法(逆波兰表示法): 逆波兰表达式去掉括号也不会有歧义 9+(3-1)*3+10÷2 = 9 (3 1-) 3*+ 10 2/+ = 9 3 1- 3*+ 10 2/+ 后缀表达式的计算方法 规则: 从左到右遍历表达式的每个数字和符号, 遇到数字就进栈, 遇到符号就将两个数字出栈, 进行运算, 再将运算结果进栈. 重复以上步骤直到最终获得结果. 以 9+(3-1)*3+10÷2 = 9 3 1- 3*+ 10 2/+ 为例 初始化一个空栈用来对要运算的数字进出使用. 后缀表达式中前三个都是数字, 所以 9, 3, 1 进栈, 如图 接下来是减号&quot;-&quot;, 所以将栈中的 1 出栈作为减数, 3 出栈作为被减数, 并运算 3-2 , 再将得到的结果 2 进栈, 如图 接着是数字 3 进栈 … 总之最后得到结果 20, 出栈变为空栈 中缀表达式转后缀表达式 9+(3-1)*3+10÷2 ----&gt; 9 3 1- 3*+ 10 2/+ 规则: 从左到右遍历中缀表达式的每个数字和符号, 若是数字就输出; 若是符号, 则判断其优先级不高于栈顶符号(遵循乘除优先加减, 左边高于右边)则将栈内元素依次出栈并输出, 并将当前符号进栈, 直到输出完整的后缀表达式. 若是右括号, 则栈内元素依次出栈直到对应的左括号出栈 初始化一个空栈, 用于存储读取的符号. 第一个字符是9, 输出9, 后面是符号&quot;+&quot;, 进栈. 第三个字符是&quot;(“, 进栈. 后面是数字3, 进栈. 接着是”-&quot;, 进栈 接下来是数字1, 输出. 后面是符号&quot;)“, 所以栈顶依次出栈, 直到”(“出栈为止. 接着是符号”*“, 因为此时的栈顶符号为”+“号, 优先级低于”*&quot;, 因此不输出, &quot;*&quot;进栈. 接着说数字3, 输出. … 读到最后, 将栈中元素全部出栈并输出. 得到后缀表达式结果: 9 3 1- 3*+ 10 2/+ 队列的定义 队列(queue)是只允许在一端进行插入操作, 而在另一端进行删除操作的线性表 队列是一组先进先出(First In First Out)的线性表, 简称FIFO. 允许插入的一端称为队尾, 允许删除的一端称为队头. 队列的抽象数据类型 12345678910111213ADT 队列(Queue)Data 同线性表. 元素具有相同的类型, 相邻元素具有前驱和后续关系.Operation InitQueue(*Q) : 初始化操作, 建立一个空队列Q DestroyQueue(*Q): 若队列Q存在, 则销毁它 ClearQueue(*Q) : 将队列Q清空 QueueEmpty(Q) : 若队列为空, 返回true, 否则返回false GetHead(Q, *e) : 用e返回队列Q的队头元素 EnQueue(*Q, e) : 插入新元素e到队列Q中并成为队尾元素 DeQueue(*Q, *e) : 删除队列Q中队头元素, 并用e返回其值 QueueLength(Q) : 返回队列Q的元素个数endADT 循环队列 队列顺序存储的不足 入列操作就是在队尾追加一个元素, 不需要移动任何元素, 时间复杂度为 \\(O(1)\\) 出列操作, 队列中的所有元素都得向前移动, 以保证队列的队头不为空, 此时时间复杂度为 \\(O(1)\\) 为了避免当只有一个元素时, 队头和队尾重合使处理变得麻烦, 引入俩个指针: 指向队头元素的 front 和指向队尾元素的下一个位置的 rear. 当 front 等于 rear 时, 队列为空. 循环队列定义 队列的这种头尾相接的顺序存储结构称为循环队列 (即指针 rear 可以在指针 front 的前面) 队列已满判断 如果我们再入队两个元素: 如何判断此时的队列已满呢? 方法1: 设置一个标志变量 flag , 当 front==rear且 flag=0 时队列空; 当 front==rear 且 flag=1 时队列满. 方法2: 当队列空时, 条件就是 front=rear, 当队列满时, 认为 (rear+1)%MAXSIZE == front 即为队列满 (取模MAXSIZE相当于让 rear&gt;4 时自动-4). 也就是说, 数组中保留一个空闲单元, 不允许右边的情况出现. 一般用第二种方法 队列实际长度的计算 当 rear 在 front 之后(即 front &lt; rear), 队列长度为 rear - front 当 rear 在 front 之前(即 front &gt; rear), 队列长度分为两段, 一段是 0 + rear, 另一段是 MAXSIZE - front. 整合起来就是: rear - front + MAXSIZE 结合两种情况, 得到通用的公式: (rear - front + MAXSIZE)%MAXSIZE 循环队列的具体实现 循环队列顺序存储结构123456typedef struct{ QElemType data[MAXSIZE] int front; int rear;} SqQueue; 循环队列初始化 InitQueue(*Q)123456int InitQueue(SqQueue *Q){ Q-&gt;front = 0; Q-&gt;rear = 0; return OK;} 循环队列求长度 QueueLength(Q)1234int QueueLength(SqQueue Q){ return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;} 循环队列入队操作 EnQueue(*Q, e)123456789int EnQueue(SqQueue *Q, QElemType e){ if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front) // 队列满的判断 return ERROR; Q-&gt;data[Q-&gt;rear] = e; // 将e赋给队尾 Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; // rear后移一位置, 若在最后则转到头部 return OK;} 循环队列出列操作 DeQueue(*Q, *e)12345678910int DeQueue(SqQueue *Q, QElemType *e){ if (Q-&gt;front == Q-&gt;rear) // 队列空的判断 return ERROR; *e = Q-&gt;data[Q-&gt;front]; // 将队头元素赋给e Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE; // front指针后移一位置, 若在最后则转到数组头部 return OK;} 队列的链式存储结构及实现 队列的链式存储结构即为只能尾进头出的单链表, 简称链队列. 空队列时, front 和 rear 都指向头结点 链队列的结构12345678910111213// QElemType类型根据实际情况而定, 这里假设为inttypedef int QElemType;typedef struct QNode // 结点结构{ QElemType data; struct QNode *next;} QNode, *QueuePtr;typedef struct // 队列的链表结构{ QueuePtr front, rear; // 队头, 队尾指针} LinkQueue; 入队操作 入队操作就是在链表尾部插入结点 实现代码如下:1234567891011121314int EnQueue(LinkQueue *Q, QElemType e){ QueuePtr newNode = (QueuePtr) malloc(sizeof(QNode)); if(!newNode) // 存储分配失败 exit(OVERFLOW); newNode-&gt;data = e; newNode-&gt;next = NULL; Q-&gt;rear-&gt;next = newNode; // 将新阶段设置为原队尾结点后继 Q-&gt;rear = newNode; // 将新结点设置为队尾结点 return OK;} 出队操作 出队操作时就是将第一个结点(头结点的后继)结点出队, 再将头结点的后继改为它后面的结点. 若链表除头结点外只剩一个元素时, 则需将 rear 指向头结点 实现代码如下:123456789101112131415161718int DeQueue(LinkQueue *Q, QElemType *e){ QueuePtr p; if (Q-&gt;front == Q-&gt;rear) // 若队列为空 return ERROR; p = Q-&gt;front-&gt;next; // 记下欲删除的结点地址 *e = p-&gt;data; // 将欲删除结点的值赋给e Q-&gt;front-&gt;next = p-&gt;next; // 将头结点后继改为欲删除结点的后继 if (Q-&gt;rear == p) // 若队头就是队尾, 则将rear指向头结点 Q-&gt;rear = Q-&gt;front; free(p); return OK;} 循环队列与链队列比较 时间上, 基本操作都为 \\(O(1)\\) , 不过循环队列是事先分配好空间, 使用期间不释放; 而对于链队列, 每次申请和释放结点也会有额外的时间开销, 如果入队出队频繁, 则两者还是有细微差异. 空间上, 循环队列必须有一个固定的长度, 所以就有空间浪费的问题. 而链队列不存在这个问题, 尽管它每个结点额外需要一个指针域, 会产生一些空间上的开销, 但也可以接受. 所以在空间上, 链队列更加灵活. 在可以确定队列长度最大值的情况下, 建议用循环队列, 如果无法预估队列的长度时, 则用链队列. 串 串的定义 串(string) 是由零个或多个字符组成的有限序列, 又名叫字符串 一般记为 \\(s=“a_1a_2\\dots a_n”(n\\geqslant 0)\\) , \\(s\\) 是串的名称, 用双引号(或单引号)括起来的是串的值. \\(a_i(1\\leqslant i\\leqslant n\\) 可以是字母、数字或其他字符. 空串(nullstring), 它的长度为零, 可以直接用两双引号 “” 表示, 也可以用希腊字母 Φ 来表示. 空格串, 只包含空格的串. 可以不止一个空格 串中任意个数的连续字符组成的串叫子串. 相应地, 包含子串的串称为主串. 串的比较 串的比较是通过组成串的字符之间的编码来进行的, 字符的编码指字符在对应字符集(如ASCII)中的序号. ASCII编码由7位二进制表示一个字符, 共能表示128个字符; 扩展ASCII码由8位二进制数表示一个字符, 共能表示256个字符 Unicode编码由16位二进制数表示一个字符, 共能表示 \\(2^16\\) 个字符(约6.5万), 为了与ASCII码兼容, Unicode的前256个字符与ASCII码完全相同 在C语言中比较两个串相等, 必须是串的长度和对应字符都相等. 两个串不相等时, 若对应字符不同, 比对应字符在ASCII码表的编码号. 若对应字符相同, 比两个串的长度. 串的抽象数据类型 线性表关注的是单个元素的操作 串关注的是多个元素的操作, 如查找子串位置, 得到指定位置子串, 替换子串等操作 串的抽象数据类型 12345678910111213141516171819202122232425262728ADT 串(string)Data 串中单个元素仅由一个字符组成, 相邻元素具有前驱和后继关系.Operation StrAssign(T, *chars) : 生成一个值为*chars的串T StrCopy(T, S) : 若串S存在, 由串S复制得串T ClearString(S) : 若串S存在, 将串清空 StringEmpty(S) : 若串S为空, 返回true, 否则返回false StrLength(S) : 返回串S的长度 StrCompare(S, T) : 若 S&gt;T, 返回值 &gt;0; 若 S=0 返回 0; 若 S&lt;T, 返回值 &lt;0 Concat(T, S1, S2) : 用T返回由S1和S2联接而成的新串 SubString(Sub, S, pos, len) : 若串S存在, 且 1 ≤ pos ≤ StrLength(S) , 0 ≤ len ≤ StrLength(S) - pos + 1 . 返回截取从pos起长度为len的子串Sub Index(S, T, pos) : 若串S和串T存在, T是非空串, 且 1 ≤ pos ≤ StrLength(S) . 若主串S中存在和串T相同的子串, 则返回它在主串S中第pos个字符起第一次出现的位置, 否则返回 -1 Replace(S, T, V) : 若串S、T、V存在, 且T是非空串. 用V替换主串S中出现的所有与T相等的子串. StrInsert(S, pos, T) : 若串S和T存在, 且 1 ≤ pos ≤ StrLength(S) + 1 . 在串S第pos个字符之前插入串T StrDelete(S, pos, len) : 若串S存在, 且 1 ≤ pos ≤ StrLength(S) - len + 1 . 从串S中删除以第pos个字符起长度为len的子串endADT 串的存储结构 串的顺序存储结构 串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列. 一般用数组来定义. C语言中, 串的最后用&quot;\\0&quot;来表示串值的终结. 串的链式存储结构 由于串结构的特殊性, 结构中每个元素数据是一个字符, 如果也简单地一个结点对应一个字符, 就会存在很大的空间浪费. 因此, 一个结点也可以考虑存放多个字符, 最后一个结点若是未被占满时, 可以用&quot;#&quot;或其他字符填充. 串的链式存储结构除了在连接串与串操作时有一定方便之外, 总的来说不如顺序存储灵活, 性能也不如顺序存储结构好 朴素的模式匹配算法 子串的定位操作通常称做串的模式匹配(Pattern matching) 举个例子: 从主串 S=“goodgoogle” 中找到 T=“google” 这个子串的位置 (图中, 竖直线表示相等, 闪电状弯折表示不等.) 主串 S 第一位开始, S 与 T 前三个字母都匹配成功, 但 S 第四个字符是 ‘d’ 而子串 T 的是 ‘g’, 因此第一位匹配失败. 从主串 S 第二位开始, 首字母是 ‘o’, 与 T 的 ‘g’ 不同, 匹配失败 从主串 S 第三位开始, 首字母还是 ‘o’, 与 T 的 ‘g’ 不同, 匹配失败 从主串 S 第四位开始, s首字母是 ‘d’, 与 T 的 ‘g’ 不同, 匹配失败 从主串 S 第五位开始, 6 个字母全匹配, 匹配成功 操作 Index(S, T, pos) 的实现算法 思路: 主串 S 从 pos 之后, 不断截取长度为 Strlength(T) 的子串与 T 进行比较 123456789101112131415161718int Index(String S, String T, int pos){ int n, m, i; String sub; if(pos &gt; 0) { n = StrLength(S); // 得到主串S长度 m = Strlength(T); // 得到子串T长度 for(i = pos; i &lt;= n - m + 1; i++) { SubString(sub, S, i, m); if (StrCompare(sub, T) == 0) // 如果两串相等 return i; } } return -1; // 若无子串与T相等, 返回 -1} 不用StrLength(), SubString(), StrCompare() 的实现 123456789101112131415161718192021int Index(String S, String T){ int i, j; // i, j 分别记录循环在 S, T 比较的下标 for (i = 1, j = 1; i &lt;= S.[0] &amp;&amp; j &lt;= T.[0];) { if (S[i] == T[j]) { i++; j++; } else // 如果比较失败 { i = i - j + 2; // i 回溯并+1 j = 1; // j 回溯 } if (j = T.[0]) return (i - T.[0]; else return 0; }} 时间复杂度分析: 最坏情况下, 每次不成功的匹配都发生在串 T 的最后一个字符 设 S 和 T 长度分别为 n=32, m=8 如主串 S=“00000000000000000000000000000001”, 而要匹配的子串 T=“00000001”, 所以最坏情况时间复杂度为 m(n-m+1)=O(m(n-m)) KMP模式匹配算法 KMP (Knuth, Morris, Pratt 三人发现) KMP算法的改进之处在于主串的 i 指针不用回溯, 而是利用之前&quot;匹配程度&quot;(以 j 指针来反应)将匹配串T向右滑动尽可能远的距离后继续比较. 如何决定滑动的距离呢? 定义一个数组 next[j] 表示当子串T中第j个字符与主串第i个字符不等时, 下一次比较的位置为 T[next[j]] 如图中 next[6] = 3, 则将 T[3]与 S[6] 比较 在此贴上 next[i] 的定义: \\(next[j]=\\begin{cases} 0, 当 j=1 时 \\\\ Max\\{k|1&lt;k&lt;j, 且 “a_1 a_2 \\dots a_{k=1}=a_{j-k+1} a_{j-k+1}\\dots a_{j-1}”\\} \\\\ 1, 其他情况\\end{cases}\\) 具体实现代码: 12345678910111213141516171819202122232425262728293031323334353637383940void get_next(String T, int *next){ int j, k; j = 1; k = 0; next[1] = 0; while(j &lt; T.[0]) // 此处T[0]表示串T的长度 { if (k == 0 || T[j] == T[k]) // { j++; k++; next[j] = k; } else k = next[k]; // k 值回溯, 同样利用了KMP, 利用之前已经算好的next[k] }}int Index_KMP(String S, String T, int pos){ int i = pos; int j = 1; int next[255]; get_next(T, next); while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) { if (j == 0 || S[i] == T[i]) { i++; j++; } else j = next[i]; } if (j &gt; T[0]) return i - T[0]; else return 0;} 时间复杂度分析 TODO 树 树的定义 树(Tree) 是 n (n≥0) 个结点的有限集, n=0 时称为空树. 在任意一颗非空树中: 有且仅有一个特定的根(Root)结点 当 n&gt;1 时, 其余结点可分为 m (m&gt;0) 个互不相交的有限集 \\(T_1, T_2, \\dots, T_m\\) , 其中每一个集合本身又是一棵树, 并且称为根的子树 如下图, 子树 \\(T_1\\) 和 \\(T_2\\) 是根结点 A 的子树 (D、G、H、I是以B为根结点的子树, E、J是以C为根结点的子树) 子数之间一定是互不相交的, 下图的两个结构就不符合树的定义 结点的分类 树的结点包含数据元素和若干指向其子树的分支. 结点的子树数量称为结点的度(Degree). 度为0的结点称为叶结点或终端结点; 度不为0的结点称为分支结点或非终端结点, 非根结点的分支结点也叫内部结点. 树的度为树内各结点的度的最大值. 举个例子: 此树的度为3 结点间关系 孩子(Child), 双亲(Parent), 兄弟(Sibling) 树的其他相关概念 结点的层次(Level) 一个 深度(Depth) 或 高度 为4的树 如果将树中结点的各子树看出从左至右是有次序的, 不能互换的, 则称该树为有序树, 否则称为无序树. 森林(Forest) 是 m (m≥0) 课互不相交的树的集合. 对树中每个结点而言, 其子树的集合即为森林. 树的抽象数据类型 1234567891011121314151617181920ADT 树(tree)Data 树是由一个根结点和若干课子树构成, 树中结点具有相同数据类型及层次关系Operation InitTree(*T) : 构造空树T DestroyTree(*T) : 摧毁树T CreateTree(*T, definition) : 按definition中给出的树的定义来构造树 ClearTree(*T) : 若树T存在, 则将树T清空 TreeEmpty(T) : 若T为空树, 返回true, 否则返回false TreeDepth(T) : 返回树T的深度 Root(T) : 返回树T的根结点 Value(T, cur_e) : cur_e是树T中一个结点, 返回此结点的数据 Assign(T, cur_e, value) : 给树T的结点cur_e赋值为value Parent(T, cur_e) : 若cur_e是树T的非根结点, 返回它的双亲, 否则返回空 LeftChild(T, cur_e) : 若cur_e是树T的非叶结点, 则返回它最左边的孩子, 否则返回空 RightSibling(T, cur_e) : 若cur_e有右兄弟, 则返回它的右兄弟, 否则返回空 InsertChild(*T, *p, i, c) : p指向树T的某个结点, i为所指结点p的度加上1, 非空树c与T不相交 操作结果为插入树c为树T中p所指结点的第i颗子树 DeleteChile(*T, *p, i) : 其中p指向树T的某个结点, i为所指结点p的度, 操作结果为删除树T中p所指结点的第i颗子树endADT 树的存储结构 双亲表示法 假设以一组连续空间存储树的结点, 同时在每个结点中, 附设一个治时期指示其双亲结点在数组中的位置. 每个结点除了知道自己是谁以外, 还知道它的双亲在哪里123456789101112131415#define MAX_TREE_SIZE 100typedef int TElemType; // 假设储存的是整型typedef struct PTNode{ TElemType data; // 结点数据 int parent; // 双亲位置} PTNode; // 结点结构typedef struct{ PTNode nodes[MAX_TREE_SIZE]; // 结点数组 int r, n; // 根的位置和结点数} PTree; 由于根结点没有双亲, 约定根结点的 parent 设为 -1 改进: 增加一个存储最左边孩子的 长子域(firstChild), 如果结点没有孩子, 就设为 -1 增加一个存储右兄弟的域(rightsib), 如果结点没有右兄弟, 就设为 -1 孩子表示法 由于树中每个结点可能有多颗子树, 可以考虑多重链表, 即每个指针指向一棵子树的根结点, 这种方法叫多重链表表示法. 方案一: 指针域的个数等于树的度 TODO: 补充不重要内容 方案二: 按需分配空间 TODO: 补充不重要内容 孩子表示法: 设置两种结构, 一个是孩子链表的孩子结点, 另一个是表头数组的表头结点. 把每个结点的孩子结点以单链表形式排列起来 12345678910111213141516171819#define MAX_TREE_SIZE 100typedef int TElemType;typedef struct CTNode // 孩子结点{ int child; // 存储该孩子在表头数组中的下标 struct CTNode *next; // 指向某结点的下一个孩子结点的指针} *ChildPtr;typedef struct // 表头结点{ TElemType data; ChildPtr firstchild;} CTBox;typedef struct{ CTBox nodes[MAX_TREE_SIZE]; // 表头数组 int r, n; // 根的位置和结点数} CTree; 这样的结构对于要查找某个结点的某个孩子, 或者某结点的兄弟, 只需要查找这个结点的孩子链表即可. 但要知道某结点的双亲是谁比较麻烦, 需要遍历整棵树才行. 双亲孩子表示法: 在孩子表示法的表头数组中, 元素增加一个记录双亲的域. 孩子兄弟表示法 设置两个指针, 分别指向该结点的第一个孩子和右兄弟 12345typedef struct CSNode{ TElemType data; struct CSNode *firstchild, *rightsib;} CSNode, *CSTree; 这种表示法, 查找某个结点的某个孩子只需要找到此结点的长子 firstchild, 再通过遍历长子结点的兄弟 rightsib 找到具体的孩子 这个表示法的最大好处是把一颗复杂的树变成了一颗二叉树 二叉树的定义 二叉树的特点 每个结点最多有两颗子树(左子树和右子树), 即二叉树中不存在度大于2的结点 左子树和右子树是有顺序的, 不能任意颠倒. 即使某结点只有一颗子树也要区分左子树和右子树. 二叉树的五种基本形态 空二叉树 只有一个根结点 根结点只有左子树 根结点只有右子树 树既有左子树也要右子树 特殊二叉树 斜树 所有的结点都只有左子树的二叉树叫作左斜树(从上往下斜); 所有的结点都只有右子树的二叉树叫作右斜树. 特点: 线性表也可以理解为斜树 斜树的结点个数根该树的深度相同 满二叉树 所有的分支结点都存在左子树和右子树, 并且所有叶子都在同一层上, 这样的二叉树称为满二叉树. 特点: 叶子只能出现在最下一层, 出现在其他车就不是满二叉树 非叶子结点的度一定是2 在同样深度的二叉树中, 满二叉树的结点个数最多, 叶子最多 完全二叉树 对一颗具有 n 给结点的二叉树按层序编号, 如果编号为 i(1≤i≤n) 的结点与同样深度的满二叉树中编号 为 i 的结点位置相同, 则这颗二叉树为完全二叉树 (简单点说就是除了最后一层没有满编其他地方与满二叉树都相同) 完全二叉树是满二叉树的必要但不充分条件 完全二叉树的特点: 叶子结点只能出现在最下两层 最下层的叶子一定集中在左部连续位置 倒数两层, 若有叶子结点, 一个都在右部连续位置 同样结点数的二叉树, 完全二叉树的深度最小 二叉树的性质 (下一层结点是上一层的2倍, 得到性质1和2) 性质1 二叉树的第i层上至多有 \\(2^{i-1}\\) 个结点 性质2 深度为k的二叉树至多有 \\(2^{k}-1\\) 个结点 性质3 对任何一颗二叉树T, 如果其终端结点数(叶子数)为 \\(n_0\\) , 度为 2 的结点数为 \\(n_2\\) , 则 \\(n_0=n_2+1\\) (一棵二叉树中, 除了叶子外, 剩下的就是度为 1 或 2 的结点了, 设 \\(n_1\\) 为度为 1 的结点数, 则数的总结点数 \\(n=n_0+n_1+n_2\\)) 性质4 具有 n 个结点的完全二叉树的深度为 \\(\\llcorner\\log_2 n\\lrcorner +1\\) (\\(\\llcorner xxx\\lrcorner\\)表示不大于xxx的最大整数) 深度为 k 的满二叉树的结点数 \\(n=2^k-1\\) , 倒推得到满二叉树的深度为 \\(k=\\log_2 (n+1)\\) . 比如结点数 15 的满二叉树, 深度为 4 . 完全二叉树的叶子只会出现在最下面两层. 结点数一定少于同样深度的满二叉树 \\(2^k-1\\), 但一定多于少一层的满二叉树 \\(2^{k-1}-1\\) 即满足 \\(2^{k-1}-1 &lt; n \\leqslant 2^k-1\\) . \\(n\\leqslant 2^k-1 \\rArr n &lt; 2^k\\) , \\(n &gt; 2^{k-1}-1 \\rArr n \\geqslant 2^{k-1}\\) 因此 \\(2^{k-1}\\leqslant n &lt; 2^k\\) , 不等式两边取对数得 \\(k-1 \\leqslant \\log_2 n &lt; k\\) 所以 \\(k=\\llcorner\\log_2 n\\lrcorner +1\\) 性质5 具有 n 个结点的完全二叉树(深度\\(\\llcorner\\log_2 n\\lrcorner +1\\)) 的结点按层序编号, 对任一结点 i (1≤i≤n) 有: 如果 i=1, 则结点 i 是二叉树的根; 如果 i&gt;1 则双亲是结点 \\(\\llcorner\\frac{i}{2}\\lrcorner\\) 如果 2i&gt;n, 则结点 i 无左孩子(即结点 i 为叶子); 否则其左孩子是结点 2i 如果 2i+1&gt;n, 则结点 i 无右孩子; 否则其右孩子是结点 2i+1 二叉树的存储结构 完全二叉树的存储 二叉树顺序结构是用一维数组存储二叉树中的结点, 并且结点的存储位置(即数组下标)要能体现结点之间的逻辑关系, 比如双亲与孩子的关系, 左右兄弟的关系 将这颗二叉树存入到数组中, 相应的下标对于其同样的位置 完全二叉树存入到数组中, 相应的下标对应同样的位置, 一般的二叉树层序编号不能反映逻辑关系, 但可以将其补全为完全二叉树来编号, 把不存在的结点设置为&quot;^&quot; 但使用这种方式编号也有缺点, 一种机端的情况是一颗深度为 k 的右斜树, 它只有 k 个结点, 却需要分配 \\(2^k-1\\) 个存储单元, 会造成对空间的极度浪费, 所以顺序结构一般只用于完全二叉树 二叉链表 二叉树每个结点最多有两个孩子, 设计一个数据域和两个指针域 结构定义代码如下: 12345typedef struct BiTNode // 结点结构{ TElemType data; struct BiTNode *lchild, *rchild; // 左右孩子指针} BiTNode, *BiTree; 结构示意图: 遍历二叉树 二叉树遍历方法 前序遍历 若二叉树为空, 则空操作返回, 否则 先访问根结点 前序遍历左子树 前序遍历右子树 图中遍历的顺序为:ABDGHCEIF 实现代码如下: 1234567891011/* 二叉树前序遍历递归算法 */void PreOrderTraverse(BiTree T){ if (T == NULL) // 也可用 if (T) 包裹全部 return; printf(&quot;%c&quot;, T-&gt;data); PreOrderTraverse(T-&gt;lchild); // 前序遍历左子树 PreOrderTraverse(T-&gt;rchild); // 前序遍历右子树} 中序遍历 若二叉树为空, 则空操作返回, 否则 从根结点开始(注意不是先访问根结点) 中序遍历根结点的左子树, 然后是访问根结点 中序遍历右子树 图中遍历的顺序为: GDHBAEICF 实现代码如下: 123456789101112/* 二叉树中序遍历递归算法 */void InOrderTraverse(BiTree T){ if (T == NULL) return; InOrderTraverse(T-&gt;lchild); // 中序遍历左子树 printf(&quot;%c&quot;, T-&gt;data); InOrderTraverse(T-&gt;rchild); // 中序遍历右子树} 后序遍历 若二叉树为空, 则空操作返回, 否则 从左到右先叶子后结点的方式遍历访问左右子树 最后是访问根结点 图中遍历的顺序为: GHDBIEFCA 实现代码如下: 123456789void PostOrderTraverse(BiTree T){ if (T == NULL) return; PostOrderTraverse(T-&gt;lchild); // 后续遍历左子树 PostOrderTraverse(T-&gt;rchild); // 后续遍历右子树 printf(&quot;%c&quot;, T-&gt;data);} 层序遍历 若树为空, 则空操作返回, 否则 从树的第一层, 也就是根结点开始访问 从上而下逐层遍历 中同一层中, 按从左到右的顺序对结点逐个访问 推导遍历结果 已知前序遍历序列和中序遍历序列, 能够唯一确定一颗二叉树 已知后序遍历序列和中序遍历序列, 能够唯一确定一颗二叉树 已知前序和后续遍历, 不能唯一确定一颗二叉树 二叉树的建立 要建立一颗普通的二叉树, 将这颗二叉树中每一个结点的空指针引出一个虚结点, 其值为一特定值, 比如&quot;#&quot;. 处理好的二叉树为扩展二叉树, 扩展二叉树能够通过一个&quot;前序&quot;或&quot;后序&quot;遍历序列确定一颗二叉树 (这样就方便用一串字符序列来建立二叉树了) 图中前序遍历序列为AB#D##C## 实现代码如下: 123456789101112131415161718// 按前序输入二叉树中各点的值void CreateBitree(Bitree *T){ TElemType ch; scanf(&quot;%c&quot;, &amp;ch); // 输入结点数据字符 if(ch == '#') *T = NULL; else { *T = (BiTree) malloc(sizeof(BiTNode)); if(!*T) // 如果分配失败 exit(OVERFLOW); (*T)-&gt;data = ch; // 给结点数据域赋值 CreateBiTree(&amp;(*T)-&gt;lchild); // 构造左孩子(子树) CreateBiTree(&amp;(*T)-&gt;rchild); // 构造右孩子(子树) }} 线索二叉树 线索二叉树原理 一个有 n 个结点的二叉链表. 每一个结点有指向左右孩子的两个指针域, 一共有 2n 个指针域. 如图, n 个结点的二叉树一共拥有 n-1 条分支线(根结点无前驱), 存在 2n - (n-1) = n+1 个空指针域 指向前驱和后继的指针称为线索, 加上线索的二叉链表则称为线索链表; 加上线索的的二叉树称为线索二叉树(Threaded Binary Tree) 树的线索化: 中序遍历后(图中为HDIBJEAFCG) 将所有空指针域中的 rchild, 改为指向它的后继结点. 如图, H 的后继是 D, I 的后继是 B, J 的后继是 E, E的后继是 A, F的后继是C, G的后继因为不存在而指向NULL. 此时共有6个空指针域被利用 将这颗二叉树的所有空指针域中的 lchild 改为指向当前结点的前驱. 如图, H 的前驱是 NULL, I 的前驱是 D, J 的前驱是 B, F 的前驱是 A, G 的前驱是 C. 一共5个空指针域被利用. 将上面两种方法整合后, 正好11个空指针域被利用 线索二叉树, 等于是把一颗二叉树转变成了一个双向链表, 对插入删除、查找某个结点都带来了方便. 对二叉树以某种次序遍历使其变为线索二叉树的过程称作是线索化 如图, 空心箭头实线为前驱, 虚线黑箭头为后继 每个结点再增设两个标志域 ltag 和 rtag, ltag 和 rtag 是布尔型变量, 它们的值取决于结点是否存在左右孩子 ltag 为 0 是指向该结点的左孩子, 为 1 时指向该结点的前驱 rtag 为 0 时指向该结点的右孩子, 为 1 时指向该结点的后继 线索二叉树结构实现 二叉树的线索存储结构定义代码如下: 123456789101112// 创建一个枚举类型用来给下面的 LTag, RTag 赋值// Link 的值为 0, 指向左右孩子指针// Thread 的值为 1, 指向前驱或后继typedef eum { Link, Thread } PointerTag;typedef struct BiThrNode{ TElemType data; struct BiThrNode *lchild, *rchild; PointerTag LTag; PointerTag RTag;} BiThrNode, *BiThrTree; 线索化的实现(在遍历二叉树的过程中修改空指针) 实现代码如下: 12345678910111213141516171819202122232425// 中序线索化BiThrTree pre; // 全局变量(因为递归要用), 存储刚刚访问过的结点(当前结点的前驱)void InThreading(BitThrTree p){ if (p) { InThreading(p-&gt;lchild); // 中序遍历 (1/2) if (!p-&gt;lchild) // 若结点无左孩子 { p-&gt;LTag = Thread; // 设置该结点 ltag p-&gt;lchild = pre; // 左孩子指针指向前驱 } if (!pre-&gt;rchild) // 若该结点的前驱没有右孩子 { pre-&gt;RTag = Thread; // 设置前驱的 ltag pre-&gt;rchild = p; // 前驱右孩子指针指向当前结点 } pre = p; // 设置为当前访问的结点 InThreading(p-&gt;rchild); // 中序遍历 (2/2) }} 双向线索链表: 在线索链表上加入一个头结点. 它的 lchild 域指向二叉树根结点; rchild 域指向中序序列最后一个结点. 中序序列第一个结点的 lchild 和最后一个结点的 rchild 域均指向头结点. 这样的优点是方便从第一个结点起顺后继进行遍历, 也能从最后一个结点起顺前驱进行遍历 TODO: 补充图片 遍历双向线索链表: 实现代码如下: 12345678910111213141516171819202122// T 指向头结点// 中序遍历, 时间复杂度为 O(n)int InOrderTraverse_Thr(BitThrTree T){ BitThrTree p; p = T-&gt;lchild; // p 指向根结点 while (p != T) // 空树或遍历结束时, p == T { while (p-&gt;LTag == Link) // 遍历到当前树的最左边 p = p-&gt;lchild; printf(&quot;%c&quot;, p-&gt;data); // 输出结点数据 while (p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T) // 若当前结点p的后继是线索化的, 且p的后继不是头结点 { p = p-&gt;rchild; // 进入后继结点(退到上级) printf(&quot;%c&quot;, p-&gt;data); } p = p-&gt;rchild; // p 进入当前结点的右子树 } return OK;} 如果所用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继, 那么采用线索二叉树的存储结构就是非常不错的选择 树、森林与二叉树的转换 二叉树中, 左孩子代表孩子, 右孩子代表兄弟 树转换为二叉树 加线. 在所有兄弟结点之间加一条线 去线. 对树中每个结点, 只保留它与第一个孩子的连线. (对于作图的)层次调整. 一树的根结点为轴心, 将整棵树顺时针旋转一定的角度, 使之结构层次分明. TODO: 补充图片 森林转换为二叉树 森林是由若干颗树组成的, 可以理解为森林中的每一颗树都是兄弟, 可以按照兄弟的处理方法来操作: 把每个树转换为二叉树 第一款二叉树不懂, 依次把后一颗二叉树的根结点作为前一颗二叉树的根结点的右孩子. TODO: 补充图片 二叉树转换为树 二叉树转换为树就是树转换为二叉树的逆过程 加线. 若某结点的左孩子结点存在, 则将这个左孩子的 n 个右孩子结点都作为此结点的孩子. 将该结点的与这些右孩子结点用线连接 去线. 删除原二叉树中所有结点与其右孩子结点的连线 (对于作图的)层次调整. 使之结构层次分明 TODO: 补充图片 二叉树转换为森林 判断一颗二叉树能否转换成森林, 看二叉树的根结点有右孩子 从根结点开始, 若右孩子存在, 则把与右孩子的连线删除; 再查看分离后的二叉树, 若右孩子存在, 则连线删除…, 直到分离后树的根结点没有右孩子. 再将每颗分离后的二叉树转换为树即可 TODO: 补充图片 树与森林的遍历 树的遍历分为两种方式: 先根遍历. 即先访问树的根结点, 然后依次先根遍历根的每颗子树 后根遍历. 即先依次后根遍历每颗子树, 然后再访问根结点 如图, 先根遍历序列为ABEFCDG, 后根遍历为EFBCGDA TODO: 补充图片 森林的遍历也分为两种方式: 前序遍历: 从左到右依次先根遍历森林中的每棵树 后序遍历: 从左到右依次后根遍历森林中的每棵树 如图, 前序遍历序列为ABCDEFGHJI, 后序遍历序列为BCDAFEJHIG TODO: 补充图片 将森林转换为二叉树后, 森林的前序遍历和二叉树的前序遍历结果相同, 森林的后序遍历和二叉树的中序遍历结果相同 TODO: 补充图片 当以二叉链表作为树的存储结构时, 树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现 赫夫曼树及其应用 赫夫曼定义与原理 TODO: 补充图片 从树中一个结点到另一个结点之间的分支(线段)构成两个结点之间的路径, 路径上的分支(线段)数目称作路径长度 树的路径长度: 从树根到每一结点的路径长度之和 如图, 二叉树 a 中, 根结点到 D 的路径长度为 4 . 二叉树 a 的树路径长度为 1+1+2+2+3+3+4+4=20; 二叉树 b 的树路径为 1+1+2+2+2+2+3+3=16 如果考虑到带权结点, 结点的带权路径长度为: 从该结点到树根之间的路径长度 × 结点的权. 假设有 n 个权值 \\(w_1, w_2, \\dots, w_n\\) , 构造一颗有 n 个叶子结点的二叉树, 每个叶子结点带权 \\(w_k\\) , 每个叶子的路径长度为 \\(l_k\\) , 则其中带权路径长度(WPL)最小的的二叉树称作赫夫曼树(最优二叉树). 二叉树a的 \\(\\text{WPL}=51+152+403+304+104=315\\) 二叉树b的 \\(\\text{WPL}=53+153+402+302+102\\) 它们都不是赫夫曼树 构造赫夫曼树: 先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列. 即: A5, E10, B15, D30, C40 取头两个最小权值的结点作为一个新结点 \\(N_1\\) 的两个叶子, 相对较小的是左孩子, 这里就是A为 \\(N_1\\) 的左孩子, E为 \\(N_1\\) 的右孩子, 新结点的权值为两个叶子权值的和(5+10=15) 用新结点 \\(N_1\\) 替换A与E, 插入有序序列中, 保存从小到大排列. 即: \\(N_1\\)15, B15, D30, C40 重复步骤2和3, \\(N_2=N_1 15+B15=30\\), 有序序列: \\(N_2\\)30, D30, C40 重复步骤2和3, \\(N_3=N_2 30+D30=60\\), 有序序列: \\(N_3\\) 60, C40 重复步骤2. 将\\(N_3\\) 与C作为新结点T的两个叶子, 由于T是根结点, 完成赫夫曼树的构造 WPL=40x1+30x2+15x3+10x4+5x4=205 构造赫夫曼树的赫夫曼算法描述: 根据给定的n个权值 \\(w_1, w_2, \\dots, w_n\\) 构成n颗二叉树的集合 \\(F=T_1, T_2, \\dots, T_n\\) , 其中每颗二叉树 \\(T_i\\) 中只有一个 \\(w_i\\) 的根结点, 其左右子树均为空. 在F中选取两颗根结点的权值最小的树作为左右子树构造一棵新的二叉树, 新的二叉树根结点的权值为其左右子树根结点的权重之和. 在F中删除这两棵树, 同时将新的到的二叉树加入F中 重复2和3步骤, 直到F只含一棵树位置. 这棵树便是赫夫曼树 赫夫曼编码 传输文字内容为&quot;BADCADFEED&quot;, 相应的二进制数据表示如下 字母 A B C D E F 二进制字符 000 001 010 011 100 101 真正传输的数据就是编码后的&quot;01000011010000011101100100011&quot; 假设六个字母的频率(权重)为 A27, B8, C15, E30, F5, 合起来正好是 100%. 完全可以重新按照赫夫曼树来规划它们 TODO: 补充图片 左图为构造赫夫曼树的权值显示. 右图为将权值左分支改为0, 右分支改为1的赫夫曼树 对这六个字母用从树根到叶子所经过路径的0或1来编码, 可以得到如表所示这样的定义: 字母 A B C D E F 二进制字符 01 1001 101 00 11 1000 将文字内容为&quot;BADCADFEED&quot;再次编码, 对比可以看到结果串变小了 数据被压缩了, 节约了大约17%的存储和传输成本. 随着字符的增加和多字符权重的不同, 这种压缩会更加显出其优势. 若要设计长短不等的编码, 则必须是任一字符的编码都不是另一个字符的编码的前缀(否则会造成歧义), 这种编码称作前缀编码 在解码时, 还要用到赫夫曼树, 即发送方和接收方必须要约定好同样的赫夫曼编码规则 设需要编码的字符集为 \\(d_1, d_2, \\dots, d_n\\) , 各个字符在电文中出现的次数(或频率)集合为 \\(w_1, w_2, \\dots, w_n\\) , 以 \\(d_1, d_2, \\dots, d_n\\) 作为叶子结点, 以 \\(w_1, w_2, \\dots, w_n\\) 作为相应叶子结点的权值来构造一颗赫夫曼树. 规定赫夫曼树的左分支代表0, 右分支代表1, 则从根结点到叶子所经过的路径分支组成序列便为该结点对应字符的编码, 也就是赫夫曼编码 图 图的定义 图(Graph)是由顶点构成的有穷非空集合和顶点之间边的集合组成 通常表示为: G(V, E), 其中G表示一个图, V是图G中顶点的集合, E是图G中边的集合 TODO: 补充图片 线性表中数据元素叫元素, 树中数据元素叫结点, 图中数据元素叫顶点(Vertex) 线性表中可以没有数据元素, 称为空表; 树中可以没有结点, 叫作空树; 但图结构中不允许没有顶点. 在定义中, 若V是顶点的集合, 则强调了顶点集合V有穷非空 线性表中, 相邻的数据元素之间具有线性关系; 树结构中, 相邻两层的结点具有层次关系; 图中任意两个顶点之间都可能有关系, 顶点之间的逻辑关系用边来表示, 边集可以是空的 各种图的定义 若顶点 \\(v_i\\) 到 \\(v_j\\) 之间的边没有方向, 则称这条边为无向边(Edge), 用无序偶对 \\((v_i, v_j)\\) 来表示. 如果图中任意两个顶点之间的边都是无向边, 则称该图为无向图(Undirected graphs) TODO: 补充图片 无序对(A,D)也可以写成(D,A) 对于无向图 \\(G_1\\) : \\(G_1=(V_1, \\{E_1\\})\\) 顶点集合 \\(V_1=\\{A, B, C, D\\}\\) 边集合 \\(E_1=\\{(A,B),(B,C),(C,D),(D,A),(A,C)\\}\\) 若从顶点 \\(v_i\\) 到 \\(v_j\\) 的边有方向, 则称这条边为有向边, 也称为弧(Arc). 用有序偶对&lt;\\(v_i\\), \\(v_j\\)&gt;来表示, \\(v_i\\) 称为弧尾(Tail), \\(v_j\\) 称为弧头(Head). 如果图中任意两个顶点之间的边都是有向边, 则称该图为有向图(Directed graphs) TODO: 补充图片 有序对&lt;A,D&gt;, A是弧尾, D是弧头, 不能写成&lt;D,A&gt; 对于有向图 \\(G_2\\) : \\(G_2=(V_2, \\{E_2\\})\\) 顶点集合 \\(V_2=\\{A,B,C,D\\}\\) 弧集合 \\(E_2=\\{&lt;A,D&gt;,&lt;B,A&gt;,&lt;C,A&gt;,&lt;B,C&gt;\\}\\) 无向边用小括号&quot;()“表示, 而有向边用尖括号”&lt;&gt;&quot;表示 在图中, 若同一条边不重复出现(如左图), 且不存在顶点到其自身的边(如右图), 则称这样的图为简单图 TODO: 补充图片 在无向图中, 如果任意两个顶点之间都存在边, 则称该图为无向完全图. 含有n个顶点的无向完全图有 \\(\\frac{n(n-1)}{2}\\) 条边 TODO: 补充图片 在有向图中, 如果任意两个顶点之间都存在方向互为相反的两条弧, 则称该图为有向完全图. 含有n个顶点的有向完全图有 \\(n(n-1)\\) 条边 TODO: 补充图片 有很少条边或弧的图称为稀疏图, 反之称为稠密图. 稀疏和稠密是模糊的概念, 是相对而言的 有些图的边或弧具有权(Weight). 这些权可以表示从一个顶点到另一个顶点的距离或耗费. 这种带权的图通常称为网(Network) TODO: 补充图片 假设有两个图 G=(V,{E}) 和 G’=(V’,{E’}), 如果 V’∈V 且 E’∈E , 则称 G’ 为 G 的子图(Sub-graph) TODO: 补充图片 图的顶点与边间关系 对于无向图 G=(V,{E}) , 如果边 (v, v’)∈E, 则称顶点 v 和 v’ 互为邻接点(Adjacent), 即 v 和 v’ 相邻接. 边 (v,v’) 依附(Incident)于顶点 v 和 v’, 或者说 (v,v’) 与顶点 v 和 v’ 相关联. 顶点 v 的度(Degree)是和 v 相关联的边的数目, 记为 TD(v). 边数是各顶点度数和的一半, 多出的一半是因为重复两次记数, \\(e=\\frac{1}{2}\\displaystyle\\sum_{i=1}^n TD\\{V_i\\}\\) 对于有向图 G=(V,{E}), 如果弧 &lt;v,v’&gt;∈E, 则称顶点 v 和 v’ 互为邻接点. 弧 &lt;v,v’&gt; 和顶点 v, v’ 相关联. 以顶点 v 为头的弧的数目称为 v 的入度(InDegree), 记为 ID(v); 以 v 结尾的弧的数目称为v的出度(OutDegree), 记为 OD(v) 顶点 v 的度为 TD(v)=ID(v)+OD(v), \\(e=\\displaystyle\\sum_{i=1}^n ID\\{V_i\\}=\\displaystyle\\sum_{i=1}^n OD\\{V_i\\}\\) 路径的长度是路径上的边或弧的数目 无向图 G=(V,{E}) 中从顶点 v 到顶点 v’ 的路径(Path)是一个顶点序列 \\(v=v_{i,0},v_{i,1},\\dots,v’=v_{i,m}\\) , 其中 \\((v_{i,j-1},v_{i,j})\\in E, 1\\leqslant j\\leqslant m\\) 如图, 顶点B到D有四种不同路径 如果G是有向图, 则路径也是有向的, 顶点序列应满足 \\(&lt;v_{i,j-1}, v_{i,j}&gt;\\in E, 1\\leqslant j\\leqslant m\\) TODO: 补充图片 第一个顶点和最后一个顶点相同的路径称为回路或环(Cycle). 序列中顶点不重复出现的路径称为简单路径. 除了第一个顶点和最后一个顶点之外, 其余顶点不重复出现的回路, 称为简单回路或简单环 如图, 两图的的粗线都构成环, 左侧属于简单环; 右侧的环由于顶点C的重复不是简单环 TODO: 补充图片 连通图相关术语 在无向图 G 中, 如果从顶点 v 到顶点 v’ 有路径, 则称 v 和 v’ 是连通的. 如果对于图中任意两个顶点 \\(v_i, v_j\\in V\\) , \\(v_i\\) 和 \\(v_j\\) 都是连通的, 则称 G 是连通图(Connected Graph) 如图, 图1显然顶点 A、B、C、D 与顶点 E 或 F 就无路径, 因此不能算是连通图; 图2顶点 A、B、C、D 都是相互连通的, 所以是连通图 TODO:补充图片, 补充下面的图片. (共两张) 无向图中的极大连通子图称为连通分量. 强调: 要是子图 子图是连续的 连通子图含有极大顶点数 具有极大定点数的连通子图包含依附于这些顶点的所有边 比如刚才的图中, 图1是一个无向非连通图. 它有两个连通分量(即图2和图3). 而图4尽管是图1的子图, 但是它不满足连通子图极大顶点数. 因此它不是图1的连通分量 在有向图 G 中, 如果对于每一对 \\(v_i,v_j\\in V \\quad(v_i\\neq v_j)\\) , 从 \\(v_i\\) 到 \\(v_j\\) 和从 \\(v_j\\) 到 \\(v_i\\) 都存在路径, 则称 G 是强连通图. 有向图中的极大强连通子图称作有向图的强连通分量 如图, 图1不是强连通图, 因为 &lt;D,A&gt; 不存在. 图2是强连通图, 且是图1的强连通分量 TODO: 补充图片 连通图的生成树是一个极小连通子图, 它含有图中全部的 n 个顶点, 但只有足以构成一棵树的 n-1 条边 如图, 图1是普通树, 当去掉两条构成环的边后(图2和图3), 就满足 n 个顶点 n-1 条边且连通的定义, 它们都是生成树. 逻辑关系: 多于 n-1 条边 是 构成环 的充分必要条件; 小于 n-1 条边 是 非连通图 的充分必要条件; 等于 n-1 条边 是 生成树 的必要但不充分条件(图4) TODO: 补充图片 如果一个有向图恰好有一个顶点的入读为0, 其余顶点的入度均为1, 则是一个有向树. 入度为 0 相当于树中的根结点, 其余顶点入度为 1 意味着树中非根结点的双亲只有一个. 一个有向图可分解为若干颗不相交的有向树, 它们组成了含有图中全部顶点的生成森林 TODO: 补充图片 总结 按照有无方向: 无向图和有向图 按照边的多少: 稀疏图和稠密图 顶点之间有邻接点的概念, 边有依附的概念. 无向图顶点的边数叫度, 有向图顶点的边分为入度和出度. 图上的边带权则称为网 若路径最终回到起始点称为环, 不重复叫简单路径. 若顶点两两相连， 称为连通图, 有向则称强连通图. 极大连通子图称为连通分量, 有向则称强连通分量 无向图中连通且 n 个顶点 n-1 条边叫生成树. 有向图中一顶点入度为0其余顶点入度为1的叫有向树. 有向图可分解为若干颗有向树构成生成森林 图的抽象数据类型 123456789101112131415161718ADT 图(Graph)Data 顶点的有穷非空集合和边的集合Operation CreateGraph(*G, V, VR) : 按照顶点集合V和边弧集VR的定义构造图G DestroyGraph(*G) : 图G存在则销毁 LocateVex(G, u) : 若图G中存在顶点 u, 则返回图中的位置 GetVex(G, v) : 返回图G中顶点 v 的值 PutVex(G, v, value) : 将图 G 中顶点 v 赋为 value FirstAdjVex(G, *v) : 返回顶点 v 的一个邻接顶点, 若顶点在 G 中无邻接顶点返回 NULL NextAdjVex(G, v, *w) : 返回顶点 v 相对于顶点 w 的下一个邻接顶点, 若 w 是 v 的最后一个邻接点则返回 NULL InsertVex(*G, v) : 在图G中增添新顶点 v DeleteVex(*G, v) : 删除图 G 中顶点 v 及其相关的弧 InsertArc(*G, v, w) : 在图G中增添弧 &lt;v,w&gt;, 若 G 是无向图, 还需要增添对称弧 &lt;w,v&gt; DeleteArc(*G, v, w) : 在图G中删除弧 &lt;v,w&gt;, 若 G 是无向图, 还需要删除对称弧 &lt;w,v&gt; DESTraverse(G) : 对图 G 中进行深度优先遍历, 以在在遍历过程中对每个顶点调用 HFSTraverse(G) : 对图 G 中进行广度优先遍历, 以在在遍历过程中对每个顶点调用endADT 图的存储结构 从图的逻辑结构定义来看, 任意顶点都可看作第一个顶点, 顶点间的逻辑关系与顶点所在位置无关 TODO: 补充图片 邻接矩阵 图的邻接矩阵（Adjacency Matrix)存储方式是用两个数组来表示图. 一个一维数组存储图中顶点信息, 一个二维数组(即邻接矩阵)存储图中的边或弧的信息 设 G 有 n 个顶点, 则邻接矩阵是一个 n×n 的方阵, 定义为: \\(arc[i][j]=\\begin{cases} 1, \\text{若}(v_i, v_j)\\in E \\text{或} &lt;v_i, v_j&gt;\\in E \\\\ 0, 反之 \\end{cases}\\) TODO: 补充图片 顶点数组为 \\(\\text{vertex}[4]=\\{v_0, v_1, v_2, v_3\\}\\) , 边数组 \\(\\text{arc}[4][4]\\) 为右图这样的一个矩阵. 矩阵的主对角线的值全为 0 是因为不存在顶点到自身的边, 无向图的边数组是一个对称矩阵. 对称矩阵就是 n 阶矩阵的元满足 \\(a_{ij}=a_{ji} \\quad(0\\leqslant i, j\\leqslant n)\\) , 即从矩阵左上至右下角的主对角线为轴呈对称关系 特点: 判定任意两顶点是否邻接 要知道顶点 \\(v_i\\) 的度, 可求 \\(v_i\\) 在邻接矩阵中第i行(或第i列)的元素之和(有向图中横向出度统计, 纵向入度统计) 有向图的邻接矩阵 顶点数组为 \\(\\text{vertex}[4]=\\{v_0, v_1, v_2, v_3\\}\\) , 边数组 \\(\\text{arc}[4][4]\\) 为右图这样的一个矩阵. 对角线上数值依旧为0, 此矩阵并不对称 TODO: 补充图片 特点: 有向图讲究入度与出度, 如顶点 \\(v_1\\) 入度为第 i 纵列总和, 出度为第 i 横行总和 判断从顶点 \\(v_i\\) 到 \\(v_j\\) 是否存在弧, 只需要查找矩阵中 arc[i][j] 是否为 1 网图的邻接矩阵 设图 G 是网图, 有 n 个顶点, 则邻接矩阵是一个 n×n 的方阵, 定义为: \\(\\text{arc}[i][j]=\\begin{cases} W_{ij} &amp; \\text{if } (v_i, v_j)\\in E \\text{ or } &lt;v_i, v_j&gt;\\in E \\\\ 0 &amp; \\text{if } i=j \\\\ \\infty &amp; \\text{other} \\end{cases}\\) TODO: 补充图片 ∞ 表示一个计算机允许的、大于所有边上权值的值, 也就是一个不可能的极限值 网图的邻接矩阵存储结构代码: 123456789101112#define MAXVEX 100 // 最大顶点数#define INFINITY 65535 // 用 65535 代替网图邻接矩阵的 ∞typedef char VertexType; // 顶点类型, 假设为 chartypedef int EdgeType; // 边上的权值类型, 假设为 inttypedef struct{ VertexType vexs[MAXVEX]; // 顶点表 EdgeType arc[MAXVEX][MAXVEX]; // 邻接矩阵(边表) int numVertexes, numEdges; // 图的当前顶点数和边数} NGraph; 无向网图的邻接矩阵结构 CreateGraph() : 123456789101112131415161718192021222324void CreateNGraph(NGraph *G){ int i, j, k, w; printf(&quot;输入顶点数和边数:\\n&quot;); scanf(&quot;%d,%d&quot;, &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges); // 给顶点表赋值 for (i = 0; i &lt; G-&gt;numVertexes; i++) scanf(&amp;G-&gt;vexs[i]); // 邻接矩阵初始化 for (i = 0; i &lt; G-&gt;numVertexes; i++) for (j = 0; j &lt; numVertexes; j++) G-&gt;arc[i][j] = INFINITY; for (k = 0; k &lt; G-&gt;numEdges; k++) { printf(&quot;输入边 (v_i, v_j) 的 i、j 和该边的权 w :\\n&quot;); scanf(&quot;%d,%d,%d&quot;, &amp;i, &amp;j, &amp;w); G-&gt;arc[i][j] = w; G-&gt;arc[j][i] = G-&gt;arc[i][j]; // 因为是无向图, 矩阵对称 (有向则没有这句) }} 时间复杂度分析: n 个顶点和 e 条边的无向网图的创建, 时间复杂度为 \\(O(n+n^2+e)\\) 邻接矩阵存储结构对于边数相对顶点较少的图来说极大浪费存储空间 邻接表 数组与链表相结合的存储方法称为邻接表(Adjacency List) 邻接表的处理方法: 顶点用一个一维数组存储. 顶点数组中, 每个元素还有一个指针域, 指向该顶点的第一个邻接点 图中每个顶点的所有邻接点构成一个线性表(存储邻接点在顶点数组中的下标), 由于邻接点的个数不定, 所以用单链表存储 无向图称为顶点 \\(v_i\\) 的边表; 有向图则称为顶点 \\(v_i\\) 的出边表(有向图也可以建立一个逆邻接表, 即为每个顶点建立一个入边表) 对于带权值的网图, 可以在边表顶点定义在再增加一个数据域存储权值 TODO: 补充图片, 补充下一张图片, 补充下一张图片 特点: 要想查某个顶点的度, 就去查这个顶点的边表中顶点的个数. 若要判断顶点 \\(v_i\\) 到 \\(v_j\\) 是否存在边, 只需测试顶点 \\(v_i\\) 的边表中是否存在顶点 \\(v_j\\) 的下标 j . 边表顶点定义代码: 12345678910111213141516171819202122232425#define MAXVEX 100 // 最大顶点数typedef char VertexType; // 顶点类型, 假设为 chartypedef int EdgeType; // 边上的权值类型, 假设为 int// 边表顶点typedef struct EdgeNode{ int adjVex; // 邻接点域, 存储该顶点对应下标 EdgeType weight; // 存储权值, 非网图可以不需要 struct EdgeNode *next;} EdgeNode;// 顶点表元素typedef struct VertexNode{ VertexType data; // 顶点域, 存储顶点信息 EdgeNode *firstEdge; // 该顶点边表的头指针} VertexNode, AdjList[MAXVEX];typedef struct{ AdjList adjList; int numVertexes, numEdges; // 图的当前顶点数和边数} GraphAdjList; 无向图的邻接表结构 CreateGraph() : 123456789101112131415161718192021222324252627282930313233void CreateALGraph(GraphAdjList *G){ int i, j, k; EdgeNode *e; printf(&quot;输入顶点数和边数:\\n&quot;); scanf(&quot;%d,%d&quot;, &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges); for (i = 0; i &lt; G-&gt;numVertexes; i++) { scanf(&amp;G-&gt;adjList[i].data); // 输入顶点信息 G-&gt;adjList[i].firstEdge = NULL; // 初始化边表指针 } for (k = 0; l &lt; G-&gt;numEdges; k++) { printf(&quot;输入边 (v_i, v_j) 上的顶点序号:\\n&quot;); scanf(&quot;%d,%d&quot;, &amp;i, &amp;j); // 创建边表新顶点 e = (EdgeNode*) malloc(sizeof(EdgeNode)); e-&gt;adjVex = j; // 邻接顶点下标为 j // 使用头插法 e-&gt;next = G-&gt;adjList[i].firstEdge; G-&gt;adjList[i].firstEdge = e; // 因为是无向图, 添加对应邻接顶点的边表顶点 (有向则没有下面的内容) e = (EdgeNode*) malloc(sizeof(EdgeNode)); e-&gt;adjVex = i; e-&gt;next = G-&gt;adjList[j].firstEdge; G-&gt;adjList[j].firstEdge = e; }} 时间复杂度分析: 本算法对于 n 个顶点 e 条边来说是 O(n+e) 邻接表的缺陷: 只关心出度问题, 想了解入度就必须遍历整个图 逆邻接表解决了入度却不了解出度的情况 十字链表 把邻接表和逆邻接表结合起来的存储结构叫十字链表(Orthogonal List) TODO: 做成表格 重新定义顶点表顶点结构: data, firstin(指向逆邻接表第一个顶点), firstout(指向邻接表第一个顶点) 重新定义边表顶点结构: tailvex, headvex, headlink, taillink (headlink逆邻接表的下一个顶点, taillink邻接表下一个顶点) TODO: 补充图片(最好把图片改一改, 划分一下区域) 十字链表的优势: 把邻接表和逆邻接表整合在了一起, 容易找到以 \\(v_i\\) 为尾的弧和以 \\(v_i\\) 为头的弧, 容易求得顶点的出度和入度 除了结构复杂一点外, CreateGraph() 的时间复杂度和邻接表相同 邻接多重表 重新定义边表顶点结构: ivex, ilink, jvex, jlink ivex和jvex是某条边依附的两个顶点的下标. link指向依附顶点ivex的下一条边, jlink指向依附顶点jvex的下一条边 ilink指向顶点的jvex一定要和它本身的ivex的值相同 TODO: 补充下下张图片(一张) 邻接多重表和邻接表的区别: 在邻接多重表中同一条边只有一个顶点. 若要删除左图的 \\((v_0, v_2)\\) 这条边, 只需要将右图的 ⑥⑨ 的链接改为 ∧ 即可 边集数组 边集数组是由两个一维数组构成. 一个存储顶点的信息(vexs[MAXVEX]); 另一个存储边的信息(edges[MAXEDGE]) TODO: 做成表格 边数组中每个元素的结构: begin, end, weight TODO: 补充图片 边集数组关注的是边的集合, 在边集数组中要查找一个顶点的度需要扫描整个边数组, 效率并不高. 因此他更适合对边依次进行处理的操作, 而不适合对顶点相关的操作 图的遍历 从图中某一顶点出发访遍图中其余顶点且每个顶点仅被访问一次, 这一过程称为图的遍历(Traversing Graph) 深度优先遍历(Depth First Search) 也称深度优先搜索, 简称DFS. 类似于树的前序遍历 (深度优先指的是: 优先找邻接点, 贯穿整个图) 从图中某个顶点 \\(v_i\\) 出发, 然后从 \\(v_i\\) 周围的(未被访问的)邻接点 \\(v_j\\) 出发找邻接点, 重复此过程直至图中所有和 \\(v_i\\) 有路径相通的顶点都被访问到. 以上说的只是连通图, 对于非连通图, 只需要对它的连通分量分别进行深度优先遍历. 即进行一次深度优先遍历后, 若图中尚有顶点未被访问, 则另选图个一个未被访问的顶点作为起始点, 再次进行深度优先遍历. 重复此过程直到所有顶点都被访问过 访问数组 visited[n], n 是图中顶点的个数, 数组中元素初值为 0, 访问后为 1 邻接矩阵的深度优先遍历算法: 12345678910111213141516171819202122232425262728293031typedef enum { false, true } bool; // C++ 中自带 bool 类型, 可以不用这句bool visited[MAX]; // MAX 等于图的 numVertexes// 邻接矩阵的深度优先递归算法, i 为当前遍历顶点的下标void DFS(MGraph G, int i){ int j; visited[i]=true; printf(&quot;%c&quot;, G.vexs[i]) // 打印顶点数据, 也可以是其他操作 for (j = 0; j &lt; G.numVertexes; j++) { if (G.arc[i][j] == 1 &amp;&amp; !visited[j]) // 找任何与 v_i 邻接的邻接点(未被访问过的) DFS(G, j); // 对要访问的邻接点递归调用 DFS() }}// 从这个函数开始void DFSTraverse(MGraph G){ int i; // 初始化 visited 数组 for (i = 0; i &lt; G.numVertexes; i++) visited[i] = false; for (i = 0; i &lt; G.numVertexes; i++) if (!visited[i]) DFS(G, i); // 对未访问过的顶点调用 DFS() (若是连通图这行代码只会执行一次)} 对于邻接表结构的图, DFS() 会稍有不同 邻接表的深度优先遍历算法: 123456789101112131415161718192021222324252627282930313233typedef enum { false, true } bool; // C++ 中自带 bool 类型, 可以不用这句bool visited[MAX]; // MAX 等于图的 numVertexes// i 为当前遍历顶点的下标void DFS(GraphAdjList GL, int i){ EdgeNode *p; visited[i] = true; printf(&quot;%c&quot;, GL-&gt;adjList[i].data); p = GL-&gt;adjList[i].firstEdge; while (p) { if (!visited[p-&gt;adjVex]) DFS(GL, p-&gt;adjvex); // 对要访问的邻接点递归调用 DFS() p = p-&gt;next; }}void DFSTraverse(GraphAdjList GL){ int i; // 初始化 visited 数组 for (i = 0; i &lt; GL-&gt;numVertexes; i++) visited[i] = false; for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (!visited[i]) DFS(GL, i); // 对未访问过的顶点调用 DFS() (若是连通图这行代码只会执行一次)} 时间复杂度分析: 如果是邻接矩阵结构表示的图, 每次找邻接点都需要把顶点下标遍历一遍, 时间复杂度 \\(O(n^2)\\) 而邻接表结构表示的图, 找邻接点所需时间取决于该顶点的出边数量, 时间复杂度 \\(O(n+e)\\) 对于点多边少的稀疏图来说, 邻接表结构的优势更大 广度优先遍历(Breadth First Search) 也称广度优先搜索, 简称BFS. 类似于树的层序遍历 如图, 将第一幅图稍微变形. 规则是顶点 A 放置在最上第一层, 使与它邻接的顶点 B、F 为第二层, 再让与 B 和 F 邻接的 C、I、G、E 为第三层, 再将与这四个顶点邻接的 D、H 放在第四层. TODO: 补充图片 邻接矩阵的广度优先遍历算法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344typedef enum { false, true } bool; // C++ 中自带 bool 类型, 可以不用这句bool visited[MAX]; // MAX 等于图的 numVertexesvoid BFSTraverse(MGraph G){ int i, j, k; Queue Q; // 临时存储顶点下标用队列 // 初始化 visited 数组 for (i = 0; i &lt; G.numVertexes; i++) visited[i] = false; InitQueue(&amp;Q); // 初始化队列 for (i = 0; i &lt; G.numVertexes; i++) { if (!visited[i]) // 对未访问过的顶点进行广度优先遍历 (若是连通图 if 内的代码只会执行一次) { // 将起始顶点进行打印等操作后加入队列 visited[i] = true; // 将当前顶点设置为被访问过 printf(&quot;%c&quot;, G.vexs[i]); // 打印顶点, 也可以是其他操作 EnQueue(&amp;Q, i); // 将此顶点加入队列 while (!QueueEmpty(Q)) // 若当前队列不为空 { DeQueue(&amp;Q, &amp;k); // 将队列中元素取出赋给变量 k for (j = 0; j &lt; G.numVertexes; j++) { if (G.arc[k][j] == 1 &amp;&amp; !visited[j]) // 遍历当前顶点 v_k 的邻接点并加入队列 { visited[j] = true; // 将找到的邻接点设置为已访问 printf(&quot;%c&quot;, G.vexs[j]); // 打印顶点, 也可以是其他操作 EnQueue(&amp;Q, j); } } } } }} 邻接矩阵的广度优先遍历算法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef enum { false, true } bool; // C++ 中自带 bool 类型, 可以不用这句bool visited[MAX]; // MAX 等于图的 numVertexesvoid BFSTraverse(GraphAdjList GL){ int i; EdgeNode *p; Queue Q; // 临时存储顶点下标用队列 // 初始化 visited 数组 for (i = 0; i &lt; GL-&gt;numVertexes; i++) visited = false; InitQueue(&amp;Q); for (i = 0; i &lt; GL-&gt;numVertexes; i++) { if (!visited[i]) { visited[i] = true; printf(&quot;%c&quot;, GL-&gt;adjList[i].data); // 打印顶点, 也可以是其他操作 EnQueue(&amp;Q, i); // 起始顶点加入队列 while (!QueueEmpty(Q)) { DeQueue(&amp;Q, &amp;i); // 遍历该顶点的边表 p = GL-&gt;adjList[i].firstEdge; while (p) { if (!visited[p-&gt;adjVex]) // 若此顶点未被访问 { visited[p-&gt;adjVex] = true; printf(&quot;%c&quot;, GL-&gt;adjList[p-&gt;adjVex].data); // 打印顶点, 也可以是其他操作 EnQueue(&amp;Q, p-&gt;adjVex); // 将此顶点加入列 } p = p-&gt;next; } } } }} 时间复杂度分析: 图的深度优先算法的时间复杂度和广度优先算法一样, 不同之处仅在于对顶点的访问次序. 深度优先算法更适合目标比较明确的, 以找到目标为主要目的的情况; 而广度优先算法更适合在不断扩大的遍历范围时找到相对最优解的情况 最小生成树 最小生成树: 将一个连通加权无向图变为生成树(即只剩 n-1 条边), 其中权值总和最小的生成树就叫最小生成树 普里姆(Prim)算法 TODO: 补充图片 思路: 设 adjVex[j] 存储当前到顶点 j 权值最小的顶点, lowCost[j] 存储当前已知的到顶点 j 最小的权值. 将 adjVex 和 lowCost 初始化为顶点 v_0 到其他点的权值(读取邻接矩阵第 v_0 行) 从 v_0 开始, 将 v_0 到附近顶点的权重计入数组 lowCost, 将 lowCost 中权重最小的下标作为最小生成树的下一个顶点(假设为 v_k) 再将 v_k 到附近的点(假设为 v_j)的权重与当前数组 lowCost[j] 对应的值比较, 如果 v_k 到 v_j 的权重更小则计入 lowCost[j]. 重复, 将 lowCost 中权重最小的下标作为生成树的下一个顶点…直到所有顶点都被纳入最小生成树中(每次循环增加一个顶点, 所以循环 MAXVEX 次). 实现代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#define INFINITY 65535// Prim 算法生成最小生成树void MiniSpanTree_Prim(MGraph MG){ int min, i, j, k; int adjVex[MAXVEX]; // 存储当前到顶点 j 权值最小的顶点 int lowCost[MAXVEX]; // 存储当前已知的到顶点 j 最小的权值. adjVex[0] = 0; // 初始顶点为 v_0 顶点 lowCost[0] = 0; // 值为 0 表示该顶点被纳入最小生成树 for (i = 1; i &lt; MG.numVertexes; i++) // 遍历除下标为0外的全部顶点 { lowCost[i] = MG.arc[0][i]; // 读取矩阵第一行数据赋给lowCost adjVex[i] = 0; } for (i = 1; i &lt; MG.numVertexes; i++) { min = INFINITY; k = 0; // 从 lowCost 找当前最小的权值, 以作为生成树的下一个顶点(设下一个顶点为 v_k) for (j = 1; j &lt; MG.numVertexes; j++) { if (lowCost[j] != 0 &amp;&amp; lowCost[j] &lt; min) // lowCost[j] != 0 排除已纳入最小生成树的顶点 { min = lowCost[j]; k = j; } } printf(&quot;(%d, %d)&quot;, adjVex[k], k); // 打印最小生成树的边, 可以是其他操作 lowCost[k] = 0; // 将 v_k 纳入最小生成树中 // 找 v_k 到邻接点的权值, 如果更小则更新 lowCost 和 adjVex for (j = 1; j &lt; MG.numVertexes; j++) { // 如果顶点 v_k 到附近的邻接点权值比起始点到那个点小 if (lowCost[j] != 0 &amp;&amp; MG.arc[k][j] &lt; lowCost[j]) // 查找邻接矩阵第 k 行的各个权值 { adjVex[j] = k; // 从 v_k 点到 v_j 点权值更低 lowCost[j] = MG.arc[k][j]; // 设置当前到 v_j 的最小权值 } } }} 时间复杂度分析: 由算法代码中的循环嵌套可得知此算法的时间复杂度为 \\(O(n^2)\\) 克鲁斯卡尔(Kruskal)算法 将邻接矩阵转化为右图所示的边集数组, 将它们按权值从小到大排序, 且 begin &lt; end 然后按权值从小到大的顺序开始生成最小生成树, 如果这条边的两个顶点都已经被纳入最小生成树(即这两个顶点已经相通), 跳过这条边 TODO: 补充图片 如何判断两个顶点已经相通呢? 使用并查集思想, 见下面具体代码 实现代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243// 边集数组 Edge 的元素结构typedef struct{ int begin; int end; int weight;} Edge;// 查找该顶点的最终好友int Find(int *buddy, int f){ while (buddy[f] &gt; 0) // 如果该顶点有好友(好友指可以不邻接但是已经连通) f = buddy[f]; // 从它的好友开始继续判断还有无别的好友 return f;}// Kruskal 算法生成最小生成树void MiniSpanTree_Kruskal(MGraph G){ int i, n, m; Edge edges[MAXEDGE]; // 边集数组, MAXEDGE 为原图的边数 int buddy[MAXVEX]; // 定义数组 buddy 来帮助判断边与边是否形成环路 // 这里用到了并查集思想 // 即 buddy[a]==c, buddy[b]==d, 若 buddy[c]==buddy[d] 则说明 a 已经连通 b // 初始化数组 buddy for (i = 0; i &lt; G.numVertexes; i++) { buddy[i] = 0; // 初始化为 0 是因为边集的 end 不可能是 0 } // 依次遍历 edge 数组 for (i = 0; i &lt; G.numEdges; i++) { n = Find(buddy, edges[i].begin); m = Find(buddy, edges[i].end); if (n != m) // n != m 代表这条边两个顶点的最终好友不同(所以还未连通) { buddy[n] = m; // 将这两个顶点建立好友关系 printf(&quot;(%d, %d) %d&quot;, edges[i].begin, edges[i].end, edges[i].weight) // 打印最小生成树的边, 可以是其他操作 } }} 实际复杂度分析: 设 n 为边数, 克鲁斯卡尔算法的时间复杂度为 \\(O(n\\log n)\\) (其中 Find() 函数时间花费 \\(O(\\log n\\)) 克鲁斯卡尔算法主要是针对边来展开, 边数少时效率会非常高, 对于稀疏图有很大的优势; 普里姆算法对于稠密图, 即边数非常多的情况会更好一些 最短路径 非网图的最短路径, 是指两顶点之间经过的边数最少的路径; 网图的最短路径是指两顶点之间经过的边上权值之和最少的路径. 称路径上的第一个顶点是源点, 最好一个顶点是终点 距离就是两顶点间权值之和, 非网图可理解为所有边权值都为 1 的网图 迪杰斯特拉(Dijkstra)算法 思路 设起始点为 v_0, PathWeight 存储 v_0 到各点的最短路径权值和, PathPrior[w] 存储 v_0 到 v_w 最短路径中 v_w 的前驱 从 v_0 开始, 首先找到 v_0 权值最小的邻接点 v_k, 将其纳入最短路径并接着找 v_k 的邻接点, 继而将 v_k 的邻接点到 v_0 路径的权值纳入 PathWeight (别忘了同时更新 PathPrior) 这样一番操作之后, v_0 到 v_k 的那些邻接点的权值就不再是 ∞ 了(即被认为和 v_0 连通), 继续按照这种方式遍历剩下的和 v_0 连通的顶点和它们的邻接点, 发现权值和更小的就更新 PathWeight 和 PathPrior. 直到所有顶点都被纳入最短路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#define MAXVEX 9#define INFINITY 65535typedef int PathPrior[MAXVEX] // 用于存储最短路径对应顶点前驱的数组, 即 PathPrior[w] == k 代表从 v_0 到 v_w 的最短路径中, v_w 的前驱是 v_k (接着持续遍历即可得到完整的最短路径)typedef int PathWeight[MAXVEX]; // 用于存储到各点最短路径的权值和// v_0 为起始点, PathPrior 为用于存储到各个点最短路径的数组, void ShortestPath_Dijkstar(MGraph G, int v_0, PathPrior pathPrior, PathWeight pathWeight){ int v, w, k, min; int final[MAXVEX]; // 标记已求得最短路径的顶点, final[w] = 1 表示已经求得顶点v_0到 v_w 的最短路径 // 初始化这三个数组 for (v = 0; v &lt; G.numVertexes; v++) { final[v] = 0; pathWeight[v] = G.arc[v_0][v]; // 将 v_0 到各点的权值依次赋给 pathWeight pathPrior[v] = 0; } final[v_0] = 1; // v_0 到 v_0 不需要路径 for (v = 1; v &lt; G.numVertexes; v++) { min = INFINITY; // 遍历 v_0 当前到各个顶点的权值, 记录 v_0 权值最小的(未被记录到路径中的)邻接点 for (w = 0; w &lt; G.numVertexes; w++) { if (!final[w] &amp;&amp; pathWeight[w] &lt; min) { k = w; min = pathWeight[w]; } } final[k] = 1; // 将此邻接点纳入最小路径 // 此时 v_k 为 v_0 附近(刚纳入最小路径)权值最小的邻接点 for (w = 0; w &lt; G.numVertexes; w++) { // 遍历 v_k 到各点(设为 v_w)的权值, 加上 v_i 到 v_k 的权值, 然后与 pathWeight 当前存储的到 v_w 的值比较 // 如果比现有记录的短, 更新到 pathWeight 和 pathPrior 中 if (!final[w] &amp;&amp; (G.arc[k][w] + min &lt; pathWeight[w])) { pathWeight[w] = min + G.arc[k][w]; pathPrior[w] = k; } } }} 时间复杂度分析: 从嵌套循环得到此算法的时间复杂度为 \\(O(n^2)\\) 弗洛伊德(Floyd)算法 该算法可求得图中任意顶点到顶点间的最短路径, 用矩阵(二维数组) PathMatrix 和 PathWeight 存储 原理也很简单, 具体实现如下: 123456789101112131415161718192021222324252627282930313233typedef int PathMatrix[MAXVEX][MAXVEX];typedef int PathWeight[MAXVEX][MAXVEX];void ShortestPath_Floyd(MGraph G, PathMatrix pathMatrix, PathWeight pathWeight){ int v, w, k; for (v = 0; v &lt; G.numVertexes; v++) { for (w = 0; w &lt; G.numVertexes; w++) { pathWeight[v][w] = G.arc[v][w]; // 初始化与网图的邻接矩阵保持一致 pathMatrix[v][w] = w; // 初始化为 pathMatrix[v][j] == j } } // 每次试探一个中继顶点都会将表中所有顶点间的当前路径检测一遍, 所有不用担心会有漏的. (因此嵌套顺序不能变) for (k = 0; k &lt; G.numVertexes; k++) { for (v = 0; v &lt; G.numVertexes; v++) { for (w = 0; w &lt; G.numVertexes; w++) { // 如果从 v_v 到 v_w, 经过下标为 k 的顶点路径比当前记录的更短 if (pathWeight[v][w] &gt; pathWeight[v][k] + pathWeight[k][w]) { pathWeight[v][w] = pathWeight[v][k] + pathWeight[k][w]; pathMatrix[v][w] = pathMatrix[v][k]; // 路径设置经过顶点 k } } } }} 输出弗洛伊德算法得到的最短路径: 12345678910111213141516for (v = 0; v &lt; G.numVertexes; v++){ for (w = v + 1; w &lt; G.numVertexes; w++) { printf(&quot;v%d-v%d weight: %d&quot;, v, w, pathWeight[v][w]); // 打印这条最短路径的权 k = pathMatrix[v][w]; printf(&quot; path: %d&quot;, v); // 打印源点 while (k != w) // 如果路径顶点不是终点 { printf(&quot; -&gt; %d&quot;, k); // 打印路径顶点 k = pathWeight[k][w]; // 获得下一个路径顶点 } printf(&quot; -&gt; %d\\n&quot;, w); // 循环结束, 说明抵达终点, 打印终点 } printf(&quot;\\n&quot;);} 时间复杂度分析: 时间复杂度为 \\(O(n^3)\\) 拓补排序 拓扑排序介绍 无环: 没有回路的图 AOV 网(Activity On Vertex Network): 用顶点表示活动, 用弧表示活动之间的优先关系. AOV 网中不能存在回路, 属于有向无环图 如图所示就是一个 AOV 网(图中省略了权值)和它的邻接表形式数据结构 TODO: 补充图片(在拓扑排序算法那里) 拓扑序列: 设 G=(V, E) 是一个具有 n 个顶点的有向图 满足若从顶点 \\(v_i\\) 到 \\(v_j\\) 有一条路径, 则在顶点序列 V 中 \\(v_i\\) 必在 \\(v_j\\) 之前. 称 V 为拓扑序列 拓扑排序: 对一个有向图构造拓扑序列的过程. 构造时会有两个结果: 如果此网的全部顶点都被输出, 说明这个网图不存在环(回路), 是 AOV 网 如果输出顶点数少了, 说明这个网图存在环(回路), 不是 AOV 网 拓扑排序算法 拓扑排序的基本思路是: 从网中选择一个入度为 0 的顶点输出, 然后删去此顶点, 并删除此顶点的出边, 继续重复此步骤, 直到输出全部顶点(是 AOV 网)或者网中不存在入度为 0 的顶点为止(不是 AOV 网) 以邻接表形式表达该网图. 考虑到算法要查找入度为 0 的顶点, 因此在原来的顶点表结点结构中, 增加一个入度域 in 以记录一个顶点的入度: 12345678910111213141516171819typedef struct EdgeNode // 边表结点{ int adjVex; int weight; struct EdgeNode *next;} EdgeNode;typedef struct VertexNode // 顶点表结点{ int in; // 增加了这个入度域 int data; EdgeNode *firstEdge;} VertexNode, AdjList[MAXVEX];typedef struct{ AdjList adjList; int numVertexes, numEdges;} GraphAdjList; 在算法中还需要栈来存储处理过程中入度为 0 的顶点, 目的是避免每次查找时都要遍历顶点表中有没有入度为 0 的顶点. 实现代码如下: 123456789101112131415161718192021222324252627282930313233int TopoLogicalSort(GraphAdjList GL){ EdgeNode *e; int i, k, gettop; // gettop 存储当前出栈元素 int top = -1; // 栈的 top 指针 int count = 0; // 用于统计输出顶点数 int *stack = (int*) malloc(GL-&gt;numVertexes * sizeof(int)); // 用于存储入度为 0 的顶点, 根据顶点数分配内存空间 // 遍历顶点表, 将入度为 0 的顶点入栈 for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (GL-&gt;adjList[i].in == 0) stack[++top] = i; while (top != -1) { gettop = stack[top--]; // 出栈 count++; // 统计输出顶点数 printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data); // 打印此顶点, 可更改为其他操作 for (e = GL-&gt;adjList[gettop].firstEdge; e; e = e-&gt;next) // 遍历此顶点的出边(中的邻接点) { k = e-&gt;adjVex; if (--GL-&gt;adjList[k].in == 0) // 若失去此顶点后邻接点的入度变为 0, 将邻接点也加入到栈中 stack[++top] = k; } } if (count &lt; GL-&gt;numVertexes) // 如果count小于顶点数, 说明存在环, 不是 AOV 网 return -1; else return OK;} 时间复杂度分析: 对于具有 n 条顶点 e 条弧的网图, 时间复杂度为 O(n+e) 关键路径 AOE 网(Activity On Edge Network): 用顶点表示时间, 用有向边表示活动, 用边上的权值表示活动的持续时间. AOE 网是有向图 AOE 网中没有入边的顶点称为始点或源点, 没有出边的顶点称为终点或汇点 如图, \\(v_0\\) 是源点, 表示一个工程的开始, \\(v_9\\) 是汇点, 表示整个工程的结束, 顶点 \\(v_0, v_1, \\dots, v_9\\) 分别表示事件, 弧 \\(&lt;v_0, v_1&gt;\\), \\(&lt;v_0, v_2&gt;\\), …, \\(&lt;v_8, v_9&gt;\\) 都表示一个活动, 用 \\(a_0, a_1, \\dots, a_12\\) 表示, 它们的值(权值)代表着活动持续的事件 TODO: 补充图片 AOV 与 AOE 的区别 AOV 用顶点表示活动, 它只描述活动之间的制约关系; AOE 用边表示活动, 要建立在活动之间制约关系没有矛盾的基础之上. 用于分析完成整个工程至少需要多少时间, 或者为了缩短工程所需时间, 应当加快哪些活动等问题. TODO: 补充图片(2张) 关键路径: 从源点到汇点具有最大长度的路径叫关键路径 关键路径算法原理 定义如下几个参数: 事件最早发生时间 etv (earliest time of vertex) 事件最晚发生时间 ltv (latest time of vertex) 活动最早开工时间 ete (earliest time of edge) 活动最晚开工时间 lte (latest time of edge) 某条路径上的活动, 最早开工时间和最晚开工时间如果相等意味着该路径上的活动不可延后, 是关键活动, 该路径为关键路径 由 1 和 2 可以求得 3 和 4, 然后根据 ete[k] 是否与 lte[k] 相等来判断 \\(a_k\\) 是否是关键活动 关键路径算法 以邻接表结构表达 AOE 网, 弧链表增加了 weight 域, 用来存储弧的权 TODO: 补充图片 计算顶点 \\(v_k\\) 的 etv[k] 的数学定义是: TODO: 补充图片 求事件最早发生事件 etv 的过程, 可放在拓扑排序算法中. 因此在求关键路径之前, 需要先调用一次拓扑排序算法来得到 etv 和拓扑序列列表. 秘诀: 从前面加权是最早时间, 从后面减权是最晚时间 实现代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091int *etv, *ltv; // 事件最早发生时间和最晚发生时间数组int *stack2; // 用于存储拓扑序列的栈int top2; // 用于栈 stack2 的指针// 改进过的拓扑排序算法int TopoLogicalSort(GraphAdjList GL){ EdgeNode *e; int i, k, gettop; int top = -1; // 栈的 top 指针 int count = 0; // 用于统计输出顶点个数 int *stack = (int*) malloc(GL-&gt;numVertexes * sizeof(int)); // 用于存储入度为 0 的顶点, 根据顶点数分配内存空间 // 遍历顶点表, 将当前入度为 0 的顶点入栈 for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (GL-&gt;adjList[i].in == 0) stack[++top] = i; etv = (int*) malloc(GL-&gt;numVertexes * sizeof(int)); // 给 etv 分配空间 for (i = 0; i &lt; GL-&gt;numVertexes; i++) etv[i] = 0; // 初始化 etv 数组, 每个顶点的 etv 默认为 0 stack2 = (int*) malloc(GL-&gt;numVertexes * sizeof(int)); // 给存储拓扑序列的栈分配空间 top2 = -1; // 空栈的 top 指针默认为 -1 while (top != -1) { gettop = stack[top--]; // 将入度为 0 的顶点出栈 count++; stack2[++top2] = gettop; // 将弹出的顶点下标压入存储拓扑序列的栈 stack2 中 // 遍历当前顶点的弧链表, 看是否有失去当前结点后入度为 0 的邻接点 for (e = GL-&gt;adjList[gettop].firstEdge; e; e = e-&gt;next) { k = e-&gt;adjVex; // k 为当前顶点的邻接点 if (--GL-&gt;adjList[k].in == 0) // 若 k 的入度 -1 后为 0 stack[++top] = k; // 入栈 // 若当前顶点(gettop)的 etv 加上当前顶点到 k 所需的时间大于已记录的 etv[k] if ((etv[gettop] + e-&gt;weight) &gt; etv[k]) etv[k] = etv[gettop] + e-&gt;weight; // 更新 etv[k], 因为 k 的前置活动(顶点 gettop)首先要完成 } } if (count &lt; GL-&gt;numVertexes) // 如果 count 小于顶点数, 说明存在环 return -1; else return OK;}void CriticalPath(GraphAdjList GL){ EdgeNode *e; int i, gettop, k, j; int ete, lte; // 活动最早发生时间和最晚发生时间 TopoLogicalSort(GL); // 求拓扑序列, 得到 etv 和 stack2 ltv = (int*) malloc(GL-&gt;numVertexes * sizeof(int)); // 事件的最晚发生时间 for (i = 0; i &lt; GL-&gt;numVertexes; i++) ltv[i] = etv[GL-&gt;numVertexes - 1]; // 初始化 ltv 数组, 每个顶点的 ltv 默认为最后一个事件发生的时间 while (top2 != -1) { gettop = stack2[top2--]; // 拓扑序列出栈(序列从后往前遍历) // 遍历顶点 gettop 的弧链表 for (e = GL-&gt;adjList[gettop].firstEdge; e; e = e-&gt;next) { k = e-&gt;adjVex; // 顶点 k 为顶点 gettop 的下一个事件 // 若该顶点 gettop 到下一个顶点 k 的最晚时间小于当前记录的最晚发生时间 if (ltv[k] - e-&gt;weight &lt; ltv[gettop]) ltv[gettop] = ltv[k] - e-&gt;weight; // 更新 ltv[gettop] } } for (j = 0; j &lt; GL-&gt;numVertexes; j++) { for (e = GL-&gt;adjList[j].firstEdge; e; e = e-&gt;next) { k = e-&gt;adjVex; ete = etv[j]; // 活动(当前的弧)最早开工时间等于(当前弧尾)最早发生时间 lte = ltv[k] - e-&gt;weight; // 活动(当前的弧)最晚开工时间 为 下个事件(弧头)的最晚发生事件减去当前活动所需时间 if (ete == lte) // 如果最早开工时间和最晚开工时间相同(开工时间无法延后), 说明当前路径为关键路径 printf(&quot;&lt;v%d, v%d&gt; length: %d, &quot;, GL-&gt;adjList[j].data, GL-&gt;adjList[k].data, e-&gt;weight); } }} 时间复杂度分析: 拓扑排序 \\(O(n+e)\\) + 初始化 ltv \\(O(n)\\) + 求 ltv \\(O(n+e)\\) + 检测是否关键路径 \\(O(n+e)\\) 所以最早时间复杂度依然是 \\(O(n+e)\\) 查找 查找概论 查找(Searching)就是根据给定的值, 在查找表中确定给定值与记录的关键字相同的记录(数据元素) 关键字(Key): 记录中某个数据项的值, 又称键值 主关键字(Primary Key): 唯一地标识一个记录的关键字(用主关键字查找只会返回唯一的一条记录) 次关键字(Secondary Key): 多个记录共有的关键字(用次关键字查找会返回所有含有该关键字的记录) 查找表(Search Table): 由同一类型的记录构成的集合 静态查找表(Static Search Table): 只作查找操作的查找表 动态查找表(Dynamic Search Table): 可在查找过程的同时插入查找表中不存在的记录, 或者从查找表中删除已存在的某个记录 顺序表查找 顺序查找(Sequential Search)又叫线性查找, 是最基本的查找技术 查找过程是: 从表中第一个(或最后一个)记录开始, 逐个进行对给定值和记录的关键字比较 若某个记录的关键字和给定值相等, 则查找成功, 找到所查的记录 如果直到最后一个(或第一个)记录, 没有与给定值相等的关键字, 则表中没有所查的记录, 查找失败 顺序表查找算法:12345678910int Sequential_Search(int *searchTable, int length, int key){ int i; for (i = 1; i &lt;= length; i++) if (searchTable[i] == key) return i; // 若查找成功, 返回查找到的记录在记录表中的下标 return -1; // 查找不成功} 顺序表查找优化 设置一个哨兵, 可以免去 for 循环本身的比较12345678910111213// 查找表 searchTable 的第一个下标需要预留给哨兵int Sequential_Search(int *searchTable, int length, int key){ int i; searchTable[0] = key; // 设置哨兵, 它的关键字为给定值 // 循环从数组尾部开始 i = length - 1; while (searchTable[i] != key) i--; return i; // 若返回的是哨兵的未知(下标0), 说明查找失败} 时间复杂度分析: 时间复杂度为 \\(O(n)\\), 顺序查找算法在 n 很大时, 查找效率极为低下. 优点是算法非常简单, 对静态查找表的记录没有任何要求. 在一些小型数据的查找时, 是可以适用的. 如果对表进行排序, 将查找频率高的记录放在前面, 不常用的放在后面, 效率可以大幅提高. 有序表查找 折半查找(Binary Search)技术, 又称为二分查找. 前提是线性表中的记录必须是关键字有序(通常从小到大有序), 且线性表必须采用顺序存储. 折半查找的思想: 在有序表中, 取中间记录作为比较对象, 若给定值与中间记录的关键字相等, 则查找成功; 若给定值小于中间记录的关键字, 则在中间记录的左半区继续查找; 若给定值大于中间记录的关键字, 则在中间记录的右半区继续查找. 不断重复上述过程, 直到查找成功, 或者没有所查的记录, 查找失败 实现代码如下: 1234567891011121314151617181920int Binary_Search(int *searchTable, int length, int key){ int low, high, mid; low = 0; // 定义最低下标为查找表首位 high = length - 1; // 定义最高下标为查找表末尾 while (low &lt;= high) { mid = (low + high) / 2; // 折半 if (key &lt; searchTable[mid]) // 若给定值比当前中值小 high = mid - 1; else if (key &gt; searchTable[mid]) // 若给定值比当前中值小大 low = mid + 1; else return mid; // 若相等返回该下标 } return -1; // 循环结束, 没有找到所查记录, 查找失败} 折半算法的时间复杂度为 \\(O(\\log n)\\) 插值查找(Interpolation Search) 折半查找可改进为 \\(\\text{mid}=\\text{low}+\\frac{\\text{key}-\\text{searchTable[low]}}{\\text{searchTable[high]-searchTable[low]}}(\\text{high}-\\text{low})\\) 即通过计算 key 在当前 (high-low) 这段中的大致位置, 可以更快的跳转到目标位置. 在折半查找算法的代码中改动如下 12- mid = (low + high) / 2; // 折半+ mid = low + (key - searchTable[low]) / (searchTable[high] - searchTable[low]) * (high - low) 插值查找时间复杂度同样为 \\(O(\\log n)\\) 对于表长较大, 关键字分布又比较均匀的查找表, 插值查找算法的平均性能比折半查找要好得多 斐波那契查找 根据斐波那契数列的性质来二分 TODO: 补充图片(需要将图中-1的部分修掉) 1234567891011121314151617181920212223242526272829303132333435363738// Fibonacci[k] 为斐波那契数列, | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 | 89 | 144 |int Fibonacci_Search(int *searchTable, int length, int key){ int low, high, mid, i, k; low = 0; high = length - 1; k = 0; while (length &gt; Fibonacci[k] - 1) // 取得 n 位于斐波那契数列中的位置 k++; for (i = length, i &lt; Fibonacci[k]; i++) // 数组的大小要与斐波那契查找对应值相等, 将不满的用最后一个记录的值补全 searchTable[i] = searchTable[length - 1]; while (low &lt;= high) { mid = low + Fibonacci[k - 1]; if (key &lt; searchTable[mid]) // 若查找记录小于当前分隔记录 { high = mid - 1; k--; // 斐波那契数列下标减一位 } else if (key &gt; searchTable[mid]) // 若查找记录大于当前分隔记录 { low = mid + 1; k -= 2; // 斐波那契数列下标减两位, 因为Fibonacci[k-2]+Fibonacci[k-1]=Fibonacci[k] } else { if (mid &lt;= length) return mid; // 若相等则说明 mid 即为查找到的位置 else return length - 1; // 若 mid &gt; n 说明是补全数值, 返回 n } } return -1;} 时间复杂度同样为 \\(O(\\log n)\\) 就平均性能来说, 斐波那契查找要优于折半查找. 如果是最坏情况， 比如要查找的记录在查找表的极左侧, 则斐波那契查找效率要低于折半查找. 线性索引查找 索引: 把一个关键字与它对应的记录相关联的过程, 一个索引由若干个索引项构成, 每个索引项至少应包含关键字和其对应的记录在存储器中的位置信息. 线性索引: 将索引项集合组织为线性结构, 也称为索引表 稠密索引 每个记录对应一个索引项的叫稠密索引 对于稠密索引表来说, 索引项一定是按照关键字有序的排列. TODO: 补充图片 分块索引 把数据集中的记录分为若干块, 将每块对应一个索引项, 并且这些块需要满足两个条件: 块内无序, 每一块内的记录不要求有序 块间有序, 比如第二块中所有记录的关键字都要大于第一块中所有记录的关键字 分块索引表的索引项结构分三个域: 最大关键字, 存储块中最大关键字(特性: 下一块中的最小关键字也比这一块中最大的关键字要大) 块长, 即块中有多少记录 指针域, 指向关联的块 TODO: 补充图片 在分块索引表中查找分两步进行: 在分块索引表中查找给定值所在的块. 由于分块索引表是块间有序的, 可利用折半、插值等算法确定目标记录所在的块. 在块中顺序查找关键码. 因为块内无序, 只能顺序查找. 分块索引的平均查找长度: 设 n 个记录的数据集被平均分成 m 块, 每个块中有 t 条记录, 显然 \\(m=\\frac{n}{t}\\) . \\(L_b\\) 为在索引表查找块的平均查找长度, 因最好(1 次)与最差(m 次)的等概率原则, \\(L_b\\) 的平均长度为 \\(\\frac{1+m}{2}\\) . \\(L_w\\) 为在块中查找记录的平均查找长度, 同理可知平均查找长度为 \\(\\frac{1+t}{2}\\) . 这样分块索引查找的平均查找长度 \\(ASL_w\\) 为: \\(ASL_w=L_b+L_w=\\frac{1+m}{2}+\\frac{1+t}{2}=\\frac{1}{2}(m+t)+1=\\frac{1}{2}(\\frac{n}{t}+t)+1\\) 最佳情况是分的块数与块中记录相等(即 \\(m=t\\) )， 此时 \\(n=m\\cdot t=t^2\\) \\(ASL_w=\\frac{1}{2}(\\frac{n}{t}+t)+1=t+1=\\sqrt{n}+1\\) 倒排索引 多个次关键字指向同一个记录, 一个次关键字指向多个记录 索引项的通用结构是: 次关键字, 如图中的&quot;英文单词&quot; 记录号表, 存储具有该次关键字的所有记录的记录号(可以是指向记录的指针或者是该记录的主关键字), 如图中的&quot;文章编号&quot; TODO: 补充图片 倒排索引源于实际应用中需要根据属性(或字段、次关键码)的值来查找记录. 这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址. 由于不是由记录来确定属性值, 而是由属性值来确定记录的位置, 因而称为倒排索引 二叉排序树 设集合 {62, 88, 58, 47, 35, 73, 51, 99, 37, 93} 将其变为一颗中序遍历序列为 {35, 37, 47, 51, 58, 62, 73, 88, 93, 99} 的二叉排序树 TODO: 补充图片, 没懂写的啥 二叉排序树(Binary Sort Tree), 又称为二叉查找树. 二叉排序树具有以下性质: 若左子树不空, 则左子树上所有结点的值均小于它的根结点 若右子树不空, 则右子树上所有结点的值均大于它的根结点 左、右子树也为二叉排序树 二叉排序树查找操作: 1234567891011121314151617181920212223/*** 递归查找二叉排序树 T 中是否存在 key* 指针 f 指向 T 的前驱(双亲), 初始值为 NULL* 若查找成功, 指针 p 指向该数据结点并返回 TRUE* 若查找失败, 指针 p 指向查找路径上访问的最后一个结点并返回 FALSE*/int SearchBST(BiTree T, int key, BiTree f, BiTree *p){ if (!T) // 如果已经没有结点 { *p = f; // 查找失败, 指向上一结点的地址 return FALSE; } else if (key == T-&gt;data) // 如果当前结点的值等于给定值, 查找成功 { *p = T; return TRUE; } else if (key &lt; T-&gt;data) // 否则继续查找下一结点 return SearchBST(T-&gt;lchild, key, T, p); // 在左子树中继续查找 else return SearchBST(T-&gt;rchild, key, T, p); // 在右子树中继续查找} 二叉排序树插入操作(附二叉排序树的创建) 12345678910111213141516171819202122int InsertBST(BiTree *T, int key){ BiTree p, s; if (!SearchBST(*T, key, NULL, &amp;p)) // 调用后指针 p 会指向查找路径上访问的最后一个结点 { // 创建新结点 s = (BiTree) malloc(sizeof(BiTNode)); s-&gt;data = key; s-&gt;lchild = s-&gt;rchild = NULL; if (!p) // 若经过 SearchBST() 后 p 为 null, 说明该树中没有结点 *T = s; // 插入s为新的根结点 else if (key &lt; p-&gt;data) // 否则根据与双亲结点的比较决定是左孩子还是右孩子 p-&gt;lchild = s; // 插入 s 为 p 的左孩子 else p-&gt;rchild = s; // 插入 s 为 p 的右孩子 return TRUE; } else return FALSE; // 如果已有相同结点, 返回 False} 实现二叉排序树的创建: 1234567int i;int a[10] = { 62, 88, 58, 47, 35, 73, 51, 99, 37, 93 };// 新建二叉树 TBiTree T = (BiTree) malloc(sizeof(BiTNode));for (i = 0; i &lt; 10; i++) // 遍历数组并插入为新结点 InsertBST(&amp;T, a[i]) 二叉排序树删除操作 情况1: 如果待删结点是叶子, 直接将双亲结点的对应后继设为 null 即可 TODO: 补充图片 情况2: 如果待删结点只有左子树或只有右子树, 将它的左子树或右子树整个移动到被删除结点的位置 TODO: 补充图片 情况3: 如果待删结点既有左右子树均不空, 根据二叉树的中序序列 用该结点在序列中的前驱代替该结点, 并删除前驱, 接上该前驱的子树; 或者用该结点在序列中的后继代替该结点, 并删除后继, 接上该后继的子树 TODO: 补充图片 具体先根据关键值找到该结点, 然后再根据以上三种情况作处理 实现代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int Delete(BiTree *p){ BiTree q, s; if ((*p)-&gt;rchild == NULL) // 右子树空则只需重接它的左子树(待删结点是叶子也走此分支) { q = *p; *p = (*p)-&gt;lchild; free(q); } else if ((*p)-&gt;lchild == NULL) // 只需重接它的右子树 { q = *p; *p = (*p)-&gt;rchild; free(q); } else // 左右子树均不空 { q = *p; s = (*p)-&gt;lchild; // s 初始化为待删结点的左子树 while (s-&gt;rchild) // 找待删结点在中序序列中的前驱(他的左子树中最右孩子或者左子树根结点(如果左子树根结点没有右孩子)), 用变量 s 记录, 用 q 记录 s 的双亲 { q = s; s = s-&gt;rchild; } (*p)-&gt;data = s-&gt;data; // 用前驱代替待删结点 if (q == *p) // 前驱的双亲等于待删结点, 意味着待删结点的左子树根结点没有右孩子 q-&gt;lchild = s-&gt;lchild; // 接上待删结点左子树的左子树 else q-&gt;rchild = s-&gt;lchild; // 接上最右孩子的左子树(因为最右孩子肯定没有右孩子) free(s); // 清理待删结点的前驱 }}int DeleteBST(BiTree *T, int key){ if(!*T) // 如果已经没有结点, 说明查找失败 return FALSE; else { if (key == (*T)-&gt;data) // 如果找到关键字等于 key 的结点 return Delete(T); // 调用 Delete() 删除该结点 else if (key &lt; (*T)-&gt;data) return DeleteBST(&amp;(*T)-&gt;lchild, key); else return DeleteBST(&amp;(*T)-&gt;rchild, key); }} 二叉排序树总结 二叉排序树是以链表的方式存储, 保持了链式存储结构在执行插入或删除操作时不用移动元素的优点, 只要找到合适的插入和删除位置后, 仅需修改链接指针即可 额外特性: 对于二叉排序树的查找, 走的就是从根结点到要查找的结点的路径, 其比较次数等于给定值的结点在二叉排序树的层数. 最少为1次, 即根结点就是要找的结点, 最多不会超过树的深度. 平衡二叉树(AVL树) TODO: 这节未完成 平衡二叉树(Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree), 是一种二叉排序树, 其中每一个结点的左子树和右子树的高度差至多等于 1 二叉树结点的左子树深度减去右子树深度的值称为平衡因子 BF(Balance Factor), 平衡二叉树上所有结点的平衡因子只可能是 -1、0、1. 最小不平衡树: 如图, 当新插入结点37时, 距离它最近的平衡因子绝对值超过 1 的结点是 58 (58左子树高度3, 右子树高度 1), 所以从 58 为跟的子树为最小不平衡树 TODO: 补充图片 平衡二叉树实现原理 构建平衡二叉树的基本思想就是在构建过程中, 每当插入一个结点时, 先检查是否因插入而破坏了树的平衡. 若是, 则找出最小不平衡树. 在保证二叉排序树特性的前提下, 调整最小不平衡子树中各结点之间的链接关系, 进行相应的旋转, 使之成为新的平衡子树. 平衡二叉树实现算法 平衡二叉树结构定义代码如下: 123456typedef struct BiTNode // 结点结构{ int data; int bf; // 结点平衡因子 struct BiTNode *lchild, *rchild;} BiTNode, *BiTree; 实现代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// 右旋操作void R_Rotate(BiTree *P){ BiTree L; L = (*P)-&gt;lchild; // L 为 P 的左子树根结点 (*P)-&gt;lchild = L-&gt;rchild; // 将 P 左子树的右子树挂接为 P 的左子树 L-&gt;rchild = (*P); // 将 L 的右子树根结点设为 P *P = L; // P 的新根结点为 L}// 左旋操作void L_Rotate(BiTree *P){ BiTree R; R = (*P)-&gt;rchild; // R 为 P 的右子树根结点 (*P)-&gt;rchild = R-&gt;lchild; // 将 P 右子树的左子树挂接为 P 的右子树 R-&gt;lchild = (*P); // 将 R 的左子树根结点设为 P *P = R; // P 的新根结点为 R}#define LH 1#define EH 0#define RH -1// 对二叉树 T 作左平衡旋转(即树的左边高于右边的情况, 此时 T-&gt;bf == 2)void LeftBalance(BiTree *T){ BiTree L, Lr; L = (*T)-&gt;lchild; // L 指向 T 的左子树根结点 switch (L-&gt;bf) // 检查 T 的左子树平衡因子 { case LH: // 新插入结点在 T 的左孩子的左子树上, 要作右旋处理 (*T)-&gt;bf = L-&gt;bf = EH; // 右旋后 T, L 结点均变为平衡(由作图分析得到) R_Rotate(T); break; case RH: // 新插入结点在 T 的左孩子的右子树上, 要作双旋处理(左子树左旋, 根结点右旋) Lr = L-&gt;rchild; // Lr 指向 T 的左孩子的右子树根 switch (Lr-&gt;bf) // 根据Lr 的平衡因子设定双旋后 T, L 结点的平衡情况(由作图分析得到) { case LH: L-&gt;bf = EH; (*T)-&gt;bf = RH; break; case EH: (*T)-&gt;bf = L-&gt;bf = EH; break; case RH: L-&gt;bf = LH; (*T)-&gt;bf = EH; break; } Lr-&gt;bf = EH; L_Rotate(&amp;(*T)-&gt;lchild); // 将 T 的左子树左旋, Lr 变为左子树根结点 R_Rotate(T); // 将 T 右旋, Lr 变为根结点 }}int InsertAVL(BiTree *T, int e, bool *taller){ if (!*T) { *T = (BiTree) malloc(sizeof(BiTNode)); (*T)-&gt;data = e; (*T)-&gt;lchild = (*T)-&gt;rchild = NULL; (*T)-&gt;bf = EH; *taller = true; } else { if (e == (*T)-&gt;data) { *taller = false; return false; } if (e &lt; (*T)-&gt;data) { if (!InvertAVL(&amp;(*T)-&gt;lchild, e, taller)) return false; if (taller) { switch((*T)-&gt;bf) { case LH: LeftBalance(T); *taller = false; break; case EH: (*T)-&gt;bf = LH; *taller = true; break; case RH: (*T)-&gt;bf = EH; *taller = false; break; } } } else { if (!InsertAVL(&amp;(*T)-&gt;rchild, e, taller)) return false; if(*taller) { switch((*T)-&gt;bf) { case LH: (*T)-&gt;bf = EH; *taller = false; break; case EH: (*T)-&gt;bf = RH; *taller = true; break; case RH: RightBalance(T); *taller = false; break; } } } } return true;} 多路查找树(B树) 散列表查找(哈希表)概述 散列表查找定义 通过某个函数 f, 使得: 存储位置=f(关键字) 散列技术是在记录的的存储位置和它的关键字之间建立一个确定的对应关系, 使得每个关键字 key 对于一个存储位置 f(key) 函数 f 称为散列函数, 又称哈希(Hash)函数. 采用散列技术将记录存储在一块连续的存储空间中, 这块连续存储空间称为散列表或哈希表(Hash table). 关键字对应记录的存储位置称为散列地址 这样查找关键字不需要比较就可获得需要的记录的存储位置 散列表查找步骤 在存储时, 所有记录都需要经过散列函数计算出地址再存储 查找记录时, 通过同样的散列函数计算记录的散列地址从而访问该地址 因此散列计算既是一种存储方法, 也是一种查找方法. 散列技术最适合的场景是查找某个指定的记录 散列技术不适合: 一个关键字对应多条记录的情况 范围查找 在理想情况下, 不同的关键字, 通过散列函数计算出来的地址都是不一样的, 可现实中时常会碰到两个关键字 key1≠key2, 但 f(key1)=f(key2) 的情况, 这种现象称为冲突(collision), 此时 key1 和 key2 称为这个散列函数的同义词(synonym) 散列函数的构造方法 两个原则: 计算简单. 散列函数的计算时间不应该超过其他查找技术与关键字比较的时间 散列地址分布均匀. 尽量让散列地址均匀地分布在存储空间中, 保证存储空间的有效利用, 减少未处理冲突而耗费的时间 直接定址法 对 0~100 岁的人口数字统计表, 对年龄这个关键字就可以直接用年龄的数字作为地址. 此时 f(key)=key TODO: 补充图片 统计 1980 后出生年份的人口数, 对出生年份这个关键字可以用年份减去 1980 来作为地址. 此时 f(key)=key-1980 TODO: 补充图片 可以取关键字的某个线性函数为散列地址, 即 f(key) = a × key + b 这样的散列函数优点是简单、均匀、不产生冲突, 但问题是需要事先知道关键字的分布情况, 适合查找表较小且连续的情况, 由于这样的限制, 此方法在现实中并不常用. 数字分析法 如果关键字是位数较多的数字, 比如 11 位手机号前三位是接入号, 一般对应不同运营商公司的子品牌; 中间四位是 HLR 识别号, 表示归属地; 后四位才是真正的用户号. TODO: 补充图片 如果用手机号作为关键字, 极有可能前 7 位都是相同的. 那么选择后四位作为散列地址就是不错的选择. 数字分析法是使用关键字的一部分来计算散列存储位置的方法, 通常适合处理关键字位数比较大的情况. 如果事先知道关键字的分布且关键字的若干位分布较均匀, 可以考虑用此方法 平方取中法 关键字 1234 的平方是 1522756, 抽取中间的三位 227 用作散列地址. 平方取中法适合于不知道关键字的分布, 而位数又不是很大的情况. 折叠法 折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数不够时可以短些), 然后将这几部分叠加求和, 并按散列表表长, 取后几位作为散列地址 关键字 9876543210, 分为四组 |987|654|321|0, 叠加求和 987+654+321+0=1962, 散列表表长为三位(0~999), 得到散列地址为962 有时还不能保证分布均匀, 不妨从一端向另一端来回折叠后对齐相加. 比如 987 和 321 反转, 在与 654 和 0 相加, 变成 789 + 654 + 123 + 0 = 1566, 此时散列地址为 566 折叠法事先不需要知道关键字的分布, 适合关键字位数较多的情况 除留余数法 除留余数法为最常用的散列函数方法. 对于散列表长度为 m 的散列函数公式为: f(key)=key % p (p ≤ m) 此方法不仅可以对关键字直接取模, 也可在折叠、平方取中后再取模. 本方法的关键在于选择合适的 p, p 如果选的不好, 可能会容易产生同义词. 极端情况: 对于如下数据, 让p为12, 所有的关键字都能整除 12, 都得到了 0 这个散列地址 TODO: 补充图片 通常选择 p 为小于等于表长的最小质数或质因子不小于 20 的合数 随机数法 选择一个随机数, 取关键字的随机函数值为它的散列地址. 即 f(key)=random(key) random() 是伪随机函数. 当关键字的长度不等时, 采用这个方法构造散列函数比较合适. 应该视不同的情况采用不同的散列函数. 考虑因素: 计算散列地址所需的时间 关键字的长度 散列表的大小 关键字的分布情况 记录查找的频率 处理散列冲突的方法 开放地址法 也称线性探测法. 指一旦发生冲突, 就去寻找下一个空的散列地址, 只要散列表足够大, 空的散列地址总能找到, 并将记录存入 公式(m 为散列表表长): \\(f_i(\\text{key}=(f(\\text{key}+d_i) \\% m (1 \\leqslant d_i \\leqslant m-1)))\\) 堆积: 本来不是同义词却需要争夺一个地址的情况. 堆积的出现需要不断处理冲突, 无论存入还是查找效率都会大大降低 二次探测法: 给增加平方运算, 目的是为了不让关键字聚集在某一块区域, 减少堆积的出现. \\(f_i(key)=(f(key)+d_i) \\% m (d_i=1^2, -1^2, 2^2, -2^2, \\dots, q^2, -q^2)(q\\leqslant \\frac{m}{2})\\) 还有一种方法是在冲突时, 对于位移量 \\(d_i\\) 采用随机函数计算得到, 称之为随机探测法 开放定址法只要在散列表未填满时, 总能找到不发生冲突的地址, 是常用的解决冲突的办法 再散列函数法 事先准备多个散列函数, 每当发生散列地址冲突时, 就换一个散列函数计算. 这种方法能够使得关键字不产生聚集, 但也增加了计算的时间 链地址法 将所有关键字为同义词的记录存储在一个单链表中, 称这种表为同义词子表, 在散列表中只存储所有同义词子表的头指针 举个例子: 对关键字集合 {12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34}, 散列函数为除留余数法, 用 12 作为除数 TODO: 补充图片 链地址法提供了绝不会出现找不到地址的保障. 但也带来了查找时需要遍历单链表的性能损耗 公共溢出区法 增加一个专门存储同义词的溢出表 举个例子: 关键字 37, 48, 34 与之前的关键字位置有冲突, 将它们存储到溢出表 TODO: 补充图片 查找时, 对给定值通过散列函数计算出散列地址后, 先与基本表的相应位置进行比对, 如果相等, 则查找成功; 如果不相等, 则到溢出表去进行顺序查找. 如果相对于基本表, 有冲突的数据很少的情况下, 公共溢出区法的性能还是非常高的 散列表查找实现 散列表查找算法实现 HashTable 是散列表结构, 结构中 *elements 为一个动态数组. 1234567typedef struct{ int *elements; // 数据元素存储基址, 动态数组 int count; // 当前数据元素个数} HashTable;int HashTableLength = 0; // 散列表表长, 全局变量 对散列表初始化 123456789101112131415#define HASHSIZE 12 // 假设表长为 12#define NULLKEY -32768 // 初始键值, 选择一个关键字取不到的值int InitHashTable(HashTable *H){ int i; HashTableLength = HASHSIZE // 设置散列表表长 H-&gt;count = HashTableLength; H-&gt;elements = (int*) malloc(HashTableLength * sizeof(int)); for (i = 0; i &lt; HashTableLength; i++) // 初始化 elements 数组 H-&gt;elem[i] = NULLKEY; return OK;} 选择一个散列函数, 这里选择了除留余数法: 1234int Hash(int key){ return key % HashTableLength;} 插入操作函数: 12345678void InsertHash(HashTable *H, int key){ int addr = Hash(key); while (H-&gt;elements[addr] != NULLKEY) // 如果该地址不等于初始值, 说明已被别的键值占有, 冲突了 addr = (addr + 1) % HashTableLength; // 这里用开放地址法解决冲突 H-&gt;elements[addr] = key;} 查找操作函数: 1234567891011121314151617// 查找成功后 *addr 指向该关键字的散列地址int SearchHash(HashTable H, int key, int *addr){ *addr = Hash(key); // 获取散列地址 while (H.elements[*addr] != key) // 如果该地址下元素与要找的不同, 说明之前发生过冲突 { *addr = (*addr + 1) % HashTableLength; // 因为之前用开放地址法解决冲突, 所有同样用这个方法找散列地址 // 前者判断在该记录未存入散列表的情况下为 true, 基于开放地址法的特性. (同时散列表也不能删除已存入元素) // 后者判断在散列表全满的情况下为 true if (H.elements[*addr] == NULLKEY || *addr == Hash(key)) { return ERROR; } } return OK;} 散列表查找性能分析 散列查找的平均查找长度取决因素: 散列函数是否均匀 处理冲突的方法 散列表的装填因子 装填因子形容散列表装满的程度, 符号 \\(\\alpha=\\frac{\\text{当前表中记录个数}}{\\text{散列表长度}}\\) \\(\\alpha\\) 越大, 产生冲突的可能性就越大. 冲突越多, 平均查找长度同样也越长. 解决方法是选择一个合适的装填因子以便将平均查找长度限定在一个范围之内, 此时散列查找的时间复杂度是 \\(O(n)\\) 通常都是将散列表的空间设置得比查找集合大, 虽然是浪费了一定的空间, 但换来的是查找效率的大大提升 排序 排序的基本概念与分类 设有 n 个记录的序列 \\(\\{r_1, r_2, \\dots, r_n\\}\\) 记录对应的关键字为 \\(\\{k_1, k_2, \\dots, k_n\\}\\) 需确定一种排列 \\(p_1, p_2, \\dots, p_n\\) 满足 \\(k_{p_1}, k_{p_2}, \\dots, k_{p_n}\\) 按顺序或逆序排列 使序列成为按关键字有序的序列 \\(\\{r_{p_1}, r_{p_2}, \\dots, r_{p_n}\\}\\) 排序的稳定性 假设 \\(k_i=j_j \\enspace(1\\leqslant i , 1\\leqslant j\\leqslant n , i \\neq j)\\) 且在排序前的序列中 \\(r_i\\) 领先于 \\(r_j\\) . 如果排序后 \\(r_i\\) 仍领先于 \\(r_j\\) 则称所用的排序方法是稳定的; 反之, 若可能使得排序后序列中 \\(r_j\\) 领先于 \\(r_i\\) 则称所用的排序方法是不稳定的. 即两个关键字一样的记录, 排序后顺序不变的说明排序方法是稳定的 TODO: 补充图片 内排序与外排序 根据在排序过程中待排序的记录是否全部被放置在内存中, 将排序分为内排序和外排序. 内排序是在整个排序过程中, 待排序的记录全部放在内存中. 外排序是由于排序的记录太多, 在整个排序过程中, 需要在内外存之间多次交换数据. 对于内排序, 排序算法性能主要受 3 个方面影响 时间性能 内排序中, 主要进行两种操作: 比较和移动. 高效率的内排序算法是尽可能少的关键字比较次数和记录移动次数 辅助空间 除了存放排序所占用的存储空间之外, 执行算法所需要的其他存储空间 算法的复杂性 指算法代码的复杂度, 不是算法的时间复杂度. 算法过于复杂也会影响排序的性能 排序用到的结构与函数 排序用的顺序表结构 123456#define MAXSIZE 10typedef struct{ int r[MAXSIZE + 1]; // r[0] 用作哨兵或临时变量, 所以要 MAXSIZE + 1 int length;} SqList; 数组两元素的交换函数 123456void swap(SqList *L, int i, int j){ int temp = L-&gt;r[i]; L-&gt;r[i] = L-&gt;r[j]; L-&gt;r[j] = temp;} 冒泡排序 最简单排序实现 12345678910111213141516// 不算标准的冒泡排序, 从小到大排列// 思路是让每一个关键字都和它后面的每一个关键字比较, 如果大则交换// 这样这个关键字在一次循环后一定变成它后面数中的最小值void NotBubbleSort(SqList *L){ int i, j; // 将每个 r[i] 与 i 之后的每个 r[j] 比一遍 for (i = 1; i &lt; L-&gt;length; i++) { for (j = i + 1; j &lt;= L-&gt;length; j++) { if (L-&gt;r[i] &gt; L-&gt;r[j]) swap(L, i, j); } }} 时间复杂度为: \\(\\frac{n(n-1)}{2}=O(n^2)\\) , 该算法的效率非常低 冒泡排序算法 冒泡排序(Bubble Sort)是一种交换排序 基本思想是: 两两比较相邻记录的关键字, 如果反序则交换, 直到没有反序的记录为止 正宗的冒泡算法: 1234567891011121314void BubbleSort(SqList *L){ int i, j; for (i = 1; i &lt; L-&gt;length; i++) { // j 从后往前循环, 比较时 j 是前者, j + 1 是后者 for (j = L-&gt;length - 1; j &gt;= i; j--) { // 若前者大于后者, 交换它们的位置 if (L-&gt;r[j] &gt; L-&gt;r[j + 1]) swap(L, j, j + 1); } }} 每次 j 的循环结束后, r[i] 位置的关键字总是后面的记录中最小的. 每次 j 的循环, 最小的关键字都会向泡泡一个依次&quot;浮&quot;上来 时间复杂度同样为 \\(O(n^2)\\) 冒泡排序优化 增加一个标记变量flag, 如果某轮 j 循环没有任何数据交换, 说明此序列已经有序,不需要再继续后面的排序工作. 1234567891011121314151617void BubbleSort2(SqList *L){ int i, j; bool flag = true; for (i = 1; i &lt; L-&gt;length &amp;&amp; flag; i++) // 增加对 flag 的判断 { flag = false; // i 循环每轮初始值为 false for (j = L-&gt;length - 1; j &gt;= i; j--) { if (L-&gt;r[j] &gt; L-&gt;r[j + 1]) { swap(L, j, j + 1); flag = true; // 如果有数据交换, 则 flag 为 true, 下次循环继续 } } }} 设待排序的序列是 {2, 1, 3, 4, 5, 6, 7, 8, 9} TODO: 补充图片 冒泡排序复杂度分析 最好情况: 要排序的表本身就是有序的, 放在冒泡排序优化版只有 n-1 次的比较, 没有数据交换, 时间复杂度为 \\(O(n)\\) 最坏情况: 排序表是逆序的情况, 此时需要比较 \\(\\frac{n(n-1)}{2}\\) 次并作等量的移动操作, 时间复杂度为 \\(O(n^2)\\) 简单选择排序 简单选择排序算法 简单选择排序法(Simple Selection Sort)是通过 n-i 次关键字间的比较, 从 n-i+1 个记录中选出关键字最小的记录, 并和第 i 个记录交换 123456789101112131415void SelectSort(SqList *L){ int i, j, min; for (i = 1; i &lt; L-&gt;length; i++) { min = i; // min 记录当前找到的最小值, 初始化值为 i for (j = i + 1; j &lt;= L-&gt;length; j++) // 在 i 之后的记录中找最小值 { if (L-&gt;r[min] &gt; L-&gt;r[j]) // 如果有比 min 小的 min = j; // 将该值赋给 min } if (i != min) // 若 min 不等于 i, 说明找到最小值, 交换 swap(L, i, min); }} 简单选择排序复杂度分析 简单排序相比冒泡排序的优点是交换记录位置的次数相当少. 对于交换次数, 最好情况为顺序表交换 0 次, 最坏情况为逆序表 n-1 次. 但无论最好最差的情况, 其比较次数都是 \\(\\frac{n(n-1)}{2}\\) 次. 因此, 时间复杂度依然为 \\(O(n^2)\\) 尽管与冒泡排序同为 \\(O(n^2)\\) , 但实际情况简单选择排序的性能还是略优于冒泡排序 直接插入排序 直接插入排序算法 直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中, 从而得到一个新的、记录数增 1 的有序表 实现代码如下: 123456789101112131415161718void InsertSort(SqList *L){ int i, j; for (i = 2; i &lt;= L-&gt;length; i++) { // r[i] 为后者, r[i - 1] 为前者, 如果后者小于前者, 说明后者需要插到前面去 if (L-&gt;r[i] &lt; L-&gt;r[i - 1]) { L-&gt;r[0] = L-&gt;r[i]; // 将后者的值存入哨兵 // 将记录后移, 给插入提供空间 for (j = i - 1; L-&gt;r[j] &gt; L-&gt;r[0]; j--) // 用 j 遍历 i 前面的记录. 如果 r[j] 大于哨兵的值 L-&gt;r[j + 1] = L-&gt;r[j] // 将该记录后移 L-&gt;r[j + 1] = L-&gt;r[0] // 循环结束后, j+1 抵消最后一次循环结束后的 j--, 即为合适的插入位置 } }} 直接插入排序复杂度分析 最好情况: 表本身有序, 共比较了 n-1 次, 没有移动记录的操作, 时间复杂度为 \\(O(n)\\) 最坏情况: 表是逆序, 需要比较 \\(2+3+…+n=\\frac{(n+2)(n-1)}{2}\\) 次, 记录移动次数 \\(\\displaystype\\sum_{i=2}^n (i+1)=\\frac{(n+4)(n-1)}{2}\\) 评价情况: 根据等概率原则, 评价比较和移动次数约为 \\(\\frac{n^2}{4}\\) 因此时间复杂度同样为 \\(O(n^2)\\) 但直接插入排序法比冒泡和简单选择排序的性能要好 希尔排序 希尔排序原理 将原本的大量记录进行分组, 分割成若干个子序列. 此时每个子序列按排序的记录个数比较少, 然后在这些子序列内分别进行直接插入排序, 当整个序列都基本有序时, 再对全体记录进行依次直接插入排序 基本有序: 小的关键字基本在前面, 大的基本在后面, 不大不小的基本在中间 {2,1,3,6,4,7,5,8,9} 可以称为基本有序. {1,5,9,3,7,8,2,4,6} 的 9 在第三位, 谈不上基本有序, 其中的 {1, 5, 9} 算局部有序 跳跃分割策略: 将相距某个&quot;增量&quot;的记录组成一个子序列, 以保证直接插入排序后的子序列是基本有序而不是局部有序 希尔排序算法 123456789101112131415161718192021222324void ShellSort(SqList *L){ int i, j; int increment = L-&gt;length; // 增量, 初始化为表的长度 do { // 确定增量大小, 每完成一次循环, 增量都会逐步减小 increment = increment / 3 + 1; // 后面 +1 是为了确保增量大于等于1, 增量等于零时此算法相当于直接插入排序 for (i = increment + 1; i &lt;= L-&gt;length; i++) { if (L-&gt;r[i] &lt; L-&gt;r[i - increment]) // 将 i 和前一个子序列对应的值比较, 小则交换位置 { L-r[0] = L-&gt;r[i]; // 暂存在L-&gt;r[0] for (j = i - increment; j &gt; 0 &amp;&amp; L-&gt;r[j] &gt; L-&gt;r[0]; j -= increment) // 从后往前, 将 L-r[0] 与每个子序列中相应位置记录比较 { L-&gt;r[j + increment] = L-&gt;r[j]; // 如果大于 L-r[0], 将该记录移到后一个子序列表相应位置中(第一次位置为 r[i] 的位置) } L-&gt;r[j + increment] = L-&gt;r[0]; // 循环结束后, 抵消最后一次循环结束后的 j -= increment, 即为合适的插入位置 } } } while (increment &gt; 1);} 希尔排序复杂度分析 希尔排序的关键是将相隔某个距离的记录组成一个个子序列, 实现跳跃式的排序, 使得排序的效率提高. 希尔排序时间复杂度为 \\(O(n^2)\\) . 由于记录是跳跃式的移动, 希尔排序并不是一种稳定的排序算法 堆排序 堆是具有下列性质的完全二叉树: 每个结点的值都大于或等于其左右孩子的值, 称为大顶堆; 或每个结点的值都小于或等于其左右孩子的值, 称为小顶堆 根结点一定是堆中所有结点最大(小)者 较大(小)的结点靠近根结点(不绝对) TODO: 补充图片 按照层序遍历的方式给 n 个结点从 1 开始编号, 结点之间满足如下关系: \\(\\begin{cases} k_i\\geqslant k_{2i} \\ k_i\\geqslant k_{2i+1} \\end{cases}\\) 或 \\(\\begin{cases} k_i\\leqslant k_{2i} \\ k_i\\leqslant k_{2i+1} \\end{cases} (1\\leqslant i\\leqslant \\frac{n}{2})\\) (可以回顾完全二叉树的存储) 将大顶堆或小顶堆用层序遍历存入数组: TODO: 补充图片 堆排序算法 堆排序(Heap Sort)是利用堆(假设利用大顶堆)进行排序的方法. 基本思想是将待排序的序列构造成一个大顶堆. 此时序列的最大值就是根节点, 将他移至序列末尾(与末尾记录交换), 然后将剩余的序列重新构造成一个堆, 这样就会得到次大值. 如此反复执行, 便能得到一个有序序列. 实现需要解决两个问题: 如何由无序序列构建成一个堆 如何在输出堆顶元素后, 调整剩余元素成为一个新堆 实现代码如下: 1234567891011121314151617181920212223242526272829303132// 堆调整函数(大顶堆), 使堆顶为当前最大的数, 调用时应确认树中子堆应该已经调整过void HeapAdjust(SqList *L, int s, int m){ int temp, j; temp = L-&gt;r[s]; // temp 存储原本堆顶的值 for (j = 2 * s; j &lt;= m; j *= 2) // 循环遍历左孩子 { if (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + 1]) // 如果 j &lt; m 说明不是最后一个结点, 左孩子小于右孩子 j++; // j 指针加 1 以使其指向右孩子 if (temp &gt;= L-&gt;r[j]) // 如果 temp 的值大于 j 指向的较大的孩子 break; // 结束循环(考虑到下面的子堆已经调整过, j 下面已经不可能会有比堆顶还大的数) L-&gt;r[s] = L-&gt;r[j]; // 否则将此孩子的值赋给当前堆顶 s = j; // 接下来调整子堆, 将指向堆顶的 s 指针指向当前孩子 j } L-&gt;r[s] = temp; // 将原本堆顶的值存入 s 指向的地方}void HeapSort(SqList *L){ int i; // 构建堆, 将数组调整为一个大顶堆 for (i = L-&gt;length / 2; i &gt; 0; i--) // 从子堆开始调整 HeapAdjust(L, i, L-&gt;length); for (i = L-&gt;length; i &gt; 1; i--) { swap(L, 1, i); // 将堆顶记录和 i 交换(i 从后往前) HeapAdjust(L, 1, i - 1); // 重新调整堆 }} 堆排序复杂度分析 运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上 构建堆: 因为是完全二叉树从最下层最右边的非终端结点开始构建, 将它与其孩子进行比较和若有必要的互换, 对于每个非终端结点, 最多进行两次比较和互换操作, 时间复杂度为 \\(O(n)\\) 正式排序: 第 i 次取堆顶记录重建堆需要用 \\(O(\\log i)\\) 的时间(完全二叉树的某个结点到根结点的距离为 \\(\\log_2 i + 1\\) , 并且需要取 n-1 次堆顶记录, 因此重建堆的时间复杂度为 \\(O(n\\log_n)\\) ​ 总体堆排序的时间复杂度为 \\(O(nlogn)\\) 由于记录的比较与交换是跳跃式进行, 堆排序也是一种不稳定的排序方法 由于初始构建堆所需的比较次数较多, 不适合待排序序列个数较少的情况 空间复杂度上只有一个用来交换的暂存单元 归并排序 归并排序算法 归并: 将两个或两个以上的有序表组合成一个新的有序表 假设初始序列含有 n 个记录, 把它看成 n 个长度为 1 的有序子序列, 然后两两归并, 得到 \\(\\ulcorner\\frac{n}{2}\\urcorner\\) (\\(\\ulcorner x\\urcorner\\) 表示大于 x 的最小整数)个长度为 2 或 1 的有序子序列. 再次两两归并, 如此重复, 直至得到一个长度为 n 的有序序列为止. 这种排序方法称为 2 路归并排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// SR 为当前分段, TR 为输出数组(SR 和 TR 两者不能为同一个), 此函数将两个有序序列 SR[i~m] 和 SR[m+1~n] 归并void Merge(int SR[], int TR[], int i, int m, int n){ int j, k, l; // 将 SR 中记录由小到大归并入 TR, i 由 i~m j 由 m+1~n for (k = i, j = m + 1; i &lt;= m &amp;&amp; j &lt;= n; k++) { // 因为两个序列有序, 只需要逐个比较然后填入 TR if (SR[i] &lt; SR[j]) TR[k] = SR[i++]; else TR[k] = SR[j++]; } // 循环结束后某一边的序列会全部填入 TR //接下来判断是否还有剩余未填入 if (i &lt;= m) { for (l = 0; l &lt;= m - i; l++) TR[k + l] = SR[i + l]; // 将剩余的 SR[i~m] 填入 TR } if (j &lt;= n) { for (l = 0; l &lt;= n - j; l++) TR[k + l] = SR[j + l]; // 将剩余的 SR[j~n] 填入 TR }}// SR为输入数组, TR1 为排序后的输出数组, s 为起始下标, t 为终端下标// 第一次传入的 TR1 只会在递归的最后赋值, 所以 SR 和 TR1 可以是同一个地址void MSort(int SR[], int TR1[], int s, int t){ int m; int TR2[t + 1]; if (s == t) // 如果已经分到了最小 TR1[s] = SR[s]; // 将 SR[s] 回递给上级递归的 TR2[s] (开始调用 Merge() 归并) else { // 将 SR 平分为 SR[s~m] 和 SR[m+1~t] m = (s + t) / 2; MSort(SR, TR2, s, m); MSort(SR, TR2, m + 1, t); Merge(TR2, TR1, s, m, t); // 将 SR[s~m] 和 SR[m+1~t] 归并到 TR1 }}void MergeSort(SqList *L){ MSort(L-&gt;r, L-&gt;r, 0, L-&gt;length - 1);} 具体递归的分析: 123456789101112131415161718假设有数组 SR == [50 10 90 30 70], 长度为5MSort(L-&gt;r, L-&gt;r, 0, 4) MSort(SR, TR2, 0, 2) [50,10,90] MSort(SR, TR2, 0, 1) MSort(SR, TR2, 0, 0) 确定上级递归 TR2 有 SR[0] == 50 MSort(SR, TR2, 1, 1) 确定上级递归 TR2 有 SR[1] == 10 于是确定此级递归的 TR2 == [50,10,null,null,null] Merge(TR2, TR1, 0, 0, 1) TR2[50,10,null,null,null] -&gt; 上级递归的 TR2[10,50,null,null,null] MSort(SR, TR2, 2, 2) 确定上级递归 TR2 有 SR[2] == 90 于是确定此级递归的 TR2 == [50,10,90,null,null] Merge(TR2, TR1, 0, 1, 2) TR2[10,50,90,null,null] -&gt; 上级递归的 TR2[10,50,90,null,null] MSort(SR, TR2, 3, 4) 30 70 MSort(SR, TR2, 3, 3) 确定上级递归 TR2 有 SR[3] == 30 MSort(SR, TR2, 4, 4) 确定上级递归 TR2 有 SR[4] == 70 于是确定此级递归的 TR2 == [null,null,null,30,70] Merge(TR2, TR1, 3, 3, 4) TR2[null,null,null,30,70] -&gt; 上级递归的 TR2[null,null,null,30,70] (加上先前的递归, 实际为 TR2[10,50,90,30,70]) Merge(TR2, TR1, 0, 2, 4) TR2[10,50,90,30,70] -&gt; TR1[10,30,50,70,90] 归并排序复杂度分析 一趟归并需要将 SR[1]~SR[n] 中相邻的有序序列进行两两归并并将结果放到 TR1 中, 需要将待排序序列中的所有记录扫描一遍, 耗时 \\(O(n)\\) 整个归并的路线可以想象成一颗完全二叉树, 由完全二叉树的深度可知, 整个归并排序需要进行 \\(\\log_2 n\\) 次, 因此总的时间复杂度为 \\(O(n\\log n)\\) 由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间, 存放归并结果以及递归时深度为 \\(\\log_2 n\\) 的栈空间, 因此空间复杂度为 \\(O(n+\\log n)\\) Merge() 函数中归并排序是两两比较, 不存在跳跃, 因此归并排序是一种稳定的排序算法 归并排序是一种比较占用内存，但却效率高且稳定的算法 非递归实现归并排序 1234567891011121314151617181920212223242526272829303132333435363738// 省略了函数 Merge()// 将 SR[] 中相邻长度为 distance 的子序列两两归并到TR[], length 为 SR[] 长度void MergePass(int SR[], int TR[], int distance, int length){ int i = 0; int j; while (i &lt;= length - 2 * distance) // 循环, 直到后面没有满足两个相邻子序列的空间 { // 归并 SR[i ~ i+(distance-1)] 和 SR[i+distance ~ i+distance+(distance-1)] (合并后就是 SR[i+distance ~ i+2×distance-1]) Merge(SR, TR, i, i + distance - 1, i + 2 * distance - 1); i += 2 * distance; // i ~ i+2×distance-1 之间长度为(包含两端本身) (i+2×distance-1) - i + 1 = 2×distance } // 归并最后两个序列 (前者的序列长度=distance ; 0 &lt; 后者的序列长度 &lt; distance) if (i &lt; length - distance) Merge(SR, TR, i, i + distance - 1, length - 1); else // 若最后只剩下 长度 ≤ distance 的单个子序列, 直接填入TR[] (或者没有剩余, 此时循环条件不满足, 不执行) for (j = i; j &lt; length; j++) TR[j] = SR[j];}// 对顺序表L作归并非递归排序void MergeSort2(SqList *L){ int *TR = (int*) malloc(L-&gt;length * sizeof(int)); int k = 1; // k 存储当前分割间距 while (k &lt; L-&gt;length) { // 在TR和L-&gt;r之间不断轮换并扩大子序列长度, 最终完成归并排序 MergePasss(L-&gt;r, TR, k, L-&gt;length); // 将 L-&gt;r 中相邻长度为当前 k 的子序列两两归并到 TR k *= 2; // 子序列长度加倍 MergePass(TR, L-&gt;r, k, L-&gt;length); // 将 TR 中相邻长度为当前 k 的子序列两两归并到 L-&gt;r k *= 2; // 子序列长度加倍 }} 非递归的迭代方法, 避免了递归时深度为的栈空间, 空间只是用到申请归并临时用的TR数组, 空间复杂度为 \\(O(n)\\) 避免递归在时间性能上也有一定的提升 快速排序 快速排序算法 快速排序(Quick Sort)的基本思想是 通过一趟排序将待排记录分割成独立的两部分, 其中一部分记录的关键字均比另一部分记录的关键字小, 分别对这两部分记录继续排序, 达到整个序列有序 1234567891011121314151617181920212223242526272829303132333435363738// 任务是选择某个记录作为枢轴, 将比它小的放左边, 比它大的放右边, 然后返回分好后枢轴的下标int Partition(SqList *L, int low, int high){ int pivotkey = L-&gt;r[low]; // 用子表的第一个记录作枢轴 // 从表的两端交替向中间扫描, 指针 low &lt; high 是前提条件 while (low &lt; high) { while (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) // 如果当前 high 指向的关键字比枢轴大 high--; // high 指针左移 swap(L, low, high); // 继续交换 low 与 high 指向的记录, 如果 high 没有右移, 则代表撤回上一次的 swap() 操作 while (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) // 如果当前 low 指向的关键字比枢轴小 low++; // low 指针右移 swap(L, low, high); // 继续交换 low 与 high 指向的记录, 如果 low 没有右移, 则代表撤回上一次的 swap() 操作 } // 每一次 swap() 操作, 如果在接下来的判断中满足与 pivotkey 的关系, 则移动指针 high 或 low 以继续下一步 swap(), 否则 swap() 操作会被撤回 // 循环中, pivotkey 不断在 low 和 high 的位置交换, 最后被递到中间(此时 low == high), 结束循环. return low; // 循环结束后 low 等于 high 等于 pivotkey 的下标.}// 对表 L 的子序列 L-&gt;r[low~high] 作快速排序void QSort(SqList *L, int low, int high){ int pivot; if (low &lt; high) { pivot = Partition(L, low, high); // 将 L-&gt;r[low~high] 一分为二, 返回枢轴的下标(枢轴左边的值都比它小, 右边的值都比它大) // 对左子表(r[low ~ pivot-1])递归排序 QSort(L, low, pivot - 1); // 对右子表(r[pivot+1 ~ high])递归排序 QSort(L, pivot + 1, high); }}void QuickSort(SqList *L){ QSort(L, 0, L-&gt;length - 1);} 递归的推算: 12345678910111213141516QSort(L, 0, 8) [50,10,90,30,70,40,80,60,20] -&gt; 执行完余下的递归后 [10,20,30,40,50,60,70,80,90] pivot=4 [20,10,40,30,50,70,80,60,90] QSort(L, 0, 3) [20,10,40,30,...] -&gt; 执行完余下的递归后 [10,20,30,40] pivot=1 [10,20,40,30,...] QSort(L, 0, 0) QSort(L, 2, 3) [x,x,40,30,...] pivot=2 [x,x,30,40,...] QSort(2,1) QSort(3,3) QSort(L, 5, 8) [...,70,80,60,90] -&gt; 执行完余下的递归后 [...,60,70,80,90] pivot=6 [...,60,70,80,90] QSort(L,5,5) QSort(L,7,8) [...,80,90] pivot=7 QSort(L,7,6) QSort(8,8) 快速排序复杂度分析 递归的运算可以想象成一颗递归树 在最优情况下, Partition() 每次都划分得很均匀, 如果排序 n 个关键字，其递归树的深度为\\(log_2 n + 1\\) 即仅需递归 \\(\\log_2 n\\) 次. 每次划分扫描耗时 \\(O(n)\\) 因此在最优情况下快速排序算法的时间复杂度为 \\(O(n\\log n)\\) 在最坏情况下, 待排序序列为正序或者逆序, 每次划分只得到比上一次划分少一个记录的子序列. 如果用递归树表示就是一颗斜树. 深度为 \\(n-1\\). 第 i 次划分需要 n-i 次比较, 即 \\(\\displaystyle\\sum_{i=1}^{n-1} n-i=O(n)\\) 因此在最坏情况下快速排序算法的时间复杂度为 \\(O(n^2)\\) 平均情况为 \\(O(n\\log n)\\) 由于关键字的比较和交换是跳跃进行的, 快速排序是一种不稳定的排序方法","link":"/zh-cn/learn/2020/data-structure/"}],"tags":[{"name":"electronic-and-information-engineering","slug":"electronic-and-information-engineering","link":"/tags/electronic-and-information-engineering/"},{"name":"mathematics","slug":"mathematics","link":"/tags/mathematics/"},{"name":"senior-high-schoool","slug":"senior-high-schoool","link":"/tags/senior-high-schoool/"},{"name":"postgraduate","slug":"postgraduate","link":"/tags/postgraduate/"}],"categories":[{"name":"computer","slug":"computer","link":"/categories/computer/"},{"name":"daily-life","slug":"daily-life","link":"/categories/daily-life/"},{"name":"ideology-and-politics","slug":"ideology-and-politics","link":"/categories/ideology-and-politics/"},{"name":"learn","slug":"learn","link":"/categories/learn/"},{"name":"minecraft","slug":"minecraft","link":"/categories/minecraft/"},{"name":"mathematics","slug":"learn/mathematics","link":"/categories/learn/mathematics/"}]}