<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>cpp - 钱桑もぺもぺ～</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="钱桑もぺもぺ～"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="钱桑もぺもぺ～"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Notes on Cherno C++ Tutorial TODO: 重新格式化这篇文章"><meta property="og:type" content="blog"><meta property="og:title" content="cpp"><meta property="og:url" content="http://blog.ndoskrnl.net/zh-cn/learn/2020/cpp/"><meta property="og:site_name" content="钱桑もぺもぺ～"><meta property="og:description" content="Notes on Cherno C++ Tutorial TODO: 重新格式化这篇文章"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://blog.ndoskrnl.net/img/og_image.png"><meta property="article:published_time" content="2020-02-08T08:45:08.000Z"><meta property="article:modified_time" content="2022-02-16T06:14:49.441Z"><meta property="article:author" content="Ndoskrnl"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.ndoskrnl.net/zh-cn/learn/2020/cpp/"},"headline":"cpp","image":["http://blog.ndoskrnl.net/img/og_image.png"],"datePublished":"2020-02-08T08:45:08.000Z","dateModified":"2022-02-16T06:14:49.441Z","author":{"@type":"Person","name":"Ndoskrnl"},"publisher":{"@type":"Organization","name":"钱桑もぺもぺ～","logo":{"@type":"ImageObject","url":"http://blog.ndoskrnl.net/img/logo.svg"}},"description":"Notes on Cherno C++ Tutorial TODO: 重新格式化这篇文章"}</script><link rel="canonical" href="http://blog.ndoskrnl.net/zh-cn/learn/2020/cpp/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start -->
        <script>
            function switchTab(element) {
                const id = element.parentElement.id;
                const tabElements = element.parentElement.parentElement.children;
                const contentElements = element.parentElement.parentElement.parentElement.parentElement.children[1].children;
                for (let i = 0; i < tabElements.length; i++) {
                    const $tab = tabElements[i];
                    const $content = contentElements[i];
                    if ($tab.id === id) {
                        $tab.classList.add('is-active');
                    } else {
                        $tab.classList.remove('is-active');
                    }
                    if ($content.id === id) {
                        $content.classList.remove('is-hidden');
                    } else {
                        $content.classList.add('is-hidden');
                    }
                }
            }
        </script>
        <!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="钱桑もぺもぺ～" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/peers">Peers</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-08T08:45:08.000Z" title="2/8/2020, 8:45:08 AM">2020-02-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-02-16T06:14:49.441Z" title="2/16/2022, 6:14:49 AM">2022-02-16</time></span><span class="level-item"><a class="link-muted" href="/categories/learn/">learn</a></span><span class="level-item">1 小时 read (About 11176 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">cpp</h1><div class="content"><p>Notes on Cherno C++ Tutorial</p>
<p>TODO: 重新格式化这篇文章</p>
<span id="more"></span>
<blockquote>
<p>写在前面: 如果你在看到一半的时候, 若出现<strong>还没有讲到过的操作出现在示范代码中</strong>(比如new), 知道它<strong>基本起什么作用</strong>即可, 在后面的episodes肯定会细讲</p>
</blockquote>
<blockquote>
<p>如果你看到夹杂英文, 那是我直接copy了@Cherno的话并懒得翻译</p>
</blockquote>
<h2 id="Notice">Notice</h2>
<ol>
<li>Always pass your function parameters with const if possible</li>
<li>If an object have pointer variable inside, write a copy constructor and use it</li>
<li>节约内存的小技巧<br>
由于内存最小可操作单位是 byte, 而 bool 类型只需要 1 字节即可(0 和 1)，巧妙的方法是使用 1 个 byte 表示 8 个 bool 类型变量</li>
<li>头文件 or inline? （inline实际上就是将函数整个代码复制到调用这个函数的函数那里）</li>
<li>宏使用<code>#if</code>和<code>#endif</code>作为条件判断<br>
<code>#if 1</code>为<code>true</code></li>
<li>声明为 static 的变量和函数只在它所在的 translation unit 有效</li>
<li>默认的浮点数是double类型的, 如果你只用float的精度, 在数据后加上&quot;f&quot;如 <code>float a = 5.5f</code></li>
</ol>
<p>@Cherno 写Class的规范:</p>
<ol>
<li>
<p>m_LogLevel的&quot;m_&quot;表示变量是类内部(private)变量</p>
</li>
<li>
<p>public和private可以分离, 如一部分Public修饰变量, 另一部分Public修饰函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> LogLevelError = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> LogLevelWarning = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> LogLevelInfo = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_LogLevel = LogLevelInfo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetLevel</span><span class="params">(<span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_LogLevel = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Error</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelError)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Error]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Warn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelWarning)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[WARNING]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelInfo)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[INFO]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="How-C-Works">How C++ Works</h2>
<p>Concepts:</p>
<ul>
<li>Every .cpp will compile to one .o/.obj file</li>
<li>multiple .cpp and .h has <code>#include</code> with each other can compose to a translation unit</li>
<li>Compile Process Path: Source-&gt;Compile-&gt;Linker-&gt;Executables</li>
</ul>
<ol>
<li>
<p>Generate Pre-process file<br>
Pro-process file is the source code that the macro (such like <code>#include</code>) was parsed by the compiler.</p>
<ul>
<li>VS2015: Project Settings-&gt;Preprocessor-&gt;Preprocess to a File</li>
<li>GCC: <code>cpp hello.cpp &gt; hello.i</code></li>
</ul>
</li>
<li>
<p>Compile &amp; Assembly</p>
<ul>
<li>VS2015: Compile Only (Ctrl+F7)</li>
<li>GCC: <code>g++ -S main.i; as main.s -o main.o</code></li>
</ul>
</li>
<li>
<p>Linker<br>
Externally defined functions will be integrated in the link phase,<br>
and function declarations that never be called will be optimized away.</p>
<p>The parameter of <code>ld</code> are platform specific (mainly depend on your gcc version)<br>
Use <code>g++ -v -o hello hello.cpp</code> we can get the parameter of the <code>collect2</code> (which is an alias for <code>ld</code>)</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ -v -o hello hello.cpp</span></span><br><span class="line">...</span><br><span class="line">/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/collect2 -plugin /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/lto-wrapper -plugin-opt=-fresolution=/tmp/ccDNo0Hr.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -o main.exe /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/Scrt1.o /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtbeginS.o -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0 -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../.. /tmp/ccs86P3x.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtendS.o /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crtn.o</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>So the <code>ld</code> command should be</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ld</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/lto-wrapper</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -plugin-opt=-fresolution=/tmp/ccHyR7Od.res</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -plugin-opt=-pass-through=-lgcc_s</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -plugin-opt=-pass-through=-lgcc</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -plugin-opt=-pass-through=-lc</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -plugin-opt=-pass-through=-lgcc_s</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -plugin-opt=-pass-through=-lgcc</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> --build-id</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> --eh-frame-hdr</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> --hash-style=gnu</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -m elf_x86_64</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -dynamic-linker /lib64/ld-linux-x86-64.so.2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -pie</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -o main /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/Scrt1.o</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crti.o</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtbeginS.o</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -L/lib/../lib</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -L/usr/lib/../lib</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../..</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> main.o</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lstdc++</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lm</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lgcc_s</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lgcc</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lc</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lgcc_s</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lgcc /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtendS.o</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crtn.o</span></span><br></pre></td></tr></table></figure>
<p>You can probably significantly shorten that link line by removing some arguments. Here’s the minimal set I came up with after some experimentation:</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ld</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -dynamic-linker /lib64/ld-linux-x86-64.so.2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -o main /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/Scrt1.o</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crti.o</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtbeginS.o</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> main.o</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lstdc++</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lc</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/crtendS.o</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/crtn.o</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Variables-in-C">Variables in C++</h2>
<p>Main idea: The difference between C++ data types are simply the different allocated memory size and the declaration of the type of data to be stored</p>
<p>Different memory allocation size for C++ Data Type:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>1 Byte</td>
</tr>
<tr>
<td>short</td>
<td>2 Bytes</td>
</tr>
<tr>
<td>int</td>
<td>4 Bytes</td>
</tr>
<tr>
<td>long</td>
<td><strong>commonly</strong> 4 Bytes</td>
</tr>
<tr>
<td>long long</td>
<td>8 Bytes</td>
</tr>
<tr>
<td>float</td>
<td>4 Bytes</td>
</tr>
<tr>
<td>double</td>
<td>8 Bytes</td>
</tr>
</tbody>
</table>
<blockquote>
<p>You can use <code>sizeof()</code> to see the data type size.</p>
</blockquote>
<h2 id="Functions-in-C">Functions in C++</h2>
<ul>
<li><strong>Function</strong> means a function that is not in a class.<br>
<strong>Method</strong> means a function in a class.</li>
<li>The main purpose of the function is to reduce code duplication.<br>
But don’t frequently divide your code into functions, calling a function requires<br>
creating an entire stack frame for that function.<br>
This means we have to push parameters and so on into the stack, and also, put something<br>
called the return address into the stack, so that after the function executed the PC register could return to the address before the function call.<br>
TLDR: Jumping around in memory to execute function instructions comsumes additional time.</li>
<li>Generally we write function definitions in header files (.h) and function bodies in .cpp files.</li>
</ul>
<h2 id="C-Header-Files">C++ Header Files</h2>
<p><code>#pragma once</code> can prevent include same header file multiple times in a translation unit<br>
(e.g. your include header file b.h in a.cpp, but b.h includes andther header file c.h, while you have already include b.h before in a.cpp)</p>
<p>The second way do the same thing as <code>#pragma once</code> (In CLion this is the default way):</p>
<figure class="highlight c++"><figcaption><span>Log.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some sentence...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="How-to-DEBUG-C-in-VISUAL-STUDIO">How to DEBUG C++ in VISUAL STUDIO</h2>
<ul>
<li>The <strong>watch view</strong> in VS2015 allows you to specify the veriables to be monitored,<br>
In <strong>memory window</strong> you can search by keyword <code>&amp;a</code> to show the address of variable <code>a</code></li>
<li>The default value of uninitialized variables is <code>0xcccccccc</code></li>
</ul>
<h2 id="Visual-Studio-Setup-for-C">Visual Studio Setup for C++</h2>
<ul>
<li>Use <strong>Show All Files</strong> view under Solution Explorer</li>
<li>By default VS2015 put intermediate files in debug directory</li>
<li>It’s recommand to set Output Directory into <code>$(SolutionDir)bin\$(Platform)\$(Configuration)\</code><br>
and set Intermediate Directory into <code>$(SolutionDir)bin\intermediate\$(Platform)\$(Configuration)\</code></li>
</ul>
<h2 id="CONDITIONS-and-BRANCHES-in-C">CONDITIONS and BRANCHES in C++</h2>
<ul>
<li>In C++ 0 means false, any other numbers means true</li>
<li><code>else if</code> is equivalent to <code>else &#123; if()&#123;&#125; &#125;</code></li>
</ul>
<h2 id="Loops-in-C">Loops in C++</h2>
<p><code>for</code> can also be written in the form of <code>while</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> condition = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> ( ; condition; )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Log</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (!(i&lt;<span class="number">5</span>))</span><br><span class="line">        condition = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="POINTERS-in-C">POINTERS in C++</h2>
<ul>
<li>Pointer: the pointer represents a momory address,<br>
generally the data type of the pointer is used to represent the data type of the data at the target address.<br>
So if we don’t care the pointed data’s data type, just using <code>void*</code></li>
<li>Pointer to Pointer:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a space with 8 char&#x27;s and fill it with zero, then finally release the memory space.</span></span><br><span class="line"><span class="keyword">char</span>* buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pointer to pointer</span></span><br><span class="line"><span class="keyword">char</span>** ptr = &amp;buffer;</span><br></pre></td></tr></table></figure>
In running, <code>ptr</code> 储存的数据为 <code>0x00B6FED4</code> (即 <code>buffer</code> 作为变量本身的地址),<br>
在 VS2019 自带的 Memory View 中<br>
<code>buffer</code>储存的数据为<code>f0 dd d0 00</code> (<code>buffer</code>指向8个char长度的空间地址),<br>
由于x86的设计,<br>
我们从 Memory View <strong>看到的是反转的数据</strong>, 实际应该是<code>00 d0 dd f0</code>(即 0x00d0ddf0), 这个地址就是那8个char长度空间的所在地.</li>
</ul>
<h2 id="Reference-in-C">Reference in C++</h2>
<p>函数的形式参数中<br>
使用引用可以使代码<strong>相比指针更简洁</strong><br>
因为访问引用变量不使用需要去引用化符号 “*”</p>
<h2 id="CLASSES-vs-STRUCTS-in-C">CLASSES vs STRUCTS in C++</h2>
<p>Struct和Class<strong>无本质区别</strong><br>
Struct更适合存储多个变量, 侧重于表达数据结构, 而对象侧重于表达对象<br>
Struct中的变量默认是Public修饰.<br>
同时, Class可以继承Struct(但编译器会报警)</p>
<p><code>public:</code> 和 <code>private:</code> 在类中可有多处</p>
<h2 id="Static-in-C">Static in C++</h2>
<p>Basically just to <code>cut to the chase</code> (切入正题/长话短说),<br>
static outside of class means that the linkage of that symbol that you declare to be static is going to be internal meaning. It;s only going to be visible to that translation unit that you’ve defined it in.</p>
<p>Whereas a static variable inside a class or struct means that variable is actually going to share memory with all of the instances of the class meaning that basically across all instances that you create of that class or struct, there’s only going to be one instance of that static variable<br>
and a similar thing applies to static methods in a class there is no instance of that class being passed into that method. (Cherno讲的是背后的原理)</p>
<p>第一种情况翻译: 由于translation unit中的(不是class中的)全局变量/函数是全局可见的, 所以加上static让全局变量只在它所在的translation unit可见. 否则在不同的translation unit声明相同符号的变量将在链接阶段报重复定义错误. 类似于translation unit的private修饰</p>
<p>@Cherno 的命名规范:</p>
<p>s_开头代表变量为静态 <code>static int s_Variable = 5;</code></p>
<hr>
<p>尽量在头文件使用static变量, 因为它只是简单将内容复制到cpp文件</p>
<h3 id="Local-Static">Local Static</h3>
<p>使变量在局部可见的同时有static的性质</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	i++;</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Classical-Singleton">Classical Singleton</h3>
<p>Singleton类在整个程序中只有一个实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> Singleton* s_Instance;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;; <span class="comment">// 这一行作用阻止类被实例化, 后面构造函数会讲</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *s_Instance; &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::s_Instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或者将对象实例放在局部静态变量中(好处: 相比上一种更少的代码量)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;; <span class="comment">// 这一行作用阻止类被实例化, 后面构造函数会讲</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">static</span> Singleton instance;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Enum-in-C">Enum in C++</h2>
<p>枚举用来管理标识符, 增强代码可读性, 本质是Integer(可指定which types of integer you want to be)<br>
如<br>
(模式是32位Integer, 这里用unsigned char只有8位可以节约内存)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Example</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">char</span></span><br><span class="line">&#123;</span><br><span class="line">    A, B, C</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用enum后的Log类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Level</span></span></span><br><span class="line"><span class="class">    &#123;</span> <span class="comment">// LevelError = 0代表从零开始递进, 当然默认就是0</span></span><br><span class="line">        LevelError = <span class="number">0</span>, LevelWarning, LevelInfo</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Level m_LogLevel = LevelInfo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetLevel</span><span class="params">(Level level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_LogLevel = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Error</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_LogLevel &gt;= LevelError)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Error]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Warn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_LogLevel &gt;= LevelWarning)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[WARNING]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_LogLevel &gt;= LevelInfo)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[INFO]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log log;</span><br><span class="line">    log.<span class="built_in">SetLevel</span>(Log::LevelWarning);</span><br><span class="line">    log.<span class="built_in">Error</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    log.<span class="built_in">Warn</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    log.<span class="built_in">Info</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Constructors-in-C">Constructors in C++</h2>
<p>You have to manually initialize all of your primitive types otherwise they will be set to whatever was left over in that memory.</p>
<p>禁止实例化类, 只需要把构造函数设为Private, 或者删除构造函数<br>
If you did not want people creating instances…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Private:</span><br><span class="line">    <span class="built_in">Log</span>() &#123;&#125; <span class="comment">// One way</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Log</span>() = <span class="keyword">delete</span>; <span class="comment">// Another way</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Only Write() can be invoke</span></span><br><span class="line">    Log::<span class="built_in">Write</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now you cannot access the constructor</span></span><br><span class="line">    Log l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Destructors-in-C">Destructors in C++</h2>
<p>折构函数可以被这样调用, 但是基本上不会用到, It’s weired</p>
<p>someClass.~someClass();</p>
<h2 id="Inheritance-in-C">Inheritance in C++</h2>
<p>没啥好说的, 唯一要注意的是继承的类的大小将是: 父类所有的变量总和 + 自己声明变量总和</p>
<p>Use colon to inerit a class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub_Class</span> :</span> Main_Class</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Virtual-Function-in-C">Virtual Function in C++</h2>
<p>首先我们来看为什么要有Virtual函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="keyword">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Player* player = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    Eneity* entity2 = player;</span><br><span class="line">    std::cout &lt;&lt; entity2-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity</span><br><span class="line">Entity</span><br></pre></td></tr></table></figure>
<p>发现问题了吗, 第二个输出本应是&quot;Cherno&quot;</p>
<p>实际上当指针类型是父类Entity时, 通过该指针调用子类Player类的重载函数GetName()并没有被调用, 而是父类定义的内容, 这会导致许多问题</p>
<p>C++11引入了Override关键字, 它不是必须的, 但能够避免发生拼写错误并能增强代码的可读性</p>
<p>正确示范:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 加上了virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="keyword">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加上了override</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Player* player = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    Eneity* entity2 = player;</span><br><span class="line">    std::cout &lt;&lt; entity2-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结:</p>
<p>If you want to override a function you have to mark the base function in the base class as virtual.</p>
<p>不重要的补充:</p>
<ol>
<li>
<p>使用virtual可以减少dynamic dispatch这种操作的使用 (运行时修改对象的vtable).</p>
</li>
<li>
<p>很不幸virtual它不属于免费的午餐, 首先使用它会需要额外的Vtable空间以让我们能够dispatch to the correct function that includes a member pointer in the actual base class that points to the Vtable. 第二, 我们每次调用virtual函数我们都要通过那个table来决定which function to actually map to.</p>
<p>但是基本上区别并不明显, 所以能用就用. 除非你的程序要跑在一个性能真的非常非常差的嵌入式设备上.</p>
</li>
</ol>
<h2 id="Interface-Pure-virtual-method">Interface (Pure virtual method)</h2>
<p>在Printable中创建一个GetClassName的赋值为0的函数, 它就是一个接口</p>
<p>这个类也不能被直接实例化, 需要实现此方法的子类才能工作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printable</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClassName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity, Printable <span class="comment">// 子类可以继承多个接口类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Printable* obj)</span> <span class="comment">// 通过这样的函数, 我们只需要实现这个方法, 该函数就会调用我们的实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj-&gt;<span class="built_in">GetClassName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Player player = <span class="keyword">new</span> <span class="built_in">Player</span>();</span><br><span class="line">    <span class="built_in">Print</span>(player);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(<span class="keyword">new</span> Player); <span class="comment">// 不要这么用, 会导致内存泄漏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Visibility-in-C">Visibility in C++</h2>
<p>The default visibility of a Class would actually be private; if its a Struct then it would be public by default.</p>
<p>private标记的内容只有本类能访问, 子类也不行, 但是朋友类(friend class)可以, 会在以后视频中讲到.</p>
<p>protected标记是在private基础上, 子类可以访问</p>
<h2 id="Arrays-in-C">Arrays in C++</h2>
<h3 id="Raw-Arrays">Raw Arrays</h3>
<p>举个例子<code>int example[5]</code></p>
<p>数组名称 example 是一个指针, 指向 example[0] 的所在地址</p>
<p>请注意, 不能使用超出数组下标的操作(如<code>example[-1] = 0</code>), 那意味着访问不在当前数组许可范围内的内存; 在debug模式下它会报错, 但在release下它可能会造成不可预料的后果</p>
<p>还可以用指针的方式访问数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> example[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span>* ptr = example;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++)</span><br><span class="line">    example[i] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">example[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// equals to *(ptr + 2) = 5;</span></span><br><span class="line"><span class="comment">// 因为这个指针是int类型, 所以每次+1都向后偏移4字节的内存地址(对指针进行加减操作是不同于普通的);</span></span><br><span class="line"><span class="comment">// 所以也可以写成:</span></span><br><span class="line"><span class="comment">// *(int*)((char*)ptr + 8) = 6;</span></span><br><span class="line"><span class="comment">// 即先以1 byte的char*进行指针加法操作, 然后再转回int*</span></span><br><span class="line"><span class="comment">// It is pretty wild line of code.</span></span><br></pre></td></tr></table></figure>
<p>更多的, 两种不同的创建数组的方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> example[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span>* another = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 前者是创建在stack上的并且会在函数执行完后被摧毁</span></span><br><span class="line"><span class="comment">// 后者是创建在heap上的</span></span><br><span class="line"><span class="comment">// 建议在类中使用前者, 在函数中使用后者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We need to delete using the square brackets</span></span><br><span class="line"><span class="keyword">delete</span>[] another;</span><br></pre></td></tr></table></figure>
<p><strong>在C++中你无法动态地检查一个普通数组的大小</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* another = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="built_in"><span class="keyword">sizeof</span></span>(another) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 使用这样的方式是不靠谱的</span></span><br><span class="line"><span class="comment">// 由于another是个指针, 所以最终 count 的结果是1, 这显然不对</span></span><br></pre></td></tr></table></figure>
<p>一个比较好的办法是管理一些记录数组大小的常量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> exampleSize = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> example[size];</span><br></pre></td></tr></table></figure>
<h3 id="C-11-Standard-Arrays">C++11 Standard Arrays</h3>
<p>好处是能很方便地检查一个数组的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 5&gt; another;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; another.<span class="built_in">size</span>(); i++)</span><br><span class="line">        eanother[i] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两者区别是Standard Arrays 相比 Raw Array s有更多性能的开销(但是值得), 且更安全</p>
<p>@TheCherno 更喜欢用Raw Arrays, Because he like to live dangerously :)</p>
<h2 id="How-Strings-Work-in-C-and-how-to-use-them">How Strings Work in C++ (and how to use them)</h2>
<h3 id="C风格字符串">C风格字符串</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">&quot;Cherno&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>字符串分配的内存是fixed allocated block, 这表示想要扩充只能通过分配全新的字符串(新的地址)并删除旧的字符串来实现<br>
同时由于这是个char指针所以这个字符串不能用delete(后面会细讲new和delete, rule of thumb is just if you don’t use ‘new’ keyword dont’t use the ‘delete’ keyword)</p>
<h4 id="细节的东西">细节的东西</h4>
<p><code>null termination character</code>: 每个字符串末尾都会有一个null结束符0(int类型, 等价于’\0’这个char类型)<br>
比如 <code>char name[7] = &#123;'C', 'h', 'e', 'r', 'n', 'o', '\0'&#125;;</code><br>
如果没有结束符, 那么当使用cout输出字符串时, 它会一直输出接下来的内存数据直到读到’\0’. (表现为输出&quot;Cherno&quot;然后跟着一串乱码)</p>
<p><strong>注意</strong>: Double quote “” by default it becomes a char pointer; 翻译: “Cherno” 默认表示为类型为 char* 的数据.<br>
为什么是 const char* ? 因为字符串本质是char数组, 而数组变量本质上储存的也就是这个数组的起始地址, 所以用 const char* 没毛病, cout对const char*有特殊对待不不断地读下去直到碰到前文所说的<code>null termination character</code></p>
<p>同时, 从Memory View看到的十六进制 <code>cc</code> 大概率表示we are right outside of the bounds of our allocation.</p>
<h3 id="C-标准字符串">C++ 标准字符串</h3>
<p><strong>本质上是char array</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">// cout没有输出string类型的overload, 如果不输出可以不用include</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    std::string name = <span class="string">&quot;Cherno&quot;</span> + <span class="string">&quot; hello!&quot;</span>; <span class="comment">//这种方式是不对的, 因为&quot;Cherno&quot;是一个 const char* 类型</span></span><br><span class="line">    </span><br><span class="line">    std::string name = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    name += <span class="string">&quot; hello!&quot;</span>; <span class="comment">// 这种是对的, a nice easy way, because you are adding it to a string, and &quot;+=&quot; is overloaded in the string class to be able to let you do that.</span></span><br><span class="line">    <span class="comment">// 或者这样(虽然会有更多的对象拷贝操作, 大多数情况下性能影响不大)</span></span><br><span class="line">    std::string name = std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>) + <span class="string">&quot; hello!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的使用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否包含指定文字</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">const</span> contains = name.<span class="built_in">find</span>(<span class="string">&quot;no&quot;</span>) != std::string::npos <span class="comment">// std::string::npos 代表没有找到返回的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为字符串操作在c++中很普遍, 而每次都进行不必要的对象复制无疑很低效, 使用const xxx&amp;将对象直接以只读形式传入函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">PrintString</span>(<span class="keyword">const</span> std::string&amp; string)</span><br><span class="line">&#123;</span><br><span class="line">    string += <span class="string">&quot;h&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; string &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="String-literals">String literals</h2>
<p>Terminal character will actuall break the behavior of this string in many cases</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> name[<span class="number">8</span>] = <span class="string">&quot;Che\0rno&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">strlen</span>(name) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String literals are stored in read-only section of memory<br>
This code might not vaild for all CPP compilers.<br>
And edit this string is actually didn’t work:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* name = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    <span class="comment">// 这种定义是错误的, 字符串类型指针应该永远是const char*</span></span><br><span class="line">    <span class="comment">// 要想运行时修改字符串, 正确操作应是定义一个字符串数组而不是一个指针</span></span><br><span class="line">    <span class="comment">// char name[] = &quot;Cherno&quot;;</span></span><br><span class="line">    name[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="其他类型的字符串">其他类型的字符串</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">u8&quot;Cherno&quot;</span>; <span class="comment">// utf-8, u8前缀非必要</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char16_t</span>* name2 = <span class="string">u&quot;Cherno&quot;</span>; <span class="comment">// two bytes per character (utf-16)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char32_t</span>* name3 = <span class="string">U&quot;Cherno&quot;</span>; <span class="comment">// four bytes per character (utf-32)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">wchar_t</span>* name4 = <span class="string">L&quot;Cherno&quot;</span>; <span class="comment">// 由编译器决定, eitger 2 ir 4 bytes, its 2 bytes on Windows and 4 on Linux and I acpect Mac as well</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++14标准</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line">    std::string name0 = <span class="string">&quot;Cherno&quot;</span>s + <span class="string">&quot; hello&quot;</span>;</span><br><span class="line">    std::wstring name1 = <span class="string">L&quot;Cherno&quot;</span>s + <span class="string">L&quot; hello&quot;</span>;</span><br><span class="line">    std::u32string name1 = <span class="string">U&quot;Cherno&quot;</span>s + <span class="string">U&quot; hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// raw形式赋值, 对拷贝大篇文章时保留文章格式有用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* rawstring = <span class="string">R&quot;(Line1</span></span><br><span class="line"><span class="string">Line2</span></span><br><span class="line"><span class="string">Line3</span></span><br><span class="line"><span class="string">Line4)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const-in-C">const in C++</h2>
<h3 id="const-pointer">const pointer</h3>
<p>在前, you cannot change the data at that memory address<br>
在后, you cannot reassign the actual pointer itself to point something else</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inst MAX_AGE = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Pointer to const value</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*a = <span class="number">2</span>; <span class="comment">// I cannot change the contents of the pointer</span></span><br><span class="line">a = (<span class="keyword">int</span>*) &amp;MAX_AGE; <span class="comment">// But I can change the pointer itself</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Const pointers</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> b = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*b = <span class="number">2</span>;</span><br><span class="line">b = (<span class="keyword">int</span>*) &amp;MAX_AGE; <span class="comment">// but you cannot change the pointer whose value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Const pointer to a const value</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> c = (<span class="keyword">int</span>*) &amp;MAX_AGE;</span><br></pre></td></tr></table></figure>
<p>注意: <code>const int*</code> 和 <code>int const*</code> 是相等的, 你需要将<code>const</code> 放在 <code>*</code> 号后面</p>
<p><span id="const_method"></span></p>
<h3 id="const-method">const method</h3>
<p>const 修饰的方法无法改变类中的变量<br>
Only avaliable in class method</p>
<p>涉及内容:</p>
<ol>
<li>当const方法返回指针类型时怎么做: 方法数据类型应为 “const int* const”</li>
<li>以 <code>const Object&amp;</code> 实例化的对象只能访问const方法</li>
<li><code>mutable</code> 变量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_X, *m_Y, *m_Z; <span class="comment">// 定义多个变量时指针类型要为每个单独加 &#x27;*&#x27; 号</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> var;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// m_X = 2; 你不能修改变量的值</span></span><br><span class="line">        var = <span class="number">233</span>; <span class="comment">// 但我们可以在const方法中修改mutable修饰的变量</span></span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">GetY</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// 若const方法要返回指针类型变量, 方法数据类型应为 &quot;const int* const&quot;</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_X = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintEntity</span> <span class="params">(<span class="keyword">const</span> Eneity&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; e.SetX() &lt;&lt; endl; 常量型对象无法访问无const修饰的方法</span></span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">GetX</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="built_in">PrintEneity</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Mutable-Keyword-in-C">Mutable Keyword in C++</h2>
<p><code>mutalbe</code>有两种用法, <br>
第一种用于常量方法中, 见<a href="#const_method">#const method</a>,<br>
第二种用于lambda, 用的不多</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=]() <span class="keyword">mutable</span></span><br><span class="line">&#123;</span><br><span class="line">    x++;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="comment">// x is still = 8, 因为[=]模式 is just copy this value into this lambda, mutable代表它能更改传递进来的值并且不让编译器报错, 但实际上8本身是个常数所以没有效果.</span></span><br></pre></td></tr></table></figure>
<p><strong>什么是lambda</strong>: a lambda is basically like a little throwaway function that you can write and assign to a variable quickly.</p>
<h2 id="Memory-Initializer-Lists-in-C-Constructor-Initializer-List">Memory Initializer Lists in C++ (Constructor Initializer List)</h2>
<p>使用构造初始化列表可以避免使用 “=” 从而实列化两次对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Example</span>(<span class="keyword">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Create Entity with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Example m_example;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">        : <span class="built_in">m_example</span>(<span class="built_in">Example</span>(<span class="number">8</span>)), <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">z</span>(<span class="number">0</span>) <span class="comment">// m_example(Example(8)) 或者m_example(8)都行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// m_Example = Example(8); 如果在构造函数中实列化内部变量, 该对象会实例化两次</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ternary-Operators-in-C-Conditional-Assignment">Ternary Operators in C++ (Conditional Assignment)</h2>
<p>使用三目运算符可以简化if_else语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_Level = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_Speed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_Speed = s_Level &gt; <span class="number">5</span> &amp;&amp; s_Level &lt; <span class="number">100</span> ? s_Level &gt; <span class="number">10</span> ? <span class="number">15</span> : <span class="number">10</span> : <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s_Speed &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以上式子等价于</span></span><br><span class="line">    <span class="comment">// if (s_Level &gt; 5 &amp;&amp; s_Level &lt; 100)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     if(s_Level &gt; 10)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         s_Speed = 15;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     else</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         s_Speed = 10;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line">    <span class="comment">// else </span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     s_Speed = 5;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="How-to-CREATE-INSTANTIATE-OBJECTS-in-C">How to CREATE/INSTANTIATE OBJECTS in C++</h2>
<p>There are two main section of memory: the stack and heap</p>
<p>Stack objects have an automatic lifespan, there lifetime is actually controlled by the scope their declared</p>
<p>Heap: once you allocated an object in that heap, it’s gonna sit there unill you explicit delete it</p>
<p>栈空间一般只有1M到几M(取决于平台), 如果你需要创建一个巨大的对象, 你将不得不将他创建在堆内存上</p>
<p>不使用 <code>new</code> 关键字, 对象创建在栈空间上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Entity <span class="title">entity</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Entity entity = <span class="built_in">Entity</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <code>new</code> 关键字, 对象创建在堆空间上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 返回的是创建对象的内存地址, 所以用 Entity*</span></span><br><span class="line">Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line"><span class="comment">// 你需要手动删除 new 创建的对象来释放内存</span></span><br><span class="line"><span class="keyword">delete</span> entity;</span><br></pre></td></tr></table></figure>
<p>所以用 <code>new</code> 创建对象很容易导致内存泄漏, 之后会讲的 <strong>智能指针</strong> 可用很好地解决这个问题</p>
<h2 id="The-NEW-Keyword-in-C">The NEW Keyword in C++</h2>
<p>更多new的细节</p>
<p>How the <code>new</code> keyword find free space on memory? There is something called <em>free list</em> which actually maintain the addresses that have bytes free. It’s obvously written in intelligent but its stll quite slow.</p>
<p>几点事实:</p>
<ol>
<li><code>new</code> is just an operator, means that you can overload <code>new</code> and change its bahavious</li>
<li>Usually calling <code>new</code> will call the underlying C Function <code>malloc()</code></li>
<li><strong>delete</strong> also calls the destructor</li>
</ol>
<p>三种 <code>new</code> 的不同使用方法(normal new, array new, placement new)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// If we wanted an array of entries (An array which is stored 50 Objects of Entity)</span></span><br><span class="line">    Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> entity; <span class="comment">// Remember delete object</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If using new with square bracket &quot;[&quot; and &quot;]&quot;</span></span><br><span class="line">    <span class="comment">// The new operator is actually a slightly differ function than normal</span></span><br><span class="line">    Entity* entity2 = <span class="keyword">new</span> <span class="built_in">Entity</span>()[<span class="number">50</span>];</span><br><span class="line">    <span class="comment">// Also we need calling delete with square bracket</span></span><br><span class="line">    <span class="keyword">delete</span>[] eneity2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Placement New is where you actually get to decide kind of where the memory comes from.</span></span><br><span class="line">    <span class="comment">// You don&#x27;t really allocating memory wieh new,</span></span><br><span class="line">    <span class="comment">// you&#x27;re just calling the constructor and initializing you Object in a specific memory address</span></span><br><span class="line">    <span class="keyword">int</span>* buffer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">    Entity* entity3 = <span class="built_in"><span class="keyword">new</span></span>(buffer) <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="keyword">delete</span> entity3;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="comment">// in C there are some kinds of equivalent:</span></span><br><span class="line">    <span class="comment">// Entity* entity = (Entity*) malloc(sizeof(Entity));</span></span><br><span class="line">    <span class="comment">// malloc() will not call the constructor so you need to call it in manual</span></span><br><span class="line">    <span class="comment">// So it&#x27;s better don&#x27;t use this in C++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Implicit-Conversion-and-the-Explicit-Keyword-in-C">Implicit Conversion and the Explicit Keyword in C++</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="keyword">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Age</span>(<span class="number">-1</span>) P&#123;&#125;</span><br><span class="line">    <span class="comment">// Use explicit keyword to disable implicit conversion</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">        : m_Name(<span class="string">&quot;Unknown&quot;</span>), m_Age(age) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="keyword">const</span> Entity&amp; entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Printing Statements</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// It&#x27;s weird , you can&#x27;t do this in other languages(such as C# or Java)</span></span><br><span class="line">    <span class="comment">// This is called implicit conversion</span></span><br><span class="line">    <span class="comment">// It implicit converting &quot;Cherno&quot; into Entity&#x27;s Constructor Method: Entity(const std::string&amp; name)</span></span><br><span class="line">    Entity a = std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    <span class="comment">// 虽然上面是个很好的隐式转换的例子, 但是不建议用这种语法实例化对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You cannot do implicit conversion with explicit method anymore</span></span><br><span class="line">    <span class="comment">// This is not allowed</span></span><br><span class="line">    Entity b = <span class="number">22</span>;</span><br><span class="line">    <span class="comment">// Correct sentence:</span></span><br><span class="line">    Entity b = <span class="built_in">Entity</span>(<span class="number">22</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is not allowed</span></span><br><span class="line">    Entity a = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    <span class="comment">// and</span></span><br><span class="line">    <span class="built_in">PrintEntity</span>(<span class="string">&quot;Cherno&quot;</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &quot;Cherno&quot; is a const char array</span></span><br><span class="line">    <span class="comment">// C++ need to do two conversions, one from const char* to std::string, and then call into Entity(const std::string&amp; name)</span></span><br><span class="line">    <span class="comment">// It&#x27;s only allowed to do one implicit conversion at same time</span></span><br><span class="line">    <span class="comment">// Correct sentence:</span></span><br><span class="line">    <span class="built_in">PrintEntity</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    <span class="comment">// or as normal:</span></span><br><span class="line">    <span class="built_in">PrintEntity</span>(<span class="built_in">Entity</span>(<span class="string">&quot;Cherno&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="OPERATORS-and-OPERATOR-OVERLOADING-in-C">OPERATORS and OPERATOR OVERLOADING in C++</h2>
<p>In the case of operator overloading you’re allowed to define or change the behavior of operator</p>
<p><strong>Operators are just functions</strong></p>
<p>Here goes some examples:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Vector2</span>(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span><br><span class="line">        : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overload the function &quot;operator+()&quot; equals redefine the behavior of operator plus in this Object</span></span><br><span class="line">    Vector2 <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector2&amp; other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x + other.x, y + other.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// As same with above</span></span><br><span class="line">    Vector2 <span class="keyword">operator</span>*(<span class="keyword">const</span> Vector2&amp; other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x * other.x, y * other.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// As same with above</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector2&amp; other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Vector2&amp; other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// We have a simple way</span></span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">operator</span>==(other);</span><br><span class="line">        <span class="comment">// Or</span></span><br><span class="line">        <span class="comment">// return !(*this == other);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See the use case in main()</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::string&amp; stream, <span class="keyword">const</span> Vector2&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; other.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; other.y;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Vector2 <span class="title">position</span><span class="params">(<span class="number">4.0f</span>, <span class="number">4.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">speed</span><span class="params">(<span class="number">0.5f</span>, <span class="number">1.5f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">powerup</span><span class="params">(<span class="number">1.1f</span>, <span class="number">1.1f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Vector2 result1 = position + speed * powerup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We cannot output the variables in vector directly</span></span><br><span class="line">    <span class="comment">// We need overload the function &quot;operator&lt;&lt;&quot;</span></span><br><span class="line">    std::cout &lt;&lt; result1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// In programs such like Java we have to use equals() to compare objects</span></span><br><span class="line">    <span class="comment">// but in C++ we can simply overload the &quot;operator==&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(retult1 == position) std::cout&lt;&lt; <span class="string">&quot;foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ths-“this”-keyword-in-C">Ths “this” keyword in C++</h2>
<p>this是一个指向当前方法所在对象的指针<br>
避免形参名字和对象成员变量的名字一样所造成的歧义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里只是示范, 实际有更方便的构造参数列表来赋值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x; <span class="comment">// or (*this).x = x;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Object-Lifetime-in-C-Stack-Scope-Lifetimes">Object Lifetime in C++ (Stack/Scope Lifetimes)</h2>
<p>下面的例子讲了三件事:</p>
<ol>
<li>编写函数时不要返回在stack内存空间创建的对象</li>
<li>使用 <code>&#123;&#125;</code> 创建局部scope以使stack上的对象更早地被自动清理</li>
<li>Unique Pointer的基本原理展示</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">CreateArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t write code like this</span></span><br><span class="line">    <span class="comment">// The array gets cleared as soon as we go out of scope</span></span><br><span class="line">    <span class="keyword">int</span> array[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* m_Ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* ptr) : <span class="built_in">m_Ptr</span>(ptr)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Ptr; <span class="comment">// delete Entity when ScopedPtr get deleted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// scope with brace</span></span><br><span class="line">    &#123;</span><br><span class="line">        Entity e; <span class="comment">// the object created on stack will gets free when out of the scope</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We could use something in the standard library called unique pointer which is a scoped pointer</span></span><br><span class="line">        <span class="comment">// but here we write our own to explain how it works</span></span><br><span class="line">        ScopedPtr e = <span class="keyword">new</span> <span class="built_in">Entity</span>(); <span class="comment">// It&#x27;s implicit conversion</span></span><br><span class="line">        <span class="comment">// because the scoped pointer object gets allocated on the stack which means it will gets deleted when out of the scope and call ~ScopedPtr()</span></span><br><span class="line">        <span class="comment">// then corresponding the Entity will gets deleted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SMART-POINTERS-in-C-std-unique-ptr-std-shared-ptr-std-weak-ptr">SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr)</h2>
<p>Smart pointers mean that when you call <code>new</code> , you don’t have to call <code>delete</code><br>
In face in many cases with smart pointers we don’t even have to call <code>new</code></p>
<p>This episode introduce:</p>
<ol>
<li>unique pointer</li>
<li>shared pointer &amp; weak pointer</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">Entity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destoryed Entity~&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// All smart pointer are marked as explicit</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">uniqueEntity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;</span><br><span class="line">        <span class="comment">// The preferred way through to construct this would be to assign it to std::make_unique&lt;Entity&gt;</span></span><br><span class="line">        <span class="comment">// The primary that is important for unique pointers is due to exception safety</span></span><br><span class="line">        std::unique_ptr&lt;Entity&gt; uniqueEntity = std::make_unique&lt;Entity&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// You can access it like you would normally</span></span><br><span class="line">        uniqueEntity-&gt;<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tou cannot copy unique pointer, you will get a compile error</span></span><br><span class="line">        std::unique_ptr&lt;Entity&gt; e0 = entity;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If you go to definition of unique pointer you&#x27;ll see that the copy constructor</span></span><br><span class="line">        <span class="comment">// and copy assignment operator are deleted;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// shared pointer is use something called reference counting</span></span><br><span class="line">         <span class="comment">// You create one shread pointer and you define another shared pointer and copy the</span></span><br><span class="line">         <span class="comment">// previous one, the reference count is now 2,</span></span><br><span class="line">         <span class="comment">// when the first one dies(out of scope), the reference count goes down 1</span></span><br><span class="line">         <span class="comment">// and when the last one dies. the reference count goes back to zero,</span></span><br><span class="line">         <span class="comment">// and free the memory.</span></span><br><span class="line">         <span class="comment">// BTW, for shared pointer using make_shared is very recommand because its more efficient</span></span><br><span class="line">         </span><br><span class="line">         <span class="comment">// There is something else that you can use with shared pointer is called weak pointer</span></span><br><span class="line">         <span class="comment">// weak pointer will not increase the reference count</span></span><br><span class="line">         std::weak_ptr&lt;Entity&gt; weakEntity;</span><br><span class="line">         &#123;</span><br><span class="line"></span><br><span class="line">             std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();</span><br><span class="line">             weakEntity = sharedEntity2;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// The sharedEntity will still be free immediately here.</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Copying-and-Copy-Constructors-in-C">Copying and Copy Constructors in C++</h2>
<ol>
<li>Ues “=”(called Shallow Copy) to copy<br>
an object created on heap(with <code>new</code>) which is without a Copy Constuctors<br>
or an object created on stack but with private pointer variables(objects created on heap)<br>
will lead to unexpected results.<br>
It’s essentially just copy the address data in pointer variable</li>
<li>So you need a Copy Constructor which delimit the behavior of the copy operation.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_Buffer;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_Size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* string)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">        m_Buffer = <span class="keyword">new</span> <span class="keyword">char</span>[m_Size + <span class="number">1</span>]; <span class="comment">// +1 for last null termination char</span></span><br><span class="line">        <span class="comment">// You can also use strcpy()</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer, string, m_Size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Consturcor</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> String&amp; other)</span><br><span class="line">        : <span class="built_in">m_Size</span>(other.m_Size)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Buffer = <span class="keyword">new</span> <span class="keyword">char</span>[m_Size + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// Or if you want to be more exciting, you can use this instead</span></span><br><span class="line">        <span class="comment">// memcpy(this, &amp;other, sizeof(String));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Or you can just prevent this object to do copy operation</span></span><br><span class="line">    <span class="comment">//String(const String&amp; other) = delete;</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_Buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Buffer[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make &lt;&lt;() to be a fried so it can access private variables in this object</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="keyword">const</span> String&amp; string);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="keyword">const</span> String&amp; string)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; string.m_Buffer;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String first_String = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    String second_string = first_string;</span><br><span class="line">    </span><br><span class="line">    second_string[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; first_String &lt;&lt; endl;</span><br><span class="line">    std::cout &lt;&lt; first_String &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-Arrow-Operator-in-C">The Arrow Operator in C++</h2>
<ol start="0">
<li>Normal usage<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    entity-&gt;x = <span class="number">2</span>; <span class="comment">// = (*entity).x = 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>It is actually possible to overload the Arror Operator and use it in specific class such as ScopedPtr (For more see previous chapter: SMART POINTERS in C++).<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* m_Obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* entity)</span><br><span class="line">        : <span class="built_in">m_Obj</span>(entity)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entity* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ScopedPtr entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(); <span class="comment">// Do you still remember the Implicit Conversion?</span></span><br><span class="line">    entity-&gt;<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>It can also be used to get the variable’s memory offset in an Object (In some memory hack :)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// I deliberately desrupt the naming order to make it in a different memory layout.</span></span><br><span class="line">    <span class="keyword">float</span> z, y, x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get the offset of that &#x27;x&#x27;</span></span><br><span class="line">    <span class="keyword">int</span> offset = (<span class="keyword">int</span>) &amp;((Vector3*)<span class="number">0</span>)-&gt;x; <span class="comment">// Or &amp;((Vector3*)nullptr)-&gt;x;</span></span><br><span class="line">    std::cout &lt;&lt; offset &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Dynamic-Arrays-in-C-std-vector">Dynamic Arrays in C++ (std::vector)</h2>
<ol>
<li>Vector in C++ is not mathematical vector, it’s kind of like Dynamic Arrays</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="keyword">const</span> Vertex&amp; vertex)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; vertex.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vertex.y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vertex.z;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// the &#x27;&lt;Object&gt;&#x27; is called template, will show in later chapter</span></span><br><span class="line">    <span class="comment">// For now, we only need to know this definite the type which the Dynamic Arrarys stores</span></span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    <span class="comment">// It is hard to decide whether you should be using like vertex pointers</span></span><br><span class="line">    <span class="comment">// or just vertex object in this case</span></span><br><span class="line">    <span class="comment">// Which is object stored in line or fragmented in memory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add object to the end of Dynamic Array</span></span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;); <span class="comment">// Note: Implicit conversion</span></span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using range based &#x27;for loop&#x27; to iterate the object in Dynamic Array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Vertex&amp; v : vertices)</span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; sed::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can remove object in dynamic array individually</span></span><br><span class="line">    <span class="comment">// This remove the second object in dynamic array</span></span><br><span class="line">    vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Or we can clean the whole dynamic array</span></span><br><span class="line">    vertices.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Optimizing-the-usage-of-std-vector-in-C">Optimizing the usage of std::vector in C++</h2>
<p>Two ways to reduce memory copy</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span><br><span class="line">        : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Constructor, used to capture copied times</span></span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="keyword">const</span> Vertex&amp; v)</span><br><span class="line">        : <span class="built_in">x</span>(v.x), <span class="built_in">y</span>(v.y), <span class="built_in">z</span>(v.z)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Output to console to see how many times copied</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Vertex&gt; vertices_bad;</span><br><span class="line">    vertices_bad.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// Make it easier to read than previous chapter</span></span><br><span class="line">    vertices_bad.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">    vertices_bad.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line">    vertices_bad.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>));</span><br><span class="line">    <span class="comment">// Each pass parameter operation in push_back() will cause 1 copy operation</span></span><br><span class="line">    <span class="comment">// And **each push_back() called will cause memory rearrange**,</span></span><br><span class="line">    <span class="comment">// which are copy previous objects in dynamic array into new memory area.</span></span><br><span class="line">    <span class="comment">// So total copied times: 1 + (1 + 1) + (1 + 2) + (1 + 3) = 10</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vertices good&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::vector&lt;Vertex&gt; vertices_good;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Below is the optimized implementation</span></span><br><span class="line">    <span class="comment">// 1. Use reserver() to prevent memory rearrange.</span></span><br><span class="line">    vertices_good.<span class="built_in">reserve</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 2. Replace push_back() with emplace_back() to prevent parameter copy</span></span><br><span class="line">    <span class="comment">// it acts as a proxy to process you provided parameter into Constructor.</span></span><br><span class="line">    vertices_good.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    vertices_good.<span class="built_in">emplace_back</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    vertices_good.<span class="built_in">emplace_back</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">    vertices_good.<span class="built_in">emplace_back</span>(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Using-Libraries-in-C">Using Libraries in C++</h2>
<p>Preposition work:<br>
Visual Studio Setup<br>
Using GLFW as example:</p>
<ol>
<li>Create a folder called “Dependencies” under your project directory<br>
and then put your libraries into it.<figure class="highlight plaintext"><figcaption><span>C:\Users\USERNAME\source\repos\Your_Project_Directory\</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Dependencies\</span><br><span class="line">-&gt; GLFW\</span><br><span class="line">   -&gt; include\</span><br><span class="line">      -&gt; GLFW\</span><br><span class="line">         glfw3.h</span><br><span class="line">         ...</span><br><span class="line">   -&gt; lib-vc2015\</span><br><span class="line">      glfw3.dll</span><br><span class="line">      glfw3.lib</span><br><span class="line">      glfw3.dll.lib</span><br></pre></td></tr></table></figure>
</li>
<li>Open your project settings:<br>
-&gt; Configuration: All Configuration<br>
-&gt; C/C++ -&gt; Additional Include Directories: <code>$(SolutionDir)\Dependencies\GLFW\include</code><br>
-&gt; Linker -&gt; General -&gt; Additional Library Directories: <code>$(SolutionDir)\Dependencies\GLFW\lib-vc2015</code></li>
</ol>
<h3 id="Static-linking">Static linking</h3>
<p>Static linking happens at compile time, the lib intergrate into executable or a dynamic library</p>
<ol>
<li>Open your project setting<br>
-&gt; Linker -&gt; Input -&gt; Additional Dependencies: <code>glfw3.lib;xxxxxx;balabala;...</code></li>
<li>Static Link<figure class="highlight c++"><figcaption><span>Main.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// quote for header in this project, regular bracket for external library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line">\\ Or `<span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">glfwInit</span><span class="params">()</span></span>;`</span><br><span class="line">\\ Because GLFW is actually a C library so we need `<span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>`</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">glfwInit</span>();</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Dynamic-linking">Dynamic linking</h3>
<p>Dynamic linking happens at runtime</p>
<ul>
<li>Some librarys like GLFW  supports both static and dynamic linking in a single header file</li>
<li><code>glfw3.dll.lib</code> is basically a series of pointers into <code>glwfw3.dll</code></li>
</ul>
<ol start="0">
<li>
<p>Code is basically as same as the Static linking above</p>
</li>
<li>
<p>Open your project settings:<br>
-&gt; Linker -&gt; Input -&gt; Additional Dependencies: <code>glfw3.dll.lib;xxxxxx;balabala;...</code></p>
</li>
<li>
<p>put your dll file(<code>glfw3.dll</code>) to the same folder as your executable file(i.e: <code>$(SolutionDir)\Debug</code>)</p>
</li>
<li>
<p>In fact, to call a function in dynamic library, it needs a prefix called <code>__declspec(dllimport)</code><br>
If you explore <code>glfw3.h</code> you will see there is a <code>GLFWAPI</code> prefix in every function definition,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_WIN32) &amp;&amp; defined(GLFW_DLL)</span></span><br><span class="line"><span class="comment">/* We are calling GLFW as a Win32 DLL */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> GLFWAPI __declspec(dllimport)</span></span><br></pre></td></tr></table></figure>
<p>So <strong>you need to define a Macro</strong> in VS:<br>
Open your project setting:<br>
-&gt; C/C++ -&gt; Preprocessor -&gt; Preprocessor Definitions: <code>GLFW_DLL;xxxxx;bababa...</code></p>
<p>But why it seems stll work properly without the <code>dllimport</code> prefix?<br>
In modern windows, <code>dllimport</code> is not needed for functions, but <code>dllimport</code> is still needed for C++ classes and global variables.</p>
</li>
</ol>
<h2 id="Making-and-Working-with-Libraries-in-C-Multiple-Projects-in-Visual-Studio">Making and Working with Libraries in C++ (Multiple Projects in Visual Studio)</h2>
<ol>
<li>Visual Studio Setup:
<ol>
<li>
<p>Create one solution with 2 projects “Game” and “Engine”,</p>
</li>
<li>
<p>Project “Game”:<br>
-&gt; Ceneral-&gt;Project Defaults-&gt;Configuration Type: Application (.exe)<br>
-&gt; C/C++ -&gt; General -&gt; Additional include Directories: <code>$(SolutionDir)\Engine\src;</code></p>
</li>
<li>
<p>Project “Engine”:<br>
Ceneral-&gt;Project Defaults-&gt;Configuration Type: Static library (.lib)</p>
</li>
<li>
<p>Right click on projects “Game” -&gt; Add -&gt; Reference -&gt; Select project “Enginx”</p>
</li>
</ol>
</li>
<li>Code for project “Engine”:<figure class="highlight c++"><figcaption><span>Your_Project_Directory\src\Engine.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> engine &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><figcaption><span>Your_Project_Directory\src\Engine.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Engine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> engine &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Code for project “Game”:<figure class="highlight c++"><figcaption><span>Your_Project_Directory\src\Application.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Engine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    engine::<span class="built_in">PrintMessage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="How-to-Deal-with-Multiple-Return-Values-in-C">How to Deal with Multiple Return Values in C++</h2>
<p>Example scenario: we have a function called <code>ParseShader()</code> , it needs to return two strings</p>
<ol>
<li>Return a struct cotains two strings (Cherno’s choose):<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ShaderProgramSource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FragmentSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ShaderProgramSource <span class="title">ParseShader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Some statements that process result &#x27;vs&#x27; and &#x27;fs&#x27;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &#123; vs, fs &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Using reference paremeter (Probably one of the most optimal way)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParseShader</span><span class="params">(std::string&amp; outVertexSource, std::string&amp; outFragmentSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Some statements that process result &#x27;vs&#x27; and &#x27;fs&#x27;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outVertexSource = vs;</span><br><span class="line">    outFragmentSource = fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::string vertexSource, fragmentSource;</span><br><span class="line">    <span class="built_in">ParseShader</span>(vertexSource, fragmentSource)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or using Pointer parameter if you want to pass nullptr(ignore the output):</span></span><br><span class="line"><span class="comment">// void ParseShader(std::string* outVertexSource, std::string* outFragmentSource)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if (outVertexSource)</span></span><br><span class="line"><span class="comment">//         *outVertexSource = vs;</span></span><br><span class="line"><span class="comment">//     if (outFragmentSource)</span></span><br><span class="line"><span class="comment">//         *outFragmentSource = fs;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     ParseShader(nullptr, &amp;fragmentSource)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>Return a <code>std::array</code> or <code>std::vector</code>(ignored, too simple)<br>
The different is primarly the arrays can be create on the stack where as<br>
vectors gonna store its underlying storage on the heap.<br>
So technically returning a standard array would be faster.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::array&lt;std::string, 2&gt; <span class="title">ParseShader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Some statements that process result &#x27;vs&#x27; and &#x27;fs&#x27;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    std::array&lt;std::string, 2&gt; result;</span><br><span class="line">    result[<span class="number">0</span>] = vs;</span><br><span class="line">    result[<span class="number">1</span>] = fs;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Using <code>std::tuple</code> and <code>std::pair</code>
<ol>
<li><code>std:tuple</code> (Can return more than two elements)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">CreatePerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="string">&quot;Cherno&quot;</span>, <span class="number">24</span> &#125;; <span class="comment">// Implicit conversation</span></span><br><span class="line">    <span class="comment">// Or use &quot;std::make_pair()&quot;:</span></span><br><span class="line">    <span class="comment">// return std::make_pair(&quot;Cherno&quot;, 24);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// &#x27;auto&#x27; means automatically check the return type</span></span><br><span class="line">    <span class="keyword">auto</span> person = <span class="built_in">CreatePerson</span>();</span><br><span class="line">    <span class="comment">// Get values in std::tuple</span></span><br><span class="line">    std::string&amp; name = std::get&lt;<span class="number">0</span>&gt;(person);</span><br><span class="line">    <span class="keyword">int</span> age = std::get&lt;<span class="number">1</span>&gt;(person);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Or using std::tie()</span></span><br><span class="line">    std::string name2;</span><br><span class="line">    <span class="keyword">int</span> age2;</span><br><span class="line">    std::<span class="built_in">tie</span>(name2, age2) = person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><code>std::pair</code> (A little bit faster than tuple)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Show the only difference with &#x27;std::tuple&#x27;</span></span><br><span class="line"><span class="function">std::pair&lt;std::string, std::string&gt; <span class="title">ParseShader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vertexSource = sources.first;</span><br><span class="line">    vertexSource = sources.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="Templates-in-C">Templates in C++</h2>
<p>Template can improve code reuse rate and reduce duplicate code (for example function overload)<br>
The essence of template is similar to macros</p>
<p>This chapter includes:</p>
<ol>
<li>template type</li>
<li>template argument</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In this case, template specifying how to create methods based on your usage of them.(Automatically generate corresponding overloaded function)</span></span><br><span class="line"><span class="comment">// So if nobody call this function, it&#x27;s code will not exist in compiled file,</span></span><br><span class="line"><span class="comment">// even if there is a grammatical error in this function code, it will still compile successfully.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// exactly same with: &quot;template&lt;class T&gt;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// I actually specifying the type explicitly</span></span><br><span class="line">    <span class="comment">// The complete code should be:</span></span><br><span class="line">    <span class="comment">// Print&lt;int&gt;(5);</span></span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5.5f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Yes, multiple template targets can be in one template definition</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_Arry[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Array&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt; array;</span><br><span class="line">    <span class="comment">// Which means its will generate the following code:</span></span><br><span class="line">    <span class="comment">// class Array</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">// private:</span></span><br><span class="line">    <span class="comment">//     int m_Arry[5];</span></span><br><span class="line">    <span class="comment">// public:</span></span><br><span class="line">    <span class="comment">//     int GetSize() const &#123; return 5; &#125;</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    std::cout &lt;&lt; array.<span class="built_in">GetSize</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Stack-vs-Heap-Memory-in-C">Stack vs Heap Memory in C++</h2>
<p>Ignore…</p>
<h2 id="Macros-in-C">Macros in C++</h2>
<ol>
<li>Macros do text replace when preprocessor<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WAIT std::cin.get()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WAIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Macros function and combine with the environment<br>
Environment variables can be defined at:<br>
Open your project settings:<br>
C/C++ -&gt; Preprocessor -&gt; Preprocessor Definitions<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PR_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(PR_RELEASE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(x) <span class="comment">// Do nothing</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="The-“auto”-keyword-in-C">The “auto” keyword in C++</h2>
<ol>
<li>be careful with <code>auto</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> name = <span class="built_in">GetName</span>();</span><br><span class="line">    <span class="comment">// Call a type specific method</span></span><br><span class="line">    <span class="comment">// if the return type of GetName() changed to &quot;char*&quot; , this will be broken</span></span><br><span class="line">    <span class="keyword">int</span> a = name.<span class="built_in">size</span>();</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>auto</code>’ to reduce type length<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeviceManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt; m_Devices;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;&amp; <span class="built_in">GetDevices</span>() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Devices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DeviceManager dm;</span><br><span class="line">    <span class="comment">// The type is too mass</span></span><br><span class="line">    <span class="keyword">const</span> std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;&amp; devices = dm.<span class="built_in">GetDevices</span>();</span><br><span class="line">    <span class="comment">// You can use keyword &quot;using&quot; or &quot;typedef&quot;</span></span><br><span class="line">    <span class="keyword">using</span> DeviceMap = std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;;</span><br><span class="line">    <span class="keyword">const</span> DeviceMap&amp; devices2 = dm.<span class="built_in">GetDevices</span>();</span><br><span class="line">    <span class="comment">// Or auto</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; devices3 = dm.<span class="built_in">GetDevices</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Static-Arrays-in-C-std-array">Static Arrays in C++ (std::array)</h2>
<p>Ignore…</p>
<h2 id="Function-Pointers-in-C">Function Pointers in C++</h2>
<ol>
<li>3 ways to definite a Function Pointers<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloWorld</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World! Value: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> function = <span class="built_in">HelloWorld</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// second way:</span></span><br><span class="line">    <span class="comment">// void(*function)(int) = HelloWorld();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// third way:</span></span><br><span class="line">    <span class="comment">// typedef void(*Balabala)(int);</span></span><br><span class="line">    <span class="comment">// Balabala function = HelloWorld;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">function</span>(<span class="number">233</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>A simple usage - the ForEach function:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintValue</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ForEach</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; values, <span class="keyword">void</span>(*func)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> value : values)</span><br><span class="line">        <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; values = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="built_in">ForEach</span>(values, PrintValue);</span><br><span class="line">    <span class="comment">// We can use lambda to simply the function PrintValue() (see more in next episode)</span></span><br><span class="line">    <span class="comment">// ForEach(values, [](int value) &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Lambdas-in-C">Lambdas in C++</h2>
<ol>
<li>How to put outside variables into lambda function<br>
[=] : Pass everything in by value, the pass in variables is independent of the outside.<br>
[&amp;] : Pass everything in by reference.<br>
[a] : Pass ‘a’ by value<br>
[&amp;a] : Pass ‘a’ by reference.</li>
<li>using <code>mutable</code> keyword to allow modify outside variables</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda = [=]() <span class="keyword">mutable</span> &#123; a = <span class="number">5</span>; std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>We need to use std::function instand of raw function pointer if our callback lambda function have pass in variables.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the only difference (Use &quot;const &amp;&quot; because its an object)</span></span><br><span class="line"><span class="comment">// &quot;void(*func)(int)&quot; to &quot;const std::function&lt;void(int)&gt;&amp; func&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ForEach</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;* values, <span class="keyword">const</span> std::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt;&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda = [=](<span class="keyword">int</span> value)) &#123;std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ForEach</span>(values, lambda&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Usage of std::find_if (Returns an iterator to the first element for which callback function returns true)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; values = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> iterator = std::<span class="built_in">find_if</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value &gt; <span class="number">3</span>;&#125;);</span><br><span class="line">std::cout &lt;&lt; *iterator &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Why-I-don’t-“using-namespace-std”">Why I don’t “using namespace std”</h2>
<p>Don’t absolutely use <code>using namespace</code> in header files<br>
But if you must using <code>using namespace</code>, please use it in a small scope as possible, but NEVER EVER in a header file.</p>
<p>For example a serious issue of implicit conversion :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> apple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(cout std::string&amp; text)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> orange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* text)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string temp = text;</span><br><span class="line">        std::<span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        std::cout &lt;&lt; temp &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> apple;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> orange;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="comment">// Which one will get called?</span></span><br><span class="line">    <span class="comment">// Answer: the orange::print() will be called, because the type of &quot;Hello&quot; is &quot;char*&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Namespaces-in-C">Namespaces in C++</h2>
<p>Use Namespace to</p>
<ol>
<li>avoid naming conflict: <code>apple::print()</code>, <code>orange::print()</code></li>
<li>avoid C library like naming: <code>GLFW_initialize</code> to <code>GLFW::initialize</code></li>
</ol>
<p>Usage:</p>
<ol>
<li>We can set to use only specific symbol in a namespace<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">namespcae apple &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* text)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_again</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">///...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> apple::print;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//We still need &quot;apple::&quot; to call print_again()</span></span><br><span class="line">    apple::<span class="built_in">print_again</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Nested Namespaces can be shorten using Alias<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> apple &#123; <span class="comment">// Or apple::functions (c++17)</span></span><br><span class="line">    <span class="keyword">namespace</span> functions &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* test)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">namespace</span> a = apple::functions;</span><br><span class="line"></span><br><span class="line">    a::<span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Threads-in-C">Threads in C++</h2>
<p>If we want to do something else when we called functions that will block the current thread, we can use threads.</p>
<p>Here is an example:<br>
We created a thread that will do loop on outputting “Working…”,<br>
and simultaneously the main() function is waiting for user input.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> is_Finished = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals; <span class="comment">// Or use &quot;sleep_for(std::chrono::seconds(1))&quot; below</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Started thread id=&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_Finished)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working...\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// As soon as we create instance, it&#x27;s going to immediately kick off that thread</span></span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(DoWork)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">    is_Finished = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call main thread to wait this thread (block main thread)</span></span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Timing-in-C">Timing in C++</h2>
<ol>
<li>Make a Timer for statistical time-consuming</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;</span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">float</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        duration = end - start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> ms = duration.<span class="built_in">count</span>() * <span class="number">1000.0f</span>;</span><br><span class="line">        std::&lt;&lt; <span class="string">&quot;Timer took &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot;ms &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The timer will be auto delete when run out of the scope</span></span><br><span class="line">    Timer timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>; <span class="comment">// std::endl is quiet slow</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Multidimensional-Arrays-in-C">Multidimensional Arrays in C++</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Allocate a 2D array to store twenty integer pointers</span></span><br><span class="line">    <span class="keyword">int</span>** a2d = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can set each of these pointers to point to an array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        a2d[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3D array, you can imagine a cube with size of 20x30x40</span></span><br><span class="line">    <span class="keyword">int</span>*** a3d = <span class="keyword">new</span> <span class="keyword">int</span>**[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a3d[i] = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">30</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a3d[i][j] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>]:</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a3d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When you want to delete this array, you have to go through inner array and delete all of those arrays from inside to out</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] a3d[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] a3d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] a3d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The most issue is that the Multidimensional Arrays will results memory fragmentation.<br>
When iterating the array we have to jump to another location to read or write that data,<br>
and that’s results probably a cache miss which means that we’re wasting time fetching data from our actual RAM.</p>
<p>One of the most important things you can do is just store them in a single dimensional array:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* array =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span> * <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">5</span>; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            array[x * <span class="number">5</span> + y] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sorting-in-C">Sorting in C++</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; values = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output the results</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : values)</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can define how the sorting rule the sort() dose</span></span><br><span class="line">    <span class="comment">// Such like sorting by big to small</span></span><br><span class="line">    std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output the results</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : values)</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Or force &#x27;1&#x27; to the last of array list</span></span><br><span class="line">    std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Return true equals do exchange the position of a, b</span></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> b &lt; a;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Type-Punning-in-C">Type Punning in C++</h2>
<p>You can Treat an Entity struct as an int array:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e = &#123; <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* position = (<span class="keyword">int</span>*)&amp;e;</span><br><span class="line">    std::cout &lt;&lt; position[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; position[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// More crazy usage</span></span><br><span class="line">    <span class="keyword">int</span> y = *(<span class="keyword">int</span>*)((<span class="keyword">char</span>*)&amp;e + <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Unions-in-C">Unions in C++</h2>
<p>Defined member in one Union means same memory location</p>
<p>We have Vector2 and Vector2, but there is only one function <code>PrintVector2()</code> can output Vector2,<br>
what can we do?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintVector2</span><span class="params">(<span class="keyword">const</span> Vector2&amp; vector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; vector.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vector.y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">// The benefit of anonymous struct is converting all variables in struct into a single member which is what the Union expects</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">float</span> x, y, z, w;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="comment">// &#x27;zy&#x27; will be the same memory as &#x27;x, y&#x27;, and &#x27;zw&#x27; will be the same memory as &#x27;z, w&#x27; </span></span><br><span class="line">            Vector2 xy, zw;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector4 vector = &#123; <span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span> &#125;;</span><br><span class="line">    <span class="built_in">PrintVector2</span>(vector.xy);</span><br><span class="line">    <span class="built_in">PrintVector2</span>(vector.zw);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    vector.z = <span class="number">500.0f</span>;</span><br><span class="line">    <span class="built_in">PrintVector2</span>(vector.xy);</span><br><span class="line">    <span class="built_in">PrintVector2</span>(vector.zw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Type Punning can do as the same result, but using Union makes it more concise.</p>
<h2 id="Virtual-Destructors-in-C">Virtual Destructors in C++</h2>
<p>Virtual Destructors is really important if you are writing a father class,<br>
otherwise no one’s going to be able to safely delete the extend class<br>
(Because without <code>virtual</code> mark you are just adding a new Destructor instead of overload it)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Polymorphic kind of type</span></span><br><span class="line">    <span class="comment">// without `virturl`, the &quot;~Derived()&quot; will not be called</span></span><br><span class="line">    Base* poly = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> poly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Casting-in-C">Casting in C++</h2>
<p>C++ cast not do anything that C-style casts cannot do<br>
those casts do make you code more solid and looks better.</p>
<ol>
<li>Static cast (Will do compile time checking)</li>
<li>Interpret cast (for Type Punning)</li>
<li>Dynamic cast (Will return <code>NULL</code> if casting is failed)</li>
<li>Const cast (TODO: Supplement this content)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Static cast</span></span><br><span class="line">    <span class="keyword">double</span> value = <span class="number">5.5</span>;</span><br><span class="line">    <span class="keyword">double</span> s = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(value);</span><br><span class="line"></span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Derived* ac = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (!ac) &#123; std::cout &lt;&lt; <span class="string">&quot;Converting failed\n&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Conditional-and-Action-Breakpoints-in-C">Conditional and Action Breakpoints in C++</h2>
<p>Condition Breakpoints: If I only want the breakpoint to trigger under a certain condition<br>
Action Breakpoints: Generally print something to the console when a breakpoint is hit<br>
They can prevent recompile and save time</p>
<p>For details. please <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=9ncNA6Co2Nk&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=70">watch the video</a></p>
<h2 id="Safety-in-modern-C-and-how-to-teach-it">Safety in modern C++ and how to teach it</h2>
<p>You should 100% use smart pointers if you are doing serious work</p>
<h2 id="Precompiled-Headers-in-C">Precompiled Headers in C++</h2>
<p>Look to 7:07</p>
<h2 id="Dynamic-Casting-in-C">Dynamic Casting in C++</h2>
<p>If we force type casting a Enemy class to Player and access data(funcions, variables) that is unique to player, the program will probablly crash.</p>
<p>Dynamic Casting is actually does some validation for us to ensure that cast is valid</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enemy</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity* actuallyPlayer = <span class="keyword">new</span> <span class="built_in">Player</span>();</span><br><span class="line">    Entity* actuallyEnemy = <span class="keyword">new</span> <span class="built_in">Enemy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// How does it know that actuallyPlayer is actually a Player and not an Enemy?</span></span><br><span class="line">    <span class="comment">// The way it does that is it stores runtime type information(RTTI)</span></span><br><span class="line">    <span class="comment">// This does add an overhead but it lets you do things like dynamic casting</span></span><br><span class="line">    <span class="comment">// Be aware that RTTI can be enabled or disabled</span></span><br><span class="line">    Player* p0 = <span class="keyword">dynamic_cast</span>&lt;Player*&gt;(actuallyPlayer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Will return null</span></span><br><span class="line">    Player* p1 = <span class="keyword">dynamic_cast</span>&lt;Player*&gt;(actuallyEnemy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dynamic_cast&lt;xxx*&gt;(xxx); equal to xxx instanceof xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BENCHMARKING-in-C-how-to-measure-performance">BENCHMARKING in C++ (how to measure performance)</h2>
<p>Always make sure that you profile is actually meaningful in a releases because you’re not gonna be shipping code in debug anyway</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::steady_clock&gt; m_StartTime, m_EndTime;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_StartTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_EndTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">auto</span> start = std::chrono::time_point_cast&lt;std::chrono::microseconds&gt;(m_StartTime).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">        <span class="keyword">auto</span> end = std::chrono::time_point_cast&lt;std::chrono::microseconds&gt;(m_EndTime).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> duration = end - start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ms = duration * <span class="number">0.001</span>;</span><br><span class="line">        std::cout &lt;&lt; duration &lt;&lt; <span class="string">&quot;us (&quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot;ms)\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Vector2</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">float</span> x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Make Shared\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="number">1000</span>&gt; sharedPtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sharedPtrs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            sharedPtrs[i] = std::make_shared&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;New Shared\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="number">1000</span>&gt; sharedPtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sharedPtrs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            sharedPtrs[i] = std::shared_ptr&lt;Vector2&gt;(<span class="keyword">new</span> <span class="built_in">Vector2</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Make Unique\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="number">1000</span>&gt; sharedPtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sharedPtrs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            sharedPtrs[i] = std::make_shared&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="STRUCTURED-BINDINGS-in-C">STRUCTURED BINDINGS in C++</h2>
<p>Only in C++17 and newer<br>
a better way compare to How to Deal with Multiple Return Values in C++</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">CreatePerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="string">&quot;Cherno&quot;</span>, <span class="number">24</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Structured binding</span></span><br><span class="line">    <span class="keyword">auto</span>[name, age] = <span class="built_in">CreatePerson</span>();</span><br><span class="line">    std::cout &lt;&lt; name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="How-to-Deal-with-OPTIONAL-Data-in-C">How to Deal with OPTIONAL Data in C++</h2>
<h2 id="Multiple-TYPES-of-Data-in-a-SINGLE-VARIABLE-in-C">Multiple TYPES of Data in a SINGLE VARIABLE in C++?</h2>
<h2 id="How-to-store-ANY-data-in-C">How to store ANY data in C++</h2>
<h2 id="How-to-make-C-run-FASTER-with-std-async">How to make C++ run FASTER (with std::async)</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::std::future&lt;<span class="keyword">void</span>&gt;&gt; m_Futures <span class="comment">// void is the return type of the function LoadMesh()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> std::mutex s_MeshesMutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here we use pointer parameter because reference parameter doesn&#x27;t work(Cherno not entirely sure why)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadMesh</span><span class="params">(<span class="keyword">const</span> std::vector&lt;Ref&lt;Mesh&gt;&gt;* meshes, std::string filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> mesh = Mesh::<span class="built_in">Load</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to lock this meshes vector while it been modify</span></span><br><span class="line">    <span class="comment">// lock the push_back() function</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(s_MeshesMutex)</span></span>;</span><br><span class="line">    meshes-&gt;<span class="built_in">push_back</span>(mesh);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EditorLayer::LoadMeshes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get file context use c++ file stream</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(<span class="string">&quot;src/Models.txt&quot;</span>)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    std::vector&lt;std::string&gt; meshFilepaths;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getLine</span>(stream, line))</span><br><span class="line">        meshFilepaths.<span class="built_in">push_back</span>(line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m_Meshes is a vector in this class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASYNC 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ASYNC</span></span><br><span class="line">    <span class="comment">// Asynchronous</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; file : meshFilepaths)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// std::async() will return std::future and its really important to handle that std::future or its will be destoryed and peform the destructor to make sure the async is actually finished</span></span><br><span class="line">        <span class="comment">// that basically means it won&#x27;t be parallel at all </span></span><br><span class="line">        m_Futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, LoadMesh, &amp;m_Meshes, file));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Sequence</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; file : meshFilepaths)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Meshes.<span class="built_in">push_back</span>(Mesh::<span class="built_in">Load</span>(file));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In VS, you can use DEBUG-&gt;Windows-&gt;Parrllel Stacks (Ctrl+Shift+D)<br>
to do window parallel debugs</p>
<h2 id="How-to-make-your-STRINGS-FASTER-in-C">How to make your STRINGS FASTER in C++!</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## VISUAL BENCHMARKING in C++ (how to measure performance visually)</span><br><span class="line"></span><br><span class="line">## SINGLETONS in C++</span><br><span class="line"></span><br><span class="line">```C++</span><br></pre></td></tr></table></figure>
<h2 id="Small-String-Optimization-in-C">Small String Optimization in C++</h2>
<h2 id="Track-MEMORY-ALLOCATIONS-the-Easy-Way-in-C">Track MEMORY ALLOCATIONS the Easy Way in C++</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">#<span class="meta"># lvalues and rvalues in C++</span></span><br><span class="line"></span><br><span class="line">In my opinion, <span class="function">any data that is <span class="keyword">not</span> being attached by a <span class="title">symbol</span><span class="params">(<span class="keyword">not</span> being explicitly assigned an address)</span> is an R-value, otherwise it&#x27;s an L-value.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1. L-value reference <span class="keyword">and</span> R-value reference</span></span><br><span class="line"><span class="function">   ```C++</span></span><br><span class="line"><span class="function">   <span class="keyword">int</span> i </span>= <span class="number">10</span>;</span><br><span class="line">   <span class="comment">// L-value reference can accept L-value and R-value</span></span><br><span class="line">   <span class="keyword">int</span>&amp; = i;</span><br><span class="line">   <span class="comment">// R-value reference can only accept R-value</span></span><br><span class="line">   <span class="keyword">int</span>&amp;&amp; = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>const type&amp;</code> is a special rule, realistically what happens is the compiler will probably create like a temporary variable.<br>
there are not to kind of avoid creating an L-value but rather to just kind of support both support both L-value and R-values<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// int temp = 10;</span></span><br><span class="line"><span class="comment">// const int&amp; a = temp;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Continuous-Integration-in-C">Continuous Integration in C++</h2>
<h2 id="Static-Analysis-in-C">Static Analysis in C++</h2>
<p>Static Analysis is a very important thing that even for an experienced programmer there is still going to be stuff what you miss.<br>
It can find logic errors in your code and gives you some tips to fix it</p>
<p><code>clang-tidy</code> is a free tool to do static analysis</p>
<h2 id="Argument-Evaluation-Order-in-C">Argument Evaluation Order in C++</h2>
<h2 id="Move-Semantics-in-C">Move Semantics in C++</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>() = <span class="keyword">default</span>; <span class="comment">// equals with String()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* string)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Created!\n&quot;</span>);</span><br><span class="line">		m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="keyword">char</span>[m_Size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(<span class="keyword">const</span> String&amp; other)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Copied!\n&quot;</span>);</span><br><span class="line">		m_Size = other.m_Size;</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="keyword">char</span>[m_Size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Data, other.m_Data, m_Size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(String&amp;&amp; older) <span class="keyword">noexcept</span> <span class="comment">// use noexcept to get rid of compiler warning</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">		m_Size = older.m_Size;</span><br><span class="line">		<span class="comment">// This immediately presents a problem</span></span><br><span class="line">		<span class="comment">// because when the old one gets deleted</span></span><br><span class="line">		<span class="comment">// it&#x27;s going to delete the m_Data with us</span></span><br><span class="line">		m_Data = older.m_Data;</span><br><span class="line">		<span class="comment">// so this is the major thing that we need to do</span></span><br><span class="line">		older.m_Size = <span class="number">0</span>;</span><br><span class="line">		older.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">String</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Destroyed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">delete</span> m_Data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_Data[i]);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* m_Data;</span><br><span class="line">	<span class="keyword">uint32_t</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="keyword">const</span> String&amp; name)</span><br><span class="line">		: <span class="built_in">m_Name</span>(name)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Entity</span>(String&amp;&amp; name)</span><br><span class="line">		: <span class="built_in">m_Name</span>(std::<span class="built_in">move</span>(name)) <span class="comment">// equals to m_Name((String&amp;&amp;) name)</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PrintName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name.<span class="built_in">Print</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	String m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Entity <span class="title">entity</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line">	entity.<span class="built_in">PrintName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-move-and-the-Move-Assignment-Operator-in-C">std::move and the Move Assignment Operator in C++</h2>
<p><code>std::move</code> actually do force casting but can make your program more search friendly</p>
<p>Move Assignment will allow us do move operation on existing objects</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* string)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Created!\n&quot;</span>);</span><br><span class="line">		m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="keyword">char</span>[m_Size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(String&amp;&amp; older) <span class="keyword">noexcept</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">		m_Size = older.m_Size;</span><br><span class="line">		m_Data = older.m_Data;</span><br><span class="line"></span><br><span class="line">		older.m_Size = <span class="number">0</span>;</span><br><span class="line">		older.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define move assignment</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(String&amp;&amp; older) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;older)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Because use move assignment meaning assure there already existing data in currently class</span></span><br><span class="line">            <span class="comment">// So clean the current class</span></span><br><span class="line">            <span class="keyword">delete</span>[] m_Data;</span><br><span class="line">        </span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">		    m_Size = older.m_Size;</span><br><span class="line">		    m_Data = older.m_Data;</span><br><span class="line"></span><br><span class="line">		    older.m_Size = <span class="number">0</span>;</span><br><span class="line">		    older.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">String</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Destroyed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">delete</span> m_Data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_Data[i]);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* m_Data;</span><br><span class="line">	<span class="keyword">uint32_t</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String apple = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">    String dest;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;Apple: &quot;</span>;</span><br><span class="line">    apple.<span class="built_in">Print</span>();</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;Dest: &quot;</span>;</span><br><span class="line">    dest.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    dest = std::<span class="built_in">move</span>(apple);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;Apple: &quot;</span>;</span><br><span class="line">    apple.<span class="built_in">Print</span>();</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;Dest: &quot;</span>;</span><br><span class="line">    dest.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ARRAY-Making-DATA-STRUCTURES-in-C">ARRAY - Making DATA STRUCTURES in C++</h2>
</div><div class="article-licensing box"><div class="licensing-title"><p>cpp</p><p><a href="http://blog.ndoskrnl.net/zh-cn/learn/2020/cpp/">http://blog.ndoskrnl.net/zh-cn/learn/2020/cpp/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Ndoskrnl</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-02-08</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-02-16</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/zh-cn/learn/2020/markdown/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">markdown</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/zh-cn/minecraft/2020/mods-changes/"><span class="level-item">mods-changes</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Notice"><span class="level-left"><span class="level-item">1</span><span class="level-item">Notice</span></span></a></li><li><a class="level is-mobile" href="#How-C-Works"><span class="level-left"><span class="level-item">2</span><span class="level-item">How C++ Works</span></span></a></li><li><a class="level is-mobile" href="#Variables-in-C"><span class="level-left"><span class="level-item">3</span><span class="level-item">Variables in C++</span></span></a></li><li><a class="level is-mobile" href="#Functions-in-C"><span class="level-left"><span class="level-item">4</span><span class="level-item">Functions in C++</span></span></a></li><li><a class="level is-mobile" href="#C-Header-Files"><span class="level-left"><span class="level-item">5</span><span class="level-item">C++ Header Files</span></span></a></li><li><a class="level is-mobile" href="#How-to-DEBUG-C-in-VISUAL-STUDIO"><span class="level-left"><span class="level-item">6</span><span class="level-item">How to DEBUG C++ in VISUAL STUDIO</span></span></a></li><li><a class="level is-mobile" href="#Visual-Studio-Setup-for-C"><span class="level-left"><span class="level-item">7</span><span class="level-item">Visual Studio Setup for C++</span></span></a></li><li><a class="level is-mobile" href="#CONDITIONS-and-BRANCHES-in-C"><span class="level-left"><span class="level-item">8</span><span class="level-item">CONDITIONS and BRANCHES in C++</span></span></a></li><li><a class="level is-mobile" href="#Loops-in-C"><span class="level-left"><span class="level-item">9</span><span class="level-item">Loops in C++</span></span></a></li><li><a class="level is-mobile" href="#POINTERS-in-C"><span class="level-left"><span class="level-item">10</span><span class="level-item">POINTERS in C++</span></span></a></li><li><a class="level is-mobile" href="#Reference-in-C"><span class="level-left"><span class="level-item">11</span><span class="level-item">Reference in C++</span></span></a></li><li><a class="level is-mobile" href="#CLASSES-vs-STRUCTS-in-C"><span class="level-left"><span class="level-item">12</span><span class="level-item">CLASSES vs STRUCTS in C++</span></span></a></li><li><a class="level is-mobile" href="#Static-in-C"><span class="level-left"><span class="level-item">13</span><span class="level-item">Static in C++</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Local-Static"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">Local Static</span></span></a></li><li><a class="level is-mobile" href="#Classical-Singleton"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">Classical Singleton</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Enum-in-C"><span class="level-left"><span class="level-item">14</span><span class="level-item">Enum in C++</span></span></a></li><li><a class="level is-mobile" href="#Constructors-in-C"><span class="level-left"><span class="level-item">15</span><span class="level-item">Constructors in C++</span></span></a></li><li><a class="level is-mobile" href="#Destructors-in-C"><span class="level-left"><span class="level-item">16</span><span class="level-item">Destructors in C++</span></span></a></li><li><a class="level is-mobile" href="#Inheritance-in-C"><span class="level-left"><span class="level-item">17</span><span class="level-item">Inheritance in C++</span></span></a></li><li><a class="level is-mobile" href="#Virtual-Function-in-C"><span class="level-left"><span class="level-item">18</span><span class="level-item">Virtual Function in C++</span></span></a></li><li><a class="level is-mobile" href="#Interface-Pure-virtual-method"><span class="level-left"><span class="level-item">19</span><span class="level-item">Interface (Pure virtual method)</span></span></a></li><li><a class="level is-mobile" href="#Visibility-in-C"><span class="level-left"><span class="level-item">20</span><span class="level-item">Visibility in C++</span></span></a></li><li><a class="level is-mobile" href="#Arrays-in-C"><span class="level-left"><span class="level-item">21</span><span class="level-item">Arrays in C++</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Raw-Arrays"><span class="level-left"><span class="level-item">21.1</span><span class="level-item">Raw Arrays</span></span></a></li><li><a class="level is-mobile" href="#C-11-Standard-Arrays"><span class="level-left"><span class="level-item">21.2</span><span class="level-item">C++11 Standard Arrays</span></span></a></li></ul></li><li><a class="level is-mobile" href="#How-Strings-Work-in-C-and-how-to-use-them"><span class="level-left"><span class="level-item">22</span><span class="level-item">How Strings Work in C++ (and how to use them)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#C风格字符串"><span class="level-left"><span class="level-item">22.1</span><span class="level-item">C风格字符串</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#细节的东西"><span class="level-left"><span class="level-item">22.1.1</span><span class="level-item">细节的东西</span></span></a></li></ul></li><li><a class="level is-mobile" href="#C-标准字符串"><span class="level-left"><span class="level-item">22.2</span><span class="level-item">C++ 标准字符串</span></span></a></li></ul></li><li><a class="level is-mobile" href="#String-literals"><span class="level-left"><span class="level-item">23</span><span class="level-item">String literals</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#其他类型的字符串"><span class="level-left"><span class="level-item">23.1</span><span class="level-item">其他类型的字符串</span></span></a></li></ul></li><li><a class="level is-mobile" href="#const-in-C"><span class="level-left"><span class="level-item">24</span><span class="level-item">const in C++</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#const-pointer"><span class="level-left"><span class="level-item">24.1</span><span class="level-item">const pointer</span></span></a></li><li><a class="level is-mobile" href="#const-method"><span class="level-left"><span class="level-item">24.2</span><span class="level-item">const method</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Mutable-Keyword-in-C"><span class="level-left"><span class="level-item">25</span><span class="level-item">Mutable Keyword in C++</span></span></a></li><li><a class="level is-mobile" href="#Memory-Initializer-Lists-in-C-Constructor-Initializer-List"><span class="level-left"><span class="level-item">26</span><span class="level-item">Memory Initializer Lists in C++ (Constructor Initializer List)</span></span></a></li><li><a class="level is-mobile" href="#Ternary-Operators-in-C-Conditional-Assignment"><span class="level-left"><span class="level-item">27</span><span class="level-item">Ternary Operators in C++ (Conditional Assignment)</span></span></a></li><li><a class="level is-mobile" href="#How-to-CREATE-INSTANTIATE-OBJECTS-in-C"><span class="level-left"><span class="level-item">28</span><span class="level-item">How to CREATE/INSTANTIATE OBJECTS in C++</span></span></a></li><li><a class="level is-mobile" href="#The-NEW-Keyword-in-C"><span class="level-left"><span class="level-item">29</span><span class="level-item">The NEW Keyword in C++</span></span></a></li><li><a class="level is-mobile" href="#Implicit-Conversion-and-the-Explicit-Keyword-in-C"><span class="level-left"><span class="level-item">30</span><span class="level-item">Implicit Conversion and the Explicit Keyword in C++</span></span></a></li><li><a class="level is-mobile" href="#OPERATORS-and-OPERATOR-OVERLOADING-in-C"><span class="level-left"><span class="level-item">31</span><span class="level-item">OPERATORS and OPERATOR OVERLOADING in C++</span></span></a></li><li><a class="level is-mobile" href="#Ths-“this”-keyword-in-C"><span class="level-left"><span class="level-item">32</span><span class="level-item">Ths “this” keyword in C++</span></span></a></li><li><a class="level is-mobile" href="#Object-Lifetime-in-C-Stack-Scope-Lifetimes"><span class="level-left"><span class="level-item">33</span><span class="level-item">Object Lifetime in C++ (Stack/Scope Lifetimes)</span></span></a></li><li><a class="level is-mobile" href="#SMART-POINTERS-in-C-std-unique-ptr-std-shared-ptr-std-weak-ptr"><span class="level-left"><span class="level-item">34</span><span class="level-item">SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr)</span></span></a></li><li><a class="level is-mobile" href="#Copying-and-Copy-Constructors-in-C"><span class="level-left"><span class="level-item">35</span><span class="level-item">Copying and Copy Constructors in C++</span></span></a></li><li><a class="level is-mobile" href="#The-Arrow-Operator-in-C"><span class="level-left"><span class="level-item">36</span><span class="level-item">The Arrow Operator in C++</span></span></a></li><li><a class="level is-mobile" href="#Dynamic-Arrays-in-C-std-vector"><span class="level-left"><span class="level-item">37</span><span class="level-item">Dynamic Arrays in C++ (std::vector)</span></span></a></li><li><a class="level is-mobile" href="#Optimizing-the-usage-of-std-vector-in-C"><span class="level-left"><span class="level-item">38</span><span class="level-item">Optimizing the usage of std::vector in C++</span></span></a></li><li><a class="level is-mobile" href="#Using-Libraries-in-C"><span class="level-left"><span class="level-item">39</span><span class="level-item">Using Libraries in C++</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Static-linking"><span class="level-left"><span class="level-item">39.1</span><span class="level-item">Static linking</span></span></a></li><li><a class="level is-mobile" href="#Dynamic-linking"><span class="level-left"><span class="level-item">39.2</span><span class="level-item">Dynamic linking</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Making-and-Working-with-Libraries-in-C-Multiple-Projects-in-Visual-Studio"><span class="level-left"><span class="level-item">40</span><span class="level-item">Making and Working with Libraries in C++ (Multiple Projects in Visual Studio)</span></span></a></li><li><a class="level is-mobile" href="#How-to-Deal-with-Multiple-Return-Values-in-C"><span class="level-left"><span class="level-item">41</span><span class="level-item">How to Deal with Multiple Return Values in C++</span></span></a></li><li><a class="level is-mobile" href="#Templates-in-C"><span class="level-left"><span class="level-item">42</span><span class="level-item">Templates in C++</span></span></a></li><li><a class="level is-mobile" href="#Stack-vs-Heap-Memory-in-C"><span class="level-left"><span class="level-item">43</span><span class="level-item">Stack vs Heap Memory in C++</span></span></a></li><li><a class="level is-mobile" href="#Macros-in-C"><span class="level-left"><span class="level-item">44</span><span class="level-item">Macros in C++</span></span></a></li><li><a class="level is-mobile" href="#The-“auto”-keyword-in-C"><span class="level-left"><span class="level-item">45</span><span class="level-item">The “auto” keyword in C++</span></span></a></li><li><a class="level is-mobile" href="#Static-Arrays-in-C-std-array"><span class="level-left"><span class="level-item">46</span><span class="level-item">Static Arrays in C++ (std::array)</span></span></a></li><li><a class="level is-mobile" href="#Function-Pointers-in-C"><span class="level-left"><span class="level-item">47</span><span class="level-item">Function Pointers in C++</span></span></a></li><li><a class="level is-mobile" href="#Lambdas-in-C"><span class="level-left"><span class="level-item">48</span><span class="level-item">Lambdas in C++</span></span></a></li><li><a class="level is-mobile" href="#Why-I-don’t-“using-namespace-std”"><span class="level-left"><span class="level-item">49</span><span class="level-item">Why I don’t “using namespace std”</span></span></a></li><li><a class="level is-mobile" href="#Namespaces-in-C"><span class="level-left"><span class="level-item">50</span><span class="level-item">Namespaces in C++</span></span></a></li><li><a class="level is-mobile" href="#Threads-in-C"><span class="level-left"><span class="level-item">51</span><span class="level-item">Threads in C++</span></span></a></li><li><a class="level is-mobile" href="#Timing-in-C"><span class="level-left"><span class="level-item">52</span><span class="level-item">Timing in C++</span></span></a></li><li><a class="level is-mobile" href="#Multidimensional-Arrays-in-C"><span class="level-left"><span class="level-item">53</span><span class="level-item">Multidimensional Arrays in C++</span></span></a></li><li><a class="level is-mobile" href="#Sorting-in-C"><span class="level-left"><span class="level-item">54</span><span class="level-item">Sorting in C++</span></span></a></li><li><a class="level is-mobile" href="#Type-Punning-in-C"><span class="level-left"><span class="level-item">55</span><span class="level-item">Type Punning in C++</span></span></a></li><li><a class="level is-mobile" href="#Unions-in-C"><span class="level-left"><span class="level-item">56</span><span class="level-item">Unions in C++</span></span></a></li><li><a class="level is-mobile" href="#Virtual-Destructors-in-C"><span class="level-left"><span class="level-item">57</span><span class="level-item">Virtual Destructors in C++</span></span></a></li><li><a class="level is-mobile" href="#Casting-in-C"><span class="level-left"><span class="level-item">58</span><span class="level-item">Casting in C++</span></span></a></li><li><a class="level is-mobile" href="#Conditional-and-Action-Breakpoints-in-C"><span class="level-left"><span class="level-item">59</span><span class="level-item">Conditional and Action Breakpoints in C++</span></span></a></li><li><a class="level is-mobile" href="#Safety-in-modern-C-and-how-to-teach-it"><span class="level-left"><span class="level-item">60</span><span class="level-item">Safety in modern C++ and how to teach it</span></span></a></li><li><a class="level is-mobile" href="#Precompiled-Headers-in-C"><span class="level-left"><span class="level-item">61</span><span class="level-item">Precompiled Headers in C++</span></span></a></li><li><a class="level is-mobile" href="#Dynamic-Casting-in-C"><span class="level-left"><span class="level-item">62</span><span class="level-item">Dynamic Casting in C++</span></span></a></li><li><a class="level is-mobile" href="#BENCHMARKING-in-C-how-to-measure-performance"><span class="level-left"><span class="level-item">63</span><span class="level-item">BENCHMARKING in C++ (how to measure performance)</span></span></a></li><li><a class="level is-mobile" href="#STRUCTURED-BINDINGS-in-C"><span class="level-left"><span class="level-item">64</span><span class="level-item">STRUCTURED BINDINGS in C++</span></span></a></li><li><a class="level is-mobile" href="#How-to-Deal-with-OPTIONAL-Data-in-C"><span class="level-left"><span class="level-item">65</span><span class="level-item">How to Deal with OPTIONAL Data in C++</span></span></a></li><li><a class="level is-mobile" href="#Multiple-TYPES-of-Data-in-a-SINGLE-VARIABLE-in-C"><span class="level-left"><span class="level-item">66</span><span class="level-item">Multiple TYPES of Data in a SINGLE VARIABLE in C++?</span></span></a></li><li><a class="level is-mobile" href="#How-to-store-ANY-data-in-C"><span class="level-left"><span class="level-item">67</span><span class="level-item">How to store ANY data in C++</span></span></a></li><li><a class="level is-mobile" href="#How-to-make-C-run-FASTER-with-std-async"><span class="level-left"><span class="level-item">68</span><span class="level-item">How to make C++ run FASTER (with std::async)</span></span></a></li><li><a class="level is-mobile" href="#How-to-make-your-STRINGS-FASTER-in-C"><span class="level-left"><span class="level-item">69</span><span class="level-item">How to make your STRINGS FASTER in C++!</span></span></a></li><li><a class="level is-mobile" href="#Small-String-Optimization-in-C"><span class="level-left"><span class="level-item">70</span><span class="level-item">Small String Optimization in C++</span></span></a></li><li><a class="level is-mobile" href="#Track-MEMORY-ALLOCATIONS-the-Easy-Way-in-C"><span class="level-left"><span class="level-item">71</span><span class="level-item">Track MEMORY ALLOCATIONS the Easy Way in C++</span></span></a></li><li><a class="level is-mobile" href="#Continuous-Integration-in-C"><span class="level-left"><span class="level-item">72</span><span class="level-item">Continuous Integration in C++</span></span></a></li><li><a class="level is-mobile" href="#Static-Analysis-in-C"><span class="level-left"><span class="level-item">73</span><span class="level-item">Static Analysis in C++</span></span></a></li><li><a class="level is-mobile" href="#Argument-Evaluation-Order-in-C"><span class="level-left"><span class="level-item">74</span><span class="level-item">Argument Evaluation Order in C++</span></span></a></li><li><a class="level is-mobile" href="#Move-Semantics-in-C"><span class="level-left"><span class="level-item">75</span><span class="level-item">Move Semantics in C++</span></span></a></li><li><a class="level is-mobile" href="#std-move-and-the-Move-Assignment-Operator-in-C"><span class="level-left"><span class="level-item">76</span><span class="level-item">std::move and the Move Assignment Operator in C++</span></span></a></li><li><a class="level is-mobile" href="#ARRAY-Making-DATA-STRUCTURES-in-C"><span class="level-left"><span class="level-item">77</span><span class="level-item">ARRAY - Making DATA STRUCTURES in C++</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/computer/"><span class="level-start"><span class="level-item">computer</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/daily-life/"><span class="level-start"><span class="level-item">daily-life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/ideology-and-politics/"><span class="level-start"><span class="level-item">ideology-and-politics</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/learn/"><span class="level-start"><span class="level-item">learn</span></span><span class="level-end"><span class="level-item tag">16</span></span></a><ul><li><a class="level is-mobile" href="/categories/learn/mathematics/"><span class="level-start"><span class="level-item">mathematics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/minecraft/"><span class="level-start"><span class="level-item">minecraft</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/electronic-and-information-engineering/"><span class="tag">electronic-and-information-engineering</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mathematics/"><span class="tag">mathematics</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgraduate/"><span class="tag">postgraduate</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/senior-high-schoool/"><span class="tag">senior-high-schoool</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="钱桑もぺもぺ～" height="28"></a><p class="is-size-7"><span>&copy; 2022 Ndoskrnl</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>