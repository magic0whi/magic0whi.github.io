<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>cpp - Proteus Chan の Notebook</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Proteus Chan の Notebook"><meta name="msapplication-TileImage" content="/img/favicon.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Proteus Chan の Notebook"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Notes on Cherno C++ Tutorial"><meta property="og:type" content="blog"><meta property="og:title" content="cpp"><meta property="og:url" content="https://magic0whi.github.io/cpp/"><meta property="og:site_name" content="Proteus Chan の Notebook"><meta property="og:description" content="Notes on Cherno C++ Tutorial"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://magic0whi.github.io/img/og_image.png"><meta property="article:published_time" content="2020-02-08T08:45:08.000Z"><meta property="article:modified_time" content="2024-08-09T14:44:29.966Z"><meta property="article:author" content="Proteus Chan"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://magic0whi.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://magic0whi.github.io/cpp/"},"headline":"cpp","image":["https://magic0whi.github.io/img/og_image.png"],"datePublished":"2020-02-08T08:45:08.000Z","dateModified":"2024-08-09T14:44:29.966Z","author":{"@type":"Person","name":"Proteus Chan"},"publisher":{"@type":"Organization","name":"Proteus Chan の Notebook","logo":{"@type":"ImageObject","url":"https://magic0whi.github.io/img/Comet_symbol.svg"}},"description":"Notes on Cherno C++ Tutorial"}</script><link rel="canonical" href="https://magic0whi.github.io/cpp/"><link rel="icon" href="/img/favicon.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link data-pjax rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/Comet_symbol.svg" alt="Proteus Chan の Notebook" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/peers">Peers</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-08T08:45:08.000Z" title="2/8/2020, 8:45:08 AM">2020-02-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-08-09T14:44:29.966Z" title="8/9/2024, 2:44:29 PM">2024-08-09</time></span><span class="level-item"><a class="link-muted" href="/categories/learn/">learn</a></span></div></div><h1 class="title is-3 is-size-4-mobile">cpp</h1><div class="content"><p>Notes on Cherno C++ Tutorial</p>
<span id="more"></span>
<style>
.card:not(#back-to-top) .card-content::before {
  background-color: #1b1b1b;
}
article.article .content {
  font-family: KaTeX_Main, FZYaSongS-R-GB, serif;
  font-size: 18px;
  word-spacing: 2px;
}
article.article .content code, article.article .content pre {
  font-family: Iosevka Term Extended, monospace;
  font-size: 14px;
}
</style>
<h2 id="Notice">Notice</h2>
<ol>
<li>If an object have pointer variable inside, write a copy constructor and use it.</li>
<li>Reduce memory usage by using bit-fields that make 1 byte stores 8 bools.</li>
<li>Default float type is <code>double</code>, use <code>float a = 5.5f</code>.</li>
<li>Header or inline?  (the later copys whole function body into the area where the function is called).</li>
</ol>
<h2 id="How-C-Works">How C++ Works</h2>
<ul>
<li>A translation unit consists of a single <code>.cpp</code> file and its associated <code>.h</code> files.</li>
<li>Compile Process Path: Source→Compile→Linker→Executables</li>
</ul>
<ol>
<li>
<p>Pre-process<br>
Compiler parses all the macros (such as <code>#include</code>) in source file.</p>
<ul>
<li>Clang: <code>clang -x c++ -E hello.cpp -o hello.i</code></li>
<li>GCC: <code>cpp hello.cpp &gt; hello.i</code></li>
<li>VS2015: <code>Project Settings</code>-&gt;<code>Preprocessor</code>-&gt;<code>Preprocess to a File</code></li>
</ul>
</li>
<li>
<p>Compile &amp; Assembly</p>
<ul>
<li>Clang: <code>clang++ -x c++-cpp-output -S hello.i -o hello.o</code></li>
<li>GCC: <code>g++ -S hello.i &amp;&amp; as hello.s -o main.o</code></li>
<li>VS2015: Compile Only (<code>&lt;C-F7&gt;</code>)</li>
</ul>
</li>
<li>
<p>Linker<br>
Externally defined functions will be integrated in the link phase. Function declarations that never be called will be optimized away.</p>
<p>The parameter of <code>ld</code> are platform specific (mainly depends on Clang/GCC version). Enable verbose to get the parameter of the <code>collect2</code> (which is an alias of <code>ld</code>):<br>
For Clang:</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># Only run preprocess, compile, and assemble steps</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang++ -v -c hello.cpp -o hello.o</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># For GCC:</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -v -c hello.cpp -o hello.o</span></span><br></pre></td></tr></table></figure>
<p>Ld may looks messy, but you can significantly shorten that link line by removing some arguments. Here’s the minimal set I came up after some experimentations:</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ld -I/lib64/ld-linux-x86-64.so.2 \</span></span><br><span class="line"><span class="language-bash">-o hello \</span></span><br><span class="line"><span class="language-bash">/usr/lib64/Scrt1.o \</span></span><br><span class="line"><span class="language-bash">-L/usr/lib64/gcc/x86_64-pc-linux-gnu/14.2.1 \</span></span><br><span class="line"><span class="language-bash">hello.o \</span></span><br><span class="line"><span class="language-bash">-l stdc++ -l m -l gcc_s -l gcc -l c \</span></span><br><span class="line"><span class="language-bash">/sbin/../lib64/gcc/x86_64-pc-linux-gnu/14.2.1/crtendS.o \</span></span><br><span class="line"><span class="language-bash">/usr/lib64/crtn.o</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Variables">Variables</h2>
<blockquote>
<p>The difference between C++ data types are simply different allocated memory size.<br>
You can use <code>sizeof()</code> to see the data type size.</p>
</blockquote>
<p>Different memory allocation size for C++ Data Type:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char</code></td>
<td>1 byte</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2 bytes</td>
</tr>
<tr>
<td><code>int</code></td>
<td>4 bytes</td>
</tr>
<tr>
<td><code>long</code></td>
<td>8 bytes (<code>c++20</code>), &gt;= 4 bytes</td>
</tr>
<tr>
<td><code>long long</code></td>
<td>8 bytes</td>
</tr>
<tr>
<td><code>float</code></td>
<td>4 bytes</td>
</tr>
<tr>
<td><code>double</code></td>
<td>8 bytes</td>
</tr>
<tr>
<td><code>void*</code></td>
<td>8 bytes (64 bits), 4 bytes (32 bits)</td>
</tr>
</tbody>
</table>
<h2 id="Functions">Functions</h2>
<ul>
<li>Write formal parameters with <code>const</code> if possible.</li>
<li><em>Function</em> is a function <strong>not</strong> in a class. whereas <em>method</em> is a function in a class.</li>
<li>Don’t frequently divide your code into functions, calling a function requires creating an entire stack frame. This means we have to push parameters and so on into the stack, and also pull something called the return address from the stack, so that after the function executed the <code>PC</code> (Program counter) register could return to the address before the function call.<br>
Conclusion: Jumping around in memory to execute function instructions comsumes additional time.</li>
</ul>
<h2 id="Header-Files">Header Files</h2>
<p>Duplicate inclusion: You include header file <code>b.h</code> in <code>a.cpp</code>, but <code>b.h</code> includes another header file <code>c.h</code>, while you have already include <code>c.h</code> before in <code>a.cpp</code>)</p>
<p>Two ways:</p>
<ul>
<li><code>#pragma once</code></li>
<li>
<figure class="highlight c++"><figcaption><span>Log.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some sentence...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Visual-Studio-Setup-Debug">Visual Studio Setup &amp; Debug</h2>
<ul>
<li>
<p>Use <code>Show All Files</code> view under <code>Solution Explorer</code>.</p>
</li>
<li>
<p>By default VS2015 put intermediate files in debug directory</p>
</li>
<li>
<p>It’s recommand to set <code>Output Directory</code> into <code>$(SolutionDir)bin\$(Platform)\$(Configuration)\</code><br>
and set <code>Intermediate Directory</code> into <code>$(SolutionDir)bin\intermediate\$(Platform)\$(Configuration)\</code></p>
</li>
<li>
<p>The <code>watch view</code> in VS2015 allows you to specify the variables to be monitored,<br>
In <code>memory window</code> you can search by keyword <code>&amp;a</code> to show the address of variable <code>a</code></p>
</li>
<li>
<p>The default value of uninitialized variables is <code>0xcccccccc</code></p>
</li>
</ul>
<h2 id="Pointers">Pointers</h2>
<ul>
<li>The pointer represents a memory address, generally the data type of the pointer is used to represent the type of the data at the target address.</li>
<li>Pointer to Pointer:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span>* buf&#123;<span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>]&#125;; <span class="comment">// Allocate a space with 8 chars</span></span><br><span class="line">  std::<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">8</span>); <span class="comment">// Fill it with zero,</span></span><br><span class="line">  <span class="type">char</span>** ptr_to_ptr&#123;&amp;buf&#125;; <span class="comment">// pointer to pointer</span></span><br><span class="line">  <span class="keyword">delete</span>[] buf; <span class="comment">// Finally release the memory space.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
In memory, it may like this:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00B6FED4 &amp;buf:           00 D0 FF F0</span><br><span class="line">0x00D0FFF0 *(new char[8]): 00 00 00 00 00 00 00 00</span><br><span class="line">0x???????? &amp;ptr_to_ptr:    00 B6 FE D4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Due to x86’s little endian design, what we see from <code>Memory View</code> is start from lower bits to higer bits, which is reversed from human’s convient that write the most significant digit first. e.g.:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                   0x0 0x1 0x2 0x3</span><br><span class="line">0x00B6FED4 (&amp;buf):  F0  FF  D0  00</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="Reference">Reference</h2>
<ul>
<li>Variables are convert to memory address in assembly by compiler. Reference let compiler just substitute memory address as is (like a macro) using it’s copy operator (<code>=()</code>), so it is different to <code>const void*</code> with creates a memory area to store a memory address (Can be <code>NULL</code>).</li>
<li>Copy operator <code>=()</code> copies value of a variable. Send the actual parameters to a function implicitly calls copy operator.</li>
<li>Dereference operator (aka. indirection operator) <code>*()</code> get the value from a memory address.</li>
<li>Address-of operator <code>&amp;()</code> obtain the memory address of a variable. Since directly send variable name to <code>=()</code> only get its stored values.</li>
</ul>
<h2 id="Classes-vs-Structs-and-Enums">Classes vs Structs, and Enums</h2>
<p>They are no different in low level, so a <code>class</code> can inherit a <code>struct</code> (Not recommand).</p>
<p><code>sturct</code> is more suitable for store multiple variables, its variables are default have attribute <code>public</code>, therefore it’s convient to express a data structure. While <code>class</code> is more suitable for express object, which has both member variables and methods.</p>
<p>Enum is a way to define a set of distinct values that have underlying integer types (, see below).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="comment">// Access specifiers &#x27;public&#x27;, &#x27;private&#x27; can be placed multiple times</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Can use `char` type as well</span></span><br><span class="line">  <span class="comment">// enum Level : unsigned char</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">Level</span> &#123;</span><br><span class="line">    <span class="comment">// Start from one, default is 0</span></span><br><span class="line">    LevelError = <span class="number">1</span>, LevelWarning, LevelInfo</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Level m_log_lv = LevelInfo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_lv</span><span class="params">(Level lv)</span> </span>&#123;</span><br><span class="line">    m_log_lv = lv;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">err</span><span class="params">(<span class="type">const</span> std::string_view msg)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_log_lv &gt;= LevelError) std::cout &lt;&lt; <span class="string">&quot;[Error]:&quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">warn</span><span class="params">(<span class="type">const</span> std::string_view msg)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_log_lv &gt;= LevelWarning) std::cout &lt;&lt; <span class="string">&quot;[WARN]:&quot;</span> &lt;&lt; msg&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">(<span class="type">const</span> std::string_view msg)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_log_lv &gt;= LevelInfo)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;[INFO]:&quot;</span> &lt;&lt; msg&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Log log;</span><br><span class="line">  log.<span class="built_in">set_lv</span>(Log::LevelWarning); <span class="comment">// Enum name is optional</span></span><br><span class="line">  log.<span class="built_in">err</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  log.<span class="built_in">warn</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  log.<span class="built_in">info</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Static">Static</h2>
<ul>
<li>Static functions and variables outside of class limit the scope in its translation unit (like <code>private</code> in a class). But define static functions or variables that share a same name in different translation unit will cause duplicate definition error in linking stage.</li>
<li>Static variable inside a class or struct means that variable is going to share memory with all of the instances of the class, in other words there’s only one instance of that static variable. Static methods cannot access non-static members its class, hence it don’t have instance of the class.</li>
<li>Define <code>static</code> variables in header files if possible.</li>
<li>Local Static<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> s_i&#123;&#125;; <span class="comment">// &#x27;s_&#x27; means static</span></span><br><span class="line">  s_i++;</span><br><span class="line">  std::cout &lt;&lt; s_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="built_in">func</span>(); <span class="built_in">func</span>(); <span class="built_in">func</span>(); <span class="built_in">func</span>(); &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Classical-Singleton">Classical Singleton</h3>
<p>Singleton are classes that allow only one instance.</p>
<ul>
<li>One way:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> Singleton* s_instance;</span><br><span class="line">  <span class="built_in">Singleton</span>() &#123;&#125;; <span class="comment">// Private empty construct function prevents instantiate</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *s_instance; &#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Static members in class shoud defined out-of-line, but here I given a nullptr to pass static analyze</span></span><br><span class="line">Singleton* Singleton::s_instance&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="comment">// Though no memory spaces created for the class, we can still access methods</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; Singleton::<span class="built_in">get</span>().<span class="built_in">hello</span>(); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Another way:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Singleton s_instance; <span class="comment">// Put instance into a local static variable (Pro: less code)</span></span><br><span class="line">    <span class="keyword">return</span> s_instance;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; Singleton::<span class="built_in">get</span>().<span class="built_in">hello</span>(); &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Constructors-Destructors">Constructors &amp; Destructors</h2>
<p>Corstructor provides a way to initialize primitive types when creating instance. Otherwise you have to do it manually or they will be keep to whatever is left over in that memory.</p>
<p>To Prevent creating instance, you can set constructor as priavate, or delete it.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Log</span>() &#123;&#125; <span class="comment">// One way</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Log() = delete; // Another way</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Log::<span class="built_in">write</span>(); <span class="comment">// Only Write() can be invoke</span></span><br><span class="line">  <span class="comment">// Log l; // Now you cannot access the constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Destructor provides a way to gently recycle memory when <code>delete</code> an object.<br>
It can be called directly: <code>SomeClass.~SomeClass();</code></p>
<h2 id="Inheritance-Virtual-Functions">Inheritance &amp; Virtual Functions</h2>
<p>Size of sub class: (base class) + (defined variables)</p>
<p>Why we need virtual function:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">get_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// public inheritance keep public members in base class public in sub class,</span></span><br><span class="line"><span class="comment">// otherwise they becomes to private</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name) : m_name&#123;name&#125; &#123;&#125;</span><br><span class="line">  <span class="function">std::string <span class="title">get_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Entity* entity&#123;<span class="keyword">new</span> Entity&#125;;</span><br><span class="line">  std::cout &lt;&lt; entity-&gt;<span class="built_in">get_name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  Player* player&#123;<span class="keyword">new</span> Player&#123;<span class="string">&quot;Cherno&quot;</span>&#125;&#125;;</span><br><span class="line">  Entity* entity2&#123;player&#125;; <span class="comment">// Cast player to Entity</span></span><br><span class="line">  std::cout &lt;&lt; entity2-&gt;<span class="built_in">get_name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Outputs:</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity</span><br><span class="line">Entity</span><br></pre></td></tr></table></figure>
<p>The problem occurs that the second output should be “Cherno”. When the pointer type is the main class <code>Entity</code>, the method <code>get_name()</code> uses it’s main class’ version even it’s actually an instance of <code>Player</code>, this definitely a problem.</p>
<p>If you want to override a method you have to mark the method in the base class as <code>virtual</code>. Correct version:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">get_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125; <span class="comment">// with &#x27;virtual&#x27; marked</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name) : m_name&#123;name&#125; &#123;&#125;</span><br><span class="line">  <span class="comment">// &#x27;override&#x27; is not necessary but it could avoid typo and imporve readability</span></span><br><span class="line">  <span class="function">std::string <span class="title">get_name</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Entity* entity&#123;<span class="keyword">new</span> Entity&#125;;</span><br><span class="line">  std::cout &lt;&lt; entity-&gt;<span class="built_in">get_name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  Player* player&#123;<span class="keyword">new</span> Player&#123;<span class="string">&quot;Cherno&quot;</span>&#125;&#125;;</span><br><span class="line">  Entity* entity2&#123;player&#125;;</span><br><span class="line">  std::cout &lt;&lt; entity2-&gt;<span class="built_in">get_name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>virtual</code> could reduce “dynamic dispatch” (change object’s vtable in runtime).<br>
<code>virtual</code> has its own overhead, it needs extra Vtable space, in order to dispatch the correct method it includes a member pointer in the base class that points to the vtable. And every time we call virtual method, we go through that table to decision which method to map.<br>
Through the extra overhead it’s still recommand to use as much as possible.</p>
</blockquote>
<h3 id="Interface-Pure-Virtual-Method">Interface (Pure Virtual Method)</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span> &#123; <span class="comment">// Interface class cannot be instantiated directlly</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">get_class_name</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// interface (pure virtual method)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity, <span class="keyword">public</span> Printable &#123; <span class="comment">// a sub class can inherit multiple interface class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">get_class_name</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Now even the Player instance is casted into its base class, it will still use sub class&#x27;s function implement</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Printable* obj)</span> </span>&#123; std::cout &lt;&lt; obj-&gt;<span class="built_in">get_class_name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Player* player&#123;<span class="keyword">new</span> Player&#125;;</span><br><span class="line">  <span class="built_in">print</span>(player);</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">new</span> Player); <span class="comment">// don&#x27;t do this, it&#x27;s very easily to cause memory leak</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Visibility-in-C">Visibility in C++</h2>
<ul>
<li>The default visibility of a Class would be <code>private</code>. If it’s a <code>struct</code> then it would be <code>public</code> by default.</li>
<li><code>private</code> things only visiable in it’s own class, nor in sub class, except friend class.</li>
<li><code>protected</code> things can be seen by sub class.</li>
</ul>
<h2 id="Literal-Arrays-C-11-Standard-Arrays">Literal Arrays &amp; C++11 Standard Arrays</h2>
<blockquote>
<p>Be aware for operations out of index (e.g. <code>example[-1] = 0</code>), in C++ you can do this by force the compiler to ignore this check, and it’s definitely discouraged.</p>
</blockquote>
<ul>
<li>Literal Array<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">5</span>]; <span class="comment">// On stack, destory on function end</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>* arr2&#123;<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#125;; <span class="comment">// on heap, would not auto destory</span></span><br><span class="line">  <span class="keyword">delete</span>[] arr2; <span class="comment">// Use square brackets to release an array on heap</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>* ptr&#123;arr&#125;; <span class="comment">// &#x27;arr&#x27; is actually a pointer which stores the begin address of the array</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) arr[i] = i;</span><br><span class="line">  </span><br><span class="line">  arr[<span class="number">2</span>] = <span class="number">5</span>; </span><br><span class="line">  *(ptr + <span class="number">2</span>) = <span class="number">5</span>; <span class="comment">// this is equal but in a pretty wild way</span></span><br><span class="line">  <span class="comment">// Bacause &#x27;ptr&#x27; has type &#x27;int&#x27; (32 bits, 4 bytes),</span></span><br><span class="line">  <span class="comment">// so + 2 let it advance two &#x27;int&#x27;s length (64 bits, 8 bytes)</span></span><br><span class="line">  <span class="comment">// We can also do the same operation in this form (`char` is 8 bits, 1 bytes)</span></span><br><span class="line">  *(<span class="type">int</span>*) ((<span class="type">char</span>*) ptr + <span class="number">8</span>) = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// You cannot dynamically chack a raw array&#x27;s size.</span></span><br><span class="line">  <span class="type">int</span> count&#123;<span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>)&#125;; <span class="comment">// Ways like this is unstable</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// A good ways is to use an constant to remember the array size,</span></span><br><span class="line">  <span class="comment">// or using c++11 standard arrays instead.</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span>&amp;&amp; arr_size&#123;<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="type">int</span> arr3[arr_size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Standard Arrays<br>
It’s more safe, but has little bit more overhead.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::array&lt;<span class="type">int</span>, 5&gt; arr;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) arr[i] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="How-Strings-Work-and-How-to-Use-Them">How Strings Work (and How to Use Them)</h2>
<h3 id="C-style-Strings-String-Literals-and-std-string-view">C-style Strings (String Literals) and std::string_view</h3>
<p>C-style strings are stored in code segment (virtual address space, which is read-only), this means you can only replace new string to the variable to “change” it.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name&#123;<span class="string">&quot;Cherno&quot;</span>&#125;;</span><br><span class="line">  <span class="comment">// &quot;Cherno&quot; + &quot; hello!&quot;; // You cannot do &#x27;+()&#x27; to literal strings since it&#x27;s constant</span></span><br><span class="line">  std::string_view name2&#123;name&#125;; <span class="comment">// c++17, it&#x27;s equivalent to &#x27;const char*&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Each strings at end has <code>\0</code> (named “null termination character”) to prevent out of index at iteration. e.g. <code>char str[7] = &#123;'C', 'h', 'e', 'r', 'n', 'o', '\0'&#125;;</code><br>
Terminal character will actuall break the behavior of string in many cases, use <code>std::string_view</code> can prevent this problem.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">8</span>]&#123;<span class="string">&quot;Che\0rno&quot;</span>&#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">strlen</span>(name) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>A sample implementation of <code>std::string_view</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An implementation of std::string_view</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticString</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> const_iterator = <span class="type">char</span> <span class="type">const</span>*;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span> <span class="type">const</span>* <span class="type">const</span> m_str;</span><br><span class="line">  std::<span class="type">size_t</span> <span class="type">const</span> m_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;std::<span class="type">size_t</span> N&gt;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">StaticString</span><span class="params">(<span class="type">char</span> <span class="type">const</span> (&amp;str)[N])</span> <span class="keyword">noexcept</span> : m_str&#123;</span>str&#125;, m_size&#123;N - <span class="number">1</span>&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">StaticString</span><span class="params">(<span class="type">char</span> <span class="type">const</span>* str, std::<span class="type">size_t</span> N)</span> <span class="keyword">noexcept</span> : m_str&#123;</span>str&#125;, m_size&#123;N&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">data</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_str; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_size; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_str; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_str + m_size; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="type">char</span> <span class="type">const</span>* <span class="title">const</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_str; &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">char</span> <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// clang-format off</span></span><br><span class="line">    <span class="keyword">return</span> n == std::numeric_limits&lt;<span class="type">size_t</span>&gt;::<span class="built_in">max</span>()</span><br><span class="line">      ? m_str[m_size - <span class="number">1</span>]</span><br><span class="line">      : n &lt; m_size ? m_str[n] : <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(std::format(<span class="string">&quot;static_string: out of range, index at &#123;&#125;&quot;</span>, n));</span><br><span class="line">    <span class="comment">// clang-format on</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, StaticString <span class="type">const</span>&amp; str) &#123; <span class="keyword">return</span> os.<span class="built_in">write</span>(str.<span class="built_in">data</span>(), str.<span class="built_in">size</span>()); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  StaticString str&#123;<span class="string">&quot;homo114514&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    str[<span class="number">-1</span>];</span><br><span class="line">    str[<span class="number">-2</span>];</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::out_of_range e) &#123; std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="std-string">std::string</h3>
<p>It’s a char array indeed.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string str&#123;<span class="string">&quot;Cherno&quot;</span>&#125;;</span><br><span class="line">  str += <span class="string">&quot; hello!&quot;</span>; <span class="comment">// &#x27;+=()&#x27; is overloaded in the string class to let you do that.</span></span><br><span class="line">  std::string str2&#123;std::string&#123;<span class="string">&quot;Cherno&quot;</span>&#125; + <span class="string">&quot; hello!&quot;</span>&#125;; <span class="comment">// This does more object copy operations</span></span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> contains = str.<span class="built_in">find</span>(<span class="string">&quot;no&quot;</span>) != std::string::npos; <span class="comment">// Check whether a string has specific word</span></span><br><span class="line">  std::cout &lt;&lt; contains &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char8_t</span>* name1&#123;<span class="string">u8&quot;Cherno&quot;</span>&#125;; <span class="comment">// utf-8, which is default</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char16_t</span>* name2&#123;<span class="string">u&quot;Cherno&quot;</span>&#125;; <span class="comment">// utf-16, two bytes per character</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char32_t</span>* name3&#123;<span class="string">U&quot;Cherno&quot;</span>&#125;; <span class="comment">// utf-32, four bytes per character</span></span><br><span class="line">  <span class="type">const</span> <span class="type">wchar_t</span>* name4&#123;<span class="string">L&quot;Cherno&quot;</span>&#125;; <span class="comment">// eitger 2 or 4 bytes, depends on compiler</span></span><br><span class="line">  <span class="comment">// Useful or you want to keep format</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* raw_string&#123;<span class="string">R&quot;(Line1</span></span><br><span class="line"><span class="string">Line2</span></span><br><span class="line"><span class="string">Line3</span></span><br><span class="line"><span class="string">Line4)&quot;</span>&#125;;</span><br><span class="line">  <span class="comment">// c++14 Standards</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line">  std::string name5&#123;<span class="string">&quot;Cherno&quot;</span>s + <span class="string">&quot; hello&quot;</span>&#125;;</span><br><span class="line">  std::wstring name6&#123;<span class="string">L&quot;Cherno&quot;</span>s + <span class="string">L&quot; hello&quot;</span>&#125;;</span><br><span class="line">  std::u32string name7&#123;<span class="string">U&quot;Cherno&quot;</span>s + <span class="string">U&quot; hello&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Constants-in-C">Constants in C++</h2>
<p>The mutability of const depends on how it stores:</p>
<ul>
<li>String Literal stored in the read-only section of the memory. So modifying will cause segmentation fault.</li>
<li>Constant variables may convert to a literal and place the primitive value in assemble in compile stage, while if the code attempt to take the address of constant variable the compiler will let it place in memory.</li>
</ul>
<h3 id="Constant-Pointer">Constant Pointer</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> MAX_AGE&#123;<span class="number">90</span>&#125;;</span><br><span class="line">  <span class="comment">// 1. Pointer to const value</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* a&#123;<span class="keyword">new</span> <span class="type">int</span>&#125;;</span><br><span class="line">  std::cout &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="comment">// *a = 2; // I can&#x27;t change the contents of the pointer</span></span><br><span class="line">  a = (<span class="type">int</span>*) &amp;MAX_AGE; <span class="comment">// But I can change the pointer itself</span></span><br><span class="line">  std::cout &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="comment">// 2. Const pointers</span></span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> b&#123;<span class="keyword">new</span> <span class="type">int</span>&#125;;</span><br><span class="line">  *b = <span class="number">2</span>; <span class="comment">// I can change the contents of the pointer</span></span><br><span class="line">  <span class="comment">// b = (int*) &amp;MAX_AGE; // But I can&#x27;t change the pointer&#x27;s value</span></span><br><span class="line">  <span class="comment">// 3. Const pointer to a const value</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> c&#123;&amp;MAX_AGE&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>const int*</code> equals <code>int const*</code>. So <code>const int*&amp; ptr&#123;&amp;a&#125;</code> is illegal since <code>a</code>’s address is a rvalue, <code>const int* const&amp; ptr&#123;&amp;a&#125;</code> or <code>const int*&amp;&amp; ptr&#123;&amp;a&#125;</code> should work.</p>
</blockquote>
<h3 id="Const-Method">Const Method</h3>
<p>Const methods cannot change member variables in the class, except for <code>mutable</code> and <code>static</code> variables.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_x, * m_y;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="type">int</span> m_z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// When a const method return pointer types, it should has &#x27;const&#x27; on both side</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> <span class="title">get_y</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_z</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// m_x = 2; // I can&#x27;t change member variable</span></span><br><span class="line">    m_z = <span class="number">2</span>; <span class="comment">// But I can change mutable variable</span></span><br><span class="line">    <span class="keyword">return</span> m_z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Entity&amp; e&#123;Entity&#123;&#125;&#125;;</span><br><span class="line">  <span class="comment">// e.set_x(); // A const object can only call its const methods.</span></span><br><span class="line">  std::cout &lt;&lt; e.<span class="built_in">get_z</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Member-Initializer-Lists-in-C-Constructor-Initializer-List">Member Initializer Lists in C++ (Constructor Initializer List)</h2>
<p>Use member initializer lists can prevent the use of <code>=</code> which may initialize object twice.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Example</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">  <span class="built_in">Example</span>(<span class="type">int</span> x) &#123; std::cout &lt;&lt; <span class="string">&quot;Created Entity with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Example m_example;</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Entity</span>() : m_example&#123;<span class="number">8</span>&#125;, x&#123;&#125;, y&#123;&#125;, z&#123;&#125; &#123; <span class="comment">// m_example&#123;8&#125; equals m_example = Example&#123;8&#125;</span></span><br><span class="line">  <span class="comment">// m_example = Example&#123;8&#125;; // This will initialize twice</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Entity</span>(<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">this</span>-&gt;x = x, <span class="keyword">this</span>-&gt;y = y; &#125; <span class="comment">// `this` is a pointer point to current object,</span></span><br><span class="line">  <span class="comment">// to avoid ambiguity in member variable and the method&#x27;s args</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; Entity e; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ternary-Operators-in-C-Conditional-Assignment">Ternary Operators in C++ (Conditional Assignment)</h2>
<p>Ternaay can simplify <code>if else</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_level&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_speed&#123;<span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  s_speed = s_level &gt; <span class="number">5</span> &amp;&amp; s_level &lt; <span class="number">100</span> ? s_level &gt; <span class="number">10</span> ? <span class="number">15</span> : <span class="number">10</span> : <span class="number">5</span>;</span><br><span class="line">  <span class="comment">// Above sentence equals to:</span></span><br><span class="line">  <span class="comment">// if (s_level &gt; 5 &amp;&amp; s_level &lt; 100)</span></span><br><span class="line">  <span class="comment">//   if(s_level &gt; 10) s_speed = 15;</span></span><br><span class="line">  <span class="comment">//   else s_speed = 10;</span></span><br><span class="line">  <span class="comment">// else s_speed = 5;</span></span><br><span class="line">  std::cout &lt;&lt; s_speed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Create-Instantiate-Objects">Create/Instantiate Objects</h2>
<p>There are two main section of memory: stack and heap.</p>
<ul>
<li>Stack objects have an automatic lifespan, their lifetime is actually controlled by the their scope.<br>
the stack size is small (usually 1~10M), if you have a big object, you have to store it in the heap.</li>
<li>Heap: once you allocated an object in the heap, it’s gonna sit there unill you explicit delete it.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Entity</span>(<span class="type">const</span> std::string_view str) &#123; std::cout&lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Without `new`, object created on the stack</span></span><br><span class="line">  Entity entity&#123;<span class="string">&quot;Cherno&quot;</span>&#125;; <span class="comment">// equals Entity entity = Entity&#123;&quot;Cherno&quot;&#125;;</span></span><br><span class="line">  <span class="comment">// With `new`, object created on the heap, new returns the memory address</span></span><br><span class="line">  Entity* entity2&#123;<span class="keyword">new</span> Entity&#123;<span class="string">&quot;Cherno&quot;</span>&#125;&#125;;</span><br><span class="line">  <span class="comment">// We need manually release the object on the heap</span></span><br><span class="line">  <span class="keyword">delete</span> entity2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Manual resource release is memory leak prone, use smart pointer is a better idea.</p>
</blockquote>
<h3 id="The-New-Delete-Keyword">The New/Delete Keyword</h3>
<p>How the <code>new</code> keyword find free space on memory? There is something called <em>free list</em> which maintain the addresses that have bytes free. It’s obvously written in intelligent but it’s stll quite slow.</p>
<ul>
<li><code>new</code> is just an operator, it uses the underlying C function <code>malloc()</code>, means that you can overload <code>new</code> and change its bahavious. <code>new</code> also calls the constructor.</li>
<li><code>delete</code> also calls the destructor.</li>
</ul>
<p>Three uses of <code>new</code> (normal new, array new, placement new)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Entity* entity&#123;<span class="keyword">new</span> Entity&#125;; <span class="comment">// Normal `new`</span></span><br><span class="line">  <span class="keyword">delete</span> entity; <span class="comment">// Remember delete object</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we want an array of entries (An array which is stored 50 Objects of Entity)</span></span><br><span class="line">  Entity* entity2&#123;<span class="keyword">new</span> Entity[<span class="number">50</span>]&#125;; <span class="comment">// Array `new`</span></span><br><span class="line">  <span class="keyword">delete</span>[]entity2; <span class="comment">// Also we need calling delete with square bracket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Placement `new` is where you actually get to decide where the memory comes from.</span></span><br><span class="line">  <span class="comment">// You don&#x27;t really allocating memory with `new`,</span></span><br><span class="line">  <span class="comment">// but just calling the constructor and initializing object in a specific memory address</span></span><br><span class="line">  <span class="type">int</span>* buffer&#123;<span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>]&#125;;</span><br><span class="line">  Entity* entity3&#123;<span class="keyword">new</span>(buffer) Entity&#125;;</span><br><span class="line">  <span class="keyword">delete</span> entity3;</span><br><span class="line">  <span class="comment">// delete[] buffer; // This will cause double free</span></span><br><span class="line">  <span class="comment">// In C there are some kinds of equivalent:</span></span><br><span class="line">  Entity* entity4&#123;(Entity*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Entity))&#125;;</span><br><span class="line">  <span class="keyword">new</span>(entity4) Entity; <span class="comment">// malloc() will not call the constructor so I need to call it in manual</span></span><br><span class="line">  entity4-&gt;~<span class="built_in">Entity</span>(); <span class="comment">// free() also not call the destructor automatically</span></span><br><span class="line">  <span class="built_in">free</span>(entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Implicit-Conversion-and-the-Explicit-Keyword-in-C">Implicit Conversion and the Explicit Keyword in C++</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string_view m_name;</span><br><span class="line">  <span class="type">int</span> m_age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Entity</span>(<span class="type">const</span> std::string_view name) : m_name&#123;name&#125;, m_age&#123;<span class="number">-1</span>&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">int</span> age)</span> : m_name(<span class="string">&quot;Unknown&quot;</span>), m_age(age) &#123;</span>&#125; <span class="comment">// Use explicit keyword to disable implicit conversion</span></span><br><span class="line">  <span class="function">std::string_view <span class="title">get_name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_entity</span><span class="params">(<span class="type">const</span> Entity&amp; entity)</span> </span>&#123; std::cout &lt;&lt; entity.<span class="built_in">get_name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is a implicit conversion</span></span><br><span class="line">  Entity a = std::string_view&#123;<span class="string">&quot;Cherno&quot;</span>&#125;;</span><br><span class="line">  <span class="comment">// It implicit converting std::string_view&#123;&quot;Cherno&quot;&#125; into</span></span><br><span class="line">  <span class="comment">// Entity&#x27;s constructor method Entity(const std::string_view&amp; name)</span></span><br><span class="line">  <span class="comment">// It&#x27;s weird , you can&#x27;t do this in other languages (such as C# or Java)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Entity b = 22; // I can&#x27;t do implicit conversion with explicit method anymore</span></span><br><span class="line">  Entity b&#123;<span class="number">22</span>&#125;; <span class="comment">// equals Entity b = Entity&#123;22&#125;;</span></span><br><span class="line">  <span class="comment">// &#123;&#125; is uniform initialization, it is narrowing conversion (high to low precision) prevention</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// C++ allows only one implicit conversion at same time</span></span><br><span class="line">  <span class="comment">// &quot;Cherno&quot; is a const char array, C++ needs to do two conversions,</span></span><br><span class="line">  <span class="comment">// one from const char* to std::string_view, and then call into Entity(const std::string_view&amp; name)</span></span><br><span class="line">  <span class="comment">// Entity c = &quot;Cherno&quot;; // Fail</span></span><br><span class="line">  <span class="comment">// print_entity(&quot;Cherno&quot;); // Fail</span></span><br><span class="line">  <span class="built_in">print_entity</span>(std::string_view&#123;<span class="string">&quot;Cherno&quot;</span>&#125;);</span><br><span class="line">  <span class="built_in">print_entity</span>(Entity&#123;<span class="string">&quot;Cherno&quot;</span>&#125;);</span><br><span class="line">  <span class="built_in">print_entity</span>(&#123;<span class="string">&quot;Cherno&quot;</span>&#125;); <span class="comment">// Same as above</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Operators-and-Operator-Overloading-in-C">Operators and Operator Overloading in C++</h2>
<p>In the case of operator overloading you’re allowed to define or change the behavior of operator</p>
<ul>
<li><strong>Operators are just functions</strong></li>
</ul>
<p>Here goes some examples:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">  <span class="type">float</span> x, y;</span><br><span class="line">  <span class="built_in">Vector2</span>(<span class="type">float</span> <span class="type">const</span> x, <span class="type">float</span> <span class="type">const</span> y) : x&#123;x&#125;, y&#123;y&#125; &#123;&#125;</span><br><span class="line">  <span class="comment">// overload the function &quot;operator+()&quot; equals redefine the behavior of &#x27;+&#x27; in this Object</span></span><br><span class="line">  Vector2 <span class="keyword">operator</span>+(Vector2 <span class="type">const</span>&amp; other) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Vector2</span>(x + other.x, y + other.y); &#125;</span><br><span class="line">  Vector2 <span class="keyword">operator</span>*(Vector2 <span class="type">const</span>&amp; other) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Vector2</span>(x * other.x, y * other.y); &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(Vector2 <span class="type">const</span>&amp; other) <span class="type">const</span> &#123; <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y; &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>!=(Vector2 <span class="type">const</span>&amp; other) <span class="type">const</span> &#123; <span class="keyword">return</span> !<span class="keyword">operator</span>==(other); <span class="comment">/*Or return !(*this == other);*/</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, Vector2 <span class="type">const</span>&amp; other) &#123;</span><br><span class="line">  <span class="keyword">return</span> stream &lt;&lt; other.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; other.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Vector2 pos&#123;<span class="number">4.0f</span>, <span class="number">4.0f</span>&#125;;</span><br><span class="line">  Vector2 spd&#123;<span class="number">0.5f</span>, <span class="number">1.5f</span>&#125;;</span><br><span class="line">  Vector2 time&#123;<span class="number">1.1f</span>, <span class="number">1.1f</span>&#125;;</span><br><span class="line">  Vector2 res&#123;pos + spd * time&#125;;</span><br><span class="line">  <span class="comment">// We cannot output the variables in vector directly,</span></span><br><span class="line">  <span class="comment">// We need overload the function `operator&lt;&lt;`</span></span><br><span class="line">  std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="comment">// In programs such as Java we have to use equals() to compare objects,</span></span><br><span class="line">  <span class="comment">// but in C++ we can simply overload the &quot;operator==&quot;</span></span><br><span class="line">  <span class="keyword">if</span> (res == pos) std::cout &lt;&lt; <span class="string">&quot;foo&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;bar&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Object-Lifetime-Stack-Scope-Lifetimes">Object Lifetime (Stack/Scope Lifetimes)</h2>
<ul>
<li>Don’t return object stored in stack</li>
<li>Use <code>&#123;&#125;</code> to create a local scope so that stacked things will be released earlier.</li>
<li>Underlying of Unique Pointer<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">CreateArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> array[<span class="number">50</span>]; <span class="comment">// Don&#x27;t write code like this</span></span><br><span class="line">  <span class="keyword">return</span> array; <span class="comment">// The array gets cleared as soon as we go out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout&lt;&lt; <span class="string">&quot;Print from Entity!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">Entity</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Entity released~&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// We can use `std::unique_pointer` which is a scoped pointer,</span></span><br><span class="line"><span class="comment">// but here we write our own to explain how it works</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ScopedPtr</span>(T* ptr) : m_ptr&#123;ptr&#125; &#123;&#125;</span><br><span class="line">  ~<span class="built_in">ScopedPtr</span>() &#123; <span class="keyword">delete</span> m_ptr; &#125;</span><br><span class="line">  <span class="comment">// `-&gt;` is special, it&#x27;s invoked in a loop to call another `-&gt;` if</span></span><br><span class="line">  <span class="comment">// the return value is another object (not a pointer), and will finally</span></span><br><span class="line">  <span class="comment">// dereference the founded pointer.</span></span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">  T <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">  <span class="built_in">ScopedPtr</span>(ScopedPtr&lt;T&gt;&amp;) = <span class="keyword">delete</span>; <span class="comment">// Inhibit copy constructor</span></span><br><span class="line">  ScopedPtr&lt;T&gt; <span class="keyword">operator</span>=(ScopedPtr&lt;T&gt;) = <span class="keyword">delete</span>; <span class="comment">// Inhibit copy assignment</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#123; <span class="comment">// scope with brace</span></span><br><span class="line">    Entity e; <span class="comment">// the object created on stack will gets free when out of the scope</span></span><br><span class="line"></span><br><span class="line">    ScopedPtr&lt;Entity&gt; ptr = &#123;<span class="keyword">new</span> Entity&#125;;</span><br><span class="line">    <span class="comment">// ScopedPtr&lt;Entity&gt; ptr2&#123;ptr&#125;;</span></span><br><span class="line">    ptr-&gt;<span class="built_in">print</span>();</span><br><span class="line">    (*ptr).<span class="built_in">print</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// since the scoped pointer object gets allocated on the stack which means it</span></span><br><span class="line">  <span class="comment">// will gets deleted when out of the scope and call ~ScopedPtr()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Smart-Pointers-std-unique-ptr-std-shared-ptr-std-weak-ptr">Smart Pointers (std::unique_ptr, std::shared_ptr, std::weak_ptr)</h2>
<p>Smart pointers is that when you call <code>new</code> , you don’t have to call <code>delete</code>. Actually in many cases with smart pointers we don’t even have to call <code>new</code>.</p>
<ul>
<li><strong>Unique pointer</strong></li>
<li><strong>Shared pointer</strong> &amp; <strong>Weak pointer</strong><br>
Shared pointer use something called reference counting. If create one shread pointer and define another shared pointer and copy the previous one, the reference count is now 2; when the first one dies (out of scope), the reference count goes down 1; when the last one dies. the reference count goes back to zero and free the memory.<br>
Weak pointer will not increase the reference count.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Entity</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">  ~<span class="built_in">Entity</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destoryed Entity~&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// All smart pointer are marked as explicit due to exception safety</span></span><br><span class="line">  std::unique_ptr&lt;Entity&gt; unique_entity&#123;<span class="keyword">new</span> Entity&#125;;</span><br><span class="line">  <span class="comment">// The preferred way to construct this would be use std::make_unique&lt;T&gt;()</span></span><br><span class="line">  <span class="keyword">auto</span> unique_entity2&#123;std::<span class="built_in">make_unique</span>&lt;Entity&gt;()&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// I can access it like I would normally</span></span><br><span class="line">  unique_entity2-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In the definition of unique pointer, the copy constructor</span></span><br><span class="line">  <span class="comment">// and copy assignment operator are deleted</span></span><br><span class="line">  <span class="comment">// std::unique_ptr&lt;Entity&gt; e0&#123;unique_entity2&#125;; // I cannot copy unique pointer</span></span><br><span class="line">         </span><br><span class="line">  <span class="comment">// Weak pointer won&#x27;t increase the reference count</span></span><br><span class="line">  std::weak_ptr&lt;Entity&gt; weak_entity;</span><br><span class="line">  &#123; <span class="comment">// For shared pointer use make_shared is very recommand because its more efficient</span></span><br><span class="line">    <span class="keyword">auto</span> shared_entity&#123;std::<span class="built_in">make_shared</span>&lt;Entity&gt;()&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current count: &quot;</span> &lt;&lt; shared_entity.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">auto</span> shared_entity2&#123;shared_entity&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current count: &quot;</span> &lt;&lt; shared_entity.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    weak_entity = shared_entity;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current count: &quot;</span> &lt;&lt; shared_entity.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125; <span class="comment">// The shared_entity will be free immediately here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Copying-and-Copy-Constructors">Copying and Copy Constructors</h2>
<p>Ues <code>=</code> (shallow copy) to copy. An object created on heap without a copy constuctors or an object created on stack but with pointer variables that point objects on heap will lead to unexpected results since shallow copy don’t copy them fully but essentially just copy the address in pointer variable. So a copy constructor is required to delimit the behavior of the copy operation.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* m_buffer;</span><br><span class="line">  <span class="type">size_t</span> m_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str) : m_size&#123;<span class="built_in">strlen</span>(str) + <span class="number">1</span>&#125; &#123;</span><br><span class="line">    m_buffer = <span class="keyword">new</span> <span class="type">char</span>[m_size + <span class="number">1</span>]; <span class="comment">// +1 for last null termination char</span></span><br><span class="line">    std::<span class="built_in">copy_n</span>(str, m_size, m_buffer);</span><br><span class="line">    <span class="comment">// memcpy(m_buffer, str, m_size + 1); // C-style way, you can also use strcpy()</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> String&amp; other) : <span class="built_in">m_size</span>(other.m_size) &#123; <span class="comment">// Copy Consturcor</span></span><br><span class="line">    m_buffer = <span class="keyword">new</span> <span class="type">char</span>[m_size + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">copy_n</span>(other.m_buffer, m_size, m_buffer);</span><br><span class="line">    <span class="comment">// The shallow copy is like &#x27;memcpy(this, &amp;other, sizeof(String));&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// String(const String&amp; other) = delete; // Or you can just prevent this object to do copy operation</span></span><br><span class="line">  ~<span class="built_in">String</span>() &#123; <span class="keyword">delete</span>[] m_buffer; &#125;</span><br><span class="line">  <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> <span class="type">int</span> <span class="type">const</span> idx) <span class="type">const</span> &#123; <span class="keyword">return</span> m_buffer[idx]; &#125;</span><br><span class="line">  <span class="comment">// make &lt;&lt;() to be a fried so it can access private variables in this object</span></span><br><span class="line">  <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; str);</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; str) &#123; <span class="keyword">return</span> stream &lt;&lt; str.m_buffer; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String first_str&#123;<span class="string">&quot;Cherno&quot;</span>&#125;;</span><br><span class="line">  String second_str&#123;first_str&#125;;</span><br><span class="line">  second_str[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; first_str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; second_str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-Arrow-Operator">The Arrow Operator</h2>
<ul>
<li>It’s possible to overload the Arror Operator and use it in specific class such as ScopedPtr:</li>
<li>It can also be used to get the variable’s memory offset in an object (in some memory hack):</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3</span> &#123;</span><br><span class="line">  <span class="type">float</span> z, y, x; <span class="comment">// I deliberately desrupt the naming order to make it in a different memory layout.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// float has 4 bytes, 32 bits, long in c++20 has 8 bytes, 64 bits</span></span><br><span class="line">  <span class="type">long</span> offset_x&#123;(<span class="type">long</span>) &amp;((Vector3*) <span class="number">0</span>)-&gt;x&#125;; <span class="comment">// Or &amp;((Vector3*) nullptr)-&gt;x;</span></span><br><span class="line">  std::cout &lt;&lt; offset_x &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">long</span> offset_y&#123;(<span class="type">long</span>) &amp;((Vector3*) <span class="number">0</span>)-&gt;y&#125;; <span class="comment">// Or &amp;((Vector3*) nullptr)-&gt;x;</span></span><br><span class="line">  std::cout &lt;&lt; offset_y &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">long</span> offset_z&#123;(<span class="type">long</span>) &amp;((Vector3*) <span class="number">0</span>)-&gt;z&#125;; <span class="comment">// Or &amp;((Vector3*) nullptr)-&gt;x;</span></span><br><span class="line">  std::cout &lt;&lt; offset_z &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dynamic-Arrays-std-vector">Dynamic Arrays (std::vector)</h2>
<p>Vector in C++ is not mathematical vector, it’s kind of dynamic arrays like.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">  <span class="type">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, Vertex <span class="type">const</span>&amp; vertex) &#123;</span><br><span class="line">  stream &lt;&lt; vertex.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vertex.y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vertex.z;</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">  vertices.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">  vertices.<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;);</span><br><span class="line">  <span class="comment">// Using range based &#x27;for loop&#x27; to iterate the object in dynamic array</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> Vertex&amp; v : vertices) std::cout &lt;&lt; v &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + <span class="number">1</span>); <span class="comment">// Remove the second object by using an iterator</span></span><br><span class="line">  vertices.<span class="built_in">clear</span>();                     <span class="comment">// Or we can clean the whole dynamic array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Optimizing-the-usage-of-std-vector">Optimizing the usage of std::vector</h3>
<p>Two ways to reduce memory copy</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">  <span class="type">float</span> x, y, z;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> copy_count;</span><br><span class="line">  <span class="built_in">Vertex</span>(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line">  <span class="comment">// Copy Constructor, used to capture copied times</span></span><br><span class="line">  <span class="built_in">Vertex</span>(Vertex <span class="type">const</span>&amp; v) : <span class="built_in">x</span>(v.x), <span class="built_in">y</span>(v.y), <span class="built_in">z</span>(v.z) &#123; std::cout &lt;&lt; <span class="string">&quot;Copied &quot;</span> &lt;&lt; ++copy_count &lt;&lt; <span class="string">&quot; times&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Vertex::copy_count&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Vertex&gt; vertices_bad;</span><br><span class="line">  vertices_bad.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// 1 copy to store</span></span><br><span class="line">  <span class="comment">// Trigger rearrange, new size is current_elements x 2, which is 2 x Vertex</span></span><br><span class="line">  vertices_bad.<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;); <span class="comment">// 1 copies to rearrange + 1 copy to store</span></span><br><span class="line">  <span class="comment">// Trigger rearrange, now reserved 4 x Vertex</span></span><br><span class="line">  vertices_bad.<span class="built_in">push_back</span>(&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);    <span class="comment">// 2 copies to rearrange + 1 copy to store</span></span><br><span class="line">  vertices_bad.<span class="built_in">push_back</span>(&#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;); <span class="comment">// 1 copy to store</span></span><br><span class="line">  <span class="comment">// Trigger rearrange, new reserved 8 x Vertex</span></span><br><span class="line">  vertices_bad.<span class="built_in">push_back</span>(&#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;); <span class="comment">// 4 copies to rearrange,  1 copy to store</span></span><br><span class="line">  vertices_bad.<span class="built_in">push_back</span>(&#123;<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>&#125;); <span class="comment">// 1 copy to store</span></span><br><span class="line">  vertices_bad.<span class="built_in">push_back</span>(&#123;<span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>&#125;); <span class="comment">// 1 copy to store</span></span><br><span class="line">  vertices_bad.<span class="built_in">push_back</span>(&#123;<span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>&#125;); <span class="comment">// 1 copy to store</span></span><br><span class="line">  <span class="comment">// Trigger rearrange, new reserved 16 x Vertex</span></span><br><span class="line">  vertices_bad.<span class="built_in">push_back</span>(&#123;<span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>&#125;); <span class="comment">// 8 copies to store, 1 copies to store, total 24</span></span><br><span class="line">  <span class="comment">// Each time push_back() will do 1 copy operation to store the Vertex to vector,</span></span><br><span class="line">  <span class="comment">// And each push back may let vector do memory rearrange if reserved memory is full, which copies</span></span><br><span class="line">  <span class="comment">// previous objects in dynamic array into new memory area.</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;vertices good&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::vector&lt;Vertex&gt; vertices_good;</span><br><span class="line">  <span class="comment">// 1. Use reserver() to prevent memory rearrange.</span></span><br><span class="line">  vertices_good.<span class="built_in">reserve</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="comment">// 2. Replace push_back() with emplace_back() to prevent parameter copy</span></span><br><span class="line">  <span class="comment">// it acts as a proxy to process you provided parameter into Constructor.</span></span><br><span class="line">  vertices_good.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  vertices_good.<span class="built_in">emplace_back</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">  vertices_good.<span class="built_in">emplace_back</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">  vertices_good.<span class="built_in">emplace_back</span>(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Using-Libraries-in-C">Using Libraries in C++</h2>
<p>Using GLFW as example.</p>
<ul>
<li>Visual Studio
<ol>
<li>Create a folder called “Dependencies” under your project directory and then put the library into it.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\USERNAME\source\repos\Your_Project_Directory\Dependencies\</span><br><span class="line">-&gt; GLFW\</span><br><span class="line">  -&gt; include\GLFW\</span><br><span class="line">    glfw3.h</span><br><span class="line">    ...</span><br><span class="line">  -&gt; lib-vc2015\</span><br><span class="line">    glfw3.dll</span><br><span class="line">    glfw3.lib</span><br><span class="line">    glfw3.dll.lib</span><br></pre></td></tr></table></figure>
</li>
<li>Open project settings:<br>
-&gt; Configuration: All Configuration<br>
-&gt; C/C++ -&gt; Additional Include Directories: <code>$(SolutionDir)\Dependencies\GLFW\include</code><br>
-&gt; Linker -&gt; General -&gt; Additional Library Directories: <code>$(SolutionDir)\Dependencies\GLFW\lib-vc2015</code></li>
</ol>
</li>
</ul>
<h3 id="Static-linking">Static linking</h3>
<p>Static linking happens at compile time, the lib intergrate into executable or a dynamic library</p>
<p>Visual Studio</p>
<ol>
<li>Open project setting<br>
-&gt; Linker -&gt; Input -&gt; Additional Dependencies: <code>glfw3.lib;xxxxxx;balabala;...</code></li>
<li>Static Link<figure class="highlight c++"><figcaption><span>Main.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// quote for header in this project, regular bracket for external library</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">// Or `extern &quot;C&quot; int glfwInit();`</span></span><br><span class="line"><span class="comment">// Since GLFW is actually a C library so we need `extern &quot;C&quot;`</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="built_in">glfwInit</span>();</span><br><span class="line">  std::cout &lt;&lt; result &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Dynamic-linking">Dynamic linking</h3>
<p>Dynamic linking happens at runtime</p>
<ul>
<li>Some librarys like GLFW supports both static and dynamic linking in a single header file.</li>
<li><code>glfw3.dll.lib</code> is basically a series of pointers into <code>glwfw3.dll</code></li>
<li>Code is basically as same as static linking.</li>
</ul>
<p>Visual Studio</p>
<ol>
<li>
<p>Open project settings:<br>
-&gt; Linker -&gt; Input -&gt; Additional Dependencies: <code>glfw3.dll.lib;xxxxxx;balabala;...</code></p>
</li>
<li>
<p>Put <code>glfw3.dll</code> to the same folder as your executable file (i.e: <code>$(SolutionDir)\Debug</code>)</p>
</li>
<li>
<p>In fact, to call a function in dynamic library, it needs a prefix called <code>__declspec(dllimport)</code><br>
If you explore <code>glfw3.h</code> you will see there is a prefix <code>GLFWAPI</code> in every function’s definition:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We are calling GLFW as a Win32 DLL */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLFWAPI __declspec(dllimport)</span></span><br></pre></td></tr></table></figure>
<p>So <strong>you need to define a Macro</strong> in VS:<br>
Open your project setting:<br>
-&gt; C/C++ -&gt; Preprocessor -&gt; Preprocessor Definitions: <code>GLFW_DLL;xxxxx;bababa...</code></p>
<p>But why it seems stll work properly without the <code>dllimport</code> prefix?<br>
In modern windows, <code>dllimport</code> is not needed for functions, but <code>dllimport</code> is still needed for C++ classes and global variables.</p>
</li>
</ol>
<h2 id="Making-and-Working-with-Libraries-in-C-Multiple-Projects-in-Visual-Studio">Making and Working with Libraries in C++ (Multiple Projects in Visual Studio)</h2>
<ol>
<li>Visual Studio Setup:
<ol>
<li>Create one solution with 2 projects: “Game” and “Engine”,</li>
<li>Project “Game”:<br>
Ceneral-&gt;Project Defaults-&gt;Configuration Type: Application (.exe)<br>
-&gt; C/C++ -&gt; General -&gt; Additional include Directories: <code>$(SolutionDir)\Engine\src;</code></li>
<li>Project “Engine”:<br>
Ceneral-&gt;Project Defaults-&gt;Configuration Type: Static library (.lib)</li>
<li>Right click on projects “Game” -&gt; Add -&gt; Reference -&gt; Select project “Engine”</li>
</ol>
</li>
<li>Code for project “Engine”:<figure class="highlight c++"><figcaption><span>Your_Project_Directory\src\Engine.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> engine &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><figcaption><span>Your_Project_Directory\src\Engine.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> engine &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello Game!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Code for project “Game”:<figure class="highlight c++"><figcaption><span>Your_Project_Directory\src\Application.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; engine::<span class="built_in">print_message</span>(); &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="How-to-Deal-with-Multiple-Return-Values-in-C">How to Deal with Multiple Return Values in C++</h2>
<p>Example scenario: We have a function called <code>parse_shader()</code>, it needs to return two strings.</p>
<ul>
<li>Return a struct cotains two strings (Cherno’s choose):<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span> &#123;</span><br><span class="line">  std::string vertex_source;</span><br><span class="line">  std::string fragment_source;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ShaderProgramSource <span class="title">parse_shader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... (Some statements that process result &#x27;vs&#x27; and &#x27;fs&#x27;)</span></span><br><span class="line">  std::string vs, fs;</span><br><span class="line">  <span class="keyword">return</span> &#123;vs, fs&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Use reference paremeter (Probably one of the most optimal way) <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse_shader</span><span class="params">(std::string&amp; out_vertex_source, std::string&amp; out_fragment_source)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... (Some statements that process result &#x27;vs&#x27; and &#x27;fs&#x27;)</span></span><br><span class="line">  std::string vs, fs;</span><br><span class="line">  std::<span class="built_in">tie</span>(out_vertex_source, out_fragment_source) = std::tuple&#123;vs, fs&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Or use pointer parameter if you want to pass nullptr (ignore the output):</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse_shader2</span><span class="params">(std::string* outVertexSource, std::string* outFragmentSource)</span> </span>&#123;</span><br><span class="line">  std::string vs, fs;</span><br><span class="line">  <span class="keyword">if</span> (outVertexSource) *outVertexSource = vs;</span><br><span class="line">  <span class="keyword">if</span> (outFragmentSource) *outFragmentSource = fs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string vertex_source, fragment_source;</span><br><span class="line">  <span class="built_in">parse_shader</span>(vertex_source, fragment_source);</span><br><span class="line">  <span class="built_in">parse_shader2</span>(<span class="literal">nullptr</span>, &amp;fragment_source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Return a <code>std::array</code> or <code>std::vector</code><br>
The different is primarly the arrays can be create on the stack whereas vectors gonna store its underlying storage on the heap.<br>
So technically returning a standard array would be faster.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function">std::array&lt;std::string, 2&gt; <span class="title">parse_shader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string vs, fs;</span><br><span class="line">  <span class="comment">// ... (Some statements that process result &#x27;vs&#x27; and &#x27;fs&#x27;)</span></span><br><span class="line">  <span class="keyword">return</span> &#123;vs, fs&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Using <code>std::tuple</code> and <code>std::pair</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">create_person</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="string">&quot;Cherno&quot;</span>, <span class="number">24</span>&#125;; &#125;</span><br><span class="line"><span class="function">std::pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">create_person2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="string">&quot;Cherno&quot;</span>, <span class="number">24</span>&#125;; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// std::tuple can return more than two elements</span></span><br><span class="line">  <span class="keyword">auto</span> person&#123;<span class="built_in">create_person</span>()&#125;;    <span class="comment">// Automatically deduce the return type</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; name&#123;std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(person)&#125;; <span class="comment">// Get values in std::tuple</span></span><br><span class="line">  <span class="type">int</span> age&#123;std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(person)&#125;;</span><br><span class="line">  <span class="comment">// std::pair is a little bit faster than tuple</span></span><br><span class="line">  <span class="keyword">auto</span> [name2, age2]&#123;<span class="built_in">create_person2</span>()&#125;; <span class="comment">// c++17 structure binding</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Templates">Templates</h2>
<p>Template can improve code reuse rate and reduce duplicate code (e.g. function overload), the essence of template is similar to macros</p>
<ol>
<li>template type</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In this case, template specifying how to create methods based on usage of them.</span></span><br><span class="line"><span class="comment">// So if nobody call this function, it&#x27;s code will not exist in compiled file,  and</span></span><br><span class="line"><span class="comment">// even if there is a grammatical error in templated function code, it will still</span></span><br><span class="line"><span class="comment">// compile successfully.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// exactly same with &#x27;template&lt;typename T&gt;&#x27;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value)</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">5</span>);      <span class="comment">// Auto deducing</span></span><br><span class="line">  <span class="built_in">print</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>); <span class="comment">// It&#x27;s a good manner specifying the type explicitly</span></span><br><span class="line">  <span class="built_in">print</span>&lt;<span class="type">char</span> <span class="type">const</span>*&gt;(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>&lt;<span class="type">float</span>&gt;(<span class="number">5.5f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>template argument<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> N&gt; <span class="comment">// Multiple template targets can be in one template definition</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T m_arr[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Array&lt;<span class="type">int</span>, <span class="number">5</span>&gt; arr; <span class="comment">// It will generate the following code:</span></span><br><span class="line">  <span class="comment">// class Array &#123;</span></span><br><span class="line">  <span class="comment">// private:</span></span><br><span class="line">  <span class="comment">//   int m_arry[5];</span></span><br><span class="line">  <span class="comment">// public:</span></span><br><span class="line">  <span class="comment">//   int get_size() const &#123; return 5; &#125;</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  std::cout &lt;&lt; arr.<span class="built_in">get_size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="SFINAE">SFINAE</h3>
<p><em>“Substitution Failure Is Not An Error”</em>, compiler will continue to find suitable template.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Template if statement using SFINAE</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> Cond, <span class="keyword">typename</span> IfTrue, <span class="keyword">typename</span> IfFalse&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = IfTrue;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IfTrue, <span class="keyword">typename</span> IfFalse&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span>&lt;<span class="literal">false</span>, IfTrue, IfFalse&gt; &#123; <span class="comment">// This will has higher priority</span></span><br><span class="line">  <span class="keyword">using</span> type = IfFalse;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Narrowing conversion check using SFINAE</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> From, <span class="keyword">typename</span> To, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> is_narrowing_conversion : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> From, <span class="keyword">typename</span> To&gt;</span><br><span class="line"><span class="comment">// To&#123;std::declval&lt;From&gt;()&#125; is ill-formed in case of narrowing cast, so will prevents match this template</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_narrowing_conversion</span>&lt;From, To, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(To&#123;std::<span class="built_in">declval</span>&lt;From&gt;()&#125;)&gt;&gt; : std::false_type &#123;&#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(!is_narrowing_conversion&lt;std::<span class="type">int8_t</span>, std::<span class="type">int16_t</span>&gt;::value);</span><br><span class="line"><span class="built_in">static_assert</span>(!is_narrowing_conversion&lt;std::<span class="type">uint8_t</span>, std::<span class="type">int16_t</span>&gt;::value);</span><br><span class="line"><span class="built_in">static_assert</span>(!is_narrowing_conversion&lt;<span class="type">float</span>, <span class="type">double</span>&gt;::value);</span><br><span class="line"><span class="built_in">static_assert</span>( is_narrowing_conversion&lt;<span class="type">double</span>, <span class="type">float</span>&gt;::value);</span><br><span class="line"><span class="built_in">static_assert</span>( is_narrowing_conversion&lt;<span class="type">int</span>, <span class="type">uint32_t</span>&gt;::value);</span><br></pre></td></tr></table></figure>
<h3 id="Ways-to-Print-Type-Name">Ways to Print Type Name</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cxxabi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;source_location&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// One way</span></span><br><span class="line"><span class="function">std::string <span class="title">type_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> TRR = std::remove_reference&lt;T&gt;::type;</span><br><span class="line">  std::unique_ptr&lt;<span class="type">char</span>, <span class="built_in">void</span> (*)(<span class="type">void</span>*)&gt; p_demangled_name&#123;abi::__cxa_demangle(<span class="built_in">typeid</span>(TRR).<span class="built_in">name</span>(), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>),</span><br><span class="line">                                                          std::free&#125;;</span><br><span class="line">  std::string ret&#123;p_demangled_name != <span class="literal">nullptr</span> ? p_demangled_name.<span class="built_in">get</span>() : <span class="built_in">typeid</span>(TRR).<span class="built_in">name</span>()&#125;;</span><br><span class="line">  <span class="keyword">if</span> (std::is_const&lt;TRR&gt;::value) ret += <span class="string">&quot; const&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (std::is_volatile&lt;TRR&gt;::value) ret += <span class="string">&quot; volatile&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (std::is_lvalue_reference&lt;T&gt;::value) ret += <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (std::is_rvalue_reference&lt;T&gt;::value) ret += <span class="string">&quot;&amp;&amp;&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Another way using function name with signature</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::string_view <span class="title">type_name2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> <span class="type">const</span>* p = std::source_location::<span class="built_in">current</span>().<span class="built_in">function_name</span>(); <span class="comment">// Or &quot;__PRETTY_FUNCTION__&quot; for &lt; c++20</span></span><br><span class="line">  <span class="comment">// e.g. &quot;static_string type_name2() [T = const int &amp;]&quot;</span></span><br><span class="line">  <span class="keyword">while</span> (*p++ != <span class="string">&#x27;=&#x27;</span>);    <span class="comment">// &quot; const int &amp;]&quot;</span></span><br><span class="line">  <span class="keyword">for</span> (; *p == <span class="string">&#x27; &#x27;</span>; p++); <span class="comment">// &quot;const int &amp;&quot;</span></span><br><span class="line">  <span class="type">char</span> <span class="type">const</span>* p2&#123;p&#125;;</span><br><span class="line">  <span class="keyword">while</span> (*++p2 != <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;p, std::<span class="built_in">size_t</span>(p2 - p)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo_lref</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">foo_rref</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo_value</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="type">const</span> ci = <span class="number">0</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype(i) is &quot;</span> &lt;&lt; <span class="built_in">type_name</span>&lt;<span class="keyword">decltype</span>(i)&gt;() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype((i)) is &quot;</span> &lt;&lt; <span class="built_in">type_name</span>&lt;<span class="keyword">decltype</span>((i))&gt;() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype(ci) is &quot;</span> &lt;&lt; <span class="built_in">type_name</span>&lt;<span class="keyword">decltype</span>(ci)&gt;() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype((ci)) is &quot;</span> &lt;&lt; <span class="built_in">type_name</span>&lt;<span class="keyword">decltype</span>((ci))&gt;() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype(static_cast&lt;int&amp;&gt;(i)) is &quot;</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&gt;(i))&gt;() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype(static_cast&lt;int&amp;&amp;&gt;(i)) is &quot;</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(i))&gt;() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype(static_cast&lt;int&gt;(i)) is &quot;</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(i))&gt;() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype(foo_lref()) is &quot;</span> &lt;&lt; <span class="built_in">type_name</span>&lt;<span class="keyword">decltype</span>(<span class="built_in">foo_lref</span>())&gt;() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype(foo_rref()) is &quot;</span> &lt;&lt; <span class="built_in">type_name</span>&lt;<span class="keyword">decltype</span>(<span class="built_in">foo_rref</span>())&gt;() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype(foo_value()) is &quot;</span> &lt;&lt; <span class="built_in">type_name</span>&lt;<span class="keyword">decltype</span>(<span class="built_in">foo_value</span>())&gt;() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Stack-vs-Heap-Memory-in-C">Stack vs Heap Memory in C++</h2>
<p>Ignore…</p>
<h2 id="Macros-in-C">Macros in C++</h2>
<p>Macros do text replace at preprocessor stage</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT std::cin.get()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WAIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Macros function and combine with the environment, environment variables can be defined at: Project settings -&gt; C/C++ -&gt; Preprocessor -&gt; Preprocessor Definitions</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PR_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(PR_RELEASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) <span class="comment">// Do nothing</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-“auto”-Keyword">The “auto” Keyword</h2>
<p>Be careful with <code>auto</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function">std::string <span class="title">get_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Cherno&quot;</span>; &#125;</span><br><span class="line"><span class="comment">// char* get_name() &#123; return &quot;Cherno&quot;; &#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> name&#123;<span class="built_in">get_name</span>()&#125;;</span><br><span class="line">  <span class="comment">// Call a type specific method size(), if the return type of GetName() changed to &quot;char*&quot; , this will be broken</span></span><br><span class="line">  <span class="type">int</span> a = name.<span class="built_in">size</span>();</span><br><span class="line">  std::cout &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>auto</code>’ can reduce type length</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Device</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeviceManager</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> Device_t = std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Device_t m_devices;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">const</span> Device_t&amp; <span class="title">GetDevices</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_devices; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  DeviceManager dm;</span><br><span class="line">  <span class="comment">// The type is too messy</span></span><br><span class="line">  <span class="type">const</span> std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;&amp; devices&#123;dm.<span class="built_in">GetDevices</span>()&#125;;</span><br><span class="line">  <span class="comment">// You can use keyword &quot;using&quot; or &quot;typedef&quot; to make alias</span></span><br><span class="line">  <span class="keyword">using</span> DeviceMap = std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;;</span><br><span class="line">  <span class="type">const</span> DeviceMap&amp; devices2&#123;dm.<span class="built_in">GetDevices</span>()&#125;;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; devices3&#123;dm.<span class="built_in">GetDevices</span>()&#125;; <span class="comment">// Or auto</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Static-Arrays-in-C-std-array">Static Arrays in C++ (std::array)</h2>
<p>Ignore…</p>
<h2 id="Function-Pointers-in-C">Function Pointers in C++</h2>
<ol>
<li>3 ways to definite a Function Pointers<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloWorld</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World! Value: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> function = <span class="built_in">HelloWorld</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// second way:</span></span><br><span class="line">    <span class="comment">// void(*function)(int) = HelloWorld();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// third way:</span></span><br><span class="line">    <span class="comment">// typedef void(*Balabala)(int);</span></span><br><span class="line">    <span class="comment">// Balabala function = HelloWorld;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">function</span>(<span class="number">233</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>A simple usage - the ForEach function:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintValue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">void</span>(*func)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> value : values)</span><br><span class="line">        <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="built_in">ForEach</span>(values, PrintValue);</span><br><span class="line">    <span class="comment">// We can use lambda to simply the function PrintValue() (see more in next episode)</span></span><br><span class="line">    <span class="comment">// ForEach(values, [](int value) &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Lambdas-in-C">Lambdas in C++</h2>
<p>A lambda is basically a little throwaway function that you can write and assign to a variable quickly.</p>
<ol>
<li>How to put outside variables into lambda function<br>
<code>[=]</code>: Pass everything in by value, the pass in variables is independent of the outside.<br>
<code>[&amp;]</code>: Pass everything in by reference.<br>
<code>[a]</code>: Pass <code>a</code> by value<br>
<code>[&amp;a]</code>: Pass <code>a</code> by reference.</li>
<li>using <code>mutable</code> keyword to allow modify pass in variables<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">auto</span> f = [=]() <span class="keyword">mutable</span> &#123; a = <span class="number">5</span>; std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">f</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// x is still = 8, because [=] just copy value into this lambda.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>We need to use <code>std::function</code> instand of raw function pointer if lambda has pass in variables (stateful).<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_each</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; func)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; i : values) <span class="built_in">func</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Cannot use C-style void(*callback)(int)</span></span><br><span class="line">  <span class="keyword">auto</span> callback = [&amp;](<span class="type">int</span> value) &#123; std::cout &lt;&lt; <span class="string">&quot;Current state: &quot;</span> &lt;&lt; state &lt;&lt; <span class="string">&quot; Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;;</span><br><span class="line">  steate = <span class="number">1</span>;</span><br><span class="line">  for_each(values, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Usage of <code>std::find_if</code> (returns an iterator to the first element for which callback function returns true)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; values = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iterator = std::<span class="built_in">find_if</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value &gt; <span class="number">3</span>; &#125;);</span><br><span class="line">std::cout &lt;&lt; *iterator &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Namespaces-in-C">Namespaces in C++</h2>
<p>Use Namespace to</p>
<ol>
<li>Avoid naming conflict: <code>apple::print()</code>, <code>orange::print()</code></li>
<li>Avoid C library like naming: <code>GLFW_initialize</code> to <code>GLFW::initialize</code></li>
</ol>
<p>Usage:</p>
<ol>
<li>We can set to use only specific symbol in a namespace<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">namespcae apple &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print_again</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">///...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> apple::print;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  apple::<span class="built_in">print_again</span>(); <span class="comment">//We still need &#x27;apple::&#x27; to call print_again()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Nested namespaces can be shorten using alias:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> apple::functions &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* test)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">namespace</span> a = apple::functions;</span><br><span class="line">    a::<span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Why-don’t-“using-namespace-std”">Why don’t “using namespace std”</h3>
<p>Absolutely don’t use <code>using namespace</code> in header files.<br>
If you must using <code>using namespace</code>, please use it in a small scope as possible.</p>
<p>For example a serious issue of implicit conversion:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> apple &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> </span>&#123; std::cout &lt;&lt; text &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> orange &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text)</span> </span>&#123;</span><br><span class="line">    std::string tmp = text;</span><br><span class="line">    std::<span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> apple;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> orange;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// Which one will get called?</span></span><br><span class="line">    <span class="comment">// Answer: the orange::print() will be called, because the type of &quot;Hello&quot; is &#x27;char*&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Threads-in-C">Threads in C++</h2>
<p>If we want to do something else when we called functions that will block the current thread, we can use threads.</p>
<p>Here is an example:<br>
We created a thread that will do loop on outputting “Working…”,<br>
and simultaneously the main() function is waiting for user input.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> is_Finished = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals; <span class="comment">// Or use &quot;sleep_for(std::chrono::seconds(1))&quot; below</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Started thread id=&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_Finished)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working...\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// As soon as we create instance, it&#x27;s going to immediately kick off that thread</span></span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(DoWork)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">    is_Finished = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call main thread to wait this thread (block main thread)</span></span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Timing-in-C">Timing in C++</h2>
<ol>
<li>Make a Timer for statistical time-consuming</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;</span><br><span class="line">    std::chrono::duration&lt;<span class="type">float</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        duration = end - start;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> ms = duration.<span class="built_in">count</span>() * <span class="number">1000.0f</span>;</span><br><span class="line">        std::&lt;&lt; <span class="string">&quot;Timer took &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot;ms &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The timer will be auto delete when run out of the scope</span></span><br><span class="line">    Timer timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>; <span class="comment">// std::endl is quiet slow</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Multidimensional-Arrays-in-C">Multidimensional Arrays in C++</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Allocate a 2D array to store twenty integer pointers</span></span><br><span class="line">    <span class="type">int</span>** a2d = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can set each of these pointers to point to an array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        a2d[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3D array, you can imagine a cube with size of 20x30x40</span></span><br><span class="line">    <span class="type">int</span>*** a3d = <span class="keyword">new</span> <span class="type">int</span>**[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a3d[i] = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">30</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a3d[i][j] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">40</span>]:</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a3d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When you want to delete this array, you have to go through inner array and delete all of those arrays from inside to out</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] a3d[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] a3d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] a3d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The most issue is that the Multidimensional Arrays will results memory fragmentation.<br>
When iterating the array we have to jump to another location to read or write that data,<br>
and that’s results probably a cache miss which means that we’re wasting time fetching data from our actual RAM.</p>
<p>One of the most important things you can do is just store them in a single dimensional array:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* array =<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span> * <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">5</span>; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            array[x * <span class="number">5</span> + y] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sorting-in-C">Sorting in C++</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output the results</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : values)</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can define how the sorting rule the sort() dose</span></span><br><span class="line">    <span class="comment">// Such like sorting by big to small</span></span><br><span class="line">    std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output the results</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : values)</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Or force &#x27;1&#x27; to the last of array list</span></span><br><span class="line">    std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Return true equals do exchange the position of a, b</span></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> b &lt; a;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Type-Punning-in-C">Type Punning in C++</h2>
<p>You can Treat an Entity struct as an int array:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e = &#123; <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* position = (<span class="type">int</span>*)&amp;e;</span><br><span class="line">    std::cout &lt;&lt; position[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; position[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// More crazy usage</span></span><br><span class="line">    <span class="type">int</span> y = *(<span class="type">int</span>*)((<span class="type">char</span>*)&amp;e + <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Unions-in-C">Unions in C++</h2>
<p>Defined member in one Union means same memory location</p>
<p>We have Vector2 and Vector2, but there is only one function <code>PrintVector2()</code> can output Vector2,<br>
what can we do?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVector2</span><span class="params">(<span class="type">const</span> Vector2&amp; vector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; vector.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vector.y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The benefit of anonymous struct is converting all variables in struct into a single member which is what the Union expects</span></span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> x, y, z, w;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// &#x27;zy&#x27; will be the same memory as &#x27;x, y&#x27;, and &#x27;zw&#x27; will be the same memory as &#x27;z, w&#x27; </span></span><br><span class="line">            Vector2 xy, zw;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector4 vector = &#123; <span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span> &#125;;</span><br><span class="line">    <span class="built_in">PrintVector2</span>(vector.xy);</span><br><span class="line">    <span class="built_in">PrintVector2</span>(vector.zw);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    vector.z = <span class="number">500.0f</span>;</span><br><span class="line">    <span class="built_in">PrintVector2</span>(vector.xy);</span><br><span class="line">    <span class="built_in">PrintVector2</span>(vector.zw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Type Punning can do as the same result, but using Union makes it more concise.</p>
<h2 id="Virtual-Destructors-in-C">Virtual Destructors in C++</h2>
<p>Virtual Destructors is really important if you are writing a father class,<br>
otherwise no one’s going to be able to safely delete the extend class<br>
(Because without <code>virtual</code> mark you are just adding a new Destructor instead of overload it)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Polymorphic kind of type</span></span><br><span class="line">    <span class="comment">// without `virturl`, the &quot;~Derived()&quot; will not be called</span></span><br><span class="line">    Base* poly = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> poly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Casting-in-C">Casting in C++</h2>
<p>C++'s cast can do anything that C-style casts can do, those casts make you code more solid and looks better.</p>
<ol>
<li>Static cast (compile time checking).</li>
<li>Interpret cast (for Type Punning).</li>
<li>Dynamic cast (will return <code>NULL</code> if casting is failed)</li>
<li>Const cast (TODO: Supplement this content)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Static cast</span></span><br><span class="line">    <span class="type">double</span> value = <span class="number">5.5</span>;</span><br><span class="line">    <span class="type">double</span> sc = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(value);</span><br><span class="line"></span><br><span class="line">    Base* p_base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Derived* ac = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(p_base); <span class="comment">// Main class cannot be casted to sub class</span></span><br><span class="line">    <span class="keyword">if</span> (!ac) &#123; std::cout &lt;&lt; <span class="string">&quot;Converting failed\n&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Conditional-and-Action-Breakpoints-in-C">Conditional and Action Breakpoints in C++</h2>
<p>Condition Breakpoints: If I only want the breakpoint to trigger under a certain condition<br>
Action Breakpoints: Generally print something to the console when a breakpoint is hit<br>
They can prevent recompile and save time</p>
<p>For details. please <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=9ncNA6Co2Nk&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=70">watch the video</a></p>
<h2 id="Safety-in-modern-C-and-how-to-teach-it">Safety in modern C++ and how to teach it</h2>
<p>You should 100% use smart pointers if you are doing serious work</p>
<h2 id="Precompiled-Headers-in-C">Precompiled Headers in C++</h2>
<p>Look to 7:07</p>
<h2 id="Dynamic-Casting-in-C">Dynamic Casting in C++</h2>
<p>If we force type casting a Enemy class to Player and access data(funcions, variables) that is unique to player, the program will probablly crash.</p>
<p>Dynamic Casting is actually does some validation for us to ensure that cast is valid</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity* actuallyPlayer = <span class="keyword">new</span> <span class="built_in">Player</span>();</span><br><span class="line">    Entity* actuallyEnemy = <span class="keyword">new</span> <span class="built_in">Enemy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// How does it know that actuallyPlayer is actually a Player and not an Enemy?</span></span><br><span class="line">    <span class="comment">// The way it does that is it stores runtime type information(RTTI)</span></span><br><span class="line">    <span class="comment">// This does add an overhead but it lets you do things like dynamic casting</span></span><br><span class="line">    <span class="comment">// Be aware that RTTI can be enabled or disabled</span></span><br><span class="line">    Player* p0 = <span class="built_in">dynamic_cast</span>&lt;Player*&gt;(actuallyPlayer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Will return null</span></span><br><span class="line">    Player* p1 = <span class="built_in">dynamic_cast</span>&lt;Player*&gt;(actuallyEnemy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dynamic_cast&lt;xxx*&gt;(xxx); equal to xxx instanceof xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BENCHMARKING-in-C-how-to-measure-performance">BENCHMARKING in C++ (how to measure performance)</h2>
<p>Always make sure that you profile is actually meaningful in a releases because you’re not gonna be shipping code in debug anyway</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::steady_clock&gt; m_StartTime, m_EndTime;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_StartTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_EndTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">auto</span> start = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(m_StartTime).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">        <span class="keyword">auto</span> end = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(m_EndTime).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> duration = end - start;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> ms = duration * <span class="number">0.001</span>;</span><br><span class="line">        std::cout &lt;&lt; duration &lt;&lt; <span class="string">&quot;us (&quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot;ms)\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Make Shared\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="number">1000</span>&gt; sharedPtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sharedPtrs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            sharedPtrs[i] = std::<span class="built_in">make_shared</span>&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;New Shared\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="number">1000</span>&gt; sharedPtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sharedPtrs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            sharedPtrs[i] = std::<span class="built_in">shared_ptr</span>&lt;Vector2&gt;(<span class="keyword">new</span> <span class="built_in">Vector2</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Make Unique\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="number">1000</span>&gt; sharedPtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sharedPtrs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            sharedPtrs[i] = std::<span class="built_in">make_shared</span>&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="STRUCTURED-BINDINGS-in-C">STRUCTURED BINDINGS in C++</h2>
<p>Only in C++17 and newer<br>
a better way compare to How to Deal with Multiple Return Values in C++</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">CreatePerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="string">&quot;Cherno&quot;</span>, <span class="number">24</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Structured binding</span></span><br><span class="line">    <span class="keyword">auto</span>[name, age] = <span class="built_in">CreatePerson</span>();</span><br><span class="line">    std::cout &lt;&lt; name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or std::tie for already defined variables</span></span><br><span class="line">  std::string name2;</span><br><span class="line">  <span class="type">int</span> age2;</span><br><span class="line">  std::<span class="built_in">tie</span>(name2, age2) = std::<span class="built_in">tuple</span>(<span class="string">&quot;&quot;</span>, <span class="number">14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="How-to-Deal-with-OPTIONAL-Data-in-C">How to Deal with OPTIONAL Data in C++</h2>
<h2 id="Multiple-TYPES-of-Data-in-a-SINGLE-VARIABLE-in-C">Multiple TYPES of Data in a SINGLE VARIABLE in C++?</h2>
<h2 id="How-to-store-ANY-data-in-C">How to store ANY data in C++</h2>
<h2 id="How-to-make-C-run-FASTER-with-std-async">How to make C++ run FASTER (with std::async)</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::std::future&lt;<span class="type">void</span>&gt;&gt; m_Futures <span class="comment">// void is the return type of the function LoadMesh()</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::mutex s_MeshesMutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here we use pointer parameter because reference parameter doesn&#x27;t work(Cherno not entirely sure why)</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">LoadMesh</span><span class="params">(<span class="type">const</span> std::vector&lt;Ref&lt;Mesh&gt;&gt;* meshes, std::string filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> mesh = Mesh::<span class="built_in">Load</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to lock this meshes vector while it been modify</span></span><br><span class="line">    <span class="comment">// lock the push_back() function</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(s_MeshesMutex)</span></span>;</span><br><span class="line">    meshes-&gt;<span class="built_in">push_back</span>(mesh);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::LoadMeshes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get file context use c++ file stream</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(<span class="string">&quot;src/Models.txt&quot;</span>)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    std::vector&lt;std::string&gt; meshFilepaths;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getLine</span>(stream, line))</span><br><span class="line">        meshFilepaths.<span class="built_in">push_back</span>(line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m_Meshes is a vector in this class</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASYNC 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ASYNC</span></span><br><span class="line">    <span class="comment">// Asynchronous</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; file : meshFilepaths)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// std::async() will return std::future and its really important to handle that std::future or its will be destoryed and peform the destructor to make sure the async is actually finished</span></span><br><span class="line">        <span class="comment">// that basically means it won&#x27;t be parallel at all </span></span><br><span class="line">        m_Futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, LoadMesh, &amp;m_Meshes, file));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// Sequence</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; file : meshFilepaths)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Meshes.<span class="built_in">push_back</span>(Mesh::<span class="built_in">Load</span>(file));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In VS, you can use DEBUG-&gt;Windows-&gt;Parrllel Stacks (Ctrl+Shift+D)<br>
to do window parallel debugs</p>
<h2 id="How-to-make-your-STRINGS-FASTER-in-C">How to make your STRINGS FASTER in C++!</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## VISUAL BENCHMARKING in C++ (how to measure performance visually)</span><br><span class="line"></span><br><span class="line">## SINGLETONS in C++</span><br><span class="line"></span><br><span class="line">```C++</span><br></pre></td></tr></table></figure>
<h2 id="Small-String-Optimization-in-C">Small String Optimization in C++</h2>
<h2 id="Track-MEMORY-ALLOCATIONS-the-Easy-Way-in-C">Track MEMORY ALLOCATIONS the Easy Way in C++</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">#<span class="meta"># lvalues and rvalues in C++</span></span><br><span class="line"></span><br><span class="line">In my opinion, <span class="function">any data that is <span class="keyword">not</span> being attached by a <span class="title">symbol</span><span class="params">(<span class="keyword">not</span> being explicitly assigned an address)</span> is an R-value, otherwise it&#x27;s an L-value.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1. L-value reference <span class="keyword">and</span> R-value reference</span></span><br><span class="line"><span class="function">   ```C++</span></span><br><span class="line"><span class="function">   <span class="type">int</span> i </span>= <span class="number">10</span>;</span><br><span class="line">   <span class="comment">// L-value reference can accept L-value and R-value</span></span><br><span class="line">   <span class="type">int</span>&amp; = i;</span><br><span class="line">   <span class="comment">// R-value reference can only accept R-value</span></span><br><span class="line">   <span class="type">int</span>&amp;&amp; = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>const type&amp;</code> is a special rule, realistically what happens is the compiler will probably create like a temporary variable.<br>
there are not to kind of avoid creating an L-value but rather to just kind of support both support both L-value and R-values<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// int temp = 10;</span></span><br><span class="line"><span class="comment">// const int&amp; a = temp;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Continuous-Integration-in-C">Continuous Integration in C++</h2>
<h2 id="Static-Analysis-in-C">Static Analysis in C++</h2>
<p>Static Analysis is a very important thing that even for an experienced programmer there is still going to be stuff what you miss.<br>
It can find logic errors in your code and gives you some tips to fix it</p>
<p><code>clang-tidy</code> is a free tool to do static analysis</p>
<h2 id="Argument-Evaluation-Order-in-C">Argument Evaluation Order in C++</h2>
<h2 id="Move-Semantics-in-C">Move Semantics in C++</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>() = <span class="keyword">default</span>; <span class="comment">// equals with String()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Created!\n&quot;</span>);</span><br><span class="line">		m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Copied!\n&quot;</span>);</span><br><span class="line">		m_Size = other.m_Size;</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Data, other.m_Data, m_Size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(String&amp;&amp; older) <span class="keyword">noexcept</span> <span class="comment">// use noexcept to get rid of compiler warning</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">		m_Size = older.m_Size;</span><br><span class="line">		<span class="comment">// This immediately presents a problem</span></span><br><span class="line">		<span class="comment">// because when the old one gets deleted</span></span><br><span class="line">		<span class="comment">// it&#x27;s going to delete the m_Data with us</span></span><br><span class="line">		m_Data = older.m_Data;</span><br><span class="line">		<span class="comment">// so this is the major thing that we need to do</span></span><br><span class="line">		older.m_Size = <span class="number">0</span>;</span><br><span class="line">		older.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">String</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Destroyed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">delete</span> m_Data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_Data[i]);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_Data;</span><br><span class="line">	<span class="type">uint32_t</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">		: <span class="built_in">m_Name</span>(name)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Entity</span>(String&amp;&amp; name)</span><br><span class="line">		: <span class="built_in">m_Name</span>(std::<span class="built_in">move</span>(name)) <span class="comment">// equals to m_Name((String&amp;&amp;) name)</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name.<span class="built_in">Print</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	String m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Entity <span class="title">entity</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line">	entity.<span class="built_in">PrintName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-move-and-the-Move-Assignment-Operator-in-C">std::move and the Move Assignment Operator in C++</h2>
<p><code>std::move</code> actually do force casting but can make your program more search friendly</p>
<p>Move Assignment will allow us do move operation on existing objects</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Created!\n&quot;</span>);</span><br><span class="line">		m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(String&amp;&amp; older) <span class="keyword">noexcept</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">		m_Size = older.m_Size;</span><br><span class="line">		m_Data = older.m_Data;</span><br><span class="line"></span><br><span class="line">		older.m_Size = <span class="number">0</span>;</span><br><span class="line">		older.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define move assignment</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(String&amp;&amp; older) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;older)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Because use move assignment meaning assure there already existing data in currently class</span></span><br><span class="line">            <span class="comment">// So clean the current class</span></span><br><span class="line">            <span class="keyword">delete</span>[] m_Data;</span><br><span class="line">        </span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">		    m_Size = older.m_Size;</span><br><span class="line">		    m_Data = older.m_Data;</span><br><span class="line"></span><br><span class="line">		    older.m_Size = <span class="number">0</span>;</span><br><span class="line">		    older.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">String</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Destroyed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">delete</span> m_Data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_Data[i]);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_Data;</span><br><span class="line">	<span class="type">uint32_t</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String apple = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">    String dest;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;Apple: &quot;</span>;</span><br><span class="line">    apple.<span class="built_in">Print</span>();</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;Dest: &quot;</span>;</span><br><span class="line">    dest.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    dest = std::<span class="built_in">move</span>(apple);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;Apple: &quot;</span>;</span><br><span class="line">    apple.<span class="built_in">Print</span>();</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;Dest: &quot;</span>;</span><br><span class="line">    dest.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ARRAY-Making-DATA-STRUCTURES-in-C">ARRAY - Making DATA STRUCTURES in C++</h2>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/markdown/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">markdown</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/mods-changes/"><span class="level-item">mods-changes</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Notice"><span class="level-left"><span class="level-item">1</span><span class="level-item">Notice</span></span></a></li><li><a class="level is-mobile" href="#How-C-Works"><span class="level-left"><span class="level-item">2</span><span class="level-item">How C++ Works</span></span></a></li><li><a class="level is-mobile" href="#Variables"><span class="level-left"><span class="level-item">3</span><span class="level-item">Variables</span></span></a></li><li><a class="level is-mobile" href="#Functions"><span class="level-left"><span class="level-item">4</span><span class="level-item">Functions</span></span></a></li><li><a class="level is-mobile" href="#Header-Files"><span class="level-left"><span class="level-item">5</span><span class="level-item">Header Files</span></span></a></li><li><a class="level is-mobile" href="#Visual-Studio-Setup-Debug"><span class="level-left"><span class="level-item">6</span><span class="level-item">Visual Studio Setup &amp; Debug</span></span></a></li><li><a class="level is-mobile" href="#Pointers"><span class="level-left"><span class="level-item">7</span><span class="level-item">Pointers</span></span></a></li><li><a class="level is-mobile" href="#Reference"><span class="level-left"><span class="level-item">8</span><span class="level-item">Reference</span></span></a></li><li><a class="level is-mobile" href="#Classes-vs-Structs-and-Enums"><span class="level-left"><span class="level-item">9</span><span class="level-item">Classes vs Structs, and Enums</span></span></a></li><li><a class="level is-mobile" href="#Static"><span class="level-left"><span class="level-item">10</span><span class="level-item">Static</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Classical-Singleton"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">Classical Singleton</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Constructors-Destructors"><span class="level-left"><span class="level-item">11</span><span class="level-item">Constructors &amp; Destructors</span></span></a></li><li><a class="level is-mobile" href="#Inheritance-Virtual-Functions"><span class="level-left"><span class="level-item">12</span><span class="level-item">Inheritance &amp; Virtual Functions</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Interface-Pure-Virtual-Method"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">Interface (Pure Virtual Method)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Visibility-in-C"><span class="level-left"><span class="level-item">13</span><span class="level-item">Visibility in C++</span></span></a></li><li><a class="level is-mobile" href="#Literal-Arrays-C-11-Standard-Arrays"><span class="level-left"><span class="level-item">14</span><span class="level-item">Literal Arrays &amp; C++11 Standard Arrays</span></span></a></li><li><a class="level is-mobile" href="#How-Strings-Work-and-How-to-Use-Them"><span class="level-left"><span class="level-item">15</span><span class="level-item">How Strings Work (and How to Use Them)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#C-style-Strings-String-Literals-and-std-string-view"><span class="level-left"><span class="level-item">15.1</span><span class="level-item">C-style Strings (String Literals) and std::string_view</span></span></a></li><li><a class="level is-mobile" href="#std-string"><span class="level-left"><span class="level-item">15.2</span><span class="level-item">std::string</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Constants-in-C"><span class="level-left"><span class="level-item">16</span><span class="level-item">Constants in C++</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Constant-Pointer"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">Constant Pointer</span></span></a></li><li><a class="level is-mobile" href="#Const-Method"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">Const Method</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Member-Initializer-Lists-in-C-Constructor-Initializer-List"><span class="level-left"><span class="level-item">17</span><span class="level-item">Member Initializer Lists in C++ (Constructor Initializer List)</span></span></a></li><li><a class="level is-mobile" href="#Ternary-Operators-in-C-Conditional-Assignment"><span class="level-left"><span class="level-item">18</span><span class="level-item">Ternary Operators in C++ (Conditional Assignment)</span></span></a></li><li><a class="level is-mobile" href="#Create-Instantiate-Objects"><span class="level-left"><span class="level-item">19</span><span class="level-item">Create/Instantiate Objects</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#The-New-Delete-Keyword"><span class="level-left"><span class="level-item">19.1</span><span class="level-item">The New/Delete Keyword</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Implicit-Conversion-and-the-Explicit-Keyword-in-C"><span class="level-left"><span class="level-item">20</span><span class="level-item">Implicit Conversion and the Explicit Keyword in C++</span></span></a></li><li><a class="level is-mobile" href="#Operators-and-Operator-Overloading-in-C"><span class="level-left"><span class="level-item">21</span><span class="level-item">Operators and Operator Overloading in C++</span></span></a></li><li><a class="level is-mobile" href="#Object-Lifetime-Stack-Scope-Lifetimes"><span class="level-left"><span class="level-item">22</span><span class="level-item">Object Lifetime (Stack/Scope Lifetimes)</span></span></a></li><li><a class="level is-mobile" href="#Smart-Pointers-std-unique-ptr-std-shared-ptr-std-weak-ptr"><span class="level-left"><span class="level-item">23</span><span class="level-item">Smart Pointers (std::unique_ptr, std::shared_ptr, std::weak_ptr)</span></span></a></li><li><a class="level is-mobile" href="#Copying-and-Copy-Constructors"><span class="level-left"><span class="level-item">24</span><span class="level-item">Copying and Copy Constructors</span></span></a></li><li><a class="level is-mobile" href="#The-Arrow-Operator"><span class="level-left"><span class="level-item">25</span><span class="level-item">The Arrow Operator</span></span></a></li><li><a class="level is-mobile" href="#Dynamic-Arrays-std-vector"><span class="level-left"><span class="level-item">26</span><span class="level-item">Dynamic Arrays (std::vector)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Optimizing-the-usage-of-std-vector"><span class="level-left"><span class="level-item">26.1</span><span class="level-item">Optimizing the usage of std::vector</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Using-Libraries-in-C"><span class="level-left"><span class="level-item">27</span><span class="level-item">Using Libraries in C++</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Static-linking"><span class="level-left"><span class="level-item">27.1</span><span class="level-item">Static linking</span></span></a></li><li><a class="level is-mobile" href="#Dynamic-linking"><span class="level-left"><span class="level-item">27.2</span><span class="level-item">Dynamic linking</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Making-and-Working-with-Libraries-in-C-Multiple-Projects-in-Visual-Studio"><span class="level-left"><span class="level-item">28</span><span class="level-item">Making and Working with Libraries in C++ (Multiple Projects in Visual Studio)</span></span></a></li><li><a class="level is-mobile" href="#How-to-Deal-with-Multiple-Return-Values-in-C"><span class="level-left"><span class="level-item">29</span><span class="level-item">How to Deal with Multiple Return Values in C++</span></span></a></li><li><a class="level is-mobile" href="#Templates"><span class="level-left"><span class="level-item">30</span><span class="level-item">Templates</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#SFINAE"><span class="level-left"><span class="level-item">30.1</span><span class="level-item">SFINAE</span></span></a></li><li><a class="level is-mobile" href="#Ways-to-Print-Type-Name"><span class="level-left"><span class="level-item">30.2</span><span class="level-item">Ways to Print Type Name</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Stack-vs-Heap-Memory-in-C"><span class="level-left"><span class="level-item">31</span><span class="level-item">Stack vs Heap Memory in C++</span></span></a></li><li><a class="level is-mobile" href="#Macros-in-C"><span class="level-left"><span class="level-item">32</span><span class="level-item">Macros in C++</span></span></a></li><li><a class="level is-mobile" href="#The-“auto”-Keyword"><span class="level-left"><span class="level-item">33</span><span class="level-item">The “auto” Keyword</span></span></a></li><li><a class="level is-mobile" href="#Static-Arrays-in-C-std-array"><span class="level-left"><span class="level-item">34</span><span class="level-item">Static Arrays in C++ (std::array)</span></span></a></li><li><a class="level is-mobile" href="#Function-Pointers-in-C"><span class="level-left"><span class="level-item">35</span><span class="level-item">Function Pointers in C++</span></span></a></li><li><a class="level is-mobile" href="#Lambdas-in-C"><span class="level-left"><span class="level-item">36</span><span class="level-item">Lambdas in C++</span></span></a></li><li><a class="level is-mobile" href="#Namespaces-in-C"><span class="level-left"><span class="level-item">37</span><span class="level-item">Namespaces in C++</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Why-don’t-“using-namespace-std”"><span class="level-left"><span class="level-item">37.1</span><span class="level-item">Why don’t “using namespace std”</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Threads-in-C"><span class="level-left"><span class="level-item">38</span><span class="level-item">Threads in C++</span></span></a></li><li><a class="level is-mobile" href="#Timing-in-C"><span class="level-left"><span class="level-item">39</span><span class="level-item">Timing in C++</span></span></a></li><li><a class="level is-mobile" href="#Multidimensional-Arrays-in-C"><span class="level-left"><span class="level-item">40</span><span class="level-item">Multidimensional Arrays in C++</span></span></a></li><li><a class="level is-mobile" href="#Sorting-in-C"><span class="level-left"><span class="level-item">41</span><span class="level-item">Sorting in C++</span></span></a></li><li><a class="level is-mobile" href="#Type-Punning-in-C"><span class="level-left"><span class="level-item">42</span><span class="level-item">Type Punning in C++</span></span></a></li><li><a class="level is-mobile" href="#Unions-in-C"><span class="level-left"><span class="level-item">43</span><span class="level-item">Unions in C++</span></span></a></li><li><a class="level is-mobile" href="#Virtual-Destructors-in-C"><span class="level-left"><span class="level-item">44</span><span class="level-item">Virtual Destructors in C++</span></span></a></li><li><a class="level is-mobile" href="#Casting-in-C"><span class="level-left"><span class="level-item">45</span><span class="level-item">Casting in C++</span></span></a></li><li><a class="level is-mobile" href="#Conditional-and-Action-Breakpoints-in-C"><span class="level-left"><span class="level-item">46</span><span class="level-item">Conditional and Action Breakpoints in C++</span></span></a></li><li><a class="level is-mobile" href="#Safety-in-modern-C-and-how-to-teach-it"><span class="level-left"><span class="level-item">47</span><span class="level-item">Safety in modern C++ and how to teach it</span></span></a></li><li><a class="level is-mobile" href="#Precompiled-Headers-in-C"><span class="level-left"><span class="level-item">48</span><span class="level-item">Precompiled Headers in C++</span></span></a></li><li><a class="level is-mobile" href="#Dynamic-Casting-in-C"><span class="level-left"><span class="level-item">49</span><span class="level-item">Dynamic Casting in C++</span></span></a></li><li><a class="level is-mobile" href="#BENCHMARKING-in-C-how-to-measure-performance"><span class="level-left"><span class="level-item">50</span><span class="level-item">BENCHMARKING in C++ (how to measure performance)</span></span></a></li><li><a class="level is-mobile" href="#STRUCTURED-BINDINGS-in-C"><span class="level-left"><span class="level-item">51</span><span class="level-item">STRUCTURED BINDINGS in C++</span></span></a></li><li><a class="level is-mobile" href="#How-to-Deal-with-OPTIONAL-Data-in-C"><span class="level-left"><span class="level-item">52</span><span class="level-item">How to Deal with OPTIONAL Data in C++</span></span></a></li><li><a class="level is-mobile" href="#Multiple-TYPES-of-Data-in-a-SINGLE-VARIABLE-in-C"><span class="level-left"><span class="level-item">53</span><span class="level-item">Multiple TYPES of Data in a SINGLE VARIABLE in C++?</span></span></a></li><li><a class="level is-mobile" href="#How-to-store-ANY-data-in-C"><span class="level-left"><span class="level-item">54</span><span class="level-item">How to store ANY data in C++</span></span></a></li><li><a class="level is-mobile" href="#How-to-make-C-run-FASTER-with-std-async"><span class="level-left"><span class="level-item">55</span><span class="level-item">How to make C++ run FASTER (with std::async)</span></span></a></li><li><a class="level is-mobile" href="#How-to-make-your-STRINGS-FASTER-in-C"><span class="level-left"><span class="level-item">56</span><span class="level-item">How to make your STRINGS FASTER in C++!</span></span></a></li><li><a class="level is-mobile" href="#Small-String-Optimization-in-C"><span class="level-left"><span class="level-item">57</span><span class="level-item">Small String Optimization in C++</span></span></a></li><li><a class="level is-mobile" href="#Track-MEMORY-ALLOCATIONS-the-Easy-Way-in-C"><span class="level-left"><span class="level-item">58</span><span class="level-item">Track MEMORY ALLOCATIONS the Easy Way in C++</span></span></a></li><li><a class="level is-mobile" href="#Continuous-Integration-in-C"><span class="level-left"><span class="level-item">59</span><span class="level-item">Continuous Integration in C++</span></span></a></li><li><a class="level is-mobile" href="#Static-Analysis-in-C"><span class="level-left"><span class="level-item">60</span><span class="level-item">Static Analysis in C++</span></span></a></li><li><a class="level is-mobile" href="#Argument-Evaluation-Order-in-C"><span class="level-left"><span class="level-item">61</span><span class="level-item">Argument Evaluation Order in C++</span></span></a></li><li><a class="level is-mobile" href="#Move-Semantics-in-C"><span class="level-left"><span class="level-item">62</span><span class="level-item">Move Semantics in C++</span></span></a></li><li><a class="level is-mobile" href="#std-move-and-the-Move-Assignment-Operator-in-C"><span class="level-left"><span class="level-item">63</span><span class="level-item">std::move and the Move Assignment Operator in C++</span></span></a></li><li><a class="level is-mobile" href="#ARRAY-Making-DATA-STRUCTURES-in-C"><span class="level-left"><span class="level-item">64</span><span class="level-item">ARRAY - Making DATA STRUCTURES in C++</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/computer/"><span class="level-start"><span class="level-item">computer</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/daily-life/"><span class="level-start"><span class="level-item">daily-life</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/dataset/"><span class="level-start"><span class="level-item">dataset</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/learn/"><span class="level-start"><span class="level-item">learn</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/learn/mathematics/"><span class="level-start"><span class="level-item">mathematics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/minecraft/"><span class="level-start"><span class="level-item">minecraft</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/electronic-and-information-engineering/"><span class="tag">electronic-and-information-engineering</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mathematics/"><span class="tag">mathematics</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgraduate/"><span class="tag">postgraduate</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/senior-high-schoool/"><span class="tag">senior-high-schoool</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/Comet_symbol.svg" alt="Proteus Chan の Notebook" height="28"></a><p class="is-size-7"><span>&copy; 2024 Proteus Chan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><!-- hexo injector body_end start -->
    <script>
    (() => {
        function switchTab() {
            if (!location.hash) {
              return;
            }
            Array
                .from(document.querySelectorAll('.tab-content'))
                .forEach($tab => {
                    $tab.classList.add('is-hidden');
                });
            Array
                .from(document.querySelectorAll('.tabs li'))
                .forEach($tab => {
                    $tab.classList.remove('is-active');
                });
            const $activeTab = document.querySelector(location.hash);
            if ($activeTab) {
                $activeTab.classList.remove('is-hidden');
            }
            const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
            if ($tabMenu) {
                $tabMenu.parentElement.classList.add('is-active');
            }
        }
        switchTab();
        window.addEventListener('hashchange', switchTab, false);
    })();
    </script>
    <!-- hexo injector body_end end --></body></html>